From 45a57a54c3e4c62e74a0526af7304e15298bc1b1 Mon Sep 17 00:00:00 2001
From: Johannes Feichtner <johannes.feichtner@iaik.tugraz.at>
Date: Thu, 14 Jun 2018 13:02:19 +0200
Subject: [PATCH 1/1] LLVMSlicer, Pointer analysis, parameter backtracking,
 rule evaluation

---
 .gitignore                                         |    4 +
 CMakeLists.txt                                     |    4 +
 include/google/dense_hash_map                      |   34 +
 include/google/dense_hash_set                      |   34 +
 include/google/sparse_hash_map                     |   34 +
 include/google/sparse_hash_set                     |   34 +
 include/google/sparsehash/densehashtable.h         |   34 +
 include/google/sparsehash/hashtable-common.h       |   34 +
 .../sparsehash/libc_allocator_with_realloc.h       |   34 +
 include/google/sparsehash/sparsehashtable.h        |   34 +
 include/google/sparsetable                         |   34 +
 include/google/template_util.h                     |   34 +
 include/google/type_traits.h                       |   34 +
 include/llvm/Analysis/Andersen/Andersen.h          |  272 +
 include/llvm/Analysis/Andersen/AndersenAA.h        |   31 +
 .../Andersen/CallHandler/ObjCRuntimeCallHandler.h  |  158 +
 include/llvm/Analysis/Andersen/CleanUpPass.h       |   19 +
 include/llvm/Analysis/Andersen/Constraint.h        |   55 +
 include/llvm/Analysis/Andersen/CycleDetector.h     |  124 +
 .../llvm/Analysis/Andersen/DetectParametersPass.h  |   84 +
 include/llvm/Analysis/Andersen/GraphTraits.h       |   53 +
 include/llvm/Analysis/Andersen/NodeFactory.h       |  169 +
 .../Analysis/Andersen/NonVolatileRegistersPass.h   |   23 +
 include/llvm/Analysis/Andersen/ObjCCallHandler.h   |   92 +
 include/llvm/Analysis/Andersen/ObjectiveCBinary.h  |   97 +
 .../llvm/Analysis/Andersen/ObjectiveCClassInfo.h   |  143 +
 include/llvm/Analysis/Andersen/PtsSet.h            |   76 +
 include/llvm/Analysis/Andersen/SimpleCallGraph.h   |   46 +
 .../llvm/Analysis/Andersen/SparseBitVectorGraph.h  |  129 +
 include/llvm/Analysis/Andersen/StackAccessPass.h   |  101 +
 include/llvm/DecMethods/AArch64RegID.h             |   12 +
 include/llvm/DecMethods/Opcodes.h                  |   11 +
 include/llvm/IR/PatternMatch.h                     |    6 +
 include/llvm/LLVMSlicer/StaticSlicer.h             |   25 +
 include/sparsehash/dense_hash_map                  |  369 +
 include/sparsehash/dense_hash_set                  |  338 +
 include/sparsehash/internal/densehashtable.h       | 1325 +++
 include/sparsehash/internal/hashtable-common.h     |  381 +
 .../internal/libc_allocator_with_realloc.h         |  119 +
 include/sparsehash/internal/sparseconfig.h         |   46 +
 include/sparsehash/internal/sparsehashtable.h      | 1247 +++
 include/sparsehash/sparse_hash_map                 |  363 +
 include/sparsehash/sparse_hash_set                 |  338 +
 include/sparsehash/sparsetable                     | 1820 +++++
 include/sparsehash/template_util.h                 |  134 +
 include/sparsehash/type_traits.h                   |  342 +
 lib/Analysis/Andersen/Andersen.cpp                 |  445 +
 lib/Analysis/Andersen/AndersenAA.cpp               |  152 +
 lib/Analysis/Andersen/CMakeLists.txt               |   24 +
 .../Andersen/CallHandler/ExternalHandler.h         | 3575 ++++++++
 .../CallHandler/ObjCRuntimeCallHandler.cpp         | 1321 +++
 lib/Analysis/Andersen/CleanUpPass.cpp              |   66 +
 lib/Analysis/Andersen/ConstraintCollect.cpp        | 1822 +++++
 lib/Analysis/Andersen/ConstraintOptimize.cpp       |  598 ++
 lib/Analysis/Andersen/ConstraintSolving.cpp        |  679 ++
 lib/Analysis/Andersen/DetectParametersPass.cpp     |  434 +
 lib/Analysis/Andersen/ExternalLibrary.cpp          |  226 +
 lib/Analysis/Andersen/LLVMBuild.txt                |   22 +
 lib/Analysis/Andersen/NodeFactory.cpp              |  328 +
 lib/Analysis/Andersen/NonVolatileRegistersPass.cpp |  134 +
 lib/Analysis/Andersen/ObjCCallHandler.cpp          |   76 +
 lib/Analysis/Andersen/ObjectiveCBinary.cpp         |  725 ++
 lib/Analysis/Andersen/ObjectiveCClassInfo.cpp      |  157 +
 lib/Analysis/Andersen/SimpleCallGraph.cpp          |  167 +
 lib/Analysis/Andersen/StackAccessPass.cpp          |  394 +
 lib/Analysis/CMakeLists.txt                        |   20 +-
 lib/Analysis/LLVMBuild.txt                         |    6 +-
 lib/CMakeLists.txt                                 |    1 +
 lib/LLVMBuild.txt                                  |    1 +
 lib/LLVMSlicer/Backtrack/Backtrack.cpp             |  266 +
 lib/LLVMSlicer/Backtrack/Constraint.cpp            |  705 ++
 lib/LLVMSlicer/Backtrack/Constraint.h              |  254 +
 lib/LLVMSlicer/Backtrack/Path.cpp                  |  334 +
 lib/LLVMSlicer/Backtrack/Path.h                    |  238 +
 lib/LLVMSlicer/Backtrack/PathGenerator.h           |   17 +
 lib/LLVMSlicer/Backtrack/Rule.cpp                  |  320 +
 lib/LLVMSlicer/Backtrack/Rule.h                    |   22 +
 lib/LLVMSlicer/Backtrack/json.hpp                  | 8638 ++++++++++++++++++++
 lib/LLVMSlicer/CMakeLists.txt                      |   16 +
 lib/LLVMSlicer/Callgraph/Callgraph.cpp             |   42 +
 lib/LLVMSlicer/Callgraph/Callgraph.h               |  135 +
 lib/LLVMSlicer/Kleerer.cpp                         |  462 ++
 lib/LLVMSlicer/LLVMBuild.txt                       |   26 +
 lib/LLVMSlicer/Languages/LLVM.cpp                  |  248 +
 lib/LLVMSlicer/Languages/LLVM.h                    |   72 +
 lib/LLVMSlicer/Languages/LLVMSupport.h             |   40 +
 lib/LLVMSlicer/ModStats.cpp                        |  352 +
 lib/LLVMSlicer/Modifies/ExternalHandler.gen        | 3570 ++++++++
 lib/LLVMSlicer/Modifies/Modifies.cpp               |  418 +
 lib/LLVMSlicer/Modifies/Modifies.h                 |  128 +
 lib/LLVMSlicer/PointsTo/PointsTo.cpp               |  696 ++
 lib/LLVMSlicer/PointsTo/PointsTo.h                 |  109 +
 lib/LLVMSlicer/PointsTo/RuleExpressions.h          |  440 +
 lib/LLVMSlicer/Slicing/ExternalHandler.h           | 5335 ++++++++++++
 lib/LLVMSlicer/Slicing/FunctionStaticSlicer.cpp    | 2367 ++++++
 lib/LLVMSlicer/Slicing/FunctionStaticSlicer.h      |  462 ++
 lib/LLVMSlicer/Slicing/PostDominanceFrontier.cpp   |  159 +
 lib/LLVMSlicer/Slicing/PostDominanceFrontier.h     |   76 +
 lib/LLVMSlicer/Slicing/Prepare.cpp                 |  306 +
 lib/LLVMSlicer/Slicing/Prepare.h                   |   23 +
 lib/LLVMSlicer/Slicing/StaticSlicer.cpp            | 1006 +++
 tools/LLVMBuild.txt                                |    2 +
 tools/llvm-andersen/CMakeLists.txt                 |   12 +
 tools/llvm-andersen/LLVMBuild.txt                  |   22 +
 tools/llvm-andersen/llvm-andersen.cpp              |  215 +
 tools/llvm-slicer/CMakeLists.txt                   |   10 +
 tools/llvm-slicer/LLVMBuild.txt                    |   22 +
 tools/llvm-slicer/Makefile                         |   17 +
 tools/llvm-slicer/llvm-slicer.cpp                  |   97 +
 tools/llvm-testpass/CMakeLists.txt                 |   13 +
 tools/llvm-testpass/LLVMBuild.txt                  |   22 +
 tools/llvm-testpass/llvm-testpass.cpp              |   88 +
 utils/TableGen/CMakeLists.txt                      |    1 +
 utils/TableGen/SliceExtEmitter.cpp                 |  441 +
 utils/TableGen/TableGen.cpp                        |   20 +-
 utils/TableGen/TableGenBackends.h                  |    3 +
 116 files changed, 48567 insertions(+), 3 deletions(-)
 create mode 100644 include/google/dense_hash_map
 create mode 100644 include/google/dense_hash_set
 create mode 100644 include/google/sparse_hash_map
 create mode 100644 include/google/sparse_hash_set
 create mode 100644 include/google/sparsehash/densehashtable.h
 create mode 100644 include/google/sparsehash/hashtable-common.h
 create mode 100644 include/google/sparsehash/libc_allocator_with_realloc.h
 create mode 100644 include/google/sparsehash/sparsehashtable.h
 create mode 100644 include/google/sparsetable
 create mode 100644 include/google/template_util.h
 create mode 100644 include/google/type_traits.h
 create mode 100644 include/llvm/Analysis/Andersen/Andersen.h
 create mode 100644 include/llvm/Analysis/Andersen/AndersenAA.h
 create mode 100644 include/llvm/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.h
 create mode 100644 include/llvm/Analysis/Andersen/CleanUpPass.h
 create mode 100644 include/llvm/Analysis/Andersen/Constraint.h
 create mode 100644 include/llvm/Analysis/Andersen/CycleDetector.h
 create mode 100644 include/llvm/Analysis/Andersen/DetectParametersPass.h
 create mode 100644 include/llvm/Analysis/Andersen/GraphTraits.h
 create mode 100644 include/llvm/Analysis/Andersen/NodeFactory.h
 create mode 100644 include/llvm/Analysis/Andersen/NonVolatileRegistersPass.h
 create mode 100644 include/llvm/Analysis/Andersen/ObjCCallHandler.h
 create mode 100644 include/llvm/Analysis/Andersen/ObjectiveCBinary.h
 create mode 100644 include/llvm/Analysis/Andersen/ObjectiveCClassInfo.h
 create mode 100644 include/llvm/Analysis/Andersen/PtsSet.h
 create mode 100644 include/llvm/Analysis/Andersen/SimpleCallGraph.h
 create mode 100644 include/llvm/Analysis/Andersen/SparseBitVectorGraph.h
 create mode 100644 include/llvm/Analysis/Andersen/StackAccessPass.h
 create mode 100644 include/llvm/DecMethods/AArch64RegID.h
 create mode 100644 include/llvm/DecMethods/Opcodes.h
 create mode 100644 include/llvm/LLVMSlicer/StaticSlicer.h
 create mode 100644 include/sparsehash/dense_hash_map
 create mode 100644 include/sparsehash/dense_hash_set
 create mode 100644 include/sparsehash/internal/densehashtable.h
 create mode 100644 include/sparsehash/internal/hashtable-common.h
 create mode 100644 include/sparsehash/internal/libc_allocator_with_realloc.h
 create mode 100644 include/sparsehash/internal/sparseconfig.h
 create mode 100644 include/sparsehash/internal/sparsehashtable.h
 create mode 100644 include/sparsehash/sparse_hash_map
 create mode 100644 include/sparsehash/sparse_hash_set
 create mode 100644 include/sparsehash/sparsetable
 create mode 100644 include/sparsehash/template_util.h
 create mode 100644 include/sparsehash/type_traits.h
 create mode 100644 lib/Analysis/Andersen/Andersen.cpp
 create mode 100644 lib/Analysis/Andersen/AndersenAA.cpp
 create mode 100644 lib/Analysis/Andersen/CMakeLists.txt
 create mode 100644 lib/Analysis/Andersen/CallHandler/ExternalHandler.h
 create mode 100644 lib/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.cpp
 create mode 100644 lib/Analysis/Andersen/CleanUpPass.cpp
 create mode 100644 lib/Analysis/Andersen/ConstraintCollect.cpp
 create mode 100644 lib/Analysis/Andersen/ConstraintOptimize.cpp
 create mode 100644 lib/Analysis/Andersen/ConstraintSolving.cpp
 create mode 100644 lib/Analysis/Andersen/DetectParametersPass.cpp
 create mode 100644 lib/Analysis/Andersen/ExternalLibrary.cpp
 create mode 100644 lib/Analysis/Andersen/LLVMBuild.txt
 create mode 100644 lib/Analysis/Andersen/NodeFactory.cpp
 create mode 100644 lib/Analysis/Andersen/NonVolatileRegistersPass.cpp
 create mode 100644 lib/Analysis/Andersen/ObjCCallHandler.cpp
 create mode 100644 lib/Analysis/Andersen/ObjectiveCBinary.cpp
 create mode 100644 lib/Analysis/Andersen/ObjectiveCClassInfo.cpp
 create mode 100644 lib/Analysis/Andersen/SimpleCallGraph.cpp
 create mode 100644 lib/Analysis/Andersen/StackAccessPass.cpp
 create mode 100644 lib/LLVMSlicer/Backtrack/Backtrack.cpp
 create mode 100644 lib/LLVMSlicer/Backtrack/Constraint.cpp
 create mode 100644 lib/LLVMSlicer/Backtrack/Constraint.h
 create mode 100644 lib/LLVMSlicer/Backtrack/Path.cpp
 create mode 100644 lib/LLVMSlicer/Backtrack/Path.h
 create mode 100644 lib/LLVMSlicer/Backtrack/PathGenerator.h
 create mode 100644 lib/LLVMSlicer/Backtrack/Rule.cpp
 create mode 100644 lib/LLVMSlicer/Backtrack/Rule.h
 create mode 100644 lib/LLVMSlicer/Backtrack/json.hpp
 create mode 100644 lib/LLVMSlicer/CMakeLists.txt
 create mode 100644 lib/LLVMSlicer/Callgraph/Callgraph.cpp
 create mode 100644 lib/LLVMSlicer/Callgraph/Callgraph.h
 create mode 100644 lib/LLVMSlicer/Kleerer.cpp
 create mode 100644 lib/LLVMSlicer/LLVMBuild.txt
 create mode 100644 lib/LLVMSlicer/Languages/LLVM.cpp
 create mode 100644 lib/LLVMSlicer/Languages/LLVM.h
 create mode 100644 lib/LLVMSlicer/Languages/LLVMSupport.h
 create mode 100644 lib/LLVMSlicer/ModStats.cpp
 create mode 100644 lib/LLVMSlicer/Modifies/ExternalHandler.gen
 create mode 100644 lib/LLVMSlicer/Modifies/Modifies.cpp
 create mode 100644 lib/LLVMSlicer/Modifies/Modifies.h
 create mode 100644 lib/LLVMSlicer/PointsTo/PointsTo.cpp
 create mode 100644 lib/LLVMSlicer/PointsTo/PointsTo.h
 create mode 100644 lib/LLVMSlicer/PointsTo/RuleExpressions.h
 create mode 100644 lib/LLVMSlicer/Slicing/ExternalHandler.h
 create mode 100644 lib/LLVMSlicer/Slicing/FunctionStaticSlicer.cpp
 create mode 100644 lib/LLVMSlicer/Slicing/FunctionStaticSlicer.h
 create mode 100644 lib/LLVMSlicer/Slicing/PostDominanceFrontier.cpp
 create mode 100644 lib/LLVMSlicer/Slicing/PostDominanceFrontier.h
 create mode 100644 lib/LLVMSlicer/Slicing/Prepare.cpp
 create mode 100644 lib/LLVMSlicer/Slicing/Prepare.h
 create mode 100644 lib/LLVMSlicer/Slicing/StaticSlicer.cpp
 create mode 100644 tools/llvm-andersen/CMakeLists.txt
 create mode 100644 tools/llvm-andersen/LLVMBuild.txt
 create mode 100644 tools/llvm-andersen/llvm-andersen.cpp
 create mode 100644 tools/llvm-slicer/CMakeLists.txt
 create mode 100644 tools/llvm-slicer/LLVMBuild.txt
 create mode 100644 tools/llvm-slicer/Makefile
 create mode 100644 tools/llvm-slicer/llvm-slicer.cpp
 create mode 100644 tools/llvm-testpass/CMakeLists.txt
 create mode 100644 tools/llvm-testpass/LLVMBuild.txt
 create mode 100644 tools/llvm-testpass/llvm-testpass.cpp
 create mode 100644 utils/TableGen/SliceExtEmitter.cpp

diff --git a/.gitignore b/.gitignore
index e3d191d..f53e893 100644
--- a/.gitignore
+++ b/.gitignore
@@ -64,3 +64,7 @@ docs/_build
 #==============================================================================#
 bindings/go/llvm/llvm_config.go
 bindings/go/llvm/workdir
+
+.idea/*
+build/*
+Release/*
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index bbfd68d..b429299 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -20,6 +20,10 @@ if (POLICY CMP0051)
   cmake_policy(SET CMP0051 OLD)
 endif()
 
+if(POLICY CMP0046)
+  cmake_policy(SET CMP0046 OLD)
+endif()
+
 if(CMAKE_VERSION VERSION_LESS 3.1.20141117)
   set(cmake_3_2_USES_TERMINAL)
 else()
diff --git a/include/google/dense_hash_map b/include/google/dense_hash_map
new file mode 100644
index 0000000..45b9d19
--- /dev/null
+++ b/include/google/dense_hash_map
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/dense_hash_map>
diff --git a/include/google/dense_hash_set b/include/google/dense_hash_set
new file mode 100644
index 0000000..691a148
--- /dev/null
+++ b/include/google/dense_hash_set
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/dense_hash_set>
diff --git a/include/google/sparse_hash_map b/include/google/sparse_hash_map
new file mode 100644
index 0000000..f6088c1
--- /dev/null
+++ b/include/google/sparse_hash_map
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/sparse_hash_map>
diff --git a/include/google/sparse_hash_set b/include/google/sparse_hash_set
new file mode 100644
index 0000000..c9ebdc7
--- /dev/null
+++ b/include/google/sparse_hash_set
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/sparse_hash_set>
diff --git a/include/google/sparsehash/densehashtable.h b/include/google/sparsehash/densehashtable.h
new file mode 100644
index 0000000..7b89543
--- /dev/null
+++ b/include/google/sparsehash/densehashtable.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/internal/densehashtable.h>
diff --git a/include/google/sparsehash/hashtable-common.h b/include/google/sparsehash/hashtable-common.h
new file mode 100644
index 0000000..b7e9153
--- /dev/null
+++ b/include/google/sparsehash/hashtable-common.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/internal/hashtable-common.h>
diff --git a/include/google/sparsehash/libc_allocator_with_realloc.h b/include/google/sparsehash/libc_allocator_with_realloc.h
new file mode 100644
index 0000000..0da7a7e
--- /dev/null
+++ b/include/google/sparsehash/libc_allocator_with_realloc.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/internal/libc_allocator_with_realloc.h>
diff --git a/include/google/sparsehash/sparsehashtable.h b/include/google/sparsehash/sparsehashtable.h
new file mode 100644
index 0000000..093bca4
--- /dev/null
+++ b/include/google/sparsehash/sparsehashtable.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/internal/sparsehashtable.h>
diff --git a/include/google/sparsetable b/include/google/sparsetable
new file mode 100644
index 0000000..2ea29c8
--- /dev/null
+++ b/include/google/sparsetable
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/sparsetable>
diff --git a/include/google/template_util.h b/include/google/template_util.h
new file mode 100644
index 0000000..9c87d6d
--- /dev/null
+++ b/include/google/template_util.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/template_util.h>
diff --git a/include/google/type_traits.h b/include/google/type_traits.h
new file mode 100644
index 0000000..cc555e3
--- /dev/null
+++ b/include/google/type_traits.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Header files have moved from the google directory to the sparsehash
+// directory.  This forwarding file is provided only for backwards
+// compatibility.  Use <sparsehash/*> in all new code.
+
+#include <sparsehash/type_traits.h>
diff --git a/include/llvm/Analysis/Andersen/Andersen.h b/include/llvm/Analysis/Andersen/Andersen.h
new file mode 100644
index 0000000..15f6c65
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/Andersen.h
@@ -0,0 +1,272 @@
+//
+// This file defines an implementation of Andersen's interprocedural alias
+// analysis
+//
+// In pointer analysis terms, this is a subset-based, flow-insensitive,
+// field-sensitive, and context-insensitive algorithm pointer algorithm.
+//
+// This algorithm is implemented as three stages:
+//   1. Object identification.
+//   2. Inclusion constraint identification.
+//   3. Offline constraint graph optimization
+//   4. Inclusion constraint solving.
+//
+// The object identification stage identifies all of the memory objects in the
+// program, which includes globals, heap allocated objects, and stack allocated
+// objects.
+//
+// The inclusion constraint identification stage finds all inclusion constraints
+// in the program by scanning the program, looking for pointer assignments and
+// other statements that effect the points-to graph.  For a statement like "A =
+// B", this statement is processed to indicate that A can point to anything that
+// B can point to.  Constraints can handle copies, loads, and stores, and
+// address taking.
+//
+// The offline constraint graph optimization portion includes offline variable
+// substitution algorithms intended to compute pointer and location
+// equivalences.  Pointer equivalences are those pointers that will have the
+// same points-to sets, and location equivalences are those variables that
+// always appear together in points-to sets.  It also includes an offline
+// cycle detection algorithm that allows cycles to be collapsed sooner
+// during solving.
+//
+// The inclusion constraint solving phase iteratively propagates the inclusion
+// constraints until a fixed point is reached.  This is an O(N^3) algorithm.
+//
+// Function constraints are handled as if they were structs with X fields.
+// Thus, an access to argument X of function Y is an access to node index
+// getNode(Y) + X.  This representation allows handling of indirect calls
+// without any issues.  To wit, an indirect call Y(a,b) is equivalent to
+// *(Y + 1) = a, *(Y + 2) = b.
+// The return node for a function is always located at getNode(F) +
+// CallReturnPos. The arguments start at getNode(F) + CallArgPos.
+//
+
+#ifndef TCFS_ANDERSEN_H
+#define TCFS_ANDERSEN_H
+
+#include "llvm/Analysis/Andersen/Constraint.h"
+#include "llvm/Analysis/Andersen/NodeFactory.h"
+#include "llvm/Analysis/Andersen/PtsSet.h"
+#include "llvm/Analysis/Andersen/DetectParametersPass.h"
+
+#include "llvm/Pass.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/CallSite.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/Analysis/Andersen/ObjectiveCBinary.h"
+
+#include "llvm/Analysis/Andersen/ObjCCallHandler.h"
+
+#include <vector>
+#include <set>
+#include <map>
+#include <mutex>
+
+#include <sparsehash/sparse_hash_set>
+
+//This is ugly as hell, but I don't want to includ a file from another module....
+namespace llvm {
+    extern llvm::Instruction const *getSuccInBlock(llvm::Instruction const *const I);
+}
+
+class Andersen : public llvm::ModulePass {
+public:
+    typedef std::set<std::pair<const llvm::Function *, int64_t>> FunctionIntPairSet_t;
+    typedef std::map<const llvm::Value *, FunctionIntPairSet_t> StackOffsetMap_t;
+    typedef std::set<std::string> StringSet_t;
+private:
+    const llvm::DataLayout *dataLayout;
+
+    // A factory object that knows how to manage AndersNodes
+    AndersNodeFactory nodeFactory;
+
+    // Constraints - This vector contains a list of all of the constraints identified by the program.
+    std::vector<AndersConstraint> constraints;
+
+    // This is the points-to graph generated by the analysis
+    std::map<NodeIndex, AndersPtsSet> ptsGraph;
+
+    std::unique_ptr<llvm::ObjectiveCBinary> MachO;
+    std::map<const llvm::Value *, StringSet_t> ObjectTypes;
+    std::deque<llvm::Instruction *> CallInstWorklist;
+    std::deque<llvm::Function *> FunctionWorklist;
+    std::unique_ptr<llvm::SimpleCallGraph> CallGraph;
+
+    // Three main phases
+    void identifyObjects(llvm::Module &);
+
+    void collectConstraints(llvm::Module &);
+
+    void optimizeConstraints();
+
+    void solveConstraints();
+
+    // Helper functions for constraint collection
+    void collectConstraintsForGlobals(llvm::Module &);
+
+    void collectConstraintsForInstruction(const llvm::Instruction *);
+
+    void addGlobalInitializerConstraints(NodeIndex, const llvm::Constant *);
+
+    void addConstraintForCall(llvm::ImmutableCallSite cs);
+
+    bool addConstraintForExternalLibrary(llvm::ImmutableCallSite cs, const llvm::Function *f);
+
+    void addArgumentConstraintForCall(llvm::ImmutableCallSite cs, const llvm::Function *f);
+
+    void addConstraintsForConstIntToPtr(const llvm::Value *IntToPtr, const llvm::ConstantInt *Const);
+
+    // Helper functions for constraint optimization
+    NodeIndex getRefNodeIndex(NodeIndex n) const;
+
+    NodeIndex getAdrNodeIndex(NodeIndex n) const;
+
+    // For debugging
+    void dumpConstraint(const AndersConstraint &) const;
+
+    void dumpConstraints() const;
+
+    void dumpConstraintsPlainVanilla() const;
+
+    void dumpPtsGraphPlainVanilla() const;
+
+    void addProtocolConstraints(std::string className, std::string protocolName);
+
+    llvm::Module *Mod;
+
+    llvm::raw_ostream *unhandledFunctions;
+
+
+    StackOffsetMap_t stackOffsetMap;
+    std::mutex constraintLock;
+
+    std::mutex outputLock;
+    std::mutex callInstLock;
+    std::mutex unhandledLock;
+    std::mutex typeLock;
+    std::mutex paramLock;
+
+    std::map<uint64_t, const llvm::Value*> ivarMap;
+    std::map<const llvm::Value*, llvm::Value*> DummyMap;
+
+    //Holds all created dummy objects that are used to help creating
+    //a callgraph (IVARs and protocol definitions for example)
+    google::sparse_hash_set<const llvm::Value*> dummyHelpers;
+public:
+    static char ID;
+
+    Andersen();
+
+    bool runOnModule(llvm::Module &M);
+
+    void getAnalysisUsage(llvm::AnalysisUsage &AU) const;
+
+    void releaseMemory();
+
+    // Given a llvm pointer v,
+    // - Return false if the analysis doesn't know where v points to. In other words, the client must conservatively assume v can points to everything.
+    // - Return true otherwise, and the points-to set of v is put into the second argument.
+    bool getPointsToSet(const llvm::Value *v, std::vector<const llvm::Value *> &ptsSet) const;
+
+    // Put all allocation sites (i.e. all memory objects identified by the analysis) into the first arugment
+    void getAllAllocationSites(std::vector<const llvm::Value *> &allocSites) const;
+
+    void setType(const llvm::Value *V, llvm::StringRef Typename);
+
+    bool getType(const llvm::Value *V, StringSet_t &Typename);
+
+    friend class AndersenAA;
+
+    llvm::ObjectiveCBinary &getMachO() { return *MachO; };
+
+    std::vector<AndersConstraint> &getConstraints() { return constraints; };
+
+    AndersNodeFactory &getNodeFactory() { return nodeFactory; };
+
+    void addToWorklist(llvm::Instruction *v) {
+        callInstLock.lock();
+        CallInstWorklist.push_back(v);
+        callInstLock.unlock();
+    }
+
+    void addToWorklist(llvm::Function *f) { FunctionWorklist.push_back(f); }
+
+    void addConstraintsForCall(const llvm::Instruction *Inst, const llvm::Function *F);
+
+    llvm::SimpleCallGraph &getCallGraph() { return *CallGraph; };
+
+    void preserveRegisterValue(llvm::Instruction *CallInst, uint64_t RegNo);
+
+    bool copyParameter(llvm::Instruction *CallInst, llvm::Function *F, uint64_t RegNo);
+
+    llvm::Module &getModule() { return *Mod; };
+
+    llvm::Instruction *findSetStackParameterInstruction(llvm::Instruction *CallInst,
+                                                        llvm::DetectParametersPass::ParameterAccessPair_t Parameter,
+                                                        int64_t StackSize, int64_t CopyInParent = 0);
+
+    llvm::Instruction *findSetRegisterParameterInstruction(llvm::Instruction *CallInst,
+                                                           llvm::DetectParametersPass::ParameterAccessPair_t Parameter);
+
+    std::set<llvm::Value *> Blocks;
+
+    bool isBlock(const llvm::Instruction *Inst, const llvm::Value *&B);
+
+    void addBlock(llvm::Value *B);
+
+    bool handleBlock(const llvm::Instruction *Call, const llvm::Value *Block);
+
+    std::set<const llvm::Value *> handledAliases;
+
+    bool findAliases(const llvm::Value *Address, bool Sharp = true, uint64_t SPIdx = 3);
+
+    llvm::raw_ostream &getUnhandledStream() { return *unhandledFunctions; }
+
+    StackOffsetMap_t &getStackOffsets() { return stackOffsetMap; }
+
+    bool pointsTo(const llvm::Value *v, const llvm::Value *loc) {
+        std::vector<const llvm::Value *> PtsTo;
+        getPointsToSet(v, PtsTo);
+        for (auto &pts_it : PtsTo) {
+            if (pts_it == loc)
+                return true;
+        }
+        return false;
+    }
+
+    inline void addConstraint(AndersConstraint::ConstraintType Ty, NodeIndex D, NodeIndex S) {
+        constraintLock.lock();
+        constraints.emplace_back(Ty, D, S);
+        constraintLock.unlock();
+    }
+
+    std::mutex &getOutputLock() { return outputLock; }
+
+    void addUnhandled(const std::string functionName, const llvm::Instruction *inst) {
+
+//        *unhandledFunctions << "Can't handle call: " << functionName << " " <<
+//        inst->getParent()->getParent()->getName() << ": ";
+//        if (llvm::getSuccInBlock(inst)) { llvm::getSuccInBlock(inst)->print(*unhandledFunctions); }
+//        *unhandledFunctions << "\n";
+
+//        *unhandledFunctions << "Can't handle call: " << functionName << "\n";
+        if (unhandledFunctions == &llvm::nulls()) {
+            return;
+        }
+
+
+        unhandledLock.lock();
+//        *unhandledFunctions << "Can't handle call: " << functionName << " ";
+//        if (s)
+//            s->print(*unhandledFunctions);
+//        *unhandledFunctions << "\n";
+        *unhandledFunctions << "Can't handle call: " << functionName << "\n";
+        unhandledLock.unlock();
+    }
+
+    bool isDummyHelper(const llvm::Value *val);
+};
+
+
+#endif
diff --git a/include/llvm/Analysis/Andersen/AndersenAA.h b/include/llvm/Analysis/Andersen/AndersenAA.h
new file mode 100644
index 0000000..aefa33f
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/AndersenAA.h
@@ -0,0 +1,31 @@
+#ifndef TCFS_ANDERSEN_AA_H
+#define TCFS_ANDERSEN_AA_H
+
+#include "llvm/Analysis/Andersen/Andersen.h"
+
+#include "llvm/Pass.h"
+#include "llvm/Analysis/AliasAnalysis.h"
+
+class AndersenAA: public llvm::ModulePass, public llvm::AliasAnalysis
+{
+private:
+	Andersen* anders;
+
+	llvm::AliasResult andersenAlias(const llvm::Value* l1, const llvm::Value* l2);
+public:
+	static char ID;
+
+	// Interfaces of AliasAnalysis.
+	llvm::AliasResult alias(const llvm::MemoryLocation& l1, const llvm::MemoryLocation& l2);
+	void deleteValue(llvm::Value* v);
+	void copyValue(llvm::Value* from, llvm::Value* to);
+	bool pointsToConstantMemory(const llvm::MemoryLocation& loc, bool orLocal);
+	//ModRefResult getModRefInfo (llvm::ImmutableCallSite cs, const Location &loc);
+
+	AndersenAA(): ModulePass(ID), anders(nullptr) {}
+	bool runOnModule(llvm::Module &M) override;
+//	void getAnalysisUsage(llvm::AnalysisUsage &AU) const;
+//	void* getAdjustedAnalysisPointer(llvm::AnalysisID PI);
+};
+
+#endif
diff --git a/include/llvm/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.h b/include/llvm/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.h
new file mode 100644
index 0000000..4742888
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.h
@@ -0,0 +1,158 @@
+#ifndef LLVM_OBJCRUNTIMECALLHANDLER_H
+#define LLVM_OBJCRUNTIMECALLHANDLER_H
+
+#include "llvm/Analysis/Andersen/ObjCCallHandler.h"
+
+#include <map>
+#include <set>
+
+class Andersen;
+
+namespace llvm {
+    namespace ObjectiveC {
+
+        class objcMsgSend: public CallHandlerBase {
+        public:
+            objcMsgSend() {}
+            virtual bool shouldHandleCall(std::string &F) {return F == "objc_msgSend";};
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+
+        private:
+            void handleCall(StringRef ClassName, StringRef MethodName, bool Meta, Instruction *CallInst, Value *X0, Value *X1, Andersen *andersen);
+        };
+
+        class objcInit: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return -1;};
+        };
+
+        class objcARC: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+
+        class objcPreserveX0: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+
+        class objcPreserveNone : public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+
+        class dispatchBlock: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        private:
+            std::mutex handlerLock;
+        };
+
+        class retainBlock: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        private:
+            std::set<const llvm::Instruction*> Preserved;
+        };
+
+        class specialAllocs: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+
+        class ClassHandler: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+
+        class MsgSendSuper: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+
+        class CopyProperty: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+
+        class ExternalHandler: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+
+        class NSArray: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+
+        private:
+            void handleFastEnum(const Instruction *CallInst, Andersen *andersen);
+        };
+
+        class UIControlTarget: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+
+        };
+
+        class UIAppDelegate: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+
+        };
+
+        class NSUserDefaults: public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        private:
+            Value *singleton = nullptr;
+        };
+
+        class SecItemCopyAdd : public CallHandlerBase {
+        public:
+            virtual bool shouldHandleCall(std::string &F);
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen);
+            virtual int64_t getPriority() const {return 1;};
+        };
+        
+
+//        static RegisterCallHandler<objcMsgSend> X2 = RegisterCallHandler<objcMsgSend>();
+//
+//        static RegisterCallHandler<DummyHandler> X3 = RegisterCallHandler<DummyHandler>();
+//        static RegisterCallHandler<objcInit> X4 = RegisterCallHandler<objcInit>();
+//        static RegisterCallHandler<objcARC> X5 = RegisterCallHandler<objcARC>();
+    }
+}
+
+
+#endif //LLVM_OBJCRUNTIMECALLHANDLER_H
diff --git a/include/llvm/Analysis/Andersen/CleanUpPass.h b/include/llvm/Analysis/Andersen/CleanUpPass.h
new file mode 100644
index 0000000..ec4b03d
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/CleanUpPass.h
@@ -0,0 +1,19 @@
+#ifndef LLVM_CLEANUPPASS_H
+#define LLVM_CLEANUPPASS_H
+
+#include "llvm/Pass.h"
+
+namespace llvm {
+    class CleanUpPass : public ModulePass {
+    public:
+        static char ID;
+
+        CleanUpPass() : ModulePass(ID) { };
+
+        virtual bool runOnModule(Module &M);
+
+    private:
+    };
+}
+
+#endif //LLVM_CLEANUPPASS_H
diff --git a/include/llvm/Analysis/Andersen/Constraint.h b/include/llvm/Analysis/Andersen/Constraint.h
new file mode 100644
index 0000000..1b476f7
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/Constraint.h
@@ -0,0 +1,55 @@
+#ifndef ANDERSEN_CONSTRAINT_H
+#define ANDERSEN_CONSTRAINT_H
+
+#include "llvm/Analysis/Andersen/NodeFactory.h"
+
+#include <cassert>
+
+/// AndersConstraint - Objects of this structure are used to represent the various constraints identified by the algorithm.  The constraints are 'copy', for statements like "A = B", 'load' for statements like "A = *B", 'store' for statements like "*A = B", and AddressOf for statements like A = alloca;  The Offset is applied as *(A + K) = B for stores, A = *(B + K) for loads, and A = B + K for copies.  It is illegal on addressof constraints (because it is statically resolvable to A = &C where C = B + K)
+class AndersConstraint {
+public:
+	enum ConstraintType
+	{
+		ADDR_OF,
+		COPY,
+		LOAD,
+		STORE,
+	};
+private:
+	ConstraintType type;
+	NodeIndex dest;
+	NodeIndex src;
+public:
+	AndersConstraint(ConstraintType Ty, NodeIndex D, NodeIndex S): type(Ty), dest(D), src(S) {
+        assert(D != AndersNodeFactory::InvalidIndex);
+        assert(S != AndersNodeFactory::InvalidIndex);
+        if (D == 489 && S == 21731) {
+            assert(true);
+        }
+    }
+
+	ConstraintType getType() const { return type; }
+	NodeIndex getDest() const { return dest; }
+	NodeIndex getSrc() const { return src; }
+
+	bool operator==(const AndersConstraint &RHS) const
+	{
+		return RHS.type == type && RHS.dest == dest && RHS.src == src;
+	}
+
+	bool operator!=(const AndersConstraint &RHS) const
+	{
+		return !(*this == RHS);
+	}
+
+	bool operator<(const AndersConstraint &RHS) const
+	{
+		if (RHS.type != type)
+			return RHS.type < type;
+		else if (RHS.dest != dest)
+			return RHS.dest < dest;
+		return RHS.src < src;
+	}
+};
+
+#endif
diff --git a/include/llvm/Analysis/Andersen/CycleDetector.h b/include/llvm/Analysis/Andersen/CycleDetector.h
new file mode 100644
index 0000000..16be5c2
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/CycleDetector.h
@@ -0,0 +1,124 @@
+#ifndef ANDERSEN_CYCLEDETECTOR_H
+#define ANDERSEN_CYCLEDETECTOR_H
+
+#include "llvm/Analysis/Andersen/GraphTraits.h"
+
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/DenseSet.h"
+
+#include <deque>
+#include <stack>
+
+// An abstract base class that offers the functionality of detecting SCC in a graph
+// Any concreate class that does cycle detection should inherit from this class, specifiy the GraphType, and implement all the abstract virtual functions
+template <class GraphType>
+class CycleDetector
+{
+public:
+	typedef AndersGraphTraits<GraphType> GraphTraits;
+	typedef typename GraphTraits::NodeType NodeType;
+	typedef typename GraphTraits::NodeIterator node_iterator;
+	typedef typename GraphTraits::ChildIterator child_iterator;
+private:
+	// The SCC stack
+	std::stack<const NodeType*> sccStack;
+	// Map from NodeIndex to DFS number. Nodes that are not in the map are never visited
+	llvm::DenseMap<const NodeType*, unsigned> dfsNum;
+	// The "inComponent" array in Nutilla's improved SCC algorithm
+	llvm::DenseSet<const NodeType*> inComponent;
+	// DFS timestamp
+	unsigned timestamp;
+
+	// visiting each node and perform some task
+	void visit(NodeType* node)
+	{
+		unsigned myTimeStamp = timestamp++;
+		assert(!dfsNum.count(node) && "Revisit the same node again?");
+		dfsNum[node] = myTimeStamp;
+
+		// Traverse succecessor edges
+		for (auto childItr = GraphTraits::child_begin(node), childIte = GraphTraits::child_end(node); childItr != childIte; ++childItr)
+		{
+			NodeType* succRep = getRep(*childItr);
+			if (!dfsNum.count(succRep))
+				visit(succRep);
+
+			if (!inComponent.count(succRep) && dfsNum[node] > dfsNum[succRep])
+				dfsNum[node] = dfsNum[succRep];
+		}
+
+		// See if we have any cycle detected
+		if (myTimeStamp != dfsNum[node])
+		{
+			// If not, push the sccStack and go on
+			sccStack.push(node);
+			return;
+		}
+
+		// Cycle detected
+		inComponent.insert(node);
+		while (!sccStack.empty())
+		{
+			const NodeType* cycleNode = sccStack.top();
+			if (dfsNum[cycleNode] < myTimeStamp)
+				break;
+
+			processNodeOnCycle(cycleNode, node);
+			inComponent.insert(cycleNode);
+			sccStack.pop();
+		}
+
+		processCycleRepNode(node);
+	}
+protected:
+	// Nodes may get merged during the analysis. This function returns the merge target (if the node is merged into another node) or the node itself (if the nodes has not been merged into another node)
+	virtual NodeType* getRep(NodeIndex node) = 0;
+	// Specify how to process the non-rep nodes if a cycle is found
+	virtual void processNodeOnCycle(const NodeType* node, const NodeType* repNode) = 0;
+	// Specify how to process the rep nodes if a cycle is found
+	virtual void processCycleRepNode(const NodeType* node) = 0;
+
+	// Running the cycle detection algorithm on a given graph G
+	void runOnGraph(GraphType* graph)
+	{
+		assert(sccStack.empty() && "sccStack is not empty before cycle detection!");
+		assert(dfsNum.empty() && "dfsNum is not empty before cycle detection!");
+		assert(inComponent.empty() && "inComponent is not empty before cycle detection!");
+
+		for (auto itr = GraphTraits::node_begin(graph), ite = GraphTraits::node_end(graph); itr != ite; ++itr)
+		{
+			NodeType* repNode = getRep(itr->getNodeIndex());
+			if (!dfsNum.count(repNode))
+				visit(repNode);
+		}
+
+		assert(sccStack.empty() && "sccStack not empty after cycle detection!");
+	}
+
+	// Running the cycle detection algorithm on a given graph node. This function is used when walking through the entire graph is not the desirable behavior.
+	void runOnNode(NodeIndex node)
+	{
+		assert(sccStack.empty() && "sccStack is not empty before cycle detection!");
+
+		NodeType* repNode = getRep(node);
+		if (!dfsNum.count(repNode))
+			visit(repNode);
+
+		assert(sccStack.empty() && "sccStack not empty after cycle detection!");
+	}
+
+	void releaseSCCMemory()
+	{
+		dfsNum.clear();
+		inComponent.clear();
+	}
+public:
+	CycleDetector(): timestamp(0) {}
+
+  virtual ~CycleDetector() {}
+
+	// The public interface of running the detector
+	virtual void run() = 0;
+};
+
+#endif
diff --git a/include/llvm/Analysis/Andersen/DetectParametersPass.h b/include/llvm/Analysis/Andersen/DetectParametersPass.h
new file mode 100644
index 0000000..bc243eb
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/DetectParametersPass.h
@@ -0,0 +1,84 @@
+#ifndef LLVM_DETECTPARAMETERSPASS_H
+#define LLVM_DETECTPARAMETERSPASS_H
+
+#include "llvm/Pass.h"
+
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Instruction.h"
+#include <vector>
+#include <set>
+#include <map>
+#include <mutex>
+
+namespace llvm {
+
+    typedef std::set<int64_t> Int64Set_t;
+
+    class DetectParametersPass : public ModulePass {
+    public:
+        typedef std::pair<uint64_t, Instruction*> ParameterAccessPair_t;
+        typedef std::set<ParameterAccessPair_t> ParameterAccessPairSet_t;
+
+        static char ID;
+        DetectParametersPass() : ModulePass(ID) {}
+        virtual void getAnalysisUsage(AnalysisUsage &) const;
+        virtual bool runOnModule(Module &M);
+
+        ParameterAccessPairSet_t &getParameterStackOffsets(const Function *F) {
+            if (StackOffsets.find(F) == StackOffsets.end())
+                StackOffsets[F] = std::unique_ptr<ParameterAccessPairSet_t>(new ParameterAccessPairSet_t());
+            return *StackOffsets[F];
+        };
+        ParameterAccessPairSet_t &getParameterRegisterIndexes(const Function *F){
+            if (RegisterIndexes.find(F) == RegisterIndexes.end())
+                RegisterIndexes[F] = std::unique_ptr<ParameterAccessPairSet_t>(new ParameterAccessPairSet_t());
+            return *RegisterIndexes[F];
+        };
+
+        ParameterAccessPairSet_t &getReturnRegisterIndexes(const Function *F){
+            if (ReturnIndexes.find(F) == ReturnIndexes.end())
+                ReturnIndexes[F] = std::unique_ptr<ParameterAccessPairSet_t>(new ParameterAccessPairSet_t());
+            return *ReturnIndexes[F];
+        };
+
+        typedef std::set<llvm::User *> UserSet_t;
+        static UserSet_t getRegisterValuesAfterCall(const uint64_t RegNo, const Instruction *Inst);
+
+        static UserSet_t getRegisterValuesBeforeCall(const uint64_t RegNo, const Instruction *Inst, const bool GetStores = false);
+
+        ParameterAccessPairSet_t getStackParameters(Function &F, std::set<uint64_t> SPIdx);
+
+        virtual const char *getPassName() const {
+            return "DetectParametersPass";
+        }
+
+        static void setSpecialPreSet(const Instruction *inst, uint64_t RegNo, UserSet_t set);
+
+    private:
+        static UserSet_t getRegisterValuesAfterCall(const uint64_t RegNo, const Instruction *Inst, std::set<const BasicBlock*> &visited);
+        static UserSet_t getRegisterValuesBeforeCall(const uint64_t RegNo, const Instruction *Inst, std::set<const BasicBlock*> &visited, const bool GetStores = false);
+
+        typedef std::vector<Instruction*> InstructionList_t;
+
+        std::map<const Function *, std::unique_ptr<ParameterAccessPairSet_t>> StackOffsets;
+        std::map<const Function *, std::unique_ptr<ParameterAccessPairSet_t>> RegisterIndexes;
+        std::map<const Function *, std::unique_ptr<ParameterAccessPairSet_t>> ReturnIndexes;
+
+        Function *CurrentFunction;
+
+        bool isParameterRegister(uint64_t Idx);
+        bool isStackRegister(uint64_t Idx);
+        bool readBeforeWrite(Instruction *Inst, Instruction *&LoadInst);
+
+        void getMemoryOperations(Instruction *Address, InstructionList_t &Load, InstructionList_t &Store);
+
+        typedef std::map<uint64_t, UserSet_t> RegUserSet_t;
+        typedef std::map<const Instruction*, RegUserSet_t> InstRegUserSet_t;
+
+        static InstRegUserSet_t specialPreSets;
+
+        static std::mutex passLock;
+    };
+}
+
+#endif //LLVM_DETECTPARAMETERSPASS_H
diff --git a/include/llvm/Analysis/Andersen/GraphTraits.h b/include/llvm/Analysis/Andersen/GraphTraits.h
new file mode 100644
index 0000000..16b35cb
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/GraphTraits.h
@@ -0,0 +1,53 @@
+#ifndef ANDERSEN_GRAPHTRAITS_H
+#define ANDERSEN_GRAPHTRAITS_H
+
+// An iterator adapter that takes an iterator over a map and returns the corresponding iterator over the VALUE part of the map (i.e. throws away the KEY part).
+// Such an adapter is useful when we want an iterator to nodes of a graph while internally the graph class save the nodes in the value part of a map
+template <class MapIterator>
+class MapValueIterator
+{
+private:
+	MapIterator itr;
+	typedef typename MapIterator::value_type::second_type MapValueType;
+public:
+	explicit MapValueIterator(const MapIterator& i): itr(i) {}
+
+	bool operator== (const MapValueIterator& other) { return itr == other.itr; }
+	bool operator!= (const MapValueIterator& other) { return !(*this == other); }
+
+	const MapValueType& operator* () { return itr->second; }
+	const MapValueType& operator* () const { return itr->second; }
+
+	const MapValueType* operator->() const { return &(itr->second); }
+
+	// Pre-increment
+	MapValueIterator& operator++() { ++itr; return *this; }
+	// Post-increment
+	const MapValueIterator operator++(int)
+	{
+		MapValueIterator ret(itr);
+		++itr;
+		return ret;
+	}
+};
+
+//This class should be specialized by different graph types used in Andersen's anlysis, which is why the default version is empty
+template <class GraphType>
+class AndersGraphTraits
+{
+	// Elements to provide:
+
+	// typedef NodeType           - Type of Node in the graph
+	// typedef NodeIterator       - Type used to iterator over nodes in graph
+	// typedef ChildIterator      - Type used to iterate over children in graph
+
+	// static ChildIterator child_begin(NodeType*)
+	// static ChildIterator child_end(NodeType*)
+	// - Return iterators that point to the beginning and ending of the child node list for the specified node
+
+	// static NodeIterator node_begin(const GraphType*)
+	// static NodeIterator node_end(const GraphType*)
+	// - Allow iteration over all nodes in the graph
+};
+
+#endif
diff --git a/include/llvm/Analysis/Andersen/NodeFactory.h b/include/llvm/Analysis/Andersen/NodeFactory.h
new file mode 100644
index 0000000..e9b6bcd
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/NodeFactory.h
@@ -0,0 +1,169 @@
+#ifndef ANDERSEN_NODE_FACTORY_H
+#define ANDERSEN_NODE_FACTORY_H
+
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/Value.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/ADT/DenseMap.h"
+
+#include <vector>
+#include <mutex>
+
+// AndersNode class - This class is used to represent a node in the constraint graph.  Due to various optimizations, it is not always the case that there is always a mapping from a Node to a Value. (In particular, we add artificial Node's that represent the set of pointed-to variables shared for each location equivalent Node.
+// Ordinary clients are not allowed to create AndersNode objects. To guarantee index consistency, AndersNodes (and its subclasses) instances should only be created through AndersNodeFactory.
+typedef unsigned NodeIndex;
+class AndersNode
+{
+public:
+	enum AndersNodeType
+	{
+		VALUE_NODE,
+		OBJ_NODE
+	};
+private:
+	AndersNodeType type;
+	NodeIndex idx, mergeTarget;
+	const llvm::Value* value;
+	AndersNode(AndersNodeType t, unsigned i, const llvm::Value* v = nullptr): type(t), idx(i), mergeTarget(i), value(v) {}
+public:
+	NodeIndex getIndex() const { return idx; }
+	const llvm::Value* getValue() const { return value; }
+
+	friend class AndersNodeFactory;
+};
+
+// This is the factory class of AndersNode
+// It use a vectors to hold all Nodes in the program
+// Since vectors may invalidate all element pointers/iterators when resizing, it is impossible to return AndersNode* in public interfaces without using std::unique_ptr and heap allocations. Therefore, we use plain integers to represent nodes for public functions like createXXX and getXXX. This is ugly, but it is efficient.
+class AndersNodeFactory
+{
+public:
+	// The largest unsigned int is reserved for invalid index
+	static const unsigned InvalidIndex;
+private:
+	// The datalayout info
+	const llvm::DataLayout* dataLayout;
+
+	// The set of nodes 
+	std::vector<AndersNode> nodes;
+
+	// Some special indices
+	static const NodeIndex UniversalPtrIndex = 0;
+	static const NodeIndex UniversalObjIndex = 1;
+	static const NodeIndex NullPtrIndex = 2;
+	static const NodeIndex NullObjectIndex = 3;
+
+	// valueNodeMap - This map indicates the AndersNode* that a particular Value* corresponds to
+	llvm::DenseMap<const llvm::Value*, NodeIndex> valueNodeMap;
+	
+	// ObjectNodes - This map contains entries for each memory object in the program: globals, alloca's and mallocs.
+	// We are able to represent them as llvm::Value* because we're modeling the heap with the simplest allocation-site approach
+	llvm::DenseMap<const llvm::Value*, NodeIndex> objNodeMap;
+
+	// returnMap - This map contains an entry for each function in the program that returns a ptr.
+	llvm::DenseMap<const llvm::Function*, NodeIndex> returnMap;
+
+	// varargMap - This map contains the entry used to represent all pointers passed through the varargs portion of a function call for a particular function.  An entry is not present in this map for functions that do not take variable arguments.
+	llvm::DenseMap<const llvm::Function*, NodeIndex> varargMap;
+
+    llvm::DenseMap<const llvm::Value*, const llvm::Value*> dummyMap;
+    llvm::DenseMap<const llvm::Value*, const llvm::Value*> dummyOriginMap;
+
+    std::recursive_mutex nodeLock;
+public:
+	AndersNodeFactory();
+
+	void setDataLayout(const llvm::DataLayout* d) { dataLayout = d; }
+
+	// Factory methods
+	NodeIndex createValueNode(const llvm::Value* val = nullptr);
+	NodeIndex createObjectNode(const llvm::Value* val = nullptr);
+	NodeIndex createReturnNode(const llvm::Function* f);
+	NodeIndex createVarargNode(const llvm::Function* f);
+
+	// Map lookup interfaces (return InvalidIndex if value not found)
+	NodeIndex getValueNodeFor(const llvm::Value* val) const;
+	NodeIndex getValueNodeForConstant(const llvm::Constant* c) const;
+	NodeIndex getObjectNodeFor(const llvm::Value* val) const;
+	NodeIndex getObjectNodeForConstant(const llvm::Constant* c) const;
+	NodeIndex getReturnNodeFor(const llvm::Function* f) const;
+	NodeIndex getVarargNodeFor(const llvm::Function* f) const;
+
+    llvm::Value *createDummy(llvm::Module &M) {
+        return new llvm::GlobalVariable(M, llvm::IntegerType::get(llvm::getGlobalContext(), 1), false, llvm::GlobalVariable::ExternalLinkage,
+                                        nullptr);
+//        return new llvm::GlobalVariable(M, llvm::IntegerType::get(llvm::getGlobalContext(), 1), false, llvm::GlobalValue::CommonLinkage);
+    }
+
+    NodeIndex createObjectNodeDummy(const llvm::Value *val, llvm::Module &M) {
+        std::unique_lock<std::recursive_mutex> lock(nodeLock);
+        const llvm::Value *dummy = createDummy(M);
+        NodeIndex idx = createObjectNode(dummy);
+        dummyMap[val] = dummy;
+        dummyOriginMap[dummy] = val;
+        return idx;
+    }
+
+    const llvm::Value *getAbstractLocation(const llvm::Value *val) {
+        std::unique_lock<std::recursive_mutex> lock(nodeLock);
+        if (dummyMap.find(val) != dummyMap.end())
+            return dummyMap[val];
+        return val;
+    }
+
+    const llvm::Value *getLocation(const llvm::Value *val) {
+        if (dummyOriginMap.find(val) == dummyOriginMap.end()) {
+            return nullptr;
+            llvm_unreachable("not a dummy?");
+        }
+        return dummyOriginMap[val];
+    }
+
+	// Node merge interfaces
+	void mergeNode(NodeIndex n0, NodeIndex n1);	// Merge n1 into n0
+	NodeIndex getMergeTarget(NodeIndex n);
+	NodeIndex getMergeTarget(NodeIndex n) const;
+
+	// Pointer arithmetic
+	bool isObjectNode(NodeIndex i) const
+	{
+		return (nodes.at(i).type == AndersNode::OBJ_NODE);
+	}
+	NodeIndex getOffsetObjectNode(NodeIndex n, unsigned offset) const
+	{
+		assert(isObjectNode(n + offset));
+		return n + offset;
+	}
+
+	// Special node getters
+	NodeIndex getUniversalPtrNode() const { return UniversalPtrIndex; }
+	NodeIndex getUniversalObjNode() const { return UniversalObjIndex; }
+	NodeIndex getNullPtrNode() const { return NullPtrIndex; }
+	NodeIndex getNullObjectNode() const { return NullObjectIndex; }
+
+	// Value getters
+	const llvm::Value* getValueForNode(NodeIndex i) const
+	{
+		return nodes.at(i).getValue();
+	}
+	void getAllocSites(std::vector<const llvm::Value*>&) const;
+
+	// Value remover
+	void removeNodeForValue(const llvm::Value* val)
+	{
+		valueNodeMap.erase(val);
+	}
+
+	// Size getters
+	unsigned getNumNodes() const { return nodes.size(); }
+
+	// For debugging purpose
+	void dumpNode(NodeIndex) const;
+	void dumpNodeInfo() const;
+	void dumpRepInfo() const;
+};
+
+#endif
diff --git a/include/llvm/Analysis/Andersen/NonVolatileRegistersPass.h b/include/llvm/Analysis/Andersen/NonVolatileRegistersPass.h
new file mode 100644
index 0000000..62cd37d
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/NonVolatileRegistersPass.h
@@ -0,0 +1,23 @@
+#ifndef LLVM_NONVOLATILEREGISTERSPASS_H
+#define LLVM_NONVOLATILEREGISTERSPASS_H
+
+#include "llvm/Pass.h"
+
+namespace llvm {
+    class NonVolatileRegistersPass : public ModulePass {
+    public:
+        static char ID;
+
+        NonVolatileRegistersPass() : ModulePass(ID) { };
+
+        virtual bool runOnModule(Module &M);
+
+    private:
+        bool hasCall(const BasicBlock &BB);
+        bool isNonVolatile(uint64_t Idx);
+        bool isStack(uint64_t Idx);
+        void replaceLoaded(Instruction *StoreInst);
+    };
+}
+
+#endif //LLVM_NONVOLATILEREGISTERSPASS_H
diff --git a/include/llvm/Analysis/Andersen/ObjCCallHandler.h b/include/llvm/Analysis/Andersen/ObjCCallHandler.h
new file mode 100644
index 0000000..2c67e89
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/ObjCCallHandler.h
@@ -0,0 +1,92 @@
+#ifndef LLVM_OBJCCALLHANDLER_H
+#define LLVM_OBJCCALLHANDLER_H
+
+#include <map>
+#include <mutex>
+#include <string>
+#include "llvm/ADT/StringRef.h"
+#include "llvm/IR/CallSite.h"
+#include "llvm/Analysis/Andersen/SimpleCallGraph.h"
+
+class Andersen;
+
+namespace llvm {
+    namespace ObjectiveC {
+
+        class CallHandlerManager;
+        class objcARC;
+        class objcInit;
+        class objcMsgSend;
+
+        class CallHandlerBase {
+        public:
+            virtual ~CallHandlerBase() {};
+            virtual StringRef &getFunctionName() {return *FunctionName;};
+
+            //TODO: make this class abstract so subclasses have to do this
+            virtual bool run(const Instruction *CallInst, std::string &F, Andersen *andersen) {return true;}
+            virtual bool shouldHandleCall(std::string &F) = 0;
+
+            bool operator<(CallHandlerBase &other) const
+            {
+                return getPriority() > other.getPriority();
+            }
+
+            static bool isObjectiveCMethod(StringRef F);
+            static StringRef getClassname(StringRef F);
+            static StringRef getMethodname(StringRef F);
+
+        protected:
+            StringRef *FunctionName;
+
+            bool isSelf(Instruction *v, Andersen *andersen);
+
+
+            virtual int64_t getPriority() const = 0;
+        };
+
+        CallHandlerManager &getGlobalCallHandlerManager();
+
+
+        class CallHandlerManager {
+        public:
+            CallHandlerManager() {
+                assert(true);
+            };
+
+            static CallHandlerManager &getInstance();
+
+            template<class T>
+            void registerCallHandler() {
+
+//                CallHandlers.insert(std::make_pair(FunctionName, NULL));
+//                CallHandlers.push_back(std::unique_ptr<CallHandlerBase>(new T()));
+                addCallHandler(std::shared_ptr<T>(new T()));
+            }
+
+            void addCallHandler(std::shared_ptr<CallHandlerBase> Handler);
+            bool handleFunctionCall(const Instruction *CallInst, std::string &F, Andersen *andersen);
+
+        private:
+            typedef std::shared_ptr<CallHandlerBase> CallHandlerPtr_t;
+            typedef std::map<StringRef, std::shared_ptr<CallHandlerBase>> CallHandlerMap_t;
+            typedef std::vector<CallHandlerPtr_t> CallHandlerList_t;
+            CallHandlerList_t CallHandlers;
+            CallHandlerPtr_t getCallHandler(StringRef &FunctionName);
+
+            static std::mutex initLock;
+        };
+
+
+        template <class T>
+        class RegisterCallHandler {
+        public:
+            RegisterCallHandler() {
+                getGlobalCallHandlerManager().registerCallHandler<T>();
+            }
+        };
+
+    }
+}
+
+#endif //LLVM_OBJCCALLHANDLER_H
diff --git a/include/llvm/Analysis/Andersen/ObjectiveCBinary.h b/include/llvm/Analysis/Andersen/ObjectiveCBinary.h
new file mode 100644
index 0000000..92baf06
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/ObjectiveCBinary.h
@@ -0,0 +1,97 @@
+#ifndef LLVM_OBJECTIVECBINARY_H
+#define LLVM_OBJECTIVECBINARY_H
+
+#include "llvm/Object/MachO.h"
+
+#include <map>
+#include "llvm/Analysis/Andersen/ObjectiveCClassInfo.h"
+#include "llvm/ADT/SmallString.h"
+
+namespace llvm {
+
+    namespace ObjectiveC {
+        class IVAR;
+    }
+
+    class ObjectiveCBinary {
+    public:
+        typedef std::shared_ptr<llvm::ObjectiveC::Base> BaseClassPtr_t;
+        typedef std::shared_ptr<llvm::ObjectiveC::Class> ClassPtr_t;
+        typedef std::map<std::string, BaseClassPtr_t> ClassMap_t;
+        typedef std::map<std::string, ObjectiveC::Protocol> ProtocolMap_t;
+
+        ObjectiveCBinary(llvm::StringRef Path);
+        bool isValidAddress(uint64_t Address);
+
+        bool isAddressInSection(uint64_t Address, object::section_iterator Section);
+        bool isSelectorRef(uint64_t Address);
+        bool isClassRef(uint64_t Address);
+        bool isMethname(uint64_t Address);
+        bool isData(uint64_t Address);
+        bool isConst(uint64_t Address);
+        bool isIVAR(uint64_t Address);
+
+        bool getValue(const uint64_t Address, uint64_t &Value);
+        bool getData(const uint64_t Address, StringRef &Content);
+
+        bool getClass(const uint64_t Address, StringRef &Classname);
+        bool getSelector(const uint64_t Address, StringRef &Selectorname);
+
+        bool isCFString(const uint64_t Address);
+        bool isCString(const uint64_t Address);
+
+        bool isConstValue(const uint64_t Address);
+
+        StringRef getString(uint64_t Address);
+
+        std::deque<std::string> getMethodCandidates(StringRef Type, StringRef Selector, bool Meta);
+        std::string getFunctionName(uint64_t Address);
+
+        template<typename T> T getRAWData(uint64_t address){
+            T r;
+            StringRef data = MachO->getData();
+            StringRef slice = data.slice(address - 0x100000000, sizeof(T));
+            r = *((T*)slice.data());
+            return r;
+        }
+
+        std::map<uint64_t, ObjectiveC::IVAR> &getIVARs() {return IVARs;};
+
+        ClassMap_t &getClasses() {return Classes;}
+        ClassMap_t &getMetaClasses() {return Metaclasses;}
+        ProtocolMap_t &getProtocols() {return protocolMap;}
+        object::section_iterator getSectionIterator(StringRef Name);
+        std::string getSectionName(uint64_t address);
+    private:
+        llvm::object::OwningBinary<llvm::object::ObjectFile> ObjectFile;
+        llvm::object::MachOObjectFile *MachO;
+
+        object::DataRefImpl SelRefsDataRef;
+        object::DataRefImpl MethnameDataRef;
+
+
+        void loadSections();
+        void loadClasses();
+        void doBinding();
+
+        void parseClass(uint64_t DataAddress, bool MetaClass = false);
+        std::vector<ObjectiveC::Method> parseMethods(uint64_t MethodsPtr, uint64_t SignatureStartPtr = 0, uint64_t *signaturesIdx = NULL);
+
+        llvm::MachO::segment_command_64 getSegment(uint64_t SegmentNo);
+
+        void addClass(StringRef ClassName, uint64_t Address);
+
+
+
+        std::map<uint64_t, StringRef> BindInfo;
+        std::map<uint64_t, StringRef> ClassRefs;
+        std::map<uint64_t, StringRef> SelRefs;
+        std::map<uint64_t, StringRef> ClassNames;
+        std::map<uint64_t, ObjectiveC::IVAR> IVARs;
+        ClassMap_t Classes;
+        ClassMap_t Metaclasses;
+        ProtocolMap_t protocolMap;
+    };
+}
+
+#endif //LLVM_OBJECTIVECBINARY_H
diff --git a/include/llvm/Analysis/Andersen/ObjectiveCClassInfo.h b/include/llvm/Analysis/Andersen/ObjectiveCClassInfo.h
new file mode 100644
index 0000000..3ae8e13
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/ObjectiveCClassInfo.h
@@ -0,0 +1,143 @@
+#ifndef LLVM_OBJECTIVECCLASSINFO_H
+#define LLVM_OBJECTIVECCLASSINFO_H
+
+#include "llvm/ADT/StringRef.h"
+
+#include <vector>
+
+namespace llvm {
+    namespace ObjectiveC {
+
+        enum ClassType {
+            Initialized,
+            Dummy,
+        };
+
+        class Method;
+        class IVAR;
+        class Protocol;
+
+        class Base {
+        public:
+            Base(StringRef Classname) : Classname(Classname), Address(0) {}
+            virtual ~Base() {}
+
+            StringRef getClassName() {
+                return Classname;
+            }
+
+            StringRef getSuperclass() {return Superclass;};
+            void setSuperclass(StringRef s) {Superclass = s;};
+
+            void setAddress(uint64_t a) { Address = a; }
+            uint64_t getAddress() { return Address; }
+
+            virtual ClassType getType() = 0;
+        protected:
+            StringRef Classname;
+            StringRef Superclass;
+            uint64_t Address;
+        };
+
+        class Class: public Base {
+        public:
+            typedef std::vector<std::string> ProtocolList_t;
+
+            Class(StringRef Classname) : Base(Classname) {}
+
+            virtual ClassType getType() { return ClassType::Initialized; };
+
+
+
+            void addMethod(Method M);
+            bool getMethod(StringRef Methodname, Method &M);
+
+            void addIVAR(IVAR ivar);
+            bool getIVAR(StringRef IVARName, IVAR &ivar);
+            bool getIVAR(uint64_t IVAROffset, IVAR &ivar);
+
+            void addProtocol(std::string protocol) {
+                protocols.push_back(protocol);
+            }
+
+            ProtocolList_t &getProtocolList() {return protocols;}
+        private:
+
+            typedef std::vector<Method> MethodList_t;
+            MethodList_t Methods;
+
+            typedef std::vector<IVAR> IVARList_t;
+            IVARList_t IVARs;
+
+            ProtocolList_t protocols;
+        };
+
+        class DummyClass: public Base {
+        public:
+            DummyClass(StringRef Classname): Base(Classname) {}
+            virtual ClassType getType() { return ClassType::Dummy; };
+        };
+
+        class Method {
+            friend class Class;
+        public:
+            typedef std::pair<uint64_t, std::string> RegType_t;
+            Method(StringRef Methodname, uint64_t IMP, StringRef type) : Methodname(Methodname), IMP(IMP), type(type), Parent(0) { parseType();}
+            Method(const Method &M) : Methodname(M.Methodname), IMP(M.IMP), type(M.type), Parent(M.Parent), regTypes(M.regTypes){}
+
+            StringRef getMethodname() {return Methodname;}
+            std::vector<RegType_t> getRegTypes() {return regTypes; };
+        private:
+            StringRef Methodname;
+            uint64_t IMP;
+            std::string type;
+            Base *Parent;
+            std::vector<RegType_t> regTypes;
+
+            void parseType();
+        };
+
+        class IVAR {
+            friend class Class;
+        public:
+            IVAR(StringRef IVARName, uint64_t OffsetPtr, StringRef IVARType) : IVARName(IVARName), OffsetPtr(OffsetPtr), IVARType(IVARType) {};
+            IVAR(const IVAR &ivar) : IVARName(ivar.IVARName), OffsetPtr(ivar.OffsetPtr), IVARType(ivar.IVARType) {};
+            IVAR() {};
+
+//            StringRef getID() {return std::string(ParentClass.str() + "." + IVARName.str());};
+            std::string getID() {return ParentClass.str() + IVARName.str();};
+
+            StringRef getType() {return IVARType;}
+        private:
+            StringRef IVARName;
+            uint64_t OffsetPtr;
+            StringRef ParentClass;
+            StringRef IVARType;
+        };
+
+        class Protocol {
+        public:
+            Protocol(std::string protocolname) : protocolName(protocolname) {
+
+            }
+
+            Protocol(const Protocol &p) : protocolName(p.protocolName), instanceMethods(p.instanceMethods), classMethods(p.classMethods) {
+
+            }
+
+            Protocol() {}
+
+            void addInstanceMethod(Method m) { instanceMethods.push_back(m); }
+            void addClassMethod(Method m) { classMethods.push_back(m); }
+
+            std::vector<Method> getInstanceMethods() {return instanceMethods;}
+            std::vector<Method> getClassMethods() {return classMethods;}
+        private:
+            std::string protocolName;
+            std::vector<Method> instanceMethods;
+            std::vector<Method> classMethods;
+        };
+    }
+}
+
+#endif //LLVM_OBJECTIVECCLASSINFO_H
diff --git a/include/llvm/Analysis/Andersen/PtsSet.h b/include/llvm/Analysis/Andersen/PtsSet.h
new file mode 100644
index 0000000..0529425
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/PtsSet.h
@@ -0,0 +1,76 @@
+#ifndef ANDERSEN_PTSSET_H
+#define ANDERSEN_PTSSET_H
+
+#include "llvm/ADT/SparseBitVector.h"
+
+// We move the points-to set representation here into a separate class
+// The intention is to let us try out different internal implementation of this data-structure (e.g. vectors/bitvecs/sets, ref-counted/non-refcounted) easily
+class AndersPtsSet
+{
+private:
+	llvm::SparseBitVector<> bitvec;
+public:
+	using iterator = llvm::SparseBitVector<>::iterator;
+
+	// Return true if *this has idx as an element
+	// This function should be marked const, but we cannot do it because SparseBitVector::test() is not marked const. WHY???
+	bool has(unsigned idx)
+	{
+		return bitvec.test(idx);
+	}
+	bool has(unsigned idx) const
+	{
+		// Since llvm::SparseBitVector::test() does not have a const quantifier, we have to use this ugly workaround to implement has()
+		llvm::SparseBitVector<> idVec;
+		idVec.set(idx);
+		return bitvec.contains(idVec);
+	}
+
+	// Return true if the ptsset changes
+	bool insert(unsigned idx)
+	{
+		return bitvec.test_and_set(idx);
+	}
+
+	// Return true if *this is a superset of other
+	bool contains(const AndersPtsSet& other) const
+	{
+		return bitvec.contains(other.bitvec);
+	}
+
+	// intersectWith: return true if *this and other share points-to elements
+	bool intersectWith(const AndersPtsSet& other) const
+	{
+		return bitvec.intersects(other.bitvec);
+	}
+
+	// Return true if the ptsset changes
+	bool unionWith(const AndersPtsSet& other)
+	{
+		return bitvec |= other.bitvec;
+	}
+
+	void clear()
+	{
+		bitvec.clear();
+	}
+
+	unsigned getSize() const
+	{
+		return bitvec.count();		// NOT a constant time operation!
+	}
+	bool isEmpty() const		// Always prefer using this function to perform empty test 
+	{
+		return bitvec.empty();
+	}
+
+	bool operator==(const AndersPtsSet& other) const
+	{
+		return bitvec == other.bitvec;
+	}
+
+	iterator begin() const { return bitvec.begin(); }
+	iterator end() const { return bitvec.end(); }
+};
+
+#endif
diff --git a/include/llvm/Analysis/Andersen/SimpleCallGraph.h b/include/llvm/Analysis/Andersen/SimpleCallGraph.h
new file mode 100644
index 0000000..fec15e2
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/SimpleCallGraph.h
@@ -0,0 +1,46 @@
+#ifndef LLVM_SIMPLECALLGRAPH_H
+#define LLVM_SIMPLECALLGRAPH_H
+
+#include <set>
+#include <map>
+#include <mutex>
+#include "llvm/ADT/StringRef.h"
+#include "llvm/IR/Instruction.h"
+
+namespace llvm {
+    class SimpleCallGraph {
+    public:
+        SimpleCallGraph(Module &M): M(M) {};
+        typedef std::set<std::string> FunctionSet_t;
+        typedef std::set<const Instruction*> InstructionSet_t;
+
+        void addCallEdge(const Instruction *CallInst, std::string Target);
+
+        InstructionSet_t &getCallers(std::string F);
+        FunctionSet_t &getCalled(const Instruction *Inst);
+        FunctionSet_t getCalled(const std::string &fun);
+        bool containtsEdge(const Instruction *Inst, std::string F);
+
+        void finalize();
+
+        bool hasPath(std::string &from, std::string &to);
+
+        void print(raw_ostream &ostream);
+    private:
+        typedef std::map<const Instruction*, std::shared_ptr<FunctionSet_t>> CallGraph_t;
+        typedef std::map<std::string, std::shared_ptr<InstructionSet_t>> ReverseCallGraph_t;
+
+        CallGraph_t CallGraph;
+        ReverseCallGraph_t ReverseCallGraph;
+
+        Module &M;
+        std::mutex graphLock;
+
+        typedef std::pair<std::string, std::string> FromTo_t;
+        typedef std::map<FromTo_t, bool> PathCache_t;
+        std::mutex pathCacheLock;
+        PathCache_t pathCache;
+    };
+}
+
+#endif //LLVM_SIMPLECALLGRAPH_H
diff --git a/include/llvm/Analysis/Andersen/SparseBitVectorGraph.h b/include/llvm/Analysis/Andersen/SparseBitVectorGraph.h
new file mode 100644
index 0000000..3eed263
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/SparseBitVectorGraph.h
@@ -0,0 +1,129 @@
+#ifndef ANDERSEN_SPARSEBITVECTOR_GRAPH_H
+#define ANDERSEN_SPARSEBITVECTOR_GRAPH_H
+
+#include "llvm/Analysis/Andersen/GraphTraits.h"
+#include "llvm/Analysis/Andersen/NodeFactory.h"
+
+#include "llvm/ADT/SparseBitVector.h"
+#include "llvm/ADT/DenseMap.h"
+
+#include <algorithm>
+#include <unordered_map>
+
+// The node of a graph class where successor edges are represented by sparse bit vectors
+class SparseBitVectorGraphNode
+{
+private:
+	NodeIndex idx;
+	llvm::SparseBitVector<> succs;
+
+	void insertEdge(NodeIndex n) { return succs.set(n); }
+
+	SparseBitVectorGraphNode(NodeIndex i): idx(i) {}
+public:
+	using iterator = llvm::SparseBitVector<>::iterator;
+
+	NodeIndex getNodeIndex() const { return idx; }
+
+	iterator begin() const { return succs.begin(); }
+	iterator end() const { return succs.end(); }
+
+	unsigned succ_getSize() const { return succs.count(); }
+
+	friend class SparseBitVectorGraph;
+};
+
+// A graph class where successor edges are represented by sparse bit vectors
+class SparseBitVectorGraph
+{
+private:
+	// Here we cannot use DenseMap because we need iterator stability: we might want to call getOrInsertNode() when another node is being iterated
+	using NodeMapTy = std::unordered_map<NodeIndex, SparseBitVectorGraphNode>;
+	NodeMapTy graph;
+public:
+	using iterator = NodeMapTy::iterator;
+	using const_iterator = NodeMapTy::const_iterator;
+private:
+	iterator getOrInsertNodeMap(NodeIndex idx)
+	{
+		auto itr = graph.find(idx);
+		if (itr == graph.end())
+			itr = graph.insert(std::make_pair(idx, SparseBitVectorGraphNode(idx))).first;
+		return itr;
+	}
+public:
+	SparseBitVectorGraph() {}
+
+	SparseBitVectorGraphNode* getOrInsertNode(NodeIndex idx)
+	{
+		auto itr = getOrInsertNodeMap(idx);
+		return &(itr->second);
+	}
+
+	void insertEdge(NodeIndex src, NodeIndex dst)
+	{
+		auto itr = getOrInsertNodeMap(src);
+		(itr->second).insertEdge(dst);
+	}
+
+	// src's successors += dst's successors
+	void mergeEdge(NodeIndex src, NodeIndex dst)
+	{
+		auto dstItr = graph.find(dst);
+		if (dstItr == graph.end())
+			return;
+
+		auto srcItr = getOrInsertNodeMap(src);
+		(srcItr->second).succs |= (dstItr->second).succs;
+	}
+
+	SparseBitVectorGraphNode* getNodeWithIndex(NodeIndex idx)
+	{
+		auto itr = graph.find(idx);
+		if (itr == graph.end())
+			return nullptr;
+		else
+			return &(itr->second);
+	}
+
+	unsigned getSize() const { return graph.size(); }
+
+	void releaseMemory()
+	{
+		graph.clear();
+	}
+
+	iterator begin() { return graph.begin(); }
+	iterator end() { return graph.end(); }
+	const_iterator begin() const { return graph.begin(); }
+	const_iterator end() const { return graph.end(); }
+};
+
+// Specialize the AnderGraphTraits for SparseBitVectorGraph
+template <> class AndersGraphTraits<SparseBitVectorGraph>
+{
+public:
+	typedef SparseBitVectorGraphNode NodeType;
+	typedef MapValueIterator<SparseBitVectorGraph::iterator> NodeIterator;
+	typedef SparseBitVectorGraphNode::iterator ChildIterator;
+
+	static inline ChildIterator child_begin(NodeType* n)
+	{
+		return n->begin();
+	}
+	static inline ChildIterator child_end(NodeType* n)
+	{
+		return n->end();
+	}
+
+	static inline NodeIterator node_begin(SparseBitVectorGraph* g)
+	{
+		return NodeIterator(g->begin());
+	}
+	static inline NodeIterator node_end(SparseBitVectorGraph* g)
+	{
+		return NodeIterator(g->end());
+	}
+};
+
+#endif
diff --git a/include/llvm/Analysis/Andersen/StackAccessPass.h b/include/llvm/Analysis/Andersen/StackAccessPass.h
new file mode 100644
index 0000000..36bfbfc
--- /dev/null
+++ b/include/llvm/Analysis/Andersen/StackAccessPass.h
@@ -0,0 +1,101 @@
+#ifndef LLVM_STACKACCESSPASS_H
+#define LLVM_STACKACCESSPASS_H
+
+#include "llvm/Pass.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Function.h"
+
+#include <map>
+#include <vector>
+#include <set>
+#include <deque>
+#include <tuple>
+#include <mutex>
+
+namespace llvm {
+
+  class StackAccessPass : public ModulePass {
+  public:
+    static char ID;
+
+    StackAccessPass() : ModulePass(ID) {
+    }
+
+    typedef std::set<const Value *> ValueList_t;
+    typedef std::set<int64_t> Int64List_t;
+    typedef std::map<const Value *, std::shared_ptr<Int64List_t>> OffsetMap_t;
+    typedef std::map<int64_t, std::shared_ptr<ValueList_t>> OffsetValueListMap_t;
+
+    virtual bool runOnModule(Module &M);
+
+    static void runOnFunction(Function &F, OffsetMap_t &OffsetMap, OffsetValueListMap_t &OffsetValueListMap,
+                              std::set<uint64_t> SPIdx);
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const;
+
+    virtual const char *getPassName() const {
+      return "StackAccessPass";
+    }
+
+    OffsetMap_t &getOffsets(const Function *F) {
+      if (Offsets.find(F) == Offsets.end())
+        Offsets[F] = std::shared_ptr<OffsetMap_t>(new OffsetMap_t());
+      return *Offsets[F];
+    };
+
+    OffsetValueListMap_t &getOffsetValues(const Function *F) {
+      if (ValuesForOffset.find(F) == ValuesForOffset.end())
+        ValuesForOffset[F] = std::shared_ptr<OffsetValueListMap_t>(new OffsetValueListMap_t());
+      return *ValuesForOffset[F];
+    };
+
+    /**
+     * findStackPointer defines if the last store of the stackpointer should be used as starting point
+     * or if false the passed instrution is used
+     */
+
+    /**
+     * findStackPointer defines if the last store of the stackpointer should be used as starting point
+     * or if false the passed instrution is used
+     * @param  Inst             The call instruction for which the stack offset should be calculated
+     * @param  findStackPointer
+     * @return                  The stack offset
+     */
+    int64_t getStackPointerValue(const Instruction *Inst, bool findStackPointer = true);
+
+  private:
+
+    typedef std::map<const Function *, std::shared_ptr<OffsetMap_t>> FunctionOffsetMap_t;
+    typedef std::map<const Function *, std::shared_ptr<OffsetValueListMap_t>> FunctionOffsetValueListMap_t;
+
+    typedef std::pair<Instruction *, int64_t> InstructionOffsetPair_t;
+    typedef std::tuple<Instruction *, int64_t, Instruction *> InstructionOffsetTuple_t;
+
+    static bool isStackPointer(Value *Ptr, std::set<uint64_t> SPIdx);
+
+    FunctionOffsetMap_t Offsets;
+    FunctionOffsetValueListMap_t ValuesForOffset;
+
+    Function *CurrentFunction;
+
+    std::deque<InstructionOffsetTuple_t> Worklist;
+
+    /**
+     * Returns the instruction that points to the stack pointer element in the register set
+     * @param  F The function of interest
+     * @return   The pointer to the stack pointer register
+     */
+    const Instruction *getStackPointer(const Function *F);
+
+    /**
+     * @param  Inst     The initial instruction to start backtracking
+     * @param  InstList A queue containing all instructions to backtrack
+     * @param  SPIdx    A set containing the indexes of the registers in the register file
+     * @return          All offset candidates at this point (Inst)
+     */
+    static std::set<int64_t> backtrackInstruction(const Instruction *Inst, std::deque<const Instruction *> &InstList, const std::set<uint64_t> SPIdx);
+  };
+}
+
+#endif //LLVM_STACKACCESSPASS_H
diff --git a/include/llvm/DecMethods/AArch64RegID.h b/include/llvm/DecMethods/AArch64RegID.h
new file mode 100644
index 0000000..940ecb7
--- /dev/null
+++ b/include/llvm/DecMethods/AArch64RegID.h
@@ -0,0 +1,12 @@
+#ifndef LLVM_AARCH64REGID_H
+#define LLVM_AARCH64REGID_H
+
+#include "Opcodes.h"
+
+namespace llvm {
+    namespace AArch64 {
+
+    }
+}
+
+#endif //LLVM_AARCH64REGID_H
diff --git a/include/llvm/DecMethods/Opcodes.h b/include/llvm/DecMethods/Opcodes.h
new file mode 100644
index 0000000..e5c7b6f
--- /dev/null
+++ b/include/llvm/DecMethods/Opcodes.h
@@ -0,0 +1,11 @@
+#ifndef LLVM_OPCODES_H
+#define LLVM_OPCODES_H
+
+namespace llvm {
+    enum {
+        ID = (0x1 << 63) | 0x1;
+    };
+
+}
+
+#endif //LLVM_OPCODES_H
diff --git a/include/llvm/IR/PatternMatch.h b/include/llvm/IR/PatternMatch.h
index f4d7d8c..da0c96e 100644
--- a/include/llvm/IR/PatternMatch.h
+++ b/include/llvm/IR/PatternMatch.h
@@ -796,6 +796,12 @@ inline CastClass_match<OpTy, Instruction::PtrToInt> m_PtrToInt(const OpTy &Op) {
   return CastClass_match<OpTy, Instruction::PtrToInt>(Op);
 }
 
+/// \brief Matches PtrToInt.
+template <typename OpTy>
+inline CastClass_match<OpTy, Instruction::IntToPtr> m_IntToPtr(const OpTy &Op) {
+    return CastClass_match<OpTy, Instruction::IntToPtr>(Op);
+}
+
 /// \brief Matches Trunc.
 template <typename OpTy>
 inline CastClass_match<OpTy, Instruction::Trunc> m_Trunc(const OpTy &Op) {
diff --git a/include/llvm/LLVMSlicer/StaticSlicer.h b/include/llvm/LLVMSlicer/StaticSlicer.h
new file mode 100644
index 0000000..0fd1783
--- /dev/null
+++ b/include/llvm/LLVMSlicer/StaticSlicer.h
@@ -0,0 +1,25 @@
+#ifndef LLVM_STATICSLICER_H_H
+#define LLVM_STATICSLICER_H_H
+
+#include "llvm/Pass.h"
+
+namespace llvm {
+
+    namespace slicing {
+
+    }
+
+    class Slicer : public ModulePass {
+    public:
+        static char ID;
+
+        Slicer() : ModulePass(ID) {}
+
+        virtual bool runOnModule(Module &M);
+
+        void getAnalysisUsage(AnalysisUsage &AU) const;
+    };
+}
+
+
+#endif //LLVM_STATICSLICER_H_H
diff --git a/include/sparsehash/dense_hash_map b/include/sparsehash/dense_hash_map
new file mode 100644
index 0000000..05fd580
--- /dev/null
+++ b/include/sparsehash/dense_hash_map
@@ -0,0 +1,369 @@
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ----
+//
+// This is just a very thin wrapper over densehashtable.h, just
+// like sgi stl's stl_hash_map is a very thin wrapper over
+// stl_hashtable.  The major thing we define is operator[], because
+// we have a concept of a data_type which stl_hashtable doesn't
+// (it only has a key and a value).
+//
+// NOTE: this is exactly like sparse_hash_map.h, with the word
+// "sparse" replaced by "dense", except for the addition of
+// set_empty_key().
+//
+//   YOU MUST CALL SET_EMPTY_KEY() IMMEDIATELY AFTER CONSTRUCTION.
+//
+// Otherwise your program will die in mysterious ways.  (Note if you
+// use the constructor that takes an InputIterator range, you pass in
+// the empty key in the constructor, rather than after.  As a result,
+// this constructor differs from the standard STL version.)
+//
+// In other respects, we adhere mostly to the STL semantics for
+// hash-map.  One important exception is that insert() may invalidate
+// iterators entirely -- STL semantics are that insert() may reorder
+// iterators, but they all still refer to something valid in the
+// hashtable.  Not so for us.  Likewise, insert() may invalidate
+// pointers into the hashtable.  (Whether insert invalidates iterators
+// and pointers depends on whether it results in a hashtable resize).
+// On the plus side, delete() doesn't invalidate iterators or pointers
+// at all, or even change the ordering of elements.
+//
+// Here are a few "power user" tips:
+//
+//    1) set_deleted_key():
+//         If you want to use erase() you *must* call set_deleted_key(),
+//         in addition to set_empty_key(), after construction.
+//         The deleted and empty keys must differ.
+//
+//    2) resize(0):
+//         When an item is deleted, its memory isn't freed right
+//         away.  This allows you to iterate over a hashtable,
+//         and call erase(), without invalidating the iterator.
+//         To force the memory to be freed, call resize(0).
+//         For tr1 compatibility, this can also be called as rehash(0).
+//
+//    3) min_load_factor(0.0)
+//         Setting the minimum load factor to 0.0 guarantees that
+//         the hash table will never shrink.
+//
+// Roughly speaking:
+//   (1) dense_hash_map: fastest, uses the most memory unless entries are small
+//   (2) sparse_hash_map: slowest, uses the least memory
+//   (3) hash_map / unordered_map (STL): in the middle
+//
+// Typically I use sparse_hash_map when I care about space and/or when
+// I need to save the hashtable on disk.  I use hash_map otherwise.  I
+// don't personally use dense_hash_set ever; some people use it for
+// small sets with lots of lookups.
+//
+// - dense_hash_map has, typically, about 78% memory overhead (if your
+//   data takes up X bytes, the hash_map uses .78X more bytes in overhead).
+// - sparse_hash_map has about 4 bits overhead per entry.
+// - sparse_hash_map can be 3-7 times slower than the others for lookup and,
+//   especially, inserts.  See time_hash_map.cc for details.
+//
+// See /usr/(local/)?doc/sparsehash-*/dense_hash_map.html
+// for information about how to use this class.
+
+#ifndef _DENSE_HASH_MAP_H_
+#define _DENSE_HASH_MAP_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <algorithm>                        // needed by stl_alloc
+#include <functional>                       // for equal_to<>, select1st<>, etc
+#include <memory>                           // for alloc
+#include <utility>                          // for pair<>
+#include <sparsehash/internal/densehashtable.h>        // IWYU pragma: export
+#include <sparsehash/internal/libc_allocator_with_realloc.h>
+#include HASH_FUN_H                 // for hash<>
+_START_GOOGLE_NAMESPACE_
+
+template <class Key, class T,
+          class HashFcn = SPARSEHASH_HASH<Key>,   // defined in sparseconfig.h
+          class EqualKey = std::equal_to<Key>,
+          class Alloc = libc_allocator_with_realloc<std::pair<const Key, T> > >
+class dense_hash_map {
+ private:
+  // Apparently select1st is not stl-standard, so we define our own
+  struct SelectKey {
+    typedef const Key& result_type;
+    const Key& operator()(const std::pair<const Key, T>& p) const {
+      return p.first;
+    }
+  };
+  struct SetKey {
+    void operator()(std::pair<const Key, T>* value, const Key& new_key) const {
+      *const_cast<Key*>(&value->first) = new_key;
+      // It would be nice to clear the rest of value here as well, in
+      // case it's taking up a lot of memory.  We do this by clearing
+      // the value.  This assumes T has a zero-arg constructor!
+      value->second = T();
+    }
+  };
+  // For operator[].
+  struct DefaultValue {
+    std::pair<const Key, T> operator()(const Key& key) {
+      return std::make_pair(key, T());
+    }
+  };
+
+  // The actual data
+  typedef dense_hashtable<std::pair<const Key, T>, Key, HashFcn, SelectKey,
+                          SetKey, EqualKey, Alloc> ht;
+  ht rep;
+
+ public:
+  typedef typename ht::key_type key_type;
+  typedef T data_type;
+  typedef T mapped_type;
+  typedef typename ht::value_type value_type;
+  typedef typename ht::hasher hasher;
+  typedef typename ht::key_equal key_equal;
+  typedef Alloc allocator_type;
+
+  typedef typename ht::size_type size_type;
+  typedef typename ht::difference_type difference_type;
+  typedef typename ht::pointer pointer;
+  typedef typename ht::const_pointer const_pointer;
+  typedef typename ht::reference reference;
+  typedef typename ht::const_reference const_reference;
+
+  typedef typename ht::iterator iterator;
+  typedef typename ht::const_iterator const_iterator;
+  typedef typename ht::local_iterator local_iterator;
+  typedef typename ht::const_local_iterator const_local_iterator;
+
+  // Iterator functions
+  iterator begin()                               { return rep.begin(); }
+  iterator end()                                 { return rep.end(); }
+  const_iterator begin() const                   { return rep.begin(); }
+  const_iterator end() const                     { return rep.end(); }
+
+
+  // These come from tr1's unordered_map. For us, a bucket has 0 or 1 elements.
+  local_iterator begin(size_type i)              { return rep.begin(i); }
+  local_iterator end(size_type i)                { return rep.end(i); }
+  const_local_iterator begin(size_type i) const  { return rep.begin(i); }
+  const_local_iterator end(size_type i) const    { return rep.end(i); }
+
+  // Accessor functions
+  allocator_type get_allocator() const           { return rep.get_allocator(); }
+  hasher hash_funct() const                      { return rep.hash_funct(); }
+  hasher hash_function() const                   { return hash_funct(); }
+  key_equal key_eq() const                       { return rep.key_eq(); }
+
+
+  // Constructors
+  explicit dense_hash_map(size_type expected_max_items_in_table = 0,
+                          const hasher& hf = hasher(),
+                          const key_equal& eql = key_equal(),
+                          const allocator_type& alloc = allocator_type())
+    : rep(expected_max_items_in_table, hf, eql, SelectKey(), SetKey(), alloc) {
+  }
+
+  template <class InputIterator>
+  dense_hash_map(InputIterator f, InputIterator l,
+                 const key_type& empty_key_val,
+                 size_type expected_max_items_in_table = 0,
+                 const hasher& hf = hasher(),
+                 const key_equal& eql = key_equal(),
+                 const allocator_type& alloc = allocator_type())
+    : rep(expected_max_items_in_table, hf, eql, SelectKey(), SetKey(), alloc) {
+    set_empty_key(empty_key_val);
+    rep.insert(f, l);
+  }
+  // We use the default copy constructor
+  // We use the default operator=()
+  // We use the default destructor
+
+  void clear()                        { rep.clear(); }
+  // This clears the hash map without resizing it down to the minimum
+  // bucket count, but rather keeps the number of buckets constant
+  void clear_no_resize()              { rep.clear_no_resize(); }
+  void swap(dense_hash_map& hs)       { rep.swap(hs.rep); }
+
+
+  // Functions concerning size
+  size_type size() const              { return rep.size(); }
+  size_type max_size() const          { return rep.max_size(); }
+  bool empty() const                  { return rep.empty(); }
+  size_type bucket_count() const      { return rep.bucket_count(); }
+  size_type max_bucket_count() const  { return rep.max_bucket_count(); }
+
+  // These are tr1 methods.  bucket() is the bucket the key is or would be in.
+  size_type bucket_size(size_type i) const    { return rep.bucket_size(i); }
+  size_type bucket(const key_type& key) const { return rep.bucket(key); }
+  float load_factor() const {
+    return size() * 1.0f / bucket_count();
+  }
+  float max_load_factor() const {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    return grow;
+  }
+  void max_load_factor(float new_grow) {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    rep.set_resizing_parameters(shrink, new_grow);
+  }
+  // These aren't tr1 methods but perhaps ought to be.
+  float min_load_factor() const {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    return shrink;
+  }
+  void min_load_factor(float new_shrink) {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    rep.set_resizing_parameters(new_shrink, grow);
+  }
+  // Deprecated; use min_load_factor() or max_load_factor() instead.
+  void set_resizing_parameters(float shrink, float grow) {
+    rep.set_resizing_parameters(shrink, grow);
+  }
+
+  void resize(size_type hint)         { rep.resize(hint); }
+  void rehash(size_type hint)         { resize(hint); }      // the tr1 name
+
+  // Lookup routines
+  iterator find(const key_type& key)                 { return rep.find(key); }
+  const_iterator find(const key_type& key) const     { return rep.find(key); }
+
+  data_type& operator[](const key_type& key) {       // This is our value-add!
+    // If key is in the hashtable, returns find(key)->second,
+    // otherwise returns insert(value_type(key, T()).first->second.
+    // Note it does not create an empty T unless the find fails.
+    return rep.template find_or_insert<DefaultValue>(key).second;
+  }
+
+  size_type count(const key_type& key) const         { return rep.count(key); }
+
+  std::pair<iterator, iterator> equal_range(const key_type& key) {
+    return rep.equal_range(key);
+  }
+  std::pair<const_iterator, const_iterator> equal_range(const key_type& key)
+      const {
+    return rep.equal_range(key);
+  }
+
+
+  // Insertion routines
+  std::pair<iterator, bool> insert(const value_type& obj) {
+    return rep.insert(obj);
+  }
+  template <class InputIterator> void insert(InputIterator f, InputIterator l) {
+    rep.insert(f, l);
+  }
+  void insert(const_iterator f, const_iterator l) {
+    rep.insert(f, l);
+  }
+  // Required for std::insert_iterator; the passed-in iterator is ignored.
+  iterator insert(iterator, const value_type& obj) {
+    return insert(obj).first;
+  }
+
+  // Deletion and empty routines
+  // THESE ARE NON-STANDARD!  I make you specify an "impossible" key
+  // value to identify deleted and empty buckets.  You can change the
+  // deleted key as time goes on, or get rid of it entirely to be insert-only.
+  void set_empty_key(const key_type& key)   {           // YOU MUST CALL THIS!
+    rep.set_empty_key(value_type(key, data_type()));    // rep wants a value
+  }
+  key_type empty_key() const {
+    return rep.empty_key().first;                       // rep returns a value
+  }
+
+  void set_deleted_key(const key_type& key)   { rep.set_deleted_key(key); }
+  void clear_deleted_key()                    { rep.clear_deleted_key(); }
+  key_type deleted_key() const                { return rep.deleted_key(); }
+
+  // These are standard
+  size_type erase(const key_type& key)               { return rep.erase(key); }
+  void erase(iterator it)                            { rep.erase(it); }
+  void erase(iterator f, iterator l)                 { rep.erase(f, l); }
+
+
+  // Comparison
+  bool operator==(const dense_hash_map& hs) const    { return rep == hs.rep; }
+  bool operator!=(const dense_hash_map& hs) const    { return rep != hs.rep; }
+
+
+  // I/O -- this is an add-on for writing hash map to disk
+  //
+  // For maximum flexibility, this does not assume a particular
+  // file type (though it will probably be a FILE *).  We just pass
+  // the fp through to rep.
+
+  // If your keys and values are simple enough, you can pass this
+  // serializer to serialize()/unserialize().  "Simple enough" means
+  // value_type is a POD type that contains no pointers.  Note,
+  // however, we don't try to normalize endianness.
+  typedef typename ht::NopointerSerializer NopointerSerializer;
+
+  // serializer: a class providing operator()(OUTPUT*, const value_type&)
+  //    (writing value_type to OUTPUT).  You can specify a
+  //    NopointerSerializer object if appropriate (see above).
+  // fp: either a FILE*, OR an ostream*/subclass_of_ostream*, OR a
+  //    pointer to a class providing size_t Write(const void*, size_t),
+  //    which writes a buffer into a stream (which fp presumably
+  //    owns) and returns the number of bytes successfully written.
+  //    Note basic_ostream<not_char> is not currently supported.
+  template <typename ValueSerializer, typename OUTPUT>
+  bool serialize(ValueSerializer serializer, OUTPUT* fp) {
+    return rep.serialize(serializer, fp);
+  }
+
+  // serializer: a functor providing operator()(INPUT*, value_type*)
+  //    (reading from INPUT and into value_type).  You can specify a
+  //    NopointerSerializer object if appropriate (see above).
+  // fp: either a FILE*, OR an istream*/subclass_of_istream*, OR a
+  //    pointer to a class providing size_t Read(void*, size_t),
+  //    which reads into a buffer from a stream (which fp presumably
+  //    owns) and returns the number of bytes successfully read.
+  //    Note basic_istream<not_char> is not currently supported.
+  // NOTE: Since value_type is std::pair<const Key, T>, ValueSerializer
+  // may need to do a const cast in order to fill in the key.
+  template <typename ValueSerializer, typename INPUT>
+  bool unserialize(ValueSerializer serializer, INPUT* fp) {
+    return rep.unserialize(serializer, fp);
+  }
+};
+
+// We need a global swap as well
+template <class Key, class T, class HashFcn, class EqualKey, class Alloc>
+inline void swap(dense_hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,
+                 dense_hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm2) {
+  hm1.swap(hm2);
+}
+
+_END_GOOGLE_NAMESPACE_
+
+#endif /* _DENSE_HASH_MAP_H_ */
diff --git a/include/sparsehash/dense_hash_set b/include/sparsehash/dense_hash_set
new file mode 100644
index 0000000..050b15d
--- /dev/null
+++ b/include/sparsehash/dense_hash_set
@@ -0,0 +1,338 @@
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+//
+// This is just a very thin wrapper over densehashtable.h, just
+// like sgi stl's stl_hash_set is a very thin wrapper over
+// stl_hashtable.  The major thing we define is operator[], because
+// we have a concept of a data_type which stl_hashtable doesn't
+// (it only has a key and a value).
+//
+// This is more different from dense_hash_map than you might think,
+// because all iterators for sets are const (you obviously can't
+// change the key, and for sets there is no value).
+//
+// NOTE: this is exactly like sparse_hash_set.h, with the word
+// "sparse" replaced by "dense", except for the addition of
+// set_empty_key().
+//
+//   YOU MUST CALL SET_EMPTY_KEY() IMMEDIATELY AFTER CONSTRUCTION.
+//
+// Otherwise your program will die in mysterious ways.  (Note if you
+// use the constructor that takes an InputIterator range, you pass in
+// the empty key in the constructor, rather than after.  As a result,
+// this constructor differs from the standard STL version.)
+//
+// In other respects, we adhere mostly to the STL semantics for
+// hash-map.  One important exception is that insert() may invalidate
+// iterators entirely -- STL semantics are that insert() may reorder
+// iterators, but they all still refer to something valid in the
+// hashtable.  Not so for us.  Likewise, insert() may invalidate
+// pointers into the hashtable.  (Whether insert invalidates iterators
+// and pointers depends on whether it results in a hashtable resize).
+// On the plus side, delete() doesn't invalidate iterators or pointers
+// at all, or even change the ordering of elements.
+//
+// Here are a few "power user" tips:
+//
+//    1) set_deleted_key():
+//         If you want to use erase() you must call set_deleted_key(),
+//         in addition to set_empty_key(), after construction.
+//         The deleted and empty keys must differ.
+//
+//    2) resize(0):
+//         When an item is deleted, its memory isn't freed right
+//         away.  This allows you to iterate over a hashtable,
+//         and call erase(), without invalidating the iterator.
+//         To force the memory to be freed, call resize(0).
+//         For tr1 compatibility, this can also be called as rehash(0).
+//
+//    3) min_load_factor(0.0)
+//         Setting the minimum load factor to 0.0 guarantees that
+//         the hash table will never shrink.
+//
+// Roughly speaking:
+//   (1) dense_hash_set: fastest, uses the most memory unless entries are small
+//   (2) sparse_hash_set: slowest, uses the least memory
+//   (3) hash_set / unordered_set (STL): in the middle
+//
+// Typically I use sparse_hash_set when I care about space and/or when
+// I need to save the hashtable on disk.  I use hash_set otherwise.  I
+// don't personally use dense_hash_set ever; some people use it for
+// small sets with lots of lookups.
+//
+// - dense_hash_set has, typically, about 78% memory overhead (if your
+//   data takes up X bytes, the hash_set uses .78X more bytes in overhead).
+// - sparse_hash_set has about 4 bits overhead per entry.
+// - sparse_hash_set can be 3-7 times slower than the others for lookup and,
+//   especially, inserts.  See time_hash_map.cc for details.
+//
+// See /usr/(local/)?doc/sparsehash-*/dense_hash_set.html
+// for information about how to use this class.
+
+#ifndef _DENSE_HASH_SET_H_
+#define _DENSE_HASH_SET_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <algorithm>                        // needed by stl_alloc
+#include <functional>                       // for equal_to<>, select1st<>, etc
+#include <memory>                           // for alloc
+#include <utility>                          // for pair<>
+#include <sparsehash/internal/densehashtable.h>        // IWYU pragma: export
+#include <sparsehash/internal/libc_allocator_with_realloc.h>
+#include HASH_FUN_H                 // for hash<>
+_START_GOOGLE_NAMESPACE_
+
+template <class Value,
+          class HashFcn = SPARSEHASH_HASH<Value>,   // defined in sparseconfig.h
+          class EqualKey = std::equal_to<Value>,
+          class Alloc = libc_allocator_with_realloc<Value> >
+class dense_hash_set {
+ private:
+  // Apparently identity is not stl-standard, so we define our own
+  struct Identity {
+    typedef const Value& result_type;
+    const Value& operator()(const Value& v) const { return v; }
+  };
+  struct SetKey {
+    void operator()(Value* value, const Value& new_key) const {
+      *value = new_key;
+    }
+  };
+
+  // The actual data
+  typedef dense_hashtable<Value, Value, HashFcn, Identity, SetKey,
+                          EqualKey, Alloc> ht;
+  ht rep;
+
+ public:
+  typedef typename ht::key_type key_type;
+  typedef typename ht::value_type value_type;
+  typedef typename ht::hasher hasher;
+  typedef typename ht::key_equal key_equal;
+  typedef Alloc allocator_type;
+
+  typedef typename ht::size_type size_type;
+  typedef typename ht::difference_type difference_type;
+  typedef typename ht::const_pointer pointer;
+  typedef typename ht::const_pointer const_pointer;
+  typedef typename ht::const_reference reference;
+  typedef typename ht::const_reference const_reference;
+
+  typedef typename ht::const_iterator iterator;
+  typedef typename ht::const_iterator const_iterator;
+  typedef typename ht::const_local_iterator local_iterator;
+  typedef typename ht::const_local_iterator const_local_iterator;
+
+
+  // Iterator functions -- recall all iterators are const
+  iterator begin() const                  { return rep.begin(); }
+  iterator end() const                    { return rep.end(); }
+
+  // These come from tr1's unordered_set. For us, a bucket has 0 or 1 elements.
+  local_iterator begin(size_type i) const { return rep.begin(i); }
+  local_iterator end(size_type i) const   { return rep.end(i); }
+
+
+  // Accessor functions
+  allocator_type get_allocator() const    { return rep.get_allocator(); }
+  hasher hash_funct() const               { return rep.hash_funct(); }
+  hasher hash_function() const            { return hash_funct(); }  // tr1 name
+  key_equal key_eq() const                { return rep.key_eq(); }
+
+
+  // Constructors
+  explicit dense_hash_set(size_type expected_max_items_in_table = 0,
+                          const hasher& hf = hasher(),
+                          const key_equal& eql = key_equal(),
+                          const allocator_type& alloc = allocator_type())
+      : rep(expected_max_items_in_table, hf, eql, Identity(), SetKey(), alloc) {
+  }
+
+  template <class InputIterator>
+  dense_hash_set(InputIterator f, InputIterator l,
+                 const key_type& empty_key_val,
+                 size_type expected_max_items_in_table = 0,
+                 const hasher& hf = hasher(),
+                 const key_equal& eql = key_equal(),
+                 const allocator_type& alloc = allocator_type())
+      : rep(expected_max_items_in_table, hf, eql, Identity(), SetKey(), alloc) {
+    set_empty_key(empty_key_val);
+    rep.insert(f, l);
+  }
+  // We use the default copy constructor
+  // We use the default operator=()
+  // We use the default destructor
+
+  void clear()                        { rep.clear(); }
+  // This clears the hash set without resizing it down to the minimum
+  // bucket count, but rather keeps the number of buckets constant
+  void clear_no_resize()              { rep.clear_no_resize(); }
+  void swap(dense_hash_set& hs)       { rep.swap(hs.rep); }
+
+
+  // Functions concerning size
+  size_type size() const              { return rep.size(); }
+  size_type max_size() const          { return rep.max_size(); }
+  bool empty() const                  { return rep.empty(); }
+  size_type bucket_count() const      { return rep.bucket_count(); }
+  size_type max_bucket_count() const  { return rep.max_bucket_count(); }
+
+  // These are tr1 methods.  bucket() is the bucket the key is or would be in.
+  size_type bucket_size(size_type i) const    { return rep.bucket_size(i); }
+  size_type bucket(const key_type& key) const { return rep.bucket(key); }
+  float load_factor() const {
+    return size() * 1.0f / bucket_count();
+  }
+  float max_load_factor() const {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    return grow;
+  }
+  void max_load_factor(float new_grow) {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    rep.set_resizing_parameters(shrink, new_grow);
+  }
+  // These aren't tr1 methods but perhaps ought to be.
+  float min_load_factor() const {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    return shrink;
+  }
+  void min_load_factor(float new_shrink) {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    rep.set_resizing_parameters(new_shrink, grow);
+  }
+  // Deprecated; use min_load_factor() or max_load_factor() instead.
+  void set_resizing_parameters(float shrink, float grow) {
+    rep.set_resizing_parameters(shrink, grow);
+  }
+
+  void resize(size_type hint)         { rep.resize(hint); }
+  void rehash(size_type hint)         { resize(hint); }     // the tr1 name
+
+  // Lookup routines
+  iterator find(const key_type& key) const           { return rep.find(key); }
+
+  size_type count(const key_type& key) const         { return rep.count(key); }
+
+  std::pair<iterator, iterator> equal_range(const key_type& key) const {
+    return rep.equal_range(key);
+  }
+
+
+  // Insertion routines
+  std::pair<iterator, bool> insert(const value_type& obj) {
+    std::pair<typename ht::iterator, bool> p = rep.insert(obj);
+    return std::pair<iterator, bool>(p.first, p.second);   // const to non-const
+  }
+  template <class InputIterator> void insert(InputIterator f, InputIterator l) {
+    rep.insert(f, l);
+  }
+  void insert(const_iterator f, const_iterator l) {
+    rep.insert(f, l);
+  }
+  // Required for std::insert_iterator; the passed-in iterator is ignored.
+  iterator insert(iterator, const value_type& obj)   {
+    return insert(obj).first;
+  }
+
+  // Deletion and empty routines
+  // THESE ARE NON-STANDARD!  I make you specify an "impossible" key
+  // value to identify deleted and empty buckets.  You can change the
+  // deleted key as time goes on, or get rid of it entirely to be insert-only.
+  void set_empty_key(const key_type& key)     { rep.set_empty_key(key); }
+  key_type empty_key() const                  { return rep.empty_key(); }
+
+  void set_deleted_key(const key_type& key)   { rep.set_deleted_key(key); }
+  void clear_deleted_key()                    { rep.clear_deleted_key(); }
+  key_type deleted_key() const                { return rep.deleted_key(); }
+
+  // These are standard
+  size_type erase(const key_type& key)               { return rep.erase(key); }
+  void erase(iterator it)                            { rep.erase(it); }
+  void erase(iterator f, iterator l)                 { rep.erase(f, l); }
+
+
+  // Comparison
+  bool operator==(const dense_hash_set& hs) const    { return rep == hs.rep; }
+  bool operator!=(const dense_hash_set& hs) const    { return rep != hs.rep; }
+
+
+  // I/O -- this is an add-on for writing metainformation to disk
+  //
+  // For maximum flexibility, this does not assume a particular
+  // file type (though it will probably be a FILE *).  We just pass
+  // the fp through to rep.
+
+  // If your keys and values are simple enough, you can pass this
+  // serializer to serialize()/unserialize().  "Simple enough" means
+  // value_type is a POD type that contains no pointers.  Note,
+  // however, we don't try to normalize endianness.
+  typedef typename ht::NopointerSerializer NopointerSerializer;
+
+  // serializer: a class providing operator()(OUTPUT*, const value_type&)
+  //    (writing value_type to OUTPUT).  You can specify a
+  //    NopointerSerializer object if appropriate (see above).
+  // fp: either a FILE*, OR an ostream*/subclass_of_ostream*, OR a
+  //    pointer to a class providing size_t Write(const void*, size_t),
+  //    which writes a buffer into a stream (which fp presumably
+  //    owns) and returns the number of bytes successfully written.
+  //    Note basic_ostream<not_char> is not currently supported.
+  template <typename ValueSerializer, typename OUTPUT>
+  bool serialize(ValueSerializer serializer, OUTPUT* fp) {
+    return rep.serialize(serializer, fp);
+  }
+
+  // serializer: a functor providing operator()(INPUT*, value_type*)
+  //    (reading from INPUT and into value_type).  You can specify a
+  //    NopointerSerializer object if appropriate (see above).
+  // fp: either a FILE*, OR an istream*/subclass_of_istream*, OR a
+  //    pointer to a class providing size_t Read(void*, size_t),
+  //    which reads into a buffer from a stream (which fp presumably
+  //    owns) and returns the number of bytes successfully read.
+  //    Note basic_istream<not_char> is not currently supported.
+  template <typename ValueSerializer, typename INPUT>
+  bool unserialize(ValueSerializer serializer, INPUT* fp) {
+    return rep.unserialize(serializer, fp);
+  }
+};
+
+template <class Val, class HashFcn, class EqualKey, class Alloc>
+inline void swap(dense_hash_set<Val, HashFcn, EqualKey, Alloc>& hs1,
+                 dense_hash_set<Val, HashFcn, EqualKey, Alloc>& hs2) {
+  hs1.swap(hs2);
+}
+
+_END_GOOGLE_NAMESPACE_
+
+#endif /* _DENSE_HASH_SET_H_ */
diff --git a/include/sparsehash/internal/densehashtable.h b/include/sparsehash/internal/densehashtable.h
new file mode 100644
index 0000000..97eb245
--- /dev/null
+++ b/include/sparsehash/internal/densehashtable.h
@@ -0,0 +1,1325 @@
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+//
+// A dense hashtable is a particular implementation of
+// a hashtable: one that is meant to minimize memory allocation.
+// It does this by using an array to store all the data.  We
+// steal a value from the key space to indicate "empty" array
+// elements (ie indices where no item lives) and another to indicate
+// "deleted" elements.
+//
+// (Note it is possible to change the value of the delete key
+// on the fly; you can even remove it, though after that point
+// the hashtable is insert_only until you set it again.  The empty
+// value however can't be changed.)
+//
+// To minimize allocation and pointer overhead, we use internal
+// probing, in which the hashtable is a single table, and collisions
+// are resolved by trying to insert again in another bucket.  The
+// most cache-efficient internal probing schemes are linear probing
+// (which suffers, alas, from clumping) and quadratic probing, which
+// is what we implement by default.
+//
+// Type requirements: value_type is required to be Copy Constructible
+// and Default Constructible. It is not required to be (and commonly
+// isn't) Assignable.
+//
+// You probably shouldn't use this code directly.  Use dense_hash_map<>
+// or dense_hash_set<> instead.
+
+// You can change the following below:
+// HT_OCCUPANCY_PCT      -- how full before we double size
+// HT_EMPTY_PCT          -- how empty before we halve size
+// HT_MIN_BUCKETS        -- default smallest bucket size
+//
+// You can also change enlarge_factor (which defaults to
+// HT_OCCUPANCY_PCT), and shrink_factor (which defaults to
+// HT_EMPTY_PCT) with set_resizing_parameters().
+//
+// How to decide what values to use?
+// shrink_factor's default of .4 * OCCUPANCY_PCT, is probably good.
+// HT_MIN_BUCKETS is probably unnecessary since you can specify
+// (indirectly) the starting number of buckets at construct-time.
+// For enlarge_factor, you can use this chart to try to trade-off
+// expected lookup time to the space taken up.  By default, this
+// code uses quadratic probing, though you can change it to linear
+// via JUMP_ below if you really want to.
+//
+// From http://www.augustana.ca/~mohrj/courses/1999.fall/csc210/lecture_notes/hashing.html
+// NUMBER OF PROBES / LOOKUP       Successful            Unsuccessful
+// Quadratic collision resolution   1 - ln(1-L) - L/2    1/(1-L) - L - ln(1-L)
+// Linear collision resolution     [1+1/(1-L)]/2         [1+1/(1-L)2]/2
+//
+// -- enlarge_factor --           0.10  0.50  0.60  0.75  0.80  0.90  0.99
+// QUADRATIC COLLISION RES.
+//    probes/successful lookup    1.05  1.44  1.62  2.01  2.21  2.85  5.11
+//    probes/unsuccessful lookup  1.11  2.19  2.82  4.64  5.81  11.4  103.6
+// LINEAR COLLISION RES.
+//    probes/successful lookup    1.06  1.5   1.75  2.5   3.0   5.5   50.5
+//    probes/unsuccessful lookup  1.12  2.5   3.6   8.5   13.0  50.0  5000.0
+
+#ifndef _DENSEHASHTABLE_H_
+#define _DENSEHASHTABLE_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <assert.h>
+#include <stdio.h>              // for FILE, fwrite, fread
+#include <algorithm>            // For swap(), eg
+#include <iterator>             // For iterator tags
+#include <limits>               // for numeric_limits
+#include <memory>               // For uninitialized_fill
+#include <utility>              // for pair
+#include <sparsehash/internal/hashtable-common.h>
+#include <sparsehash/internal/libc_allocator_with_realloc.h>
+#include <sparsehash/type_traits.h>
+#include <stdexcept>                 // For length_error
+
+_START_GOOGLE_NAMESPACE_
+
+namespace base {   // just to make google->opensource transition easier
+using GOOGLE_NAMESPACE::true_type;
+using GOOGLE_NAMESPACE::false_type;
+using GOOGLE_NAMESPACE::integral_constant;
+using GOOGLE_NAMESPACE::is_same;
+using GOOGLE_NAMESPACE::remove_const;
+}
+
+// The probing method
+// Linear probing
+// #define JUMP_(key, num_probes)    ( 1 )
+// Quadratic probing
+#define JUMP_(key, num_probes)    ( num_probes )
+
+// Hashtable class, used to implement the hashed associative containers
+// hash_set and hash_map.
+
+// Value: what is stored in the table (each bucket is a Value).
+// Key: something in a 1-to-1 correspondence to a Value, that can be used
+//      to search for a Value in the table (find() takes a Key).
+// HashFcn: Takes a Key and returns an integer, the more unique the better.
+// ExtractKey: given a Value, returns the unique Key associated with it.
+//             Must inherit from unary_function, or at least have a
+//             result_type enum indicating the return type of operator().
+// SetKey: given a Value* and a Key, modifies the value such that
+//         ExtractKey(value) == key.  We guarantee this is only called
+//         with key == deleted_key or key == empty_key.
+// EqualKey: Given two Keys, says whether they are the same (that is,
+//           if they are both associated with the same Value).
+// Alloc: STL allocator to use to allocate memory.
+
+template <class Value, class Key, class HashFcn,
+          class ExtractKey, class SetKey, class EqualKey, class Alloc>
+class dense_hashtable;
+
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct dense_hashtable_iterator;
+
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct dense_hashtable_const_iterator;
+
+// We're just an array, but we need to skip over empty and deleted elements
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct dense_hashtable_iterator {
+ private:
+  typedef typename A::template rebind<V>::other value_alloc_type;
+
+ public:
+  typedef dense_hashtable_iterator<V,K,HF,ExK,SetK,EqK,A>       iterator;
+  typedef dense_hashtable_const_iterator<V,K,HF,ExK,SetK,EqK,A> const_iterator;
+
+  typedef std::forward_iterator_tag iterator_category;  // very little defined!
+  typedef V value_type;
+  typedef typename value_alloc_type::difference_type difference_type;
+  typedef typename value_alloc_type::size_type size_type;
+  typedef typename value_alloc_type::reference reference;
+  typedef typename value_alloc_type::pointer pointer;
+
+  // "Real" constructor and default constructor
+  dense_hashtable_iterator(const dense_hashtable<V,K,HF,ExK,SetK,EqK,A> *h,
+                           pointer it, pointer it_end, bool advance)
+    : ht(h), pos(it), end(it_end)   {
+    if (advance)  advance_past_empty_and_deleted();
+  }
+  dense_hashtable_iterator() { }
+  // The default destructor is fine; we don't define one
+  // The default operator= is fine; we don't define one
+
+  // Happy dereferencer
+  reference operator*() const { return *pos; }
+  pointer operator->() const { return &(operator*()); }
+
+  // Arithmetic.  The only hard part is making sure that
+  // we're not on an empty or marked-deleted array element
+  void advance_past_empty_and_deleted() {
+    while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )
+      ++pos;
+  }
+  iterator& operator++()   {
+    assert(pos != end); ++pos; advance_past_empty_and_deleted(); return *this;
+  }
+  iterator operator++(int) { iterator tmp(*this); ++*this; return tmp; }
+
+  // Comparison.
+  bool operator==(const iterator& it) const { return pos == it.pos; }
+  bool operator!=(const iterator& it) const { return pos != it.pos; }
+
+
+  // The actual data
+  const dense_hashtable<V,K,HF,ExK,SetK,EqK,A> *ht;
+  pointer pos, end;
+};
+
+
+// Now do it all again, but with const-ness!
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct dense_hashtable_const_iterator {
+ private:
+  typedef typename A::template rebind<V>::other value_alloc_type;
+
+ public:
+  typedef dense_hashtable_iterator<V,K,HF,ExK,SetK,EqK,A>       iterator;
+  typedef dense_hashtable_const_iterator<V,K,HF,ExK,SetK,EqK,A> const_iterator;
+
+  typedef std::forward_iterator_tag iterator_category;  // very little defined!
+  typedef V value_type;
+  typedef typename value_alloc_type::difference_type difference_type;
+  typedef typename value_alloc_type::size_type size_type;
+  typedef typename value_alloc_type::const_reference reference;
+  typedef typename value_alloc_type::const_pointer pointer;
+
+  // "Real" constructor and default constructor
+  dense_hashtable_const_iterator(
+      const dense_hashtable<V,K,HF,ExK,SetK,EqK,A> *h,
+      pointer it, pointer it_end, bool advance)
+    : ht(h), pos(it), end(it_end)   {
+    if (advance)  advance_past_empty_and_deleted();
+  }
+  dense_hashtable_const_iterator()
+    : ht(NULL), pos(pointer()), end(pointer()) { }
+  // This lets us convert regular iterators to const iterators
+  dense_hashtable_const_iterator(const iterator &it)
+    : ht(it.ht), pos(it.pos), end(it.end) { }
+  // The default destructor is fine; we don't define one
+  // The default operator= is fine; we don't define one
+
+  // Happy dereferencer
+  reference operator*() const { return *pos; }
+  pointer operator->() const { return &(operator*()); }
+
+  // Arithmetic.  The only hard part is making sure that
+  // we're not on an empty or marked-deleted array element
+  void advance_past_empty_and_deleted() {
+    while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )
+      ++pos;
+  }
+  const_iterator& operator++()   {
+    assert(pos != end); ++pos; advance_past_empty_and_deleted(); return *this;
+  }
+  const_iterator operator++(int) { const_iterator tmp(*this); ++*this; return tmp; }
+
+  // Comparison.
+  bool operator==(const const_iterator& it) const { return pos == it.pos; }
+  bool operator!=(const const_iterator& it) const { return pos != it.pos; }
+
+
+  // The actual data
+  const dense_hashtable<V,K,HF,ExK,SetK,EqK,A> *ht;
+  pointer pos, end;
+};
+
+template <class Value, class Key, class HashFcn,
+          class ExtractKey, class SetKey, class EqualKey, class Alloc>
+class dense_hashtable {
+ private:
+  typedef typename Alloc::template rebind<Value>::other value_alloc_type;
+
+ public:
+  typedef Key key_type;
+  typedef Value value_type;
+  typedef HashFcn hasher;
+  typedef EqualKey key_equal;
+  typedef Alloc allocator_type;
+
+  typedef typename value_alloc_type::size_type size_type;
+  typedef typename value_alloc_type::difference_type difference_type;
+  typedef typename value_alloc_type::reference reference;
+  typedef typename value_alloc_type::const_reference const_reference;
+  typedef typename value_alloc_type::pointer pointer;
+  typedef typename value_alloc_type::const_pointer const_pointer;
+  typedef dense_hashtable_iterator<Value, Key, HashFcn,
+                                   ExtractKey, SetKey, EqualKey, Alloc>
+  iterator;
+
+  typedef dense_hashtable_const_iterator<Value, Key, HashFcn,
+                                         ExtractKey, SetKey, EqualKey, Alloc>
+  const_iterator;
+
+  // These come from tr1.  For us they're the same as regular iterators.
+  typedef iterator local_iterator;
+  typedef const_iterator const_local_iterator;
+
+  // How full we let the table get before we resize, by default.
+  // Knuth says .8 is good -- higher causes us to probe too much,
+  // though it saves memory.
+  static const int HT_OCCUPANCY_PCT;  // defined at the bottom of this file
+
+  // How empty we let the table get before we resize lower, by default.
+  // (0.0 means never resize lower.)
+  // It should be less than OCCUPANCY_PCT / 2 or we thrash resizing
+  static const int HT_EMPTY_PCT;      // defined at the bottom of this file
+
+  // Minimum size we're willing to let hashtables be.
+  // Must be a power of two, and at least 4.
+  // Note, however, that for a given hashtable, the initial size is a
+  // function of the first constructor arg, and may be >HT_MIN_BUCKETS.
+  static const size_type HT_MIN_BUCKETS = 4;
+
+  // By default, if you don't specify a hashtable size at
+  // construction-time, we use this size.  Must be a power of two, and
+  // at least HT_MIN_BUCKETS.
+  static const size_type HT_DEFAULT_STARTING_BUCKETS = 32;
+
+  // ITERATOR FUNCTIONS
+  iterator begin()             { return iterator(this, table,
+                                                 table + num_buckets, true); }
+  iterator end()               { return iterator(this, table + num_buckets,
+                                                 table + num_buckets, true); }
+  const_iterator begin() const { return const_iterator(this, table,
+                                                       table+num_buckets,true);}
+  const_iterator end() const   { return const_iterator(this, table + num_buckets,
+                                                       table+num_buckets,true);}
+
+  // These come from tr1 unordered_map.  They iterate over 'bucket' n.
+  // We'll just consider bucket n to be the n-th element of the table.
+  local_iterator begin(size_type i) {
+    return local_iterator(this, table + i, table + i+1, false);
+  }
+  local_iterator end(size_type i) {
+    local_iterator it = begin(i);
+    if (!test_empty(i) && !test_deleted(i))
+      ++it;
+    return it;
+  }
+  const_local_iterator begin(size_type i) const {
+    return const_local_iterator(this, table + i, table + i+1, false);
+  }
+  const_local_iterator end(size_type i) const {
+    const_local_iterator it = begin(i);
+    if (!test_empty(i) && !test_deleted(i))
+      ++it;
+    return it;
+  }
+
+  // ACCESSOR FUNCTIONS for the things we templatize on, basically
+  hasher hash_funct() const               { return settings; }
+  key_equal key_eq() const                { return key_info; }
+  allocator_type get_allocator() const {
+    return allocator_type(val_info);
+  }
+
+  // Accessor function for statistics gathering.
+  int num_table_copies() const { return settings.num_ht_copies(); }
+
+ private:
+  // Annoyingly, we can't copy values around, because they might have
+  // const components (they're probably pair<const X, Y>).  We use
+  // explicit destructor invocation and placement new to get around
+  // this.  Arg.
+  void set_value(pointer dst, const_reference src) {
+    dst->~value_type();   // delete the old value, if any
+    new(dst) value_type(src);
+  }
+
+  void destroy_buckets(size_type first, size_type last) {
+    for ( ; first != last; ++first)
+      table[first].~value_type();
+  }
+
+  // DELETE HELPER FUNCTIONS
+  // This lets the user describe a key that will indicate deleted
+  // table entries.  This key should be an "impossible" entry --
+  // if you try to insert it for real, you won't be able to retrieve it!
+  // (NB: while you pass in an entire value, only the key part is looked
+  // at.  This is just because I don't know how to assign just a key.)
+ private:
+  void squash_deleted() {           // gets rid of any deleted entries we have
+    if ( num_deleted ) {            // get rid of deleted before writing
+      dense_hashtable tmp(*this);   // copying will get rid of deleted
+      swap(tmp);                    // now we are tmp
+    }
+    assert(num_deleted == 0);
+  }
+
+  // Test if the given key is the deleted indicator.  Requires
+  // num_deleted > 0, for correctness of read(), and because that
+  // guarantees that key_info.delkey is valid.
+  bool test_deleted_key(const key_type& key) const {
+    assert(num_deleted > 0);
+    return equals(key_info.delkey, key);
+  }
+
+ public:
+  void set_deleted_key(const key_type &key) {
+    // the empty indicator (if specified) and the deleted indicator
+    // must be different
+    assert((!settings.use_empty() || !equals(key, get_key(val_info.emptyval)))
+           && "Passed the empty-key to set_deleted_key");
+    // It's only safe to change what "deleted" means if we purge deleted guys
+    squash_deleted();
+    settings.set_use_deleted(true);
+    key_info.delkey = key;
+  }
+  void clear_deleted_key() {
+    squash_deleted();
+    settings.set_use_deleted(false);
+  }
+  key_type deleted_key() const {
+    assert(settings.use_deleted()
+           && "Must set deleted key before calling deleted_key");
+    return key_info.delkey;
+  }
+
+  // These are public so the iterators can use them
+  // True if the item at position bucknum is "deleted" marker
+  bool test_deleted(size_type bucknum) const {
+    // Invariant: !use_deleted() implies num_deleted is 0.
+    assert(settings.use_deleted() || num_deleted == 0);
+    return num_deleted > 0 && test_deleted_key(get_key(table[bucknum]));
+  }
+  bool test_deleted(const iterator &it) const {
+    // Invariant: !use_deleted() implies num_deleted is 0.
+    assert(settings.use_deleted() || num_deleted == 0);
+    return num_deleted > 0 && test_deleted_key(get_key(*it));
+  }
+  bool test_deleted(const const_iterator &it) const {
+    // Invariant: !use_deleted() implies num_deleted is 0.
+    assert(settings.use_deleted() || num_deleted == 0);
+    return num_deleted > 0 && test_deleted_key(get_key(*it));
+  }
+
+ private:
+  void check_use_deleted(const char* caller) {
+    (void)caller;    // could log it if the assert failed
+    assert(settings.use_deleted());
+  }
+
+  // Set it so test_deleted is true.  true if object didn't used to be deleted.
+  bool set_deleted(iterator &it) {
+    check_use_deleted("set_deleted()");
+    bool retval = !test_deleted(it);
+    // &* converts from iterator to value-type.
+    set_key(&(*it), key_info.delkey);
+    return retval;
+  }
+  // Set it so test_deleted is false.  true if object used to be deleted.
+  bool clear_deleted(iterator &it) {
+    check_use_deleted("clear_deleted()");
+    // Happens automatically when we assign something else in its place.
+    return test_deleted(it);
+  }
+
+  // We also allow to set/clear the deleted bit on a const iterator.
+  // We allow a const_iterator for the same reason you can delete a
+  // const pointer: it's convenient, and semantically you can't use
+  // 'it' after it's been deleted anyway, so its const-ness doesn't
+  // really matter.
+  bool set_deleted(const_iterator &it) {
+    check_use_deleted("set_deleted()");
+    bool retval = !test_deleted(it);
+    set_key(const_cast<pointer>(&(*it)), key_info.delkey);
+    return retval;
+  }
+  // Set it so test_deleted is false.  true if object used to be deleted.
+  bool clear_deleted(const_iterator &it) {
+    check_use_deleted("clear_deleted()");
+    return test_deleted(it);
+  }
+
+  // EMPTY HELPER FUNCTIONS
+  // This lets the user describe a key that will indicate empty (unused)
+  // table entries.  This key should be an "impossible" entry --
+  // if you try to insert it for real, you won't be able to retrieve it!
+  // (NB: while you pass in an entire value, only the key part is looked
+  // at.  This is just because I don't know how to assign just a key.)
+ public:
+  // These are public so the iterators can use them
+  // True if the item at position bucknum is "empty" marker
+  bool test_empty(size_type bucknum) const {
+    assert(settings.use_empty());  // we always need to know what's empty!
+    return equals(get_key(val_info.emptyval), get_key(table[bucknum]));
+  }
+  bool test_empty(const iterator &it) const {
+    assert(settings.use_empty());  // we always need to know what's empty!
+    return equals(get_key(val_info.emptyval), get_key(*it));
+  }
+  bool test_empty(const const_iterator &it) const {
+    assert(settings.use_empty());  // we always need to know what's empty!
+    return equals(get_key(val_info.emptyval), get_key(*it));
+  }
+
+ private:
+  void fill_range_with_empty(pointer table_start, pointer table_end) {
+    std::uninitialized_fill(table_start, table_end, val_info.emptyval);
+  }
+
+ public:
+  // TODO(csilvers): change all callers of this to pass in a key instead,
+  //                 and take a const key_type instead of const value_type.
+  void set_empty_key(const_reference val) {
+    // Once you set the empty key, you can't change it
+    assert(!settings.use_empty() && "Calling set_empty_key multiple times");
+    // The deleted indicator (if specified) and the empty indicator
+    // must be different.
+    assert((!settings.use_deleted() || !equals(get_key(val), key_info.delkey))
+           && "Setting the empty key the same as the deleted key");
+    settings.set_use_empty(true);
+    set_value(&val_info.emptyval, val);
+
+    assert(!table);                  // must set before first use
+    // num_buckets was set in constructor even though table was NULL
+    table = val_info.allocate(num_buckets);
+    assert(table);
+    fill_range_with_empty(table, table + num_buckets);
+  }
+  // TODO(user): return a key_type rather than a value_type
+  value_type empty_key() const {
+    assert(settings.use_empty());
+    return val_info.emptyval;
+  }
+
+  // FUNCTIONS CONCERNING SIZE
+ public:
+  size_type size() const      { return num_elements - num_deleted; }
+  size_type max_size() const  { return val_info.max_size(); }
+  bool empty() const          { return size() == 0; }
+  size_type bucket_count() const      { return num_buckets; }
+  size_type max_bucket_count() const  { return max_size(); }
+  size_type nonempty_bucket_count() const { return num_elements; }
+  // These are tr1 methods.  Their idea of 'bucket' doesn't map well to
+  // what we do.  We just say every bucket has 0 or 1 items in it.
+  size_type bucket_size(size_type i) const {
+    return begin(i) == end(i) ? 0 : 1;
+  }
+
+ private:
+  // Because of the above, size_type(-1) is never legal; use it for errors
+  static const size_type ILLEGAL_BUCKET = size_type(-1);
+
+  // Used after a string of deletes.  Returns true if we actually shrunk.
+  // TODO(csilvers): take a delta so we can take into account inserts
+  // done after shrinking.  Maybe make part of the Settings class?
+  bool maybe_shrink() {
+    assert(num_elements >= num_deleted);
+    assert((bucket_count() & (bucket_count()-1)) == 0); // is a power of two
+    assert(bucket_count() >= HT_MIN_BUCKETS);
+    bool retval = false;
+
+    // If you construct a hashtable with < HT_DEFAULT_STARTING_BUCKETS,
+    // we'll never shrink until you get relatively big, and we'll never
+    // shrink below HT_DEFAULT_STARTING_BUCKETS.  Otherwise, something
+    // like "dense_hash_set<int> x; x.insert(4); x.erase(4);" will
+    // shrink us down to HT_MIN_BUCKETS buckets, which is too small.
+    const size_type num_remain = num_elements - num_deleted;
+    const size_type shrink_threshold = settings.shrink_threshold();
+    if (shrink_threshold > 0 && num_remain < shrink_threshold &&
+        bucket_count() > HT_DEFAULT_STARTING_BUCKETS) {
+      const float shrink_factor = settings.shrink_factor();
+      size_type sz = bucket_count() / 2;    // find how much we should shrink
+      while (sz > HT_DEFAULT_STARTING_BUCKETS &&
+             num_remain < sz * shrink_factor) {
+        sz /= 2;                            // stay a power of 2
+      }
+      dense_hashtable tmp(*this, sz);       // Do the actual resizing
+      swap(tmp);                            // now we are tmp
+      retval = true;
+    }
+    settings.set_consider_shrink(false);    // because we just considered it
+    return retval;
+  }
+
+  // We'll let you resize a hashtable -- though this makes us copy all!
+  // When you resize, you say, "make it big enough for this many more elements"
+  // Returns true if we actually resized, false if size was already ok.
+  bool resize_delta(size_type delta) {
+    bool did_resize = false;
+    if ( settings.consider_shrink() ) {  // see if lots of deletes happened
+      if ( maybe_shrink() )
+        did_resize = true;
+    }
+    if (num_elements >=
+        (std::numeric_limits<size_type>::max)() - delta) {
+      throw std::length_error("resize overflow");
+    }
+    if ( bucket_count() >= HT_MIN_BUCKETS &&
+         (num_elements + delta) <= settings.enlarge_threshold() )
+      return did_resize;                          // we're ok as we are
+
+    // Sometimes, we need to resize just to get rid of all the
+    // "deleted" buckets that are clogging up the hashtable.  So when
+    // deciding whether to resize, count the deleted buckets (which
+    // are currently taking up room).  But later, when we decide what
+    // size to resize to, *don't* count deleted buckets, since they
+    // get discarded during the resize.
+    size_type needed_size = settings.min_buckets(num_elements + delta, 0);
+    if ( needed_size <= bucket_count() )      // we have enough buckets
+      return did_resize;
+
+    size_type resize_to =
+      settings.min_buckets(num_elements - num_deleted + delta, bucket_count());
+
+    // When num_deleted is large, we may still grow but we do not want to
+    // over expand.  So we reduce needed_size by a portion of num_deleted
+    // (the exact portion does not matter).  This is especially helpful
+    // when min_load_factor is zero (no shrink at all) to avoid doubling
+    // the bucket count to infinity.  See also test ResizeWithoutShrink.
+    needed_size = settings.min_buckets(num_elements - num_deleted / 4 + delta, 0);
+    if (resize_to < needed_size &&    // may double resize_to
+        resize_to < (std::numeric_limits<size_type>::max)() / 2) {
+      // This situation means that we have enough deleted elements,
+      // that once we purge them, we won't actually have needed to
+      // grow.  But we may want to grow anyway: if we just purge one
+      // element, say, we'll have to grow anyway next time we
+      // insert.  Might as well grow now, since we're already going
+      // through the trouble of copying (in order to purge the
+      // deleted elements).
+      const size_type target =
+          static_cast<size_type>(settings.shrink_size(resize_to*2));
+      if (num_elements - num_deleted + delta >= target) {
+        // Good, we won't be below the shrink threshhold even if we double.
+        resize_to *= 2;
+      }
+    }
+    dense_hashtable tmp(*this, resize_to);
+    swap(tmp);                             // now we are tmp
+    return true;
+  }
+
+  // We require table be not-NULL and empty before calling this.
+  void resize_table(size_type /*old_size*/, size_type new_size,
+                    base::true_type) {
+    table = val_info.realloc_or_die(table, new_size);
+  }
+
+  void resize_table(size_type old_size, size_type new_size, base::false_type) {
+    val_info.deallocate(table, old_size);
+    table = val_info.allocate(new_size);
+  }
+
+  // Used to actually do the rehashing when we grow/shrink a hashtable
+  void copy_from(const dense_hashtable &ht, size_type min_buckets_wanted) {
+    clear_to_size(settings.min_buckets(ht.size(), min_buckets_wanted));
+
+    // We use a normal iterator to get non-deleted bcks from ht
+    // We could use insert() here, but since we know there are
+    // no duplicates and no deleted items, we can be more efficient
+    assert((bucket_count() & (bucket_count()-1)) == 0);      // a power of two
+    for ( const_iterator it = ht.begin(); it != ht.end(); ++it ) {
+      size_type num_probes = 0;              // how many times we've probed
+      size_type bucknum;
+      const size_type bucket_count_minus_one = bucket_count() - 1;
+      for (bucknum = hash(get_key(*it)) & bucket_count_minus_one;
+           !test_empty(bucknum);                               // not empty
+           bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one) {
+        ++num_probes;
+        assert(num_probes < bucket_count()
+               && "Hashtable is full: an error in key_equal<> or hash<>");
+      }
+      set_value(&table[bucknum], *it);       // copies the value to here
+      num_elements++;
+    }
+    settings.inc_num_ht_copies();
+  }
+
+  // Required by the spec for hashed associative container
+ public:
+  // Though the docs say this should be num_buckets, I think it's much
+  // more useful as num_elements.  As a special feature, calling with
+  // req_elements==0 will cause us to shrink if we can, saving space.
+  void resize(size_type req_elements) {       // resize to this or larger
+    if ( settings.consider_shrink() || req_elements == 0 )
+      maybe_shrink();
+    if ( req_elements > num_elements )
+      resize_delta(req_elements - num_elements);
+  }
+
+  // Get and change the value of shrink_factor and enlarge_factor.  The
+  // description at the beginning of this file explains how to choose
+  // the values.  Setting the shrink parameter to 0.0 ensures that the
+  // table never shrinks.
+  void get_resizing_parameters(float* shrink, float* grow) const {
+    *shrink = settings.shrink_factor();
+    *grow = settings.enlarge_factor();
+  }
+  void set_resizing_parameters(float shrink, float grow) {
+    settings.set_resizing_parameters(shrink, grow);
+    settings.reset_thresholds(bucket_count());
+  }
+
+  // CONSTRUCTORS -- as required by the specs, we take a size,
+  // but also let you specify a hashfunction, key comparator,
+  // and key extractor.  We also define a copy constructor and =.
+  // DESTRUCTOR -- needs to free the table
+  explicit dense_hashtable(size_type expected_max_items_in_table = 0,
+                           const HashFcn& hf = HashFcn(),
+                           const EqualKey& eql = EqualKey(),
+                           const ExtractKey& ext = ExtractKey(),
+                           const SetKey& set = SetKey(),
+                           const Alloc& alloc = Alloc())
+      : settings(hf),
+        key_info(ext, set, eql),
+        num_deleted(0),
+        num_elements(0),
+        num_buckets(expected_max_items_in_table == 0
+                    ? HT_DEFAULT_STARTING_BUCKETS
+                    : settings.min_buckets(expected_max_items_in_table, 0)),
+        val_info(alloc_impl<value_alloc_type>(alloc)),
+        table(NULL) {
+    // table is NULL until emptyval is set.  However, we set num_buckets
+    // here so we know how much space to allocate once emptyval is set
+    settings.reset_thresholds(bucket_count());
+  }
+
+  // As a convenience for resize(), we allow an optional second argument
+  // which lets you make this new hashtable a different size than ht
+  dense_hashtable(const dense_hashtable& ht,
+                  size_type min_buckets_wanted = HT_DEFAULT_STARTING_BUCKETS)
+      : settings(ht.settings),
+        key_info(ht.key_info),
+        num_deleted(0),
+        num_elements(0),
+        num_buckets(0),
+        val_info(ht.val_info),
+        table(NULL) {
+    if (!ht.settings.use_empty()) {
+      // If use_empty isn't set, copy_from will crash, so we do our own copying.
+      assert(ht.empty());
+      num_buckets = settings.min_buckets(ht.size(), min_buckets_wanted);
+      settings.reset_thresholds(bucket_count());
+      return;
+    }
+    settings.reset_thresholds(bucket_count());
+    copy_from(ht, min_buckets_wanted);   // copy_from() ignores deleted entries
+  }
+
+  dense_hashtable& operator= (const dense_hashtable& ht) {
+    if (&ht == this)  return *this;        // don't copy onto ourselves
+    if (!ht.settings.use_empty()) {
+      assert(ht.empty());
+      dense_hashtable empty_table(ht);  // empty table with ht's thresholds
+      this->swap(empty_table);
+      return *this;
+    }
+    settings = ht.settings;
+    key_info = ht.key_info;
+    set_value(&val_info.emptyval, ht.val_info.emptyval);
+    // copy_from() calls clear and sets num_deleted to 0 too
+    copy_from(ht, HT_MIN_BUCKETS);
+    // we purposefully don't copy the allocator, which may not be copyable
+    return *this;
+  }
+
+  ~dense_hashtable() {
+    if (table) {
+      destroy_buckets(0, num_buckets);
+      val_info.deallocate(table, num_buckets);
+    }
+  }
+
+  // Many STL algorithms use swap instead of copy constructors
+  void swap(dense_hashtable& ht) {
+    std::swap(settings, ht.settings);
+    std::swap(key_info, ht.key_info);
+    std::swap(num_deleted, ht.num_deleted);
+    std::swap(num_elements, ht.num_elements);
+    std::swap(num_buckets, ht.num_buckets);
+    { value_type tmp;     // for annoying reasons, swap() doesn't work
+      set_value(&tmp, val_info.emptyval);
+      set_value(&val_info.emptyval, ht.val_info.emptyval);
+      set_value(&ht.val_info.emptyval, tmp);
+    }
+    std::swap(table, ht.table);
+    settings.reset_thresholds(bucket_count());  // also resets consider_shrink
+    ht.settings.reset_thresholds(ht.bucket_count());
+    // we purposefully don't swap the allocator, which may not be swap-able
+  }
+
+ private:
+  void clear_to_size(size_type new_num_buckets) {
+    if (!table) {
+      table = val_info.allocate(new_num_buckets);
+    } else {
+      destroy_buckets(0, num_buckets);
+      if (new_num_buckets != num_buckets) {   // resize, if necessary
+        typedef base::integral_constant<bool,
+            base::is_same<value_alloc_type,
+                          libc_allocator_with_realloc<value_type> >::value>
+            realloc_ok;
+        resize_table(num_buckets, new_num_buckets, realloc_ok());
+      }
+    }
+    assert(table);
+    fill_range_with_empty(table, table + new_num_buckets);
+    num_elements = 0;
+    num_deleted = 0;
+    num_buckets = new_num_buckets;          // our new size
+    settings.reset_thresholds(bucket_count());
+  }
+
+ public:
+  // It's always nice to be able to clear a table without deallocating it
+  void clear() {
+    // If the table is already empty, and the number of buckets is
+    // already as we desire, there's nothing to do.
+    const size_type new_num_buckets = settings.min_buckets(0, 0);
+    if (num_elements == 0 && new_num_buckets == num_buckets) {
+      return;
+    }
+    clear_to_size(new_num_buckets);
+  }
+
+  // Clear the table without resizing it.
+  // Mimicks the stl_hashtable's behaviour when clear()-ing in that it
+  // does not modify the bucket count
+  void clear_no_resize() {
+    if (num_elements > 0) {
+      assert(table);
+      destroy_buckets(0, num_buckets);
+      fill_range_with_empty(table, table + num_buckets);
+    }
+    // don't consider to shrink before another erase()
+    settings.reset_thresholds(bucket_count());
+    num_elements = 0;
+    num_deleted = 0;
+  }
+
+  // LOOKUP ROUTINES
+ private:
+  // Returns a pair of positions: 1st where the object is, 2nd where
+  // it would go if you wanted to insert it.  1st is ILLEGAL_BUCKET
+  // if object is not found; 2nd is ILLEGAL_BUCKET if it is.
+  // Note: because of deletions where-to-insert is not trivial: it's the
+  // first deleted bucket we see, as long as we don't find the key later
+  std::pair<size_type, size_type> find_position(const key_type &key) const {
+    size_type num_probes = 0;              // how many times we've probed
+    const size_type bucket_count_minus_one = bucket_count() - 1;
+    size_type bucknum = hash(key) & bucket_count_minus_one;
+    size_type insert_pos = ILLEGAL_BUCKET; // where we would insert
+    while ( 1 ) {                          // probe until something happens
+      if ( test_empty(bucknum) ) {         // bucket is empty
+        if ( insert_pos == ILLEGAL_BUCKET )   // found no prior place to insert
+          return std::pair<size_type,size_type>(ILLEGAL_BUCKET, bucknum);
+        else
+          return std::pair<size_type,size_type>(ILLEGAL_BUCKET, insert_pos);
+
+      } else if ( test_deleted(bucknum) ) {// keep searching, but mark to insert
+        if ( insert_pos == ILLEGAL_BUCKET )
+          insert_pos = bucknum;
+
+      } else if ( equals(key, get_key(table[bucknum])) ) {
+        return std::pair<size_type,size_type>(bucknum, ILLEGAL_BUCKET);
+      }
+      ++num_probes;                        // we're doing another probe
+      bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one;
+      assert(num_probes < bucket_count()
+             && "Hashtable is full: an error in key_equal<> or hash<>");
+    }
+  }
+
+ public:
+
+  iterator find(const key_type& key) {
+    if ( size() == 0 ) return end();
+    std::pair<size_type, size_type> pos = find_position(key);
+    if ( pos.first == ILLEGAL_BUCKET )     // alas, not there
+      return end();
+    else
+      return iterator(this, table + pos.first, table + num_buckets, false);
+  }
+
+  const_iterator find(const key_type& key) const {
+    if ( size() == 0 ) return end();
+    std::pair<size_type, size_type> pos = find_position(key);
+    if ( pos.first == ILLEGAL_BUCKET )     // alas, not there
+      return end();
+    else
+      return const_iterator(this, table + pos.first, table+num_buckets, false);
+  }
+
+  // This is a tr1 method: the bucket a given key is in, or what bucket
+  // it would be put in, if it were to be inserted.  Shrug.
+  size_type bucket(const key_type& key) const {
+    std::pair<size_type, size_type> pos = find_position(key);
+    return pos.first == ILLEGAL_BUCKET ? pos.second : pos.first;
+  }
+
+  // Counts how many elements have key key.  For maps, it's either 0 or 1.
+  size_type count(const key_type &key) const {
+    std::pair<size_type, size_type> pos = find_position(key);
+    return pos.first == ILLEGAL_BUCKET ? 0 : 1;
+  }
+
+  // Likewise, equal_range doesn't really make sense for us.  Oh well.
+  std::pair<iterator,iterator> equal_range(const key_type& key) {
+    iterator pos = find(key);      // either an iterator or end
+    if (pos == end()) {
+      return std::pair<iterator,iterator>(pos, pos);
+    } else {
+      const iterator startpos = pos++;
+      return std::pair<iterator,iterator>(startpos, pos);
+    }
+  }
+  std::pair<const_iterator,const_iterator> equal_range(const key_type& key)
+      const {
+    const_iterator pos = find(key);      // either an iterator or end
+    if (pos == end()) {
+      return std::pair<const_iterator,const_iterator>(pos, pos);
+    } else {
+      const const_iterator startpos = pos++;
+      return std::pair<const_iterator,const_iterator>(startpos, pos);
+    }
+  }
+
+
+  // INSERTION ROUTINES
+ private:
+  // Private method used by insert_noresize and find_or_insert.
+  iterator insert_at(const_reference obj, size_type pos) {
+    if (size() >= max_size()) {
+      throw std::length_error("insert overflow");
+    }
+    if ( test_deleted(pos) ) {      // just replace if it's been del.
+      // shrug: shouldn't need to be const.
+      const_iterator delpos(this, table + pos, table + num_buckets, false);
+      clear_deleted(delpos);
+      assert( num_deleted > 0);
+      --num_deleted;                // used to be, now it isn't
+    } else {
+      ++num_elements;               // replacing an empty bucket
+    }
+    set_value(&table[pos], obj);
+    return iterator(this, table + pos, table + num_buckets, false);
+  }
+
+  // If you know *this is big enough to hold obj, use this routine
+  std::pair<iterator, bool> insert_noresize(const_reference obj) {
+    // First, double-check we're not inserting delkey or emptyval
+    assert((!settings.use_empty() || !equals(get_key(obj),
+                                             get_key(val_info.emptyval)))
+           && "Inserting the empty key");
+    assert((!settings.use_deleted() || !equals(get_key(obj), key_info.delkey))
+           && "Inserting the deleted key");
+    const std::pair<size_type,size_type> pos = find_position(get_key(obj));
+    if ( pos.first != ILLEGAL_BUCKET) {      // object was already there
+      return std::pair<iterator,bool>(iterator(this, table + pos.first,
+                                          table + num_buckets, false),
+                                 false);          // false: we didn't insert
+    } else {                                 // pos.second says where to put it
+      return std::pair<iterator,bool>(insert_at(obj, pos.second), true);
+    }
+  }
+
+  // Specializations of insert(it, it) depending on the power of the iterator:
+  // (1) Iterator supports operator-, resize before inserting
+  template <class ForwardIterator>
+  void insert(ForwardIterator f, ForwardIterator l, std::forward_iterator_tag) {
+    size_t dist = std::distance(f, l);
+    if (dist >= (std::numeric_limits<size_type>::max)()) {
+      throw std::length_error("insert-range overflow");
+    }
+    resize_delta(static_cast<size_type>(dist));
+    for ( ; dist > 0; --dist, ++f) {
+      insert_noresize(*f);
+    }
+  }
+
+  // (2) Arbitrary iterator, can't tell how much to resize
+  template <class InputIterator>
+  void insert(InputIterator f, InputIterator l, std::input_iterator_tag) {
+    for ( ; f != l; ++f)
+      insert(*f);
+  }
+
+ public:
+  // This is the normal insert routine, used by the outside world
+  std::pair<iterator, bool> insert(const_reference obj) {
+    resize_delta(1);                      // adding an object, grow if need be
+    return insert_noresize(obj);
+  }
+
+  // When inserting a lot at a time, we specialize on the type of iterator
+  template <class InputIterator>
+  void insert(InputIterator f, InputIterator l) {
+    // specializes on iterator type
+    insert(f, l,
+           typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  // DefaultValue is a functor that takes a key and returns a value_type
+  // representing the default value to be inserted if none is found.
+  template <class DefaultValue>
+  value_type& find_or_insert(const key_type& key) {
+    // First, double-check we're not inserting emptykey or delkey
+    assert((!settings.use_empty() || !equals(key, get_key(val_info.emptyval)))
+           && "Inserting the empty key");
+    assert((!settings.use_deleted() || !equals(key, key_info.delkey))
+           && "Inserting the deleted key");
+    const std::pair<size_type,size_type> pos = find_position(key);
+    DefaultValue default_value;
+    if ( pos.first != ILLEGAL_BUCKET) {  // object was already there
+      return table[pos.first];
+    } else if (resize_delta(1)) {        // needed to rehash to make room
+      // Since we resized, we can't use pos, so recalculate where to insert.
+      return *insert_noresize(default_value(key)).first;
+    } else {                             // no need to rehash, insert right here
+      return *insert_at(default_value(key), pos.second);
+    }
+  }
+
+
+  // DELETION ROUTINES
+  size_type erase(const key_type& key) {
+    // First, double-check we're not trying to erase delkey or emptyval.
+    assert((!settings.use_empty() || !equals(key, get_key(val_info.emptyval)))
+           && "Erasing the empty key");
+    assert((!settings.use_deleted() || !equals(key, key_info.delkey))
+           && "Erasing the deleted key");
+    const_iterator pos = find(key);   // shrug: shouldn't need to be const
+    if ( pos != end() ) {
+      assert(!test_deleted(pos));  // or find() shouldn't have returned it
+      set_deleted(pos);
+      ++num_deleted;
+      settings.set_consider_shrink(true); // will think about shrink after next insert
+      return 1;                    // because we deleted one thing
+    } else {
+      return 0;                    // because we deleted nothing
+    }
+  }
+
+  // We return the iterator past the deleted item.
+  void erase(iterator pos) {
+    if ( pos == end() ) return;    // sanity check
+    if ( set_deleted(pos) ) {      // true if object has been newly deleted
+      ++num_deleted;
+      settings.set_consider_shrink(true); // will think about shrink after next insert
+    }
+  }
+
+  void erase(iterator f, iterator l) {
+    for ( ; f != l; ++f) {
+      if ( set_deleted(f)  )       // should always be true
+        ++num_deleted;
+    }
+    settings.set_consider_shrink(true); // will think about shrink after next insert
+  }
+
+  // We allow you to erase a const_iterator just like we allow you to
+  // erase an iterator.  This is in parallel to 'delete': you can delete
+  // a const pointer just like a non-const pointer.  The logic is that
+  // you can't use the object after it's erased anyway, so it doesn't matter
+  // if it's const or not.
+  void erase(const_iterator pos) {
+    if ( pos == end() ) return;    // sanity check
+    if ( set_deleted(pos) ) {      // true if object has been newly deleted
+      ++num_deleted;
+      settings.set_consider_shrink(true); // will think about shrink after next insert
+    }
+  }
+  void erase(const_iterator f, const_iterator l) {
+    for ( ; f != l; ++f) {
+      if ( set_deleted(f)  )       // should always be true
+        ++num_deleted;
+    }
+    settings.set_consider_shrink(true);   // will think about shrink after next insert
+  }
+
+
+  // COMPARISON
+  bool operator==(const dense_hashtable& ht) const {
+    if (size() != ht.size()) {
+      return false;
+    } else if (this == &ht) {
+      return true;
+    } else {
+      // Iterate through the elements in "this" and see if the
+      // corresponding element is in ht
+      for ( const_iterator it = begin(); it != end(); ++it ) {
+        const_iterator it2 = ht.find(get_key(*it));
+        if ((it2 == ht.end()) || (*it != *it2)) {
+          return false;
+        }
+      }
+      return true;
+    }
+  }
+  bool operator!=(const dense_hashtable& ht) const {
+    return !(*this == ht);
+  }
+
+
+  // I/O
+  // We support reading and writing hashtables to disk.  Alas, since
+  // I don't know how to write a hasher or key_equal, you have to make
+  // sure everything but the table is the same.  We compact before writing.
+ private:
+  // Every time the disk format changes, this should probably change too
+  typedef unsigned long MagicNumberType;
+  static const MagicNumberType MAGIC_NUMBER = 0x13578642;
+
+ public:
+  // I/O -- this is an add-on for writing hash table to disk
+  //
+  // INPUT and OUTPUT must be either a FILE, *or* a C++ stream
+  //    (istream, ostream, etc) *or* a class providing
+  //    Read(void*, size_t) and Write(const void*, size_t)
+  //    (respectively), which writes a buffer into a stream
+  //    (which the INPUT/OUTPUT instance presumably owns).
+
+  typedef sparsehash_internal::pod_serializer<value_type> NopointerSerializer;
+
+  // ValueSerializer: a functor.  operator()(OUTPUT*, const value_type&)
+  template <typename ValueSerializer, typename OUTPUT>
+  bool serialize(ValueSerializer serializer, OUTPUT *fp) {
+    squash_deleted();           // so we don't have to worry about delkey
+    if ( !sparsehash_internal::write_bigendian_number(fp, MAGIC_NUMBER, 4) )
+      return false;
+    if ( !sparsehash_internal::write_bigendian_number(fp, num_buckets, 8) )
+      return false;
+    if ( !sparsehash_internal::write_bigendian_number(fp, num_elements, 8) )
+      return false;
+    // Now write a bitmap of non-empty buckets.
+    for ( size_type i = 0; i < num_buckets; i += 8 ) {
+      unsigned char bits = 0;
+      for ( int bit = 0; bit < 8; ++bit ) {
+        if ( i + bit < num_buckets && !test_empty(i + bit) )
+          bits |= (1 << bit);
+      }
+      if ( !sparsehash_internal::write_data(fp, &bits, sizeof(bits)) )
+        return false;
+      for ( int bit = 0; bit < 8; ++bit ) {
+        if ( bits & (1 << bit) ) {
+          if ( !serializer(fp, table[i + bit]) ) return false;
+        }
+      }
+    }
+    return true;
+  }
+
+  // INPUT: anything we've written an overload of read_data() for.
+  // ValueSerializer: a functor.  operator()(INPUT*, value_type*)
+  template <typename ValueSerializer, typename INPUT>
+  bool unserialize(ValueSerializer serializer, INPUT *fp) {
+    assert(settings.use_empty() && "empty_key not set for read");
+
+    clear();                        // just to be consistent
+    MagicNumberType magic_read;
+    if ( !sparsehash_internal::read_bigendian_number(fp, &magic_read, 4) )
+      return false;
+    if ( magic_read != MAGIC_NUMBER ) {
+      return false;
+    }
+    size_type new_num_buckets;
+    if ( !sparsehash_internal::read_bigendian_number(fp, &new_num_buckets, 8) )
+      return false;
+    clear_to_size(new_num_buckets);
+    if ( !sparsehash_internal::read_bigendian_number(fp, &num_elements, 8) )
+      return false;
+
+    // Read the bitmap of non-empty buckets.
+    for (size_type i = 0; i < num_buckets; i += 8) {
+      unsigned char bits;
+      if ( !sparsehash_internal::read_data(fp, &bits, sizeof(bits)) )
+        return false;
+      for ( int bit = 0; bit < 8; ++bit ) {
+        if ( i + bit < num_buckets && (bits & (1 << bit)) ) {  // not empty
+          if ( !serializer(fp, &table[i + bit]) ) return false;
+        }
+      }
+    }
+    return true;
+  }
+
+ private:
+  template <class A>
+  class alloc_impl : public A {
+   public:
+    typedef typename A::pointer pointer;
+    typedef typename A::size_type size_type;
+
+    // Convert a normal allocator to one that has realloc_or_die()
+    alloc_impl(const A& a) : A(a) { }
+
+    // realloc_or_die should only be used when using the default
+    // allocator (libc_allocator_with_realloc).
+    pointer realloc_or_die(pointer /*ptr*/, size_type /*n*/) {
+      fprintf(stderr, "realloc_or_die is only supported for "
+                      "libc_allocator_with_realloc\n");
+      exit(1);
+      return NULL;
+    }
+  };
+
+  // A template specialization of alloc_impl for
+  // libc_allocator_with_realloc that can handle realloc_or_die.
+  template <class A>
+  class alloc_impl<libc_allocator_with_realloc<A> >
+      : public libc_allocator_with_realloc<A> {
+   public:
+    typedef typename libc_allocator_with_realloc<A>::pointer pointer;
+    typedef typename libc_allocator_with_realloc<A>::size_type size_type;
+
+    alloc_impl(const libc_allocator_with_realloc<A>& a)
+        : libc_allocator_with_realloc<A>(a) { }
+
+    pointer realloc_or_die(pointer ptr, size_type n) {
+      pointer retval = this->reallocate(ptr, n);
+      if (retval == NULL) {
+        fprintf(stderr, "sparsehash: FATAL ERROR: failed to reallocate "
+                "%lu elements for ptr %p", static_cast<unsigned long>(n), ptr);
+        exit(1);
+      }
+      return retval;
+    }
+  };
+
+  // Package allocator with emptyval to eliminate memory needed for
+  // the zero-size allocator.
+  // If new fields are added to this class, we should add them to
+  // operator= and swap.
+  class ValInfo : public alloc_impl<value_alloc_type> {
+   public:
+    typedef typename alloc_impl<value_alloc_type>::value_type value_type;
+
+    ValInfo(const alloc_impl<value_alloc_type>& a)
+        : alloc_impl<value_alloc_type>(a), emptyval() { }
+    ValInfo(const ValInfo& v)
+        : alloc_impl<value_alloc_type>(v), emptyval(v.emptyval) { }
+
+    value_type emptyval;    // which key marks unused entries
+  };
+
+
+  // Package functors with another class to eliminate memory needed for
+  // zero-size functors.  Since ExtractKey and hasher's operator() might
+  // have the same function signature, they must be packaged in
+  // different classes.
+  struct Settings :
+      sparsehash_internal::sh_hashtable_settings<key_type, hasher,
+                                                 size_type, HT_MIN_BUCKETS> {
+    explicit Settings(const hasher& hf)
+        : sparsehash_internal::sh_hashtable_settings<key_type, hasher,
+                                                     size_type, HT_MIN_BUCKETS>(
+            hf, HT_OCCUPANCY_PCT / 100.0f, HT_EMPTY_PCT / 100.0f) {}
+  };
+
+  // Packages ExtractKey and SetKey functors.
+  class KeyInfo : public ExtractKey, public SetKey, public EqualKey {
+   public:
+    KeyInfo(const ExtractKey& ek, const SetKey& sk, const EqualKey& eq)
+        : ExtractKey(ek),
+          SetKey(sk),
+          EqualKey(eq) {
+    }
+
+    // We want to return the exact same type as ExtractKey: Key or const Key&
+    typename ExtractKey::result_type get_key(const_reference v) const {
+      return ExtractKey::operator()(v);
+    }
+    void set_key(pointer v, const key_type& k) const {
+      SetKey::operator()(v, k);
+    }
+    bool equals(const key_type& a, const key_type& b) const {
+      return EqualKey::operator()(a, b);
+    }
+
+    // Which key marks deleted entries.
+    // TODO(csilvers): make a pointer, and get rid of use_deleted (benchmark!)
+    typename base::remove_const<key_type>::type delkey;
+  };
+
+  // Utility functions to access the templated operators
+  size_type hash(const key_type& v) const {
+    return settings.hash(v);
+  }
+  bool equals(const key_type& a, const key_type& b) const {
+    return key_info.equals(a, b);
+  }
+  typename ExtractKey::result_type get_key(const_reference v) const {
+    return key_info.get_key(v);
+  }
+  void set_key(pointer v, const key_type& k) const {
+    key_info.set_key(v, k);
+  }
+
+ private:
+  // Actual data
+  Settings settings;
+  KeyInfo key_info;
+
+  size_type num_deleted;  // how many occupied buckets are marked deleted
+  size_type num_elements;
+  size_type num_buckets;
+  ValInfo val_info;       // holds emptyval, and also the allocator
+  pointer table;
+};
+
+
+// We need a global swap as well
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+inline void swap(dense_hashtable<V,K,HF,ExK,SetK,EqK,A> &x,
+                 dense_hashtable<V,K,HF,ExK,SetK,EqK,A> &y) {
+  x.swap(y);
+}
+
+#undef JUMP_
+
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+const typename dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::size_type
+  dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::ILLEGAL_BUCKET;
+
+// How full we let the table get before we resize.  Knuth says .8 is
+// good -- higher causes us to probe too much, though saves memory.
+// However, we go with .5, getting better performance at the cost of
+// more space (a trade-off densehashtable explicitly chooses to make).
+// Feel free to play around with different values, though, via
+// max_load_factor() and/or set_resizing_parameters().
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+const int dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_OCCUPANCY_PCT = 50;
+
+// How empty we let the table get before we resize lower.
+// It should be less than OCCUPANCY_PCT / 2 or we thrash resizing.
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+const int dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_EMPTY_PCT
+  = static_cast<int>(0.4 *
+                     dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_OCCUPANCY_PCT);
+
+_END_GOOGLE_NAMESPACE_
+
+#endif /* _DENSEHASHTABLE_H_ */
diff --git a/include/sparsehash/internal/hashtable-common.h b/include/sparsehash/internal/hashtable-common.h
new file mode 100644
index 0000000..bac2b88
--- /dev/null
+++ b/include/sparsehash/internal/hashtable-common.h
@@ -0,0 +1,381 @@
+// Copyright (c) 2010, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+//
+// Provides classes shared by both sparse and dense hashtable.
+//
+// sh_hashtable_settings has parameters for growing and shrinking
+// a hashtable.  It also packages zero-size functor (ie. hasher).
+//
+// Other functions and classes provide common code for serializing
+// and deserializing hashtables to a stream (such as a FILE*).
+
+#ifndef UTIL_GTL_HASHTABLE_COMMON_H_
+#define UTIL_GTL_HASHTABLE_COMMON_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <assert.h>
+#include <stdio.h>
+#include <stddef.h>                  // for size_t
+#include <iosfwd>
+#include <stdexcept>                 // For length_error
+
+_START_GOOGLE_NAMESPACE_
+
+template <bool> struct SparsehashCompileAssert { };
+#define SPARSEHASH_COMPILE_ASSERT(expr, msg) \
+  __attribute__((unused)) typedef SparsehashCompileAssert<(bool(expr))> msg[bool(expr) ? 1 : -1]
+
+namespace sparsehash_internal {
+
+// Adaptor methods for reading/writing data from an INPUT or OUPTUT
+// variable passed to serialize() or unserialize().  For now we
+// have implemented INPUT/OUTPUT for FILE*, istream*/ostream* (note
+// they are pointers, unlike typical use), or else a pointer to
+// something that supports a Read()/Write() method.
+//
+// For technical reasons, we implement read_data/write_data in two
+// stages.  The actual work is done in *_data_internal, which takes
+// the stream argument twice: once as a template type, and once with
+// normal type information.  (We only use the second version.)  We do
+// this because of how C++ picks what function overload to use.  If we
+// implemented this the naive way:
+//    bool read_data(istream* is, const void* data, size_t length);
+//    template<typename T> read_data(T* fp,  const void* data, size_t length);
+// C++ would prefer the second version for every stream type except
+// istream.  However, we want C++ to prefer the first version for
+// streams that are *subclasses* of istream, such as istringstream.
+// This is not possible given the way template types are resolved.  So
+// we split the stream argument in two, one of which is templated and
+// one of which is not.  The specialized functions (like the istream
+// version above) ignore the template arg and use the second, 'type'
+// arg, getting subclass matching as normal.  The 'catch-all'
+// functions (the second version above) use the template arg to deduce
+// the type, and use a second, void* arg to achieve the desired
+// 'catch-all' semantics.
+
+// ----- low-level I/O for FILE* ----
+
+template<typename Ignored>
+inline bool read_data_internal(Ignored*, FILE* fp,
+                               void* data, size_t length) {
+  return fread(data, length, 1, fp) == 1;
+}
+
+template<typename Ignored>
+inline bool write_data_internal(Ignored*, FILE* fp,
+                                const void* data, size_t length) {
+  return fwrite(data, length, 1, fp) == 1;
+}
+
+// ----- low-level I/O for iostream ----
+
+// We want the caller to be responsible for #including <iostream>, not
+// us, because iostream is a big header!  According to the standard,
+// it's only legal to delay the instantiation the way we want to if
+// the istream/ostream is a template type.  So we jump through hoops.
+template<typename ISTREAM>
+inline bool read_data_internal_for_istream(ISTREAM* fp,
+                                           void* data, size_t length) {
+  return fp->read(reinterpret_cast<char*>(data), length).good();
+}
+template<typename Ignored>
+inline bool read_data_internal(Ignored*, std::istream* fp,
+                               void* data, size_t length) {
+  return read_data_internal_for_istream(fp, data, length);
+}
+
+template<typename OSTREAM>
+inline bool write_data_internal_for_ostream(OSTREAM* fp,
+                                            const void* data, size_t length) {
+  return fp->write(reinterpret_cast<const char*>(data), length).good();
+}
+template<typename Ignored>
+inline bool write_data_internal(Ignored*, std::ostream* fp,
+                                const void* data, size_t length) {
+  return write_data_internal_for_ostream(fp, data, length);
+}
+
+// ----- low-level I/O for custom streams ----
+
+// The INPUT type needs to support a Read() method that takes a
+// buffer and a length and returns the number of bytes read.
+template <typename INPUT>
+inline bool read_data_internal(INPUT* fp, void*,
+                               void* data, size_t length) {
+  return static_cast<size_t>(fp->Read(data, length)) == length;
+}
+
+// The OUTPUT type needs to support a Write() operation that takes
+// a buffer and a length and returns the number of bytes written.
+template <typename OUTPUT>
+inline bool write_data_internal(OUTPUT* fp, void*,
+                                const void* data, size_t length) {
+  return static_cast<size_t>(fp->Write(data, length)) == length;
+}
+
+// ----- low-level I/O: the public API ----
+
+template <typename INPUT>
+inline bool read_data(INPUT* fp, void* data, size_t length) {
+  return read_data_internal(fp, fp, data, length);
+}
+
+template <typename OUTPUT>
+inline bool write_data(OUTPUT* fp, const void* data, size_t length) {
+  return write_data_internal(fp, fp, data, length);
+}
+
+// Uses read_data() and write_data() to read/write an integer.
+// length is the number of bytes to read/write (which may differ
+// from sizeof(IntType), allowing us to save on a 32-bit system
+// and load on a 64-bit system).  Excess bytes are taken to be 0.
+// INPUT and OUTPUT must match legal inputs to read/write_data (above).
+template <typename INPUT, typename IntType>
+bool read_bigendian_number(INPUT* fp, IntType* value, size_t length) {
+  *value = 0;
+  unsigned char byte;
+  // We require IntType to be unsigned or else the shifting gets all screwy.
+  SPARSEHASH_COMPILE_ASSERT(static_cast<IntType>(-1) > static_cast<IntType>(0),
+                            serializing_int_requires_an_unsigned_type);
+  for (size_t i = 0; i < length; ++i) {
+    if (!read_data(fp, &byte, sizeof(byte))) return false;
+    *value |= static_cast<IntType>(byte) << ((length - 1 - i) * 8);
+  }
+  return true;
+}
+
+template <typename OUTPUT, typename IntType>
+bool write_bigendian_number(OUTPUT* fp, IntType value, size_t length) {
+  unsigned char byte;
+  // We require IntType to be unsigned or else the shifting gets all screwy.
+  SPARSEHASH_COMPILE_ASSERT(static_cast<IntType>(-1) > static_cast<IntType>(0),
+                            serializing_int_requires_an_unsigned_type);
+  for (size_t i = 0; i < length; ++i) {
+    byte = (sizeof(value) <= length-1 - i)
+        ? 0 : static_cast<unsigned char>((value >> ((length-1 - i) * 8)) & 255);
+    if (!write_data(fp, &byte, sizeof(byte))) return false;
+  }
+  return true;
+}
+
+// If your keys and values are simple enough, you can pass this
+// serializer to serialize()/unserialize().  "Simple enough" means
+// value_type is a POD type that contains no pointers.  Note,
+// however, we don't try to normalize endianness.
+// This is the type used for NopointerSerializer.
+template <typename value_type> struct pod_serializer {
+  template <typename INPUT>
+  bool operator()(INPUT* fp, value_type* value) const {
+    return read_data(fp, value, sizeof(*value));
+  }
+
+  template <typename OUTPUT>
+  bool operator()(OUTPUT* fp, const value_type& value) const {
+    return write_data(fp, &value, sizeof(value));
+  }
+};
+
+
+// Settings contains parameters for growing and shrinking the table.
+// It also packages zero-size functor (ie. hasher).
+//
+// It does some munging of the hash value in cases where we think
+// (fear) the original hash function might not be very good.  In
+// particular, the default hash of pointers is the identity hash,
+// so probably all the low bits are 0.  We identify when we think
+// we're hashing a pointer, and chop off the low bits.  Note this
+// isn't perfect: even when the key is a pointer, we can't tell
+// for sure that the hash is the identity hash.  If it's not, this
+// is needless work (and possibly, though not likely, harmful).
+
+template<typename Key, typename HashFunc,
+         typename SizeType, int HT_MIN_BUCKETS>
+class sh_hashtable_settings : public HashFunc {
+ public:
+  typedef Key key_type;
+  typedef HashFunc hasher;
+  typedef SizeType size_type;
+
+ public:
+  sh_hashtable_settings(const hasher& hf,
+                        const float ht_occupancy_flt,
+                        const float ht_empty_flt)
+      : hasher(hf),
+        enlarge_threshold_(0),
+        shrink_threshold_(0),
+        consider_shrink_(false),
+        use_empty_(false),
+        use_deleted_(false),
+        num_ht_copies_(0) {
+    set_enlarge_factor(ht_occupancy_flt);
+    set_shrink_factor(ht_empty_flt);
+  }
+
+  size_type hash(const key_type& v) const {
+    // We munge the hash value when we don't trust hasher::operator().
+    return hash_munger<Key>::MungedHash(hasher::operator()(v));
+  }
+
+  float enlarge_factor() const {
+    return enlarge_factor_;
+  }
+  void set_enlarge_factor(float f) {
+    enlarge_factor_ = f;
+  }
+  float shrink_factor() const {
+    return shrink_factor_;
+  }
+  void set_shrink_factor(float f) {
+    shrink_factor_ = f;
+  }
+
+  size_type enlarge_threshold() const {
+    return enlarge_threshold_;
+  }
+  void set_enlarge_threshold(size_type t) {
+    enlarge_threshold_ = t;
+  }
+  size_type shrink_threshold() const {
+    return shrink_threshold_;
+  }
+  void set_shrink_threshold(size_type t) {
+    shrink_threshold_ = t;
+  }
+
+  size_type enlarge_size(size_type x) const {
+    return static_cast<size_type>(x * enlarge_factor_);
+  }
+  size_type shrink_size(size_type x) const {
+    return static_cast<size_type>(x * shrink_factor_);
+  }
+
+  bool consider_shrink() const {
+    return consider_shrink_;
+  }
+  void set_consider_shrink(bool t) {
+    consider_shrink_ = t;
+  }
+
+  bool use_empty() const {
+    return use_empty_;
+  }
+  void set_use_empty(bool t) {
+    use_empty_ = t;
+  }
+
+  bool use_deleted() const {
+    return use_deleted_;
+  }
+  void set_use_deleted(bool t) {
+    use_deleted_ = t;
+  }
+
+  size_type num_ht_copies() const {
+    return static_cast<size_type>(num_ht_copies_);
+  }
+  void inc_num_ht_copies() {
+    ++num_ht_copies_;
+  }
+
+  // Reset the enlarge and shrink thresholds
+  void reset_thresholds(size_type num_buckets) {
+    set_enlarge_threshold(enlarge_size(num_buckets));
+    set_shrink_threshold(shrink_size(num_buckets));
+    // whatever caused us to reset already considered
+    set_consider_shrink(false);
+  }
+
+  // Caller is resposible for calling reset_threshold right after
+  // set_resizing_parameters.
+  void set_resizing_parameters(float shrink, float grow) {
+    assert(shrink >= 0.0);
+    assert(grow <= 1.0);
+    if (shrink > grow/2.0f)
+      shrink = grow / 2.0f;     // otherwise we thrash hashtable size
+    set_shrink_factor(shrink);
+    set_enlarge_factor(grow);
+  }
+
+  // This is the smallest size a hashtable can be without being too crowded
+  // If you like, you can give a min #buckets as well as a min #elts
+  size_type min_buckets(size_type num_elts, size_type min_buckets_wanted) {
+    float enlarge = enlarge_factor();
+    size_type sz = HT_MIN_BUCKETS;             // min buckets allowed
+    while ( sz < min_buckets_wanted ||
+            num_elts >= static_cast<size_type>(sz * enlarge) ) {
+      // This just prevents overflowing size_type, since sz can exceed
+      // max_size() here.
+      if (static_cast<size_type>(sz * 2) < sz) {
+        throw std::length_error("resize overflow");  // protect against overflow
+      }
+      sz *= 2;
+    }
+    return sz;
+  }
+
+ private:
+  template<class HashKey> class hash_munger {
+   public:
+    static size_t MungedHash(size_t hash) {
+      return hash;
+    }
+  };
+  // This matches when the hashtable key is a pointer.
+  template<class HashKey> class hash_munger<HashKey*> {
+   public:
+    static size_t MungedHash(size_t hash) {
+      // TODO(csilvers): consider rotating instead:
+      //    static const int shift = (sizeof(void *) == 4) ? 2 : 3;
+      //    return (hash << (sizeof(hash) * 8) - shift)) | (hash >> shift);
+      // This matters if we ever change sparse/dense_hash_* to compare
+      // hashes before comparing actual values.  It's speedy on x86.
+      return hash / sizeof(void*);   // get rid of known-0 bits
+    }
+  };
+
+  size_type enlarge_threshold_;  // table.size() * enlarge_factor
+  size_type shrink_threshold_;   // table.size() * shrink_factor
+  float enlarge_factor_;         // how full before resize
+  float shrink_factor_;          // how empty before resize
+  // consider_shrink=true if we should try to shrink before next insert
+  bool consider_shrink_;
+  bool use_empty_;    // used only by densehashtable, not sparsehashtable
+  bool use_deleted_;  // false until delkey has been set
+  // num_ht_copies is a counter incremented every Copy/Move
+  unsigned int num_ht_copies_;
+};
+
+}  // namespace sparsehash_internal
+
+#undef SPARSEHASH_COMPILE_ASSERT
+_END_GOOGLE_NAMESPACE_
+
+#endif  // UTIL_GTL_HASHTABLE_COMMON_H_
diff --git a/include/sparsehash/internal/libc_allocator_with_realloc.h b/include/sparsehash/internal/libc_allocator_with_realloc.h
new file mode 100644
index 0000000..0c1e03d
--- /dev/null
+++ b/include/sparsehash/internal/libc_allocator_with_realloc.h
@@ -0,0 +1,119 @@
+// Copyright (c) 2010, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+
+#ifndef UTIL_GTL_LIBC_ALLOCATOR_WITH_REALLOC_H_
+#define UTIL_GTL_LIBC_ALLOCATOR_WITH_REALLOC_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <stdlib.h>           // for malloc/realloc/free
+#include <stddef.h>           // for ptrdiff_t
+#include <new>                // for placement new
+
+_START_GOOGLE_NAMESPACE_
+
+template<class T>
+class libc_allocator_with_realloc {
+ public:
+  typedef T value_type;
+  typedef size_t size_type;
+  typedef ptrdiff_t difference_type;
+
+  typedef T* pointer;
+  typedef const T* const_pointer;
+  typedef T& reference;
+  typedef const T& const_reference;
+
+  libc_allocator_with_realloc() {}
+  libc_allocator_with_realloc(const libc_allocator_with_realloc&) {}
+  ~libc_allocator_with_realloc() {}
+
+  pointer address(reference r) const  { return &r; }
+  const_pointer address(const_reference r) const  { return &r; }
+
+  pointer allocate(size_type n, const_pointer = 0) {
+    return static_cast<pointer>(malloc(n * sizeof(value_type)));
+  }
+  void deallocate(pointer p, size_type) {
+    free(p);
+  }
+  pointer reallocate(pointer p, size_type n) {
+    return static_cast<pointer>(realloc(p, n * sizeof(value_type)));
+  }
+
+  size_type max_size() const  {
+    return static_cast<size_type>(-1) / sizeof(value_type);
+  }
+
+  void construct(pointer p, const value_type& val) {
+    new(p) value_type(val);
+  }
+  void destroy(pointer p) { p->~value_type(); }
+
+  template <class U>
+  libc_allocator_with_realloc(const libc_allocator_with_realloc<U>&) {}
+
+  template<class U>
+  struct rebind {
+    typedef libc_allocator_with_realloc<U> other;
+  };
+};
+
+// libc_allocator_with_realloc<void> specialization.
+template<>
+class libc_allocator_with_realloc<void> {
+ public:
+  typedef void value_type;
+  typedef size_t size_type;
+  typedef ptrdiff_t difference_type;
+  typedef void* pointer;
+  typedef const void* const_pointer;
+
+  template<class U>
+  struct rebind {
+    typedef libc_allocator_with_realloc<U> other;
+  };
+};
+
+template<class T>
+inline bool operator==(const libc_allocator_with_realloc<T>&,
+                       const libc_allocator_with_realloc<T>&) {
+  return true;
+}
+
+template<class T>
+inline bool operator!=(const libc_allocator_with_realloc<T>&,
+                       const libc_allocator_with_realloc<T>&) {
+  return false;
+}
+
+_END_GOOGLE_NAMESPACE_
+
+#endif  // UTIL_GTL_LIBC_ALLOCATOR_WITH_REALLOC_H_
diff --git a/include/sparsehash/internal/sparseconfig.h b/include/sparsehash/internal/sparseconfig.h
new file mode 100644
index 0000000..18f4b2d
--- /dev/null
+++ b/include/sparsehash/internal/sparseconfig.h
@@ -0,0 +1,46 @@
+/*
+ * NOTE: This file is for internal use only.
+ *       Do not use these #defines in your own program!
+ */
+
+/* Namespace for Google classes */
+#define GOOGLE_NAMESPACE ::google
+
+/* the location of the header defining hash functions */
+#define HASH_FUN_H <functional>
+
+/* the namespace of the hash<> function */
+#define HASH_NAMESPACE std
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if the system has the type `long long'. */
+#define HAVE_LONG_LONG 1
+
+/* Define to 1 if you have the `memcpy' function. */
+#define HAVE_MEMCPY 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if the system has the type `uint16_t'. */
+#define HAVE_UINT16_T 1
+
+/* Define to 1 if the system has the type `u_int16_t'. */
+#define HAVE_U_INT16_T 1
+
+/* Define to 1 if the system has the type `__uint16'. */
+/* #undef HAVE___UINT16 */
+
+/* The system-provided hash function including the namespace. */
+#define SPARSEHASH_HASH HASH_NAMESPACE::hash
+
+/* Stops putting the code inside the Google namespace */
+#define _END_GOOGLE_NAMESPACE_ }
+
+/* Puts following code inside the Google namespace */
+#define _START_GOOGLE_NAMESPACE_ namespace google {
diff --git a/include/sparsehash/internal/sparsehashtable.h b/include/sparsehash/internal/sparsehashtable.h
new file mode 100644
index 0000000..f54ea51
--- /dev/null
+++ b/include/sparsehash/internal/sparsehashtable.h
@@ -0,0 +1,1247 @@
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+//
+// A sparse hashtable is a particular implementation of
+// a hashtable: one that is meant to minimize memory use.
+// It does this by using a *sparse table* (cf sparsetable.h),
+// which uses between 1 and 2 bits to store empty buckets
+// (we may need another bit for hashtables that support deletion).
+//
+// When empty buckets are so cheap, an appealing hashtable
+// implementation is internal probing, in which the hashtable
+// is a single table, and collisions are resolved by trying
+// to insert again in another bucket.  The most cache-efficient
+// internal probing schemes are linear probing (which suffers,
+// alas, from clumping) and quadratic probing, which is what
+// we implement by default.
+//
+// Deleted buckets are a bit of a pain.  We have to somehow mark
+// deleted buckets (the probing must distinguish them from empty
+// buckets).  The most principled way is to have another bitmap,
+// but that's annoying and takes up space.  Instead we let the
+// user specify an "impossible" key.  We set deleted buckets
+// to have the impossible key.
+//
+// Note it is possible to change the value of the delete key
+// on the fly; you can even remove it, though after that point
+// the hashtable is insert_only until you set it again.
+//
+// You probably shouldn't use this code directly.  Use
+// sparse_hash_map<> or sparse_hash_set<> instead.
+//
+// You can modify the following, below:
+// HT_OCCUPANCY_PCT            -- how full before we double size
+// HT_EMPTY_PCT                -- how empty before we halve size
+// HT_MIN_BUCKETS              -- smallest bucket size
+// HT_DEFAULT_STARTING_BUCKETS -- default bucket size at construct-time
+//
+// You can also change enlarge_factor (which defaults to
+// HT_OCCUPANCY_PCT), and shrink_factor (which defaults to
+// HT_EMPTY_PCT) with set_resizing_parameters().
+//
+// How to decide what values to use?
+// shrink_factor's default of .4 * OCCUPANCY_PCT, is probably good.
+// HT_MIN_BUCKETS is probably unnecessary since you can specify
+// (indirectly) the starting number of buckets at construct-time.
+// For enlarge_factor, you can use this chart to try to trade-off
+// expected lookup time to the space taken up.  By default, this
+// code uses quadratic probing, though you can change it to linear
+// via _JUMP below if you really want to.
+//
+// From http://www.augustana.ca/~mohrj/courses/1999.fall/csc210/lecture_notes/hashing.html
+// NUMBER OF PROBES / LOOKUP       Successful            Unsuccessful
+// Quadratic collision resolution   1 - ln(1-L) - L/2    1/(1-L) - L - ln(1-L)
+// Linear collision resolution     [1+1/(1-L)]/2         [1+1/(1-L)2]/2
+//
+// -- enlarge_factor --           0.10  0.50  0.60  0.75  0.80  0.90  0.99
+// QUADRATIC COLLISION RES.
+//    probes/successful lookup    1.05  1.44  1.62  2.01  2.21  2.85  5.11
+//    probes/unsuccessful lookup  1.11  2.19  2.82  4.64  5.81  11.4  103.6
+// LINEAR COLLISION RES.
+//    probes/successful lookup    1.06  1.5   1.75  2.5   3.0   5.5   50.5
+//    probes/unsuccessful lookup  1.12  2.5   3.6   8.5   13.0  50.0  5000.0
+//
+// The value type is required to be copy constructible and default
+// constructible, but it need not be (and commonly isn't) assignable.
+
+#ifndef _SPARSEHASHTABLE_H_
+#define _SPARSEHASHTABLE_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <assert.h>
+#include <algorithm>                 // For swap(), eg
+#include <iterator>                  // for iterator tags
+#include <limits>                    // for numeric_limits
+#include <utility>                   // for pair
+#include <sparsehash/type_traits.h>        // for remove_const
+#include <sparsehash/internal/hashtable-common.h>
+#include <sparsehash/sparsetable>    // IWYU pragma: export
+#include <stdexcept>                 // For length_error
+
+_START_GOOGLE_NAMESPACE_
+
+namespace base {   // just to make google->opensource transition easier
+using GOOGLE_NAMESPACE::remove_const;
+}
+
+#ifndef SPARSEHASH_STAT_UPDATE
+#define SPARSEHASH_STAT_UPDATE(x) ((void) 0)
+#endif
+
+// The probing method
+// Linear probing
+// #define JUMP_(key, num_probes)    ( 1 )
+// Quadratic probing
+#define JUMP_(key, num_probes)    ( num_probes )
+
+// The smaller this is, the faster lookup is (because the group bitmap is
+// smaller) and the faster insert is, because there's less to move.
+// On the other hand, there are more groups.  Since group::size_type is
+// a short, this number should be of the form 32*x + 16 to avoid waste.
+static const u_int16_t DEFAULT_GROUP_SIZE = 48;   // fits in 1.5 words
+
+// Hashtable class, used to implement the hashed associative containers
+// hash_set and hash_map.
+//
+// Value: what is stored in the table (each bucket is a Value).
+// Key: something in a 1-to-1 correspondence to a Value, that can be used
+//      to search for a Value in the table (find() takes a Key).
+// HashFcn: Takes a Key and returns an integer, the more unique the better.
+// ExtractKey: given a Value, returns the unique Key associated with it.
+//             Must inherit from unary_function, or at least have a
+//             result_type enum indicating the return type of operator().
+// SetKey: given a Value* and a Key, modifies the value such that
+//         ExtractKey(value) == key.  We guarantee this is only called
+//         with key == deleted_key.
+// EqualKey: Given two Keys, says whether they are the same (that is,
+//           if they are both associated with the same Value).
+// Alloc: STL allocator to use to allocate memory.
+
+template <class Value, class Key, class HashFcn,
+          class ExtractKey, class SetKey, class EqualKey, class Alloc>
+class sparse_hashtable;
+
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct sparse_hashtable_iterator;
+
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct sparse_hashtable_const_iterator;
+
+// As far as iterating, we're basically just a sparsetable
+// that skips over deleted elements.
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct sparse_hashtable_iterator {
+ private:
+  typedef typename A::template rebind<V>::other value_alloc_type;
+
+ public:
+  typedef sparse_hashtable_iterator<V,K,HF,ExK,SetK,EqK,A>       iterator;
+  typedef sparse_hashtable_const_iterator<V,K,HF,ExK,SetK,EqK,A> const_iterator;
+  typedef typename sparsetable<V,DEFAULT_GROUP_SIZE,value_alloc_type>::nonempty_iterator
+      st_iterator;
+
+  typedef std::forward_iterator_tag iterator_category;  // very little defined!
+  typedef V value_type;
+  typedef typename value_alloc_type::difference_type difference_type;
+  typedef typename value_alloc_type::size_type size_type;
+  typedef typename value_alloc_type::reference reference;
+  typedef typename value_alloc_type::pointer pointer;
+
+  // "Real" constructor and default constructor
+  sparse_hashtable_iterator(const sparse_hashtable<V,K,HF,ExK,SetK,EqK,A> *h,
+                            st_iterator it, st_iterator it_end)
+    : ht(h), pos(it), end(it_end)   { advance_past_deleted(); }
+  sparse_hashtable_iterator() { }      // not ever used internally
+  // The default destructor is fine; we don't define one
+  // The default operator= is fine; we don't define one
+
+  // Happy dereferencer
+  reference operator*() const { return *pos; }
+  pointer operator->() const { return &(operator*()); }
+
+  // Arithmetic.  The only hard part is making sure that
+  // we're not on a marked-deleted array element
+  void advance_past_deleted() {
+    while ( pos != end && ht->test_deleted(*this) )
+      ++pos;
+  }
+  iterator& operator++()   {
+    assert(pos != end); ++pos; advance_past_deleted(); return *this;
+  }
+  iterator operator++(int) { iterator tmp(*this); ++*this; return tmp; }
+
+  // Comparison.
+  bool operator==(const iterator& it) const { return pos == it.pos; }
+  bool operator!=(const iterator& it) const { return pos != it.pos; }
+
+
+  // The actual data
+  const sparse_hashtable<V,K,HF,ExK,SetK,EqK,A> *ht;
+  st_iterator pos, end;
+};
+
+// Now do it all again, but with const-ness!
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct sparse_hashtable_const_iterator {
+ private:
+  typedef typename A::template rebind<V>::other value_alloc_type;
+
+ public:
+  typedef sparse_hashtable_iterator<V,K,HF,ExK,SetK,EqK,A>       iterator;
+  typedef sparse_hashtable_const_iterator<V,K,HF,ExK,SetK,EqK,A> const_iterator;
+  typedef typename sparsetable<V,DEFAULT_GROUP_SIZE,value_alloc_type>::const_nonempty_iterator
+      st_iterator;
+
+  typedef std::forward_iterator_tag iterator_category;  // very little defined!
+  typedef V value_type;
+  typedef typename value_alloc_type::difference_type difference_type;
+  typedef typename value_alloc_type::size_type size_type;
+  typedef typename value_alloc_type::const_reference reference;
+  typedef typename value_alloc_type::const_pointer pointer;
+
+  // "Real" constructor and default constructor
+  sparse_hashtable_const_iterator(const sparse_hashtable<V,K,HF,ExK,SetK,EqK,A> *h,
+                                  st_iterator it, st_iterator it_end)
+    : ht(h), pos(it), end(it_end)   { advance_past_deleted(); }
+  // This lets us convert regular iterators to const iterators
+  sparse_hashtable_const_iterator() { }      // never used internally
+  sparse_hashtable_const_iterator(const iterator &it)
+    : ht(it.ht), pos(it.pos), end(it.end) { }
+  // The default destructor is fine; we don't define one
+  // The default operator= is fine; we don't define one
+
+  // Happy dereferencer
+  reference operator*() const { return *pos; }
+  pointer operator->() const { return &(operator*()); }
+
+  // Arithmetic.  The only hard part is making sure that
+  // we're not on a marked-deleted array element
+  void advance_past_deleted() {
+    while ( pos != end && ht->test_deleted(*this) )
+      ++pos;
+  }
+  const_iterator& operator++() {
+    assert(pos != end); ++pos; advance_past_deleted(); return *this;
+  }
+  const_iterator operator++(int) { const_iterator tmp(*this); ++*this; return tmp; }
+
+  // Comparison.
+  bool operator==(const const_iterator& it) const { return pos == it.pos; }
+  bool operator!=(const const_iterator& it) const { return pos != it.pos; }
+
+
+  // The actual data
+  const sparse_hashtable<V,K,HF,ExK,SetK,EqK,A> *ht;
+  st_iterator pos, end;
+};
+
+// And once again, but this time freeing up memory as we iterate
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+struct sparse_hashtable_destructive_iterator {
+ private:
+  typedef typename A::template rebind<V>::other value_alloc_type;
+
+ public:
+  typedef sparse_hashtable_destructive_iterator<V,K,HF,ExK,SetK,EqK,A> iterator;
+  typedef typename sparsetable<V,DEFAULT_GROUP_SIZE,value_alloc_type>::destructive_iterator
+      st_iterator;
+
+  typedef std::forward_iterator_tag iterator_category;  // very little defined!
+  typedef V value_type;
+  typedef typename value_alloc_type::difference_type difference_type;
+  typedef typename value_alloc_type::size_type size_type;
+  typedef typename value_alloc_type::reference reference;
+  typedef typename value_alloc_type::pointer pointer;
+
+  // "Real" constructor and default constructor
+  sparse_hashtable_destructive_iterator(const
+                                        sparse_hashtable<V,K,HF,ExK,SetK,EqK,A> *h,
+                                        st_iterator it, st_iterator it_end)
+    : ht(h), pos(it), end(it_end)   { advance_past_deleted(); }
+  sparse_hashtable_destructive_iterator() { }          // never used internally
+  // The default destructor is fine; we don't define one
+  // The default operator= is fine; we don't define one
+
+  // Happy dereferencer
+  reference operator*() const { return *pos; }
+  pointer operator->() const { return &(operator*()); }
+
+  // Arithmetic.  The only hard part is making sure that
+  // we're not on a marked-deleted array element
+  void advance_past_deleted() {
+    while ( pos != end && ht->test_deleted(*this) )
+      ++pos;
+  }
+  iterator& operator++()   {
+    assert(pos != end); ++pos; advance_past_deleted(); return *this;
+  }
+  iterator operator++(int) { iterator tmp(*this); ++*this; return tmp; }
+
+  // Comparison.
+  bool operator==(const iterator& it) const { return pos == it.pos; }
+  bool operator!=(const iterator& it) const { return pos != it.pos; }
+
+
+  // The actual data
+  const sparse_hashtable<V,K,HF,ExK,SetK,EqK,A> *ht;
+  st_iterator pos, end;
+};
+
+
+template <class Value, class Key, class HashFcn,
+          class ExtractKey, class SetKey, class EqualKey, class Alloc>
+class sparse_hashtable {
+ private:
+  typedef typename Alloc::template rebind<Value>::other value_alloc_type;
+
+ public:
+  typedef Key key_type;
+  typedef Value value_type;
+  typedef HashFcn hasher;
+  typedef EqualKey key_equal;
+  typedef Alloc allocator_type;
+
+  typedef typename value_alloc_type::size_type size_type;
+  typedef typename value_alloc_type::difference_type difference_type;
+  typedef typename value_alloc_type::reference reference;
+  typedef typename value_alloc_type::const_reference const_reference;
+  typedef typename value_alloc_type::pointer pointer;
+  typedef typename value_alloc_type::const_pointer const_pointer;
+  typedef sparse_hashtable_iterator<Value, Key, HashFcn, ExtractKey,
+                                    SetKey, EqualKey, Alloc>
+  iterator;
+
+  typedef sparse_hashtable_const_iterator<Value, Key, HashFcn, ExtractKey,
+                                          SetKey, EqualKey, Alloc>
+  const_iterator;
+
+  typedef sparse_hashtable_destructive_iterator<Value, Key, HashFcn, ExtractKey,
+                                                SetKey, EqualKey, Alloc>
+  destructive_iterator;
+
+  // These come from tr1.  For us they're the same as regular iterators.
+  typedef iterator local_iterator;
+  typedef const_iterator const_local_iterator;
+
+  // How full we let the table get before we resize, by default.
+  // Knuth says .8 is good -- higher causes us to probe too much,
+  // though it saves memory.
+  static const int HT_OCCUPANCY_PCT; // = 80 (out of 100);
+
+  // How empty we let the table get before we resize lower, by default.
+  // (0.0 means never resize lower.)
+  // It should be less than OCCUPANCY_PCT / 2 or we thrash resizing
+  static const int HT_EMPTY_PCT; // = 0.4 * HT_OCCUPANCY_PCT;
+
+  // Minimum size we're willing to let hashtables be.
+  // Must be a power of two, and at least 4.
+  // Note, however, that for a given hashtable, the initial size is a
+  // function of the first constructor arg, and may be >HT_MIN_BUCKETS.
+  static const size_type HT_MIN_BUCKETS = 4;
+
+  // By default, if you don't specify a hashtable size at
+  // construction-time, we use this size.  Must be a power of two, and
+  // at least HT_MIN_BUCKETS.
+  static const size_type HT_DEFAULT_STARTING_BUCKETS = 32;
+
+  // ITERATOR FUNCTIONS
+  iterator begin()             { return iterator(this, table.nonempty_begin(),
+                                                 table.nonempty_end()); }
+  iterator end()               { return iterator(this, table.nonempty_end(),
+                                                 table.nonempty_end()); }
+  const_iterator begin() const { return const_iterator(this,
+                                                       table.nonempty_begin(),
+                                                       table.nonempty_end()); }
+  const_iterator end() const   { return const_iterator(this,
+                                                       table.nonempty_end(),
+                                                       table.nonempty_end()); }
+
+  // These come from tr1 unordered_map.  They iterate over 'bucket' n.
+  // For sparsehashtable, we could consider each 'group' to be a bucket,
+  // I guess, but I don't really see the point.  We'll just consider
+  // bucket n to be the n-th element of the sparsetable, if it's occupied,
+  // or some empty element, otherwise.
+  local_iterator begin(size_type i) {
+    if (table.test(i))
+      return local_iterator(this, table.get_iter(i), table.nonempty_end());
+    else
+      return local_iterator(this, table.nonempty_end(), table.nonempty_end());
+  }
+  local_iterator end(size_type i) {
+    local_iterator it = begin(i);
+    if (table.test(i) && !test_deleted(i))
+      ++it;
+    return it;
+  }
+  const_local_iterator begin(size_type i) const {
+    if (table.test(i))
+      return const_local_iterator(this, table.get_iter(i),
+                                  table.nonempty_end());
+    else
+      return const_local_iterator(this, table.nonempty_end(),
+                                  table.nonempty_end());
+  }
+  const_local_iterator end(size_type i) const {
+    const_local_iterator it = begin(i);
+    if (table.test(i) && !test_deleted(i))
+      ++it;
+    return it;
+  }
+
+  // This is used when resizing
+  destructive_iterator destructive_begin() {
+    return destructive_iterator(this, table.destructive_begin(),
+                                table.destructive_end());
+  }
+  destructive_iterator destructive_end() {
+    return destructive_iterator(this, table.destructive_end(),
+                                table.destructive_end());
+  }
+
+
+  // ACCESSOR FUNCTIONS for the things we templatize on, basically
+  hasher hash_funct() const               { return settings; }
+  key_equal key_eq() const                { return key_info; }
+  allocator_type get_allocator() const    { return table.get_allocator(); }
+
+  // Accessor function for statistics gathering.
+  int num_table_copies() const { return settings.num_ht_copies(); }
+
+ private:
+  // We need to copy values when we set the special marker for deleted
+  // elements, but, annoyingly, we can't just use the copy assignment
+  // operator because value_type might not be assignable (it's often
+  // pair<const X, Y>).  We use explicit destructor invocation and
+  // placement new to get around this.  Arg.
+  void set_value(pointer dst, const_reference src) {
+    dst->~value_type();   // delete the old value, if any
+    new(dst) value_type(src);
+  }
+
+  // This is used as a tag for the copy constructor, saying to destroy its
+  // arg We have two ways of destructively copying: with potentially growing
+  // the hashtable as we copy, and without.  To make sure the outside world
+  // can't do a destructive copy, we make the typename private.
+  enum MoveDontCopyT {MoveDontCopy, MoveDontGrow};
+
+  // DELETE HELPER FUNCTIONS
+  // This lets the user describe a key that will indicate deleted
+  // table entries.  This key should be an "impossible" entry --
+  // if you try to insert it for real, you won't be able to retrieve it!
+  // (NB: while you pass in an entire value, only the key part is looked
+  // at.  This is just because I don't know how to assign just a key.)
+ private:
+  void squash_deleted() {           // gets rid of any deleted entries we have
+    if ( num_deleted ) {            // get rid of deleted before writing
+      sparse_hashtable tmp(MoveDontGrow, *this);
+      swap(tmp);                    // now we are tmp
+    }
+    assert(num_deleted == 0);
+  }
+
+  // Test if the given key is the deleted indicator.  Requires
+  // num_deleted > 0, for correctness of read(), and because that
+  // guarantees that key_info.delkey is valid.
+  bool test_deleted_key(const key_type& key) const {
+    assert(num_deleted > 0);
+    return equals(key_info.delkey, key);
+  }
+
+ public:
+  void set_deleted_key(const key_type &key) {
+    // It's only safe to change what "deleted" means if we purge deleted guys
+    squash_deleted();
+    settings.set_use_deleted(true);
+    key_info.delkey = key;
+  }
+  void clear_deleted_key() {
+    squash_deleted();
+    settings.set_use_deleted(false);
+  }
+  key_type deleted_key() const {
+    assert(settings.use_deleted()
+           && "Must set deleted key before calling deleted_key");
+    return key_info.delkey;
+  }
+
+  // These are public so the iterators can use them
+  // True if the item at position bucknum is "deleted" marker
+  bool test_deleted(size_type bucknum) const {
+    // Invariant: !use_deleted() implies num_deleted is 0.
+    assert(settings.use_deleted() || num_deleted == 0);
+    return num_deleted > 0 && table.test(bucknum) &&
+        test_deleted_key(get_key(table.unsafe_get(bucknum)));
+  }
+  bool test_deleted(const iterator &it) const {
+    // Invariant: !use_deleted() implies num_deleted is 0.
+    assert(settings.use_deleted() || num_deleted == 0);
+    return num_deleted > 0 && test_deleted_key(get_key(*it));
+  }
+  bool test_deleted(const const_iterator &it) const {
+    // Invariant: !use_deleted() implies num_deleted is 0.
+    assert(settings.use_deleted() || num_deleted == 0);
+    return num_deleted > 0 && test_deleted_key(get_key(*it));
+  }
+  bool test_deleted(const destructive_iterator &it) const {
+    // Invariant: !use_deleted() implies num_deleted is 0.
+    assert(settings.use_deleted() || num_deleted == 0);
+    return num_deleted > 0 && test_deleted_key(get_key(*it));
+  }
+
+ private:
+  void check_use_deleted(const char* caller) {
+    (void)caller;    // could log it if the assert failed
+    assert(settings.use_deleted());
+  }
+
+  // Set it so test_deleted is true.  true if object didn't used to be deleted.
+  // TODO(csilvers): make these private (also in densehashtable.h)
+  bool set_deleted(iterator &it) {
+    check_use_deleted("set_deleted()");
+    bool retval = !test_deleted(it);
+    // &* converts from iterator to value-type.
+    set_key(&(*it), key_info.delkey);
+    return retval;
+  }
+  // Set it so test_deleted is false.  true if object used to be deleted.
+  bool clear_deleted(iterator &it) {
+    check_use_deleted("clear_deleted()");
+    // Happens automatically when we assign something else in its place.
+    return test_deleted(it);
+  }
+
+  // We also allow to set/clear the deleted bit on a const iterator.
+  // We allow a const_iterator for the same reason you can delete a
+  // const pointer: it's convenient, and semantically you can't use
+  // 'it' after it's been deleted anyway, so its const-ness doesn't
+  // really matter.
+  bool set_deleted(const_iterator &it) {
+    check_use_deleted("set_deleted()");
+    bool retval = !test_deleted(it);
+    set_key(const_cast<pointer>(&(*it)), key_info.delkey);
+    return retval;
+  }
+  // Set it so test_deleted is false.  true if object used to be deleted.
+  bool clear_deleted(const_iterator &it) {
+    check_use_deleted("clear_deleted()");
+    return test_deleted(it);
+  }
+
+  // FUNCTIONS CONCERNING SIZE
+ public:
+  size_type size() const      { return table.num_nonempty() - num_deleted; }
+  size_type max_size() const          { return table.max_size(); }
+  bool empty() const                  { return size() == 0; }
+  size_type bucket_count() const      { return table.size(); }
+  size_type max_bucket_count() const  { return max_size(); }
+  // These are tr1 methods.  Their idea of 'bucket' doesn't map well to
+  // what we do.  We just say every bucket has 0 or 1 items in it.
+  size_type bucket_size(size_type i) const {
+    return begin(i) == end(i) ? 0 : 1;
+  }
+
+ private:
+  // Because of the above, size_type(-1) is never legal; use it for errors
+  static const size_type ILLEGAL_BUCKET = size_type(-1);
+
+  // Used after a string of deletes.  Returns true if we actually shrunk.
+  // TODO(csilvers): take a delta so we can take into account inserts
+  // done after shrinking.  Maybe make part of the Settings class?
+  bool maybe_shrink() {
+    assert(table.num_nonempty() >= num_deleted);
+    assert((bucket_count() & (bucket_count()-1)) == 0); // is a power of two
+    assert(bucket_count() >= HT_MIN_BUCKETS);
+    bool retval = false;
+
+    // If you construct a hashtable with < HT_DEFAULT_STARTING_BUCKETS,
+    // we'll never shrink until you get relatively big, and we'll never
+    // shrink below HT_DEFAULT_STARTING_BUCKETS.  Otherwise, something
+    // like "dense_hash_set<int> x; x.insert(4); x.erase(4);" will
+    // shrink us down to HT_MIN_BUCKETS buckets, which is too small.
+    const size_type num_remain = table.num_nonempty() - num_deleted;
+    const size_type shrink_threshold = settings.shrink_threshold();
+    if (shrink_threshold > 0 && num_remain < shrink_threshold &&
+        bucket_count() > HT_DEFAULT_STARTING_BUCKETS) {
+      const float shrink_factor = settings.shrink_factor();
+      size_type sz = bucket_count() / 2;    // find how much we should shrink
+      while (sz > HT_DEFAULT_STARTING_BUCKETS &&
+             num_remain < static_cast<size_type>(sz * shrink_factor)) {
+        sz /= 2;                            // stay a power of 2
+      }
+      sparse_hashtable tmp(MoveDontCopy, *this, sz);
+      swap(tmp);                            // now we are tmp
+      retval = true;
+    }
+    settings.set_consider_shrink(false);   // because we just considered it
+    return retval;
+  }
+
+  // We'll let you resize a hashtable -- though this makes us copy all!
+  // When you resize, you say, "make it big enough for this many more elements"
+  // Returns true if we actually resized, false if size was already ok.
+  bool resize_delta(size_type delta) {
+    bool did_resize = false;
+    if ( settings.consider_shrink() ) {  // see if lots of deletes happened
+      if ( maybe_shrink() )
+        did_resize = true;
+    }
+    if (table.num_nonempty() >=
+        (std::numeric_limits<size_type>::max)() - delta) {
+      throw std::length_error("resize overflow");
+    }
+    if ( bucket_count() >= HT_MIN_BUCKETS &&
+         (table.num_nonempty() + delta) <= settings.enlarge_threshold() )
+      return did_resize;                       // we're ok as we are
+
+    // Sometimes, we need to resize just to get rid of all the
+    // "deleted" buckets that are clogging up the hashtable.  So when
+    // deciding whether to resize, count the deleted buckets (which
+    // are currently taking up room).  But later, when we decide what
+    // size to resize to, *don't* count deleted buckets, since they
+    // get discarded during the resize.
+    const size_type needed_size =
+        settings.min_buckets(table.num_nonempty() + delta, 0);
+    if ( needed_size <= bucket_count() )      // we have enough buckets
+      return did_resize;
+
+    size_type resize_to =
+        settings.min_buckets(table.num_nonempty() - num_deleted + delta,
+                             bucket_count());
+    if (resize_to < needed_size &&    // may double resize_to
+        resize_to < (std::numeric_limits<size_type>::max)() / 2) {
+      // This situation means that we have enough deleted elements,
+      // that once we purge them, we won't actually have needed to
+      // grow.  But we may want to grow anyway: if we just purge one
+      // element, say, we'll have to grow anyway next time we
+      // insert.  Might as well grow now, since we're already going
+      // through the trouble of copying (in order to purge the
+      // deleted elements).
+      const size_type target =
+          static_cast<size_type>(settings.shrink_size(resize_to*2));
+      if (table.num_nonempty() - num_deleted + delta >= target) {
+        // Good, we won't be below the shrink threshhold even if we double.
+        resize_to *= 2;
+      }
+    }
+
+    sparse_hashtable tmp(MoveDontCopy, *this, resize_to);
+    swap(tmp);                             // now we are tmp
+    return true;
+  }
+
+  // Used to actually do the rehashing when we grow/shrink a hashtable
+  void copy_from(const sparse_hashtable &ht, size_type min_buckets_wanted) {
+    clear();            // clear table, set num_deleted to 0
+
+    // If we need to change the size of our table, do it now
+    const size_type resize_to =
+        settings.min_buckets(ht.size(), min_buckets_wanted);
+    if ( resize_to > bucket_count() ) {      // we don't have enough buckets
+      table.resize(resize_to);               // sets the number of buckets
+      settings.reset_thresholds(bucket_count());
+    }
+
+    // We use a normal iterator to get non-deleted bcks from ht
+    // We could use insert() here, but since we know there are
+    // no duplicates and no deleted items, we can be more efficient
+    assert((bucket_count() & (bucket_count()-1)) == 0);      // a power of two
+    for ( const_iterator it = ht.begin(); it != ht.end(); ++it ) {
+      size_type num_probes = 0;              // how many times we've probed
+      size_type bucknum;
+      const size_type bucket_count_minus_one = bucket_count() - 1;
+      for (bucknum = hash(get_key(*it)) & bucket_count_minus_one;
+           table.test(bucknum);                          // not empty
+           bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one) {
+        ++num_probes;
+        assert(num_probes < bucket_count()
+               && "Hashtable is full: an error in key_equal<> or hash<>");
+      }
+      table.set(bucknum, *it);               // copies the value to here
+    }
+    settings.inc_num_ht_copies();
+  }
+
+  // Implementation is like copy_from, but it destroys the table of the
+  // "from" guy by freeing sparsetable memory as we iterate.  This is
+  // useful in resizing, since we're throwing away the "from" guy anyway.
+  void move_from(MoveDontCopyT mover, sparse_hashtable &ht,
+                 size_type min_buckets_wanted) {
+    clear();            // clear table, set num_deleted to 0
+
+    // If we need to change the size of our table, do it now
+    size_type resize_to;
+    if ( mover == MoveDontGrow )
+      resize_to = ht.bucket_count();         // keep same size as old ht
+    else                                     // MoveDontCopy
+      resize_to = settings.min_buckets(ht.size(), min_buckets_wanted);
+    if ( resize_to > bucket_count() ) {      // we don't have enough buckets
+      table.resize(resize_to);               // sets the number of buckets
+      settings.reset_thresholds(bucket_count());
+    }
+
+    // We use a normal iterator to get non-deleted bcks from ht
+    // We could use insert() here, but since we know there are
+    // no duplicates and no deleted items, we can be more efficient
+    assert( (bucket_count() & (bucket_count()-1)) == 0);      // a power of two
+    // THIS IS THE MAJOR LINE THAT DIFFERS FROM COPY_FROM():
+    for ( destructive_iterator it = ht.destructive_begin();
+          it != ht.destructive_end(); ++it ) {
+      size_type num_probes = 0;              // how many times we've probed
+      size_type bucknum;
+      for ( bucknum = hash(get_key(*it)) & (bucket_count()-1);  // h % buck_cnt
+            table.test(bucknum);                          // not empty
+            bucknum = (bucknum + JUMP_(key, num_probes)) & (bucket_count()-1) ) {
+        ++num_probes;
+        assert(num_probes < bucket_count()
+               && "Hashtable is full: an error in key_equal<> or hash<>");
+      }
+      table.set(bucknum, *it);               // copies the value to here
+    }
+    settings.inc_num_ht_copies();
+  }
+
+
+  // Required by the spec for hashed associative container
+ public:
+  // Though the docs say this should be num_buckets, I think it's much
+  // more useful as num_elements.  As a special feature, calling with
+  // req_elements==0 will cause us to shrink if we can, saving space.
+  void resize(size_type req_elements) {       // resize to this or larger
+    if ( settings.consider_shrink() || req_elements == 0 )
+      maybe_shrink();
+    if ( req_elements > table.num_nonempty() )    // we only grow
+      resize_delta(req_elements - table.num_nonempty());
+  }
+
+  // Get and change the value of shrink_factor and enlarge_factor.  The
+  // description at the beginning of this file explains how to choose
+  // the values.  Setting the shrink parameter to 0.0 ensures that the
+  // table never shrinks.
+  void get_resizing_parameters(float* shrink, float* grow) const {
+    *shrink = settings.shrink_factor();
+    *grow = settings.enlarge_factor();
+  }
+  void set_resizing_parameters(float shrink, float grow) {
+    settings.set_resizing_parameters(shrink, grow);
+    settings.reset_thresholds(bucket_count());
+  }
+
+  // CONSTRUCTORS -- as required by the specs, we take a size,
+  // but also let you specify a hashfunction, key comparator,
+  // and key extractor.  We also define a copy constructor and =.
+  // DESTRUCTOR -- the default is fine, surprisingly.
+  explicit sparse_hashtable(size_type expected_max_items_in_table = 0,
+                            const HashFcn& hf = HashFcn(),
+                            const EqualKey& eql = EqualKey(),
+                            const ExtractKey& ext = ExtractKey(),
+                            const SetKey& set = SetKey(),
+                            const Alloc& alloc = Alloc())
+      : settings(hf),
+        key_info(ext, set, eql),
+        num_deleted(0),
+        table((expected_max_items_in_table == 0
+               ? HT_DEFAULT_STARTING_BUCKETS
+               : settings.min_buckets(expected_max_items_in_table, 0)),
+              alloc) {
+    settings.reset_thresholds(bucket_count());
+  }
+
+  // As a convenience for resize(), we allow an optional second argument
+  // which lets you make this new hashtable a different size than ht.
+  // We also provide a mechanism of saying you want to "move" the ht argument
+  // into us instead of copying.
+  sparse_hashtable(const sparse_hashtable& ht,
+                   size_type min_buckets_wanted = HT_DEFAULT_STARTING_BUCKETS)
+      : settings(ht.settings),
+        key_info(ht.key_info),
+        num_deleted(0),
+        table(0, ht.get_allocator()) {
+    settings.reset_thresholds(bucket_count());
+    copy_from(ht, min_buckets_wanted);   // copy_from() ignores deleted entries
+  }
+  sparse_hashtable(MoveDontCopyT mover, sparse_hashtable& ht,
+                   size_type min_buckets_wanted = HT_DEFAULT_STARTING_BUCKETS)
+      : settings(ht.settings),
+        key_info(ht.key_info),
+        num_deleted(0),
+        table(0, ht.get_allocator()) {
+    settings.reset_thresholds(bucket_count());
+    move_from(mover, ht, min_buckets_wanted);  // ignores deleted entries
+  }
+
+  sparse_hashtable& operator= (const sparse_hashtable& ht) {
+    if (&ht == this)  return *this;        // don't copy onto ourselves
+    settings = ht.settings;
+    key_info = ht.key_info;
+    num_deleted = ht.num_deleted;
+    // copy_from() calls clear and sets num_deleted to 0 too
+    copy_from(ht, HT_MIN_BUCKETS);
+    // we purposefully don't copy the allocator, which may not be copyable
+    return *this;
+  }
+
+  // Many STL algorithms use swap instead of copy constructors
+  void swap(sparse_hashtable& ht) {
+    std::swap(settings, ht.settings);
+    std::swap(key_info, ht.key_info);
+    std::swap(num_deleted, ht.num_deleted);
+    table.swap(ht.table);
+    settings.reset_thresholds(bucket_count());  // also resets consider_shrink
+    ht.settings.reset_thresholds(ht.bucket_count());
+    // we purposefully don't swap the allocator, which may not be swap-able
+  }
+
+  // It's always nice to be able to clear a table without deallocating it
+  void clear() {
+    if (!empty() || (num_deleted != 0)) {
+      table.clear();
+    }
+    settings.reset_thresholds(bucket_count());
+    num_deleted = 0;
+  }
+
+  // LOOKUP ROUTINES
+ private:
+  // Returns a pair of positions: 1st where the object is, 2nd where
+  // it would go if you wanted to insert it.  1st is ILLEGAL_BUCKET
+  // if object is not found; 2nd is ILLEGAL_BUCKET if it is.
+  // Note: because of deletions where-to-insert is not trivial: it's the
+  // first deleted bucket we see, as long as we don't find the key later
+  std::pair<size_type, size_type> find_position(const key_type &key) const {
+    size_type num_probes = 0;              // how many times we've probed
+    const size_type bucket_count_minus_one = bucket_count() - 1;
+    size_type bucknum = hash(key) & bucket_count_minus_one;
+    size_type insert_pos = ILLEGAL_BUCKET; // where we would insert
+    SPARSEHASH_STAT_UPDATE(total_lookups += 1);
+    while ( 1 ) {                          // probe until something happens
+      if ( !table.test(bucknum) ) {        // bucket is empty
+        SPARSEHASH_STAT_UPDATE(total_probes += num_probes);
+        if ( insert_pos == ILLEGAL_BUCKET )  // found no prior place to insert
+          return std::pair<size_type,size_type>(ILLEGAL_BUCKET, bucknum);
+        else
+          return std::pair<size_type,size_type>(ILLEGAL_BUCKET, insert_pos);
+
+      } else if ( test_deleted(bucknum) ) {// keep searching, but mark to insert
+        if ( insert_pos == ILLEGAL_BUCKET )
+          insert_pos = bucknum;
+
+      } else if ( equals(key, get_key(table.unsafe_get(bucknum))) ) {
+        SPARSEHASH_STAT_UPDATE(total_probes += num_probes);
+        return std::pair<size_type,size_type>(bucknum, ILLEGAL_BUCKET);
+      }
+      ++num_probes;                        // we're doing another probe
+      bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one;
+      assert(num_probes < bucket_count()
+             && "Hashtable is full: an error in key_equal<> or hash<>");
+    }
+  }
+
+ public:
+
+  iterator find(const key_type& key) {
+    if ( size() == 0 ) return end();
+    std::pair<size_type, size_type> pos = find_position(key);
+    if ( pos.first == ILLEGAL_BUCKET )     // alas, not there
+      return end();
+    else
+      return iterator(this, table.get_iter(pos.first), table.nonempty_end());
+  }
+
+  const_iterator find(const key_type& key) const {
+    if ( size() == 0 ) return end();
+    std::pair<size_type, size_type> pos = find_position(key);
+    if ( pos.first == ILLEGAL_BUCKET )     // alas, not there
+      return end();
+    else
+      return const_iterator(this,
+                            table.get_iter(pos.first), table.nonempty_end());
+  }
+
+  // This is a tr1 method: the bucket a given key is in, or what bucket
+  // it would be put in, if it were to be inserted.  Shrug.
+  size_type bucket(const key_type& key) const {
+    std::pair<size_type, size_type> pos = find_position(key);
+    return pos.first == ILLEGAL_BUCKET ? pos.second : pos.first;
+  }
+
+  // Counts how many elements have key key.  For maps, it's either 0 or 1.
+  size_type count(const key_type &key) const {
+    std::pair<size_type, size_type> pos = find_position(key);
+    return pos.first == ILLEGAL_BUCKET ? 0 : 1;
+  }
+
+  // Likewise, equal_range doesn't really make sense for us.  Oh well.
+  std::pair<iterator,iterator> equal_range(const key_type& key) {
+    iterator pos = find(key);      // either an iterator or end
+    if (pos == end()) {
+      return std::pair<iterator,iterator>(pos, pos);
+    } else {
+      const iterator startpos = pos++;
+      return std::pair<iterator,iterator>(startpos, pos);
+    }
+  }
+  std::pair<const_iterator,const_iterator> equal_range(const key_type& key)
+      const {
+    const_iterator pos = find(key);      // either an iterator or end
+    if (pos == end()) {
+      return std::pair<const_iterator,const_iterator>(pos, pos);
+    } else {
+      const const_iterator startpos = pos++;
+      return std::pair<const_iterator,const_iterator>(startpos, pos);
+    }
+  }
+
+
+  // INSERTION ROUTINES
+ private:
+  // Private method used by insert_noresize and find_or_insert.
+  iterator insert_at(const_reference obj, size_type pos) {
+    if (size() >= max_size()) {
+      throw std::length_error("insert overflow");
+    }
+    if ( test_deleted(pos) ) {      // just replace if it's been deleted
+      // The set() below will undelete this object.  We just worry about stats
+      assert(num_deleted > 0);
+      --num_deleted;                // used to be, now it isn't
+    }
+    table.set(pos, obj);
+    return iterator(this, table.get_iter(pos), table.nonempty_end());
+  }
+
+  // If you know *this is big enough to hold obj, use this routine
+  std::pair<iterator, bool> insert_noresize(const_reference obj) {
+    // First, double-check we're not inserting delkey
+    assert((!settings.use_deleted() || !equals(get_key(obj), key_info.delkey))
+           && "Inserting the deleted key");
+    const std::pair<size_type,size_type> pos = find_position(get_key(obj));
+    if ( pos.first != ILLEGAL_BUCKET) {      // object was already there
+      return std::pair<iterator,bool>(iterator(this, table.get_iter(pos.first),
+                                               table.nonempty_end()),
+                                      false);     // false: we didn't insert
+    } else {                                 // pos.second says where to put it
+      return std::pair<iterator,bool>(insert_at(obj, pos.second), true);
+    }
+  }
+
+  // Specializations of insert(it, it) depending on the power of the iterator:
+  // (1) Iterator supports operator-, resize before inserting
+  template <class ForwardIterator>
+  void insert(ForwardIterator f, ForwardIterator l, std::forward_iterator_tag) {
+    size_t dist = std::distance(f, l);
+    if (dist >= (std::numeric_limits<size_type>::max)()) {
+      throw std::length_error("insert-range overflow");
+    }
+    resize_delta(static_cast<size_type>(dist));
+    for ( ; dist > 0; --dist, ++f) {
+      insert_noresize(*f);
+    }
+  }
+
+  // (2) Arbitrary iterator, can't tell how much to resize
+  template <class InputIterator>
+  void insert(InputIterator f, InputIterator l, std::input_iterator_tag) {
+    for ( ; f != l; ++f)
+      insert(*f);
+  }
+
+ public:
+  // This is the normal insert routine, used by the outside world
+  std::pair<iterator, bool> insert(const_reference obj) {
+    resize_delta(1);                      // adding an object, grow if need be
+    return insert_noresize(obj);
+  }
+
+  // When inserting a lot at a time, we specialize on the type of iterator
+  template <class InputIterator>
+  void insert(InputIterator f, InputIterator l) {
+    // specializes on iterator type
+    insert(f, l,
+           typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  // DefaultValue is a functor that takes a key and returns a value_type
+  // representing the default value to be inserted if none is found.
+  template <class DefaultValue>
+  value_type& find_or_insert(const key_type& key) {
+    // First, double-check we're not inserting delkey
+    assert((!settings.use_deleted() || !equals(key, key_info.delkey))
+           && "Inserting the deleted key");
+    const std::pair<size_type,size_type> pos = find_position(key);
+    DefaultValue default_value;
+    if ( pos.first != ILLEGAL_BUCKET) {  // object was already there
+      return *table.get_iter(pos.first);
+    } else if (resize_delta(1)) {        // needed to rehash to make room
+      // Since we resized, we can't use pos, so recalculate where to insert.
+      return *insert_noresize(default_value(key)).first;
+    } else {                             // no need to rehash, insert right here
+      return *insert_at(default_value(key), pos.second);
+    }
+  }
+
+  // DELETION ROUTINES
+  size_type erase(const key_type& key) {
+    // First, double-check we're not erasing delkey.
+    assert((!settings.use_deleted() || !equals(key, key_info.delkey))
+           && "Erasing the deleted key");
+    assert(!settings.use_deleted() || !equals(key, key_info.delkey));
+    const_iterator pos = find(key);   // shrug: shouldn't need to be const
+    if ( pos != end() ) {
+      assert(!test_deleted(pos));  // or find() shouldn't have returned it
+      set_deleted(pos);
+      ++num_deleted;
+      // will think about shrink after next insert
+      settings.set_consider_shrink(true);
+      return 1;                    // because we deleted one thing
+    } else {
+      return 0;                    // because we deleted nothing
+    }
+  }
+
+  // We return the iterator past the deleted item.
+  void erase(iterator pos) {
+    if ( pos == end() ) return;    // sanity check
+    if ( set_deleted(pos) ) {      // true if object has been newly deleted
+      ++num_deleted;
+      // will think about shrink after next insert
+      settings.set_consider_shrink(true);
+    }
+  }
+
+  void erase(iterator f, iterator l) {
+    for ( ; f != l; ++f) {
+      if ( set_deleted(f)  )       // should always be true
+        ++num_deleted;
+    }
+    // will think about shrink after next insert
+    settings.set_consider_shrink(true);
+  }
+
+  // We allow you to erase a const_iterator just like we allow you to
+  // erase an iterator.  This is in parallel to 'delete': you can delete
+  // a const pointer just like a non-const pointer.  The logic is that
+  // you can't use the object after it's erased anyway, so it doesn't matter
+  // if it's const or not.
+  void erase(const_iterator pos) {
+    if ( pos == end() ) return;    // sanity check
+    if ( set_deleted(pos) ) {      // true if object has been newly deleted
+      ++num_deleted;
+      // will think about shrink after next insert
+      settings.set_consider_shrink(true);
+    }
+  }
+  void erase(const_iterator f, const_iterator l) {
+    for ( ; f != l; ++f) {
+      if ( set_deleted(f)  )       // should always be true
+        ++num_deleted;
+    }
+    // will think about shrink after next insert
+    settings.set_consider_shrink(true);
+  }
+
+
+  // COMPARISON
+  bool operator==(const sparse_hashtable& ht) const {
+    if (size() != ht.size()) {
+      return false;
+    } else if (this == &ht) {
+      return true;
+    } else {
+      // Iterate through the elements in "this" and see if the
+      // corresponding element is in ht
+      for ( const_iterator it = begin(); it != end(); ++it ) {
+        const_iterator it2 = ht.find(get_key(*it));
+        if ((it2 == ht.end()) || (*it != *it2)) {
+          return false;
+        }
+      }
+      return true;
+    }
+  }
+  bool operator!=(const sparse_hashtable& ht) const {
+    return !(*this == ht);
+  }
+
+
+  // I/O
+  // We support reading and writing hashtables to disk.  NOTE that
+  // this only stores the hashtable metadata, not the stuff you've
+  // actually put in the hashtable!  Alas, since I don't know how to
+  // write a hasher or key_equal, you have to make sure everything
+  // but the table is the same.  We compact before writing.
+  //
+  // The OUTPUT type needs to support a Write() operation. File and
+  // OutputBuffer are appropriate types to pass in.
+  //
+  // The INPUT type needs to support a Read() operation. File and
+  // InputBuffer are appropriate types to pass in.
+  template <typename OUTPUT>
+  bool write_metadata(OUTPUT *fp) {
+    squash_deleted();           // so we don't have to worry about delkey
+    return table.write_metadata(fp);
+  }
+
+  template <typename INPUT>
+  bool read_metadata(INPUT *fp) {
+    num_deleted = 0;            // since we got rid before writing
+    const bool result = table.read_metadata(fp);
+    settings.reset_thresholds(bucket_count());
+    return result;
+  }
+
+  // Only meaningful if value_type is a POD.
+  template <typename OUTPUT>
+  bool write_nopointer_data(OUTPUT *fp) {
+    return table.write_nopointer_data(fp);
+  }
+
+  // Only meaningful if value_type is a POD.
+  template <typename INPUT>
+  bool read_nopointer_data(INPUT *fp) {
+    return table.read_nopointer_data(fp);
+  }
+
+  // INPUT and OUTPUT must be either a FILE, *or* a C++ stream
+  //    (istream, ostream, etc) *or* a class providing
+  //    Read(void*, size_t) and Write(const void*, size_t)
+  //    (respectively), which writes a buffer into a stream
+  //    (which the INPUT/OUTPUT instance presumably owns).
+
+  typedef sparsehash_internal::pod_serializer<value_type> NopointerSerializer;
+
+  // ValueSerializer: a functor.  operator()(OUTPUT*, const value_type&)
+  template <typename ValueSerializer, typename OUTPUT>
+  bool serialize(ValueSerializer serializer, OUTPUT *fp) {
+    squash_deleted();           // so we don't have to worry about delkey
+    return table.serialize(serializer, fp);
+  }
+
+  // ValueSerializer: a functor.  operator()(INPUT*, value_type*)
+  template <typename ValueSerializer, typename INPUT>
+  bool unserialize(ValueSerializer serializer, INPUT *fp) {
+    num_deleted = 0;            // since we got rid before writing
+    const bool result = table.unserialize(serializer, fp);
+    settings.reset_thresholds(bucket_count());
+    return result;
+  }
+
+ private:
+  // Table is the main storage class.
+  typedef sparsetable<value_type, DEFAULT_GROUP_SIZE, value_alloc_type> Table;
+
+  // Package templated functors with the other types to eliminate memory
+  // needed for storing these zero-size operators.  Since ExtractKey and
+  // hasher's operator() might have the same function signature, they
+  // must be packaged in different classes.
+  struct Settings :
+      sparsehash_internal::sh_hashtable_settings<key_type, hasher,
+                                                 size_type, HT_MIN_BUCKETS> {
+    explicit Settings(const hasher& hf)
+        : sparsehash_internal::sh_hashtable_settings<key_type, hasher,
+                                                     size_type, HT_MIN_BUCKETS>(
+            hf, HT_OCCUPANCY_PCT / 100.0f, HT_EMPTY_PCT / 100.0f) {}
+  };
+
+  // KeyInfo stores delete key and packages zero-size functors:
+  // ExtractKey and SetKey.
+  class KeyInfo : public ExtractKey, public SetKey, public EqualKey {
+   public:
+    KeyInfo(const ExtractKey& ek, const SetKey& sk, const EqualKey& eq)
+        : ExtractKey(ek),
+          SetKey(sk),
+          EqualKey(eq) {
+    }
+    // We want to return the exact same type as ExtractKey: Key or const Key&
+    typename ExtractKey::result_type get_key(const_reference v) const {
+      return ExtractKey::operator()(v);
+    }
+    void set_key(pointer v, const key_type& k) const {
+      SetKey::operator()(v, k);
+    }
+    bool equals(const key_type& a, const key_type& b) const {
+      return EqualKey::operator()(a, b);
+    }
+
+    // Which key marks deleted entries.
+    // TODO(csilvers): make a pointer, and get rid of use_deleted (benchmark!)
+    typename base::remove_const<key_type>::type delkey;
+  };
+
+  // Utility functions to access the templated operators
+  size_type hash(const key_type& v) const {
+    return settings.hash(v);
+  }
+  bool equals(const key_type& a, const key_type& b) const {
+    return key_info.equals(a, b);
+  }
+  typename ExtractKey::result_type get_key(const_reference v) const {
+    return key_info.get_key(v);
+  }
+  void set_key(pointer v, const key_type& k) const {
+    key_info.set_key(v, k);
+  }
+
+ private:
+  // Actual data
+  Settings settings;
+  KeyInfo key_info;
+  size_type num_deleted;   // how many occupied buckets are marked deleted
+  Table table;     // holds num_buckets and num_elements too
+};
+
+
+// We need a global swap as well
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+inline void swap(sparse_hashtable<V,K,HF,ExK,SetK,EqK,A> &x,
+                 sparse_hashtable<V,K,HF,ExK,SetK,EqK,A> &y) {
+  x.swap(y);
+}
+
+#undef JUMP_
+
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+const typename sparse_hashtable<V,K,HF,ExK,SetK,EqK,A>::size_type
+  sparse_hashtable<V,K,HF,ExK,SetK,EqK,A>::ILLEGAL_BUCKET;
+
+// How full we let the table get before we resize.  Knuth says .8 is
+// good -- higher causes us to probe too much, though saves memory
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+const int sparse_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_OCCUPANCY_PCT = 80;
+
+// How empty we let the table get before we resize lower.
+// It should be less than OCCUPANCY_PCT / 2 or we thrash resizing
+template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
+const int sparse_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_EMPTY_PCT
+  = static_cast<int>(0.4 *
+                     sparse_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_OCCUPANCY_PCT);
+
+_END_GOOGLE_NAMESPACE_
+
+#endif /* _SPARSEHASHTABLE_H_ */
diff --git a/include/sparsehash/sparse_hash_map b/include/sparsehash/sparse_hash_map
new file mode 100644
index 0000000..1687a8b
--- /dev/null
+++ b/include/sparsehash/sparse_hash_map
@@ -0,0 +1,363 @@
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+//
+// This is just a very thin wrapper over sparsehashtable.h, just
+// like sgi stl's stl_hash_map is a very thin wrapper over
+// stl_hashtable.  The major thing we define is operator[], because
+// we have a concept of a data_type which stl_hashtable doesn't
+// (it only has a key and a value).
+//
+// We adhere mostly to the STL semantics for hash-map.  One important
+// exception is that insert() may invalidate iterators entirely -- STL
+// semantics are that insert() may reorder iterators, but they all
+// still refer to something valid in the hashtable.  Not so for us.
+// Likewise, insert() may invalidate pointers into the hashtable.
+// (Whether insert invalidates iterators and pointers depends on
+// whether it results in a hashtable resize).  On the plus side,
+// delete() doesn't invalidate iterators or pointers at all, or even
+// change the ordering of elements.
+//
+// Here are a few "power user" tips:
+//
+//    1) set_deleted_key():
+//         Unlike STL's hash_map, if you want to use erase() you
+//         *must* call set_deleted_key() after construction.
+//
+//    2) resize(0):
+//         When an item is deleted, its memory isn't freed right
+//         away.  This is what allows you to iterate over a hashtable
+//         and call erase() without invalidating the iterator.
+//         To force the memory to be freed, call resize(0).
+//         For tr1 compatibility, this can also be called as rehash(0).
+//
+//    3) min_load_factor(0.0)
+//         Setting the minimum load factor to 0.0 guarantees that
+//         the hash table will never shrink.
+//
+// Roughly speaking:
+//   (1) dense_hash_map: fastest, uses the most memory unless entries are small
+//   (2) sparse_hash_map: slowest, uses the least memory
+//   (3) hash_map / unordered_map (STL): in the middle
+//
+// Typically I use sparse_hash_map when I care about space and/or when
+// I need to save the hashtable on disk.  I use hash_map otherwise.  I
+// don't personally use dense_hash_map ever; some people use it for
+// small maps with lots of lookups.
+//
+// - dense_hash_map has, typically, about 78% memory overhead (if your
+//   data takes up X bytes, the hash_map uses .78X more bytes in overhead).
+// - sparse_hash_map has about 4 bits overhead per entry.
+// - sparse_hash_map can be 3-7 times slower than the others for lookup and,
+//   especially, inserts.  See time_hash_map.cc for details.
+//
+// See /usr/(local/)?doc/sparsehash-*/sparse_hash_map.html
+// for information about how to use this class.
+
+#ifndef _SPARSE_HASH_MAP_H_
+#define _SPARSE_HASH_MAP_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <algorithm>                        // needed by stl_alloc
+#include <functional>                       // for equal_to<>, select1st<>, etc
+#include <memory>                           // for alloc
+#include <utility>                          // for pair<>
+#include <sparsehash/internal/libc_allocator_with_realloc.h>
+#include <sparsehash/internal/sparsehashtable.h>       // IWYU pragma: export
+#include HASH_FUN_H                 // for hash<>
+_START_GOOGLE_NAMESPACE_
+
+template <class Key, class T,
+          class HashFcn = SPARSEHASH_HASH<Key>,   // defined in sparseconfig.h
+          class EqualKey = std::equal_to<Key>,
+          class Alloc = libc_allocator_with_realloc<std::pair<const Key, T> > >
+class sparse_hash_map {
+ private:
+  // Apparently select1st is not stl-standard, so we define our own
+  struct SelectKey {
+    typedef const Key& result_type;
+    const Key& operator()(const std::pair<const Key, T>& p) const {
+      return p.first;
+    }
+  };
+  struct SetKey {
+    void operator()(std::pair<const Key, T>* value, const Key& new_key) const {
+      *const_cast<Key*>(&value->first) = new_key;
+      // It would be nice to clear the rest of value here as well, in
+      // case it's taking up a lot of memory.  We do this by clearing
+      // the value.  This assumes T has a zero-arg constructor!
+      value->second = T();
+    }
+  };
+  // For operator[].
+  struct DefaultValue {
+    std::pair<const Key, T> operator()(const Key& key) {
+      return std::make_pair(key, T());
+    }
+  };
+
+  // The actual data
+  typedef sparse_hashtable<std::pair<const Key, T>, Key, HashFcn, SelectKey,
+                           SetKey, EqualKey, Alloc> ht;
+  ht rep;
+
+ public:
+  typedef typename ht::key_type key_type;
+  typedef T data_type;
+  typedef T mapped_type;
+  typedef typename ht::value_type value_type;
+  typedef typename ht::hasher hasher;
+  typedef typename ht::key_equal key_equal;
+  typedef Alloc allocator_type;
+
+  typedef typename ht::size_type size_type;
+  typedef typename ht::difference_type difference_type;
+  typedef typename ht::pointer pointer;
+  typedef typename ht::const_pointer const_pointer;
+  typedef typename ht::reference reference;
+  typedef typename ht::const_reference const_reference;
+
+  typedef typename ht::iterator iterator;
+  typedef typename ht::const_iterator const_iterator;
+  typedef typename ht::local_iterator local_iterator;
+  typedef typename ht::const_local_iterator const_local_iterator;
+
+  // Iterator functions
+  iterator begin()                               { return rep.begin(); }
+  iterator end()                                 { return rep.end(); }
+  const_iterator begin() const                   { return rep.begin(); }
+  const_iterator end() const                     { return rep.end(); }
+
+  // These come from tr1's unordered_map. For us, a bucket has 0 or 1 elements.
+  local_iterator begin(size_type i)              { return rep.begin(i); }
+  local_iterator end(size_type i)                { return rep.end(i); }
+  const_local_iterator begin(size_type i) const  { return rep.begin(i); }
+  const_local_iterator end(size_type i) const    { return rep.end(i); }
+
+  // Accessor functions
+  allocator_type get_allocator() const           { return rep.get_allocator(); }
+  hasher hash_funct() const                      { return rep.hash_funct(); }
+  hasher hash_function() const                   { return hash_funct(); }
+  key_equal key_eq() const                       { return rep.key_eq(); }
+
+
+  // Constructors
+  explicit sparse_hash_map(size_type expected_max_items_in_table = 0,
+                           const hasher& hf = hasher(),
+                           const key_equal& eql = key_equal(),
+                           const allocator_type& alloc = allocator_type())
+    : rep(expected_max_items_in_table, hf, eql, SelectKey(), SetKey(), alloc) {
+  }
+
+  template <class InputIterator>
+  sparse_hash_map(InputIterator f, InputIterator l,
+                  size_type expected_max_items_in_table = 0,
+                  const hasher& hf = hasher(),
+                  const key_equal& eql = key_equal(),
+                  const allocator_type& alloc = allocator_type())
+    : rep(expected_max_items_in_table, hf, eql, SelectKey(), SetKey(), alloc) {
+    rep.insert(f, l);
+  }
+  // We use the default copy constructor
+  // We use the default operator=()
+  // We use the default destructor
+
+  void clear()                        { rep.clear(); }
+  void swap(sparse_hash_map& hs)      { rep.swap(hs.rep); }
+
+
+  // Functions concerning size
+  size_type size() const              { return rep.size(); }
+  size_type max_size() const          { return rep.max_size(); }
+  bool empty() const                  { return rep.empty(); }
+  size_type bucket_count() const      { return rep.bucket_count(); }
+  size_type max_bucket_count() const  { return rep.max_bucket_count(); }
+
+  // These are tr1 methods.  bucket() is the bucket the key is or would be in.
+  size_type bucket_size(size_type i) const    { return rep.bucket_size(i); }
+  size_type bucket(const key_type& key) const { return rep.bucket(key); }
+  float load_factor() const {
+    return size() * 1.0f / bucket_count();
+  }
+  float max_load_factor() const {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    return grow;
+  }
+  void max_load_factor(float new_grow) {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    rep.set_resizing_parameters(shrink, new_grow);
+  }
+  // These aren't tr1 methods but perhaps ought to be.
+  float min_load_factor() const {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    return shrink;
+  }
+  void min_load_factor(float new_shrink) {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    rep.set_resizing_parameters(new_shrink, grow);
+  }
+  // Deprecated; use min_load_factor() or max_load_factor() instead.
+  void set_resizing_parameters(float shrink, float grow) {
+    rep.set_resizing_parameters(shrink, grow);
+  }
+
+  void resize(size_type hint)         { rep.resize(hint); }
+  void rehash(size_type hint)         { resize(hint); }      // the tr1 name
+
+  // Lookup routines
+  iterator find(const key_type& key)                 { return rep.find(key); }
+  const_iterator find(const key_type& key) const     { return rep.find(key); }
+
+  data_type& operator[](const key_type& key) {       // This is our value-add!
+    // If key is in the hashtable, returns find(key)->second,
+    // otherwise returns insert(value_type(key, T()).first->second.
+    // Note it does not create an empty T unless the find fails.
+    return rep.template find_or_insert<DefaultValue>(key).second;
+  }
+
+  size_type count(const key_type& key) const         { return rep.count(key); }
+
+  std::pair<iterator, iterator> equal_range(const key_type& key) {
+    return rep.equal_range(key);
+  }
+  std::pair<const_iterator, const_iterator> equal_range(const key_type& key)
+      const {
+    return rep.equal_range(key);
+  }
+
+  // Insertion routines
+  std::pair<iterator, bool> insert(const value_type& obj) {
+    return rep.insert(obj);
+  }
+  template <class InputIterator> void insert(InputIterator f, InputIterator l) {
+    rep.insert(f, l);
+  }
+  void insert(const_iterator f, const_iterator l) {
+    rep.insert(f, l);
+  }
+  // Required for std::insert_iterator; the passed-in iterator is ignored.
+  iterator insert(iterator, const value_type& obj) {
+    return insert(obj).first;
+  }
+
+  // Deletion routines
+  // THESE ARE NON-STANDARD!  I make you specify an "impossible" key
+  // value to identify deleted buckets.  You can change the key as
+  // time goes on, or get rid of it entirely to be insert-only.
+  void set_deleted_key(const key_type& key)   {
+    rep.set_deleted_key(key);
+  }
+  void clear_deleted_key()                    { rep.clear_deleted_key(); }
+  key_type deleted_key() const                { return rep.deleted_key(); }
+
+  // These are standard
+  size_type erase(const key_type& key)               { return rep.erase(key); }
+  void erase(iterator it)                            { rep.erase(it); }
+  void erase(iterator f, iterator l)                 { rep.erase(f, l); }
+
+
+  // Comparison
+  bool operator==(const sparse_hash_map& hs) const   { return rep == hs.rep; }
+  bool operator!=(const sparse_hash_map& hs) const   { return rep != hs.rep; }
+
+
+  // I/O -- this is an add-on for writing metainformation to disk
+  //
+  // For maximum flexibility, this does not assume a particular
+  // file type (though it will probably be a FILE *).  We just pass
+  // the fp through to rep.
+
+  // If your keys and values are simple enough, you can pass this
+  // serializer to serialize()/unserialize().  "Simple enough" means
+  // value_type is a POD type that contains no pointers.  Note,
+  // however, we don't try to normalize endianness.
+  typedef typename ht::NopointerSerializer NopointerSerializer;
+
+  // serializer: a class providing operator()(OUTPUT*, const value_type&)
+  //    (writing value_type to OUTPUT).  You can specify a
+  //    NopointerSerializer object if appropriate (see above).
+  // fp: either a FILE*, OR an ostream*/subclass_of_ostream*, OR a
+  //    pointer to a class providing size_t Write(const void*, size_t),
+  //    which writes a buffer into a stream (which fp presumably
+  //    owns) and returns the number of bytes successfully written.
+  //    Note basic_ostream<not_char> is not currently supported.
+  template <typename ValueSerializer, typename OUTPUT>
+  bool serialize(ValueSerializer serializer, OUTPUT* fp) {
+    return rep.serialize(serializer, fp);
+  }
+
+  // serializer: a functor providing operator()(INPUT*, value_type*)
+  //    (reading from INPUT and into value_type).  You can specify a
+  //    NopointerSerializer object if appropriate (see above).
+  // fp: either a FILE*, OR an istream*/subclass_of_istream*, OR a
+  //    pointer to a class providing size_t Read(void*, size_t),
+  //    which reads into a buffer from a stream (which fp presumably
+  //    owns) and returns the number of bytes successfully read.
+  //    Note basic_istream<not_char> is not currently supported.
+  // NOTE: Since value_type is std::pair<const Key, T>, ValueSerializer
+  // may need to do a const cast in order to fill in the key.
+  // NOTE: if Key or T are not POD types, the serializer MUST use
+  // placement-new to initialize their values, rather than a normal
+  // equals-assignment or similar.  (The value_type* passed into the
+  // serializer points to garbage memory.)
+  template <typename ValueSerializer, typename INPUT>
+  bool unserialize(ValueSerializer serializer, INPUT* fp) {
+    return rep.unserialize(serializer, fp);
+  }
+
+  // The four methods below are DEPRECATED.
+  // Use serialize() and unserialize() for new code.
+  template <typename OUTPUT>
+  bool write_metadata(OUTPUT *fp)       { return rep.write_metadata(fp); }
+
+  template <typename INPUT>
+  bool read_metadata(INPUT *fp)         { return rep.read_metadata(fp); }
+
+  template <typename OUTPUT>
+  bool write_nopointer_data(OUTPUT *fp) { return rep.write_nopointer_data(fp); }
+
+  template <typename INPUT>
+  bool read_nopointer_data(INPUT *fp)   { return rep.read_nopointer_data(fp); }
+};
+
+// We need a global swap as well
+template <class Key, class T, class HashFcn, class EqualKey, class Alloc>
+inline void swap(sparse_hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,
+                 sparse_hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm2) {
+  hm1.swap(hm2);
+}
+
+_END_GOOGLE_NAMESPACE_
+
+#endif /* _SPARSE_HASH_MAP_H_ */
diff --git a/include/sparsehash/sparse_hash_set b/include/sparsehash/sparse_hash_set
new file mode 100644
index 0000000..ae4a97a
--- /dev/null
+++ b/include/sparsehash/sparse_hash_set
@@ -0,0 +1,338 @@
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+//
+// This is just a very thin wrapper over sparsehashtable.h, just
+// like sgi stl's stl_hash_set is a very thin wrapper over
+// stl_hashtable.  The major thing we define is operator[], because
+// we have a concept of a data_type which stl_hashtable doesn't
+// (it only has a key and a value).
+//
+// This is more different from sparse_hash_map than you might think,
+// because all iterators for sets are const (you obviously can't
+// change the key, and for sets there is no value).
+//
+// We adhere mostly to the STL semantics for hash-map.  One important
+// exception is that insert() may invalidate iterators entirely -- STL
+// semantics are that insert() may reorder iterators, but they all
+// still refer to something valid in the hashtable.  Not so for us.
+// Likewise, insert() may invalidate pointers into the hashtable.
+// (Whether insert invalidates iterators and pointers depends on
+// whether it results in a hashtable resize).  On the plus side,
+// delete() doesn't invalidate iterators or pointers at all, or even
+// change the ordering of elements.
+//
+// Here are a few "power user" tips:
+//
+//    1) set_deleted_key():
+//         Unlike STL's hash_map, if you want to use erase() you
+//         *must* call set_deleted_key() after construction.
+//
+//    2) resize(0):
+//         When an item is deleted, its memory isn't freed right
+//         away.  This allows you to iterate over a hashtable,
+//         and call erase(), without invalidating the iterator.
+//         To force the memory to be freed, call resize(0).
+//         For tr1 compatibility, this can also be called as rehash(0).
+//
+//    3) min_load_factor(0.0)
+//         Setting the minimum load factor to 0.0 guarantees that
+//         the hash table will never shrink.
+//
+// Roughly speaking:
+//   (1) dense_hash_set: fastest, uses the most memory unless entries are small
+//   (2) sparse_hash_set: slowest, uses the least memory
+//   (3) hash_set / unordered_set (STL): in the middle
+//
+// Typically I use sparse_hash_set when I care about space and/or when
+// I need to save the hashtable on disk.  I use hash_set otherwise.  I
+// don't personally use dense_hash_set ever; some people use it for
+// small sets with lots of lookups.
+//
+// - dense_hash_set has, typically, about 78% memory overhead (if your
+//   data takes up X bytes, the hash_set uses .78X more bytes in overhead).
+// - sparse_hash_set has about 4 bits overhead per entry.
+// - sparse_hash_set can be 3-7 times slower than the others for lookup and,
+//   especially, inserts.  See time_hash_map.cc for details.
+//
+// See /usr/(local/)?doc/sparsehash-*/sparse_hash_set.html
+// for information about how to use this class.
+
+#ifndef _SPARSE_HASH_SET_H_
+#define _SPARSE_HASH_SET_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <algorithm>                       // needed by stl_alloc
+#include <functional>                      // for equal_to<>
+#include <memory>                          // for alloc (which we don't use)
+#include <utility>                         // for pair<>
+#include <sparsehash/internal/libc_allocator_with_realloc.h>
+#include <sparsehash/internal/sparsehashtable.h>      // IWYU pragma: export
+#include HASH_FUN_H                // for hash<>
+
+_START_GOOGLE_NAMESPACE_
+
+template <class Value,
+          class HashFcn = SPARSEHASH_HASH<Value>,   // defined in sparseconfig.h
+          class EqualKey = std::equal_to<Value>,
+          class Alloc = libc_allocator_with_realloc<Value> >
+class sparse_hash_set {
+ private:
+  // Apparently identity is not stl-standard, so we define our own
+  struct Identity {
+    typedef const Value& result_type;
+    const Value& operator()(const Value& v) const { return v; }
+  };
+  struct SetKey {
+    void operator()(Value* value, const Value& new_key) const {
+      *value = new_key;
+    }
+  };
+
+  typedef sparse_hashtable<Value, Value, HashFcn, Identity, SetKey,
+                           EqualKey, Alloc> ht;
+  ht rep;
+
+ public:
+  typedef typename ht::key_type key_type;
+  typedef typename ht::value_type value_type;
+  typedef typename ht::hasher hasher;
+  typedef typename ht::key_equal key_equal;
+  typedef Alloc allocator_type;
+
+  typedef typename ht::size_type size_type;
+  typedef typename ht::difference_type difference_type;
+  typedef typename ht::const_pointer pointer;
+  typedef typename ht::const_pointer const_pointer;
+  typedef typename ht::const_reference reference;
+  typedef typename ht::const_reference const_reference;
+
+  typedef typename ht::const_iterator iterator;
+  typedef typename ht::const_iterator const_iterator;
+  typedef typename ht::const_local_iterator local_iterator;
+  typedef typename ht::const_local_iterator const_local_iterator;
+
+
+  // Iterator functions -- recall all iterators are const
+  iterator begin() const                  { return rep.begin(); }
+  iterator end() const                    { return rep.end(); }
+
+  // These come from tr1's unordered_set. For us, a bucket has 0 or 1 elements.
+  local_iterator begin(size_type i) const { return rep.begin(i); }
+  local_iterator end(size_type i) const   { return rep.end(i); }
+
+
+  // Accessor functions
+  allocator_type get_allocator() const    { return rep.get_allocator(); }
+  hasher hash_funct() const               { return rep.hash_funct(); }
+  hasher hash_function() const            { return hash_funct(); }  // tr1 name
+  key_equal key_eq() const                { return rep.key_eq(); }
+
+
+  // Constructors
+  explicit sparse_hash_set(size_type expected_max_items_in_table = 0,
+                           const hasher& hf = hasher(),
+                           const key_equal& eql = key_equal(),
+                           const allocator_type& alloc = allocator_type())
+      : rep(expected_max_items_in_table, hf, eql, Identity(), SetKey(), alloc) {
+  }
+
+  template <class InputIterator>
+  sparse_hash_set(InputIterator f, InputIterator l,
+                  size_type expected_max_items_in_table = 0,
+                  const hasher& hf = hasher(),
+                  const key_equal& eql = key_equal(),
+                  const allocator_type& alloc = allocator_type())
+      : rep(expected_max_items_in_table, hf, eql, Identity(), SetKey(), alloc) {
+    rep.insert(f, l);
+  }
+  // We use the default copy constructor
+  // We use the default operator=()
+  // We use the default destructor
+
+  void clear()                        { rep.clear(); }
+  void swap(sparse_hash_set& hs)      { rep.swap(hs.rep); }
+
+
+  // Functions concerning size
+  size_type size() const              { return rep.size(); }
+  size_type max_size() const          { return rep.max_size(); }
+  bool empty() const                  { return rep.empty(); }
+  size_type bucket_count() const      { return rep.bucket_count(); }
+  size_type max_bucket_count() const  { return rep.max_bucket_count(); }
+
+  // These are tr1 methods.  bucket() is the bucket the key is or would be in.
+  size_type bucket_size(size_type i) const    { return rep.bucket_size(i); }
+  size_type bucket(const key_type& key) const { return rep.bucket(key); }
+  float load_factor() const {
+    return size() * 1.0f / bucket_count();
+  }
+  float max_load_factor() const {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    return grow;
+  }
+  void max_load_factor(float new_grow) {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    rep.set_resizing_parameters(shrink, new_grow);
+  }
+  // These aren't tr1 methods but perhaps ought to be.
+  float min_load_factor() const {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    return shrink;
+  }
+  void min_load_factor(float new_shrink) {
+    float shrink, grow;
+    rep.get_resizing_parameters(&shrink, &grow);
+    rep.set_resizing_parameters(new_shrink, grow);
+  }
+  // Deprecated; use min_load_factor() or max_load_factor() instead.
+  void set_resizing_parameters(float shrink, float grow) {
+    rep.set_resizing_parameters(shrink, grow);
+  }
+
+  void resize(size_type hint)         { rep.resize(hint); }
+  void rehash(size_type hint)         { resize(hint); }     // the tr1 name
+
+  // Lookup routines
+  iterator find(const key_type& key) const           { return rep.find(key); }
+
+  size_type count(const key_type& key) const         { return rep.count(key); }
+
+  std::pair<iterator, iterator> equal_range(const key_type& key) const {
+    return rep.equal_range(key);
+  }
+
+
+  // Insertion routines
+  std::pair<iterator, bool> insert(const value_type& obj) {
+    std::pair<typename ht::iterator, bool> p = rep.insert(obj);
+    return std::pair<iterator, bool>(p.first, p.second);   // const to non-const
+  }
+  template <class InputIterator> void insert(InputIterator f, InputIterator l) {
+    rep.insert(f, l);
+  }
+  void insert(const_iterator f, const_iterator l) {
+    rep.insert(f, l);
+  }
+  // Required for std::insert_iterator; the passed-in iterator is ignored.
+  iterator insert(iterator, const value_type& obj)   {
+    return insert(obj).first;
+  }
+
+  // Deletion routines
+  // THESE ARE NON-STANDARD!  I make you specify an "impossible" key
+  // value to identify deleted buckets.  You can change the key as
+  // time goes on, or get rid of it entirely to be insert-only.
+  void set_deleted_key(const key_type& key)   { rep.set_deleted_key(key); }
+  void clear_deleted_key()                    { rep.clear_deleted_key(); }
+  key_type deleted_key() const                { return rep.deleted_key(); }
+
+  // These are standard
+  size_type erase(const key_type& key)               { return rep.erase(key); }
+  void erase(iterator it)                            { rep.erase(it); }
+  void erase(iterator f, iterator l)                 { rep.erase(f, l); }
+
+
+  // Comparison
+  bool operator==(const sparse_hash_set& hs) const   { return rep == hs.rep; }
+  bool operator!=(const sparse_hash_set& hs) const   { return rep != hs.rep; }
+
+
+  // I/O -- this is an add-on for writing metainformation to disk
+  //
+  // For maximum flexibility, this does not assume a particular
+  // file type (though it will probably be a FILE *).  We just pass
+  // the fp through to rep.
+
+  // If your keys and values are simple enough, you can pass this
+  // serializer to serialize()/unserialize().  "Simple enough" means
+  // value_type is a POD type that contains no pointers.  Note,
+  // however, we don't try to normalize endianness.
+  typedef typename ht::NopointerSerializer NopointerSerializer;
+
+  // serializer: a class providing operator()(OUTPUT*, const value_type&)
+  //    (writing value_type to OUTPUT).  You can specify a
+  //    NopointerSerializer object if appropriate (see above).
+  // fp: either a FILE*, OR an ostream*/subclass_of_ostream*, OR a
+  //    pointer to a class providing size_t Write(const void*, size_t),
+  //    which writes a buffer into a stream (which fp presumably
+  //    owns) and returns the number of bytes successfully written.
+  //    Note basic_ostream<not_char> is not currently supported.
+  template <typename ValueSerializer, typename OUTPUT>
+  bool serialize(ValueSerializer serializer, OUTPUT* fp) {
+    return rep.serialize(serializer, fp);
+  }
+
+  // serializer: a functor providing operator()(INPUT*, value_type*)
+  //    (reading from INPUT and into value_type).  You can specify a
+  //    NopointerSerializer object if appropriate (see above).
+  // fp: either a FILE*, OR an istream*/subclass_of_istream*, OR a
+  //    pointer to a class providing size_t Read(void*, size_t),
+  //    which reads into a buffer from a stream (which fp presumably
+  //    owns) and returns the number of bytes successfully read.
+  //    Note basic_istream<not_char> is not currently supported.
+  // NOTE: Since value_type is const Key, ValueSerializer
+  // may need to do a const cast in order to fill in the key.
+  // NOTE: if Key is not a POD type, the serializer MUST use
+  // placement-new to initialize its value, rather than a normal
+  // equals-assignment or similar.  (The value_type* passed into
+  // the serializer points to garbage memory.)
+  template <typename ValueSerializer, typename INPUT>
+  bool unserialize(ValueSerializer serializer, INPUT* fp) {
+    return rep.unserialize(serializer, fp);
+  }
+
+  // The four methods below are DEPRECATED.
+  // Use serialize() and unserialize() for new code.
+  template <typename OUTPUT>
+  bool write_metadata(OUTPUT *fp)       { return rep.write_metadata(fp); }
+
+  template <typename INPUT>
+  bool read_metadata(INPUT *fp)         { return rep.read_metadata(fp); }
+
+  template <typename OUTPUT>
+  bool write_nopointer_data(OUTPUT *fp) { return rep.write_nopointer_data(fp); }
+
+  template <typename INPUT>
+  bool read_nopointer_data(INPUT *fp)   { return rep.read_nopointer_data(fp); }
+};
+
+template <class Val, class HashFcn, class EqualKey, class Alloc>
+inline void swap(sparse_hash_set<Val, HashFcn, EqualKey, Alloc>& hs1,
+                 sparse_hash_set<Val, HashFcn, EqualKey, Alloc>& hs2) {
+  hs1.swap(hs2);
+}
+
+_END_GOOGLE_NAMESPACE_
+
+#endif /* _SPARSE_HASH_SET_H_ */
diff --git a/include/sparsehash/sparsetable b/include/sparsehash/sparsetable
new file mode 100644
index 0000000..7bf4759
--- /dev/null
+++ b/include/sparsehash/sparsetable
@@ -0,0 +1,1820 @@
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+//
+//
+// A sparsetable is a random container that implements a sparse array,
+// that is, an array that uses very little memory to store unassigned
+// indices (in this case, between 1-2 bits per unassigned index).  For
+// instance, if you allocate an array of size 5 and assign a[2] = <big
+// struct>, then a[2] will take up a lot of memory but a[0], a[1],
+// a[3], and a[4] will not.  Array elements that have a value are
+// called "assigned".  Array elements that have no value yet, or have
+// had their value cleared using erase() or clear(), are called
+// "unassigned".
+//
+// Unassigned values seem to have the default value of T (see below).
+// Nevertheless, there is a difference between an unassigned index and
+// one explicitly assigned the value of T().  The latter is considered
+// assigned.
+//
+// Access to an array element is constant time, as is insertion and
+// deletion.  Insertion and deletion may be fairly slow, however:
+// because of this container's memory economy, each insert and delete
+// causes a memory reallocation.
+//
+// NOTE: You should not test(), get(), or set() any index that is
+// greater than sparsetable.size().  If you need to do that, call
+// resize() first.
+//
+// --- Template parameters
+// PARAMETER   DESCRIPTION                           DEFAULT
+// T           The value of the array: the type of   --
+//             object that is stored in the array.
+//
+// GROUP_SIZE  How large each "group" in the table   48
+//             is (see below).  Larger values use
+//             a little less memory but cause most
+//             operations to be a little slower
+//
+// Alloc:      Allocator to use to allocate memory.  libc_allocator_with_realloc
+//
+// --- Model of
+// Random Access Container
+//
+// --- Type requirements
+// T must be Copy Constructible. It need not be Assignable.
+//
+// --- Public base classes
+// None.
+//
+// --- Members
+// Type members
+//
+// MEMBER           WHERE DEFINED DESCRIPTION
+// value_type       container     The type of object, T, stored in the array
+// allocator_type   container     Allocator to use
+// pointer          container     Pointer to p
+// const_pointer    container     Const pointer to p
+// reference        container     Reference to t
+// const_reference  container     Const reference to t
+// size_type        container     An unsigned integral type
+// difference_type  container     A signed integral type
+// iterator [*]     container     Iterator used to iterate over a sparsetable
+// const_iterator   container     Const iterator used to iterate over a table
+// reverse_iterator reversible    Iterator used to iterate backwards over
+//                  container     a sparsetable
+// const_reverse_iterator   reversible container   Guess
+// nonempty_iterator [+]           sparsetable     Iterates over assigned
+//                                                 array elements only
+// const_nonempty_iterator         sparsetable     Iterates over assigned
+//                                                 array elements only
+// reverse_nonempty_iterator       sparsetable     Iterates backwards over
+//                                                 assigned array elements only
+// const_reverse_nonempty_iterator sparsetable     Iterates backwards over
+//                                                 assigned array elements only
+//
+// [*] All iterators are const in a sparsetable (though nonempty_iterators
+//     may not be).  Use get() and set() to assign values, not iterators.
+//
+// [+] iterators are random-access iterators.  nonempty_iterators are
+//     bidirectional iterators.
+
+// Iterator members
+// MEMBER              WHERE DEFINED  DESCRIPTION
+//
+// iterator begin()    container      An iterator to the beginning of the table
+// iterator end()      container      An iterator to the end of the table
+// const_iterator      container      A const_iterator pointing to the
+//   begin() const                    beginning of a sparsetable
+// const_iterator      container      A const_iterator pointing to the
+//   end() const                      end of a sparsetable
+//
+// reverse_iterator          reversable     Points to beginning of a reversed
+//   rbegin()                container      sparsetable
+// reverse_iterator          reversable     Points to end of a reversed table
+//   rend()                  container
+// const_reverse_iterator    reversable     Points to beginning of a
+//   rbegin() const          container      reversed sparsetable
+// const_reverse_iterator    reversable     Points to end of a reversed table
+//   rend() const            container
+//
+// nonempty_iterator         sparsetable    Points to first assigned element
+//    begin()                               of a sparsetable
+// nonempty_iterator         sparsetable    Points past last assigned element
+//    end()                                 of a sparsetable
+// const_nonempty_iterator   sparsetable    Points to first assigned element
+//    begin() const                         of a sparsetable
+// const_nonempty_iterator   sparsetable    Points past last assigned element
+//    end() const                           of a sparsetable
+//
+// reverse_nonempty_iterator sparsetable    Points to first assigned element
+//    begin()                               of a reversed sparsetable
+// reverse_nonempty_iterator sparsetable    Points past last assigned element
+//    end()                                 of a reversed sparsetable
+// const_reverse_nonempty_iterator sparsetable    Points to first assigned
+//    begin() const                               elt of a reversed sparsetable
+// const_reverse_nonempty_iterator sparsetable    Points past last assigned
+//    end() const                                 elt of a reversed sparsetable
+//
+//
+// Other members
+// MEMBER                      WHERE DEFINED  DESCRIPTION
+// sparsetable()               sparsetable    A table of size 0; must resize()
+//                                            before using.
+// sparsetable(size_type size) sparsetable    A table of size size.  All
+//                                            indices are unassigned.
+// sparsetable(
+//    const sparsetable &tbl)  sparsetable    Copy constructor
+// ~sparsetable()              sparsetable    The destructor
+// sparsetable &operator=(     sparsetable    The assignment operator
+//    const sparsetable &tbl)
+//
+// void resize(size_type size) sparsetable    Grow or shrink a table to
+//                                            have size indices [*]
+//
+// void swap(sparsetable &x)   sparsetable    Swap two sparsetables
+// void swap(sparsetable &x,   sparsetable    Swap two sparsetables
+//           sparsetable &y)                  (global, not member, function)
+//
+// size_type size() const      sparsetable    Number of "buckets" in the table
+// size_type max_size() const  sparsetable    Max allowed size of a sparsetable
+// bool empty() const          sparsetable    true if size() == 0
+// size_type num_nonempty() const  sparsetable  Number of assigned "buckets"
+//
+// const_reference get(        sparsetable    Value at index i, or default
+//    size_type i) const                      value if i is unassigned
+// const_reference operator[]( sparsetable    Identical to get(i) [+]
+//    difference_type i) const
+// reference set(size_type i,  sparsetable    Set element at index i to
+//    const_reference val)                    be a copy of val
+// bool test(size_type i)      sparsetable    True if element at index i
+//    const                                   has been assigned to
+// bool test(iterator pos)     sparsetable    True if element pointed to
+//    const                                   by pos has been assigned to
+// void erase(iterator pos)    sparsetable    Set element pointed to by
+//                                            pos to be unassigned [!]
+// void erase(size_type i)     sparsetable    Set element i to be unassigned
+// void erase(iterator start,  sparsetable    Erases all elements between
+//            iterator end)                   start and end
+// void clear()                sparsetable    Erases all elements in the table
+//
+// I/O versions exist for both FILE* and for File* (Google2-style files):
+// bool write_metadata(FILE *fp) sparsetable  Writes a sparsetable to the
+// bool write_metadata(File *fp)              given file.  true if write
+//                                            completes successfully
+// bool read_metadata(FILE *fp) sparsetable   Replaces sparsetable with
+// bool read_metadata(File *fp)               version read from fp.  true
+//                                            if read completes sucessfully
+// bool write_nopointer_data(FILE *fp)        Read/write the data stored in
+// bool read_nopointer_data(FILE*fp)          the table, if it's simple
+//
+// bool operator==(            forward        Tests two tables for equality.
+//    const sparsetable &t1,   container      This is a global function,
+//    const sparsetable &t2)                  not a member function.
+// bool operator<(             forward        Lexicographical comparison.
+//    const sparsetable &t1,   container      This is a global function,
+//    const sparsetable &t2)                  not a member function.
+//
+// [*] If you shrink a sparsetable using resize(), assigned elements
+// past the end of the table are removed using erase().  If you grow
+// a sparsetable, new unassigned indices are created.
+//
+// [+] Note that operator[] returns a const reference.  You must use
+// set() to change the value of a table element.
+//
+// [!] Unassignment also calls the destructor.
+//
+// Iterators are invalidated whenever an item is inserted or
+// deleted (ie set() or erase() is used) or when the size of
+// the table changes (ie resize() or clear() is used).
+//
+// See doc/sparsetable.html for more information about how to use this class.
+
+// Note: this uses STL style for naming, rather than Google naming.
+// That's because this is an STL-y container
+
+#ifndef UTIL_GTL_SPARSETABLE_H_
+#define UTIL_GTL_SPARSETABLE_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <stdlib.h>             // for malloc/free
+#include <stdio.h>              // to read/write tables
+#include <string.h>             // for memcpy
+#ifdef HAVE_STDINT_H
+#include <stdint.h>         // the normal place uint16_t is defined
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>      // the normal place u_int16_t is defined
+#endif
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>       // a third place for uint16_t or u_int16_t
+#endif
+#include <assert.h>             // for bounds checking
+#include <iterator>             // to define reverse_iterator for me
+#include <algorithm>            // equal, lexicographical_compare, swap,...
+#include <memory>               // uninitialized_copy, uninitialized_fill
+#include <vector>               // a sparsetable is a vector of groups
+#include <sparsehash/type_traits.h>
+#include <sparsehash/internal/hashtable-common.h>
+#include <sparsehash/internal/libc_allocator_with_realloc.h>
+
+// A lot of work to get a type that's guaranteed to be 16 bits...
+#ifndef HAVE_U_INT16_T
+# if defined HAVE_UINT16_T
+    typedef uint16_t u_int16_t;    // true on solaris, possibly other C99 libc's
+# elif defined HAVE___UINT16
+    typedef __int16 int16_t;       // true on vc++7
+    typedef unsigned __int16 u_int16_t;
+# else
+    // Cannot find a 16-bit integer type.  Hoping for the best with "short"...
+    typedef short int int16_t;
+    typedef unsigned short int u_int16_t;
+# endif
+#endif
+
+_START_GOOGLE_NAMESPACE_
+
+namespace base {   // just to make google->opensource transition easier
+using GOOGLE_NAMESPACE::true_type;
+using GOOGLE_NAMESPACE::false_type;
+using GOOGLE_NAMESPACE::integral_constant;
+using GOOGLE_NAMESPACE::has_trivial_copy;
+using GOOGLE_NAMESPACE::has_trivial_destructor;
+using GOOGLE_NAMESPACE::is_same;
+}
+
+
+// The smaller this is, the faster lookup is (because the group bitmap is
+// smaller) and the faster insert is, because there's less to move.
+// On the other hand, there are more groups.  Since group::size_type is
+// a short, this number should be of the form 32*x + 16 to avoid waste.
+static const u_int16_t DEFAULT_SPARSEGROUP_SIZE = 48;   // fits in 1.5 words
+
+
+// Our iterator as simple as iterators can be: basically it's just
+// the index into our table.  Dereference, the only complicated
+// thing, we punt to the table class.  This just goes to show how
+// much machinery STL requires to do even the most trivial tasks.
+//
+// A NOTE ON ASSIGNING:
+// A sparse table does not actually allocate memory for entries
+// that are not filled.  Because of this, it becomes complicated
+// to have a non-const iterator: we don't know, if the iterator points
+// to a not-filled bucket, whether you plan to fill it with something
+// or whether you plan to read its value (in which case you'll get
+// the default bucket value).  Therefore, while we can define const
+// operations in a pretty 'normal' way, for non-const operations, we
+// define something that returns a helper object with operator= and
+// operator& that allocate a bucket lazily.  We use this for table[]
+// and also for regular table iterators.
+
+template <class tabletype>
+class table_element_adaptor {
+ public:
+  typedef typename tabletype::value_type value_type;
+  typedef typename tabletype::size_type size_type;
+  typedef typename tabletype::reference reference;
+  typedef typename tabletype::pointer pointer;
+
+  table_element_adaptor(tabletype *tbl, size_type p)
+    : table(tbl), pos(p) { }
+  table_element_adaptor& operator= (const value_type &val) {
+    table->set(pos, val);
+    return *this;
+  }
+  operator value_type() { return table->get(pos); }   // we look like a value
+  pointer operator& () { return &table->mutating_get(pos); }
+
+ private:
+  tabletype* table;
+  size_type pos;
+};
+
+// Our iterator as simple as iterators can be: basically it's just
+// the index into our table.  Dereference, the only complicated
+// thing, we punt to the table class.  This just goes to show how
+// much machinery STL requires to do even the most trivial tasks.
+//
+// By templatizing over tabletype, we have one iterator type which
+// we can use for both sparsetables and sparsebins.  In fact it
+// works on any class that allows size() and operator[] (eg vector),
+// as long as it does the standard STL typedefs too (eg value_type).
+
+template <class tabletype>
+class table_iterator {
+ public:
+  typedef table_iterator iterator;
+
+  typedef std::random_access_iterator_tag iterator_category;
+  typedef typename tabletype::value_type value_type;
+  typedef typename tabletype::difference_type difference_type;
+  typedef typename tabletype::size_type size_type;
+  typedef table_element_adaptor<tabletype> reference;
+  typedef table_element_adaptor<tabletype>* pointer;
+
+  // The "real" constructor
+  table_iterator(tabletype *tbl, size_type p)
+    : table(tbl), pos(p) { }
+  // The default constructor, used when I define vars of type table::iterator
+  table_iterator() : table(NULL), pos(0) { }
+  // The copy constructor, for when I say table::iterator foo = tbl.begin()
+  // The default destructor is fine; we don't define one
+  // The default operator= is fine; we don't define one
+
+  // The main thing our iterator does is dereference.  If the table entry
+  // we point to is empty, we return the default value type.
+  // This is the big different function from the const iterator.
+  reference operator*()              {
+    return table_element_adaptor<tabletype>(table, pos);
+  }
+  pointer operator->()               { return &(operator*()); }
+
+  // Helper function to assert things are ok; eg pos is still in range
+  void check() const {
+    assert(table);
+    assert(pos <= table->size());
+  }
+
+  // Arithmetic: we just do arithmetic on pos.  We don't even need to
+  // do bounds checking, since STL doesn't consider that its job.  :-)
+  iterator& operator+=(size_type t) { pos += t; check(); return *this; }
+  iterator& operator-=(size_type t) { pos -= t; check(); return *this; }
+  iterator& operator++()            { ++pos; check(); return *this; }
+  iterator& operator--()            { --pos; check(); return *this; }
+  iterator operator++(int)          { iterator tmp(*this);     // for x++
+                                      ++pos; check(); return tmp; }
+  iterator operator--(int)          { iterator tmp(*this);     // for x--
+                                      --pos; check(); return tmp; }
+  iterator operator+(difference_type i) const  { iterator tmp(*this);
+                                                 tmp += i; return tmp; }
+  iterator operator-(difference_type i) const  { iterator tmp(*this);
+                                                 tmp -= i; return tmp; }
+  difference_type operator-(iterator it) const {      // for "x = it2 - it"
+    assert(table == it.table);
+    return pos - it.pos;
+  }
+  reference operator[](difference_type n) const {
+    return *(*this + n);            // simple though not totally efficient
+  }
+
+  // Comparisons.
+  bool operator==(const iterator& it) const {
+    return table == it.table && pos == it.pos;
+  }
+  bool operator<(const iterator& it) const {
+    assert(table == it.table);              // life is bad bad bad otherwise
+    return pos < it.pos;
+  }
+  bool operator!=(const iterator& it) const { return !(*this == it); }
+  bool operator<=(const iterator& it) const { return !(it < *this); }
+  bool operator>(const iterator& it) const { return it < *this; }
+  bool operator>=(const iterator& it) const { return !(*this < it); }
+
+  // Here's the info we actually need to be an iterator
+  tabletype *table;              // so we can dereference and bounds-check
+  size_type pos;                 // index into the table
+};
+
+// support for "3 + iterator" has to be defined outside the class, alas
+template<class T>
+table_iterator<T> operator+(typename table_iterator<T>::difference_type i,
+                            table_iterator<T> it) {
+  return it + i;               // so people can say it2 = 3 + it
+}
+
+template <class tabletype>
+class const_table_iterator {
+ public:
+  typedef table_iterator<tabletype> iterator;
+  typedef const_table_iterator const_iterator;
+
+  typedef std::random_access_iterator_tag iterator_category;
+  typedef typename tabletype::value_type value_type;
+  typedef typename tabletype::difference_type difference_type;
+  typedef typename tabletype::size_type size_type;
+  typedef typename tabletype::const_reference reference;  // we're const-only
+  typedef typename tabletype::const_pointer pointer;
+
+  // The "real" constructor
+  const_table_iterator(const tabletype *tbl, size_type p)
+    : table(tbl), pos(p) { }
+  // The default constructor, used when I define vars of type table::iterator
+  const_table_iterator() : table(NULL), pos(0) { }
+  // The copy constructor, for when I say table::iterator foo = tbl.begin()
+  // Also converts normal iterators to const iterators
+  const_table_iterator(const iterator &from)
+    : table(from.table), pos(from.pos) { }
+  // The default destructor is fine; we don't define one
+  // The default operator= is fine; we don't define one
+
+  // The main thing our iterator does is dereference.  If the table entry
+  // we point to is empty, we return the default value type.
+  reference operator*() const       { return (*table)[pos]; }
+  pointer operator->() const        { return &(operator*()); }
+
+  // Helper function to assert things are ok; eg pos is still in range
+  void check() const {
+    assert(table);
+    assert(pos <= table->size());
+  }
+
+  // Arithmetic: we just do arithmetic on pos.  We don't even need to
+  // do bounds checking, since STL doesn't consider that its job.  :-)
+  const_iterator& operator+=(size_type t) { pos += t; check(); return *this; }
+  const_iterator& operator-=(size_type t) { pos -= t; check(); return *this; }
+  const_iterator& operator++()            { ++pos; check(); return *this; }
+  const_iterator& operator--()            { --pos; check(); return *this; }
+  const_iterator operator++(int)          { const_iterator tmp(*this); // for x++
+                                            ++pos; check(); return tmp; }
+  const_iterator operator--(int)          { const_iterator tmp(*this); // for x--
+                                            --pos; check(); return tmp; }
+  const_iterator operator+(difference_type i) const  { const_iterator tmp(*this);
+                                                       tmp += i; return tmp; }
+  const_iterator operator-(difference_type i) const  { const_iterator tmp(*this);
+                                                       tmp -= i; return tmp; }
+  difference_type operator-(const_iterator it) const {   // for "x = it2 - it"
+    assert(table == it.table);
+    return pos - it.pos;
+  }
+  reference operator[](difference_type n) const {
+    return *(*this + n);            // simple though not totally efficient
+  }
+
+  // Comparisons.
+  bool operator==(const const_iterator& it) const {
+    return table == it.table && pos == it.pos;
+  }
+  bool operator<(const const_iterator& it) const {
+    assert(table == it.table);              // life is bad bad bad otherwise
+    return pos < it.pos;
+  }
+  bool operator!=(const const_iterator& it) const { return !(*this == it); }
+  bool operator<=(const const_iterator& it) const { return !(it < *this); }
+  bool operator>(const const_iterator& it) const { return it < *this; }
+  bool operator>=(const const_iterator& it) const { return !(*this < it); }
+
+  // Here's the info we actually need to be an iterator
+  const tabletype *table;        // so we can dereference and bounds-check
+  size_type pos;                 // index into the table
+};
+
+// support for "3 + iterator" has to be defined outside the class, alas
+template<class T>
+const_table_iterator<T> operator+(typename
+                                  const_table_iterator<T>::difference_type i,
+                                  const_table_iterator<T> it) {
+  return it + i;               // so people can say it2 = 3 + it
+}
+
+
+// ---------------------------------------------------------------------------
+
+
+/*
+// This is a 2-D iterator.  You specify a begin and end over a list
+// of *containers*.  We iterate over each container by iterating over
+// it.  It's actually simple:
+// VECTOR.begin() VECTOR[0].begin()  --------> VECTOR[0].end() ---,
+//     |          ________________________________________________/
+//     |          \_> VECTOR[1].begin()  -------->  VECTOR[1].end() -,
+//     |          ___________________________________________________/
+//     v          \_> ......
+// VECTOR.end()
+//
+// It's impossible to do random access on one of these things in constant
+// time, so it's just a bidirectional iterator.
+//
+// Unfortunately, because we need to use this for a non-empty iterator,
+// we use nonempty_begin() and nonempty_end() instead of begin() and end()
+// (though only going across, not down).
+*/
+
+#define TWOD_BEGIN_      nonempty_begin
+#define TWOD_END_        nonempty_end
+#define TWOD_ITER_       nonempty_iterator
+#define TWOD_CONST_ITER_ const_nonempty_iterator
+
+template <class containertype>
+class two_d_iterator {
+ public:
+  typedef two_d_iterator iterator;
+
+  typedef std::bidirectional_iterator_tag iterator_category;
+  // apparently some versions of VC++ have trouble with two ::'s in a typename
+  typedef typename containertype::value_type _tmp_vt;
+  typedef typename _tmp_vt::value_type value_type;
+  typedef typename _tmp_vt::difference_type difference_type;
+  typedef typename _tmp_vt::reference reference;
+  typedef typename _tmp_vt::pointer pointer;
+
+  // The "real" constructor.  begin and end specify how many rows we have
+  // (in the diagram above); we always iterate over each row completely.
+  two_d_iterator(typename containertype::iterator begin,
+                 typename containertype::iterator end,
+                 typename containertype::iterator curr)
+    : row_begin(begin), row_end(end), row_current(curr), col_current() {
+    if ( row_current != row_end ) {
+      col_current = row_current->TWOD_BEGIN_();
+      advance_past_end();                 // in case cur->begin() == cur->end()
+    }
+  }
+  // If you want to start at an arbitrary place, you can, I guess
+  two_d_iterator(typename containertype::iterator begin,
+                 typename containertype::iterator end,
+                 typename containertype::iterator curr,
+                 typename containertype::value_type::TWOD_ITER_ col)
+    : row_begin(begin), row_end(end), row_current(curr), col_current(col) {
+    advance_past_end();                 // in case cur->begin() == cur->end()
+  }
+  // The default constructor, used when I define vars of type table::iterator
+  two_d_iterator() : row_begin(), row_end(), row_current(), col_current() { }
+  // The default destructor is fine; we don't define one
+  // The default operator= is fine; we don't define one
+
+  // Happy dereferencer
+  reference operator*() const    { return *col_current; }
+  pointer operator->() const     { return &(operator*()); }
+
+  // Arithmetic: we just do arithmetic on pos.  We don't even need to
+  // do bounds checking, since STL doesn't consider that its job.  :-)
+  // NOTE: this is not amortized constant time!  What do we do about it?
+  void advance_past_end() {          // used when col_current points to end()
+    while ( col_current == row_current->TWOD_END_() ) {  // end of current row
+      ++row_current;                                // go to beginning of next
+      if ( row_current != row_end )                 // col is irrelevant at end
+        col_current = row_current->TWOD_BEGIN_();
+      else
+        break;                                      // don't go past row_end
+    }
+  }
+
+  iterator& operator++() {
+    assert(row_current != row_end);                 // how to ++ from there?
+    ++col_current;
+    advance_past_end();                 // in case col_current is at end()
+    return *this;
+  }
+  iterator& operator--() {
+    while ( row_current == row_end ||
+            col_current == row_current->TWOD_BEGIN_() ) {
+      assert(row_current != row_begin);
+      --row_current;
+      col_current = row_current->TWOD_END_();             // this is 1 too far
+    }
+    --col_current;
+    return *this;
+  }
+  iterator operator++(int)       { iterator tmp(*this); ++*this; return tmp; }
+  iterator operator--(int)       { iterator tmp(*this); --*this; return tmp; }
+
+
+  // Comparisons.
+  bool operator==(const iterator& it) const {
+    return ( row_begin == it.row_begin &&
+             row_end == it.row_end &&
+             row_current == it.row_current &&
+             (row_current == row_end || col_current == it.col_current) );
+  }
+  bool operator!=(const iterator& it) const { return !(*this == it); }
+
+
+  // Here's the info we actually need to be an iterator
+  // These need to be public so we convert from iterator to const_iterator
+  typename containertype::iterator row_begin, row_end, row_current;
+  typename containertype::value_type::TWOD_ITER_ col_current;
+};
+
+// The same thing again, but this time const.  :-(
+template <class containertype>
+class const_two_d_iterator {
+ public:
+  typedef const_two_d_iterator iterator;
+
+  typedef std::bidirectional_iterator_tag iterator_category;
+  // apparently some versions of VC++ have trouble with two ::'s in a typename
+  typedef typename containertype::value_type _tmp_vt;
+  typedef typename _tmp_vt::value_type value_type;
+  typedef typename _tmp_vt::difference_type difference_type;
+  typedef typename _tmp_vt::const_reference reference;
+  typedef typename _tmp_vt::const_pointer pointer;
+
+  const_two_d_iterator(typename containertype::const_iterator begin,
+                       typename containertype::const_iterator end,
+                       typename containertype::const_iterator curr)
+    : row_begin(begin), row_end(end), row_current(curr), col_current() {
+    if ( curr != end ) {
+      col_current = curr->TWOD_BEGIN_();
+      advance_past_end();                 // in case cur->begin() == cur->end()
+    }
+  }
+  const_two_d_iterator(typename containertype::const_iterator begin,
+                       typename containertype::const_iterator end,
+                       typename containertype::const_iterator curr,
+                       typename containertype::value_type::TWOD_CONST_ITER_ col)
+    : row_begin(begin), row_end(end), row_current(curr), col_current(col) {
+    advance_past_end();                 // in case cur->begin() == cur->end()
+  }
+  const_two_d_iterator()
+    : row_begin(), row_end(), row_current(), col_current() {
+  }
+  // Need this explicitly so we can convert normal iterators to const iterators
+  const_two_d_iterator(const two_d_iterator<containertype>& it) :
+    row_begin(it.row_begin), row_end(it.row_end), row_current(it.row_current),
+    col_current(it.col_current) { }
+
+  typename containertype::const_iterator row_begin, row_end, row_current;
+  typename containertype::value_type::TWOD_CONST_ITER_ col_current;
+
+
+  // EVERYTHING FROM HERE DOWN IS THE SAME AS THE NON-CONST ITERATOR
+  reference operator*() const    { return *col_current; }
+  pointer operator->() const     { return &(operator*()); }
+
+  void advance_past_end() {          // used when col_current points to end()
+    while ( col_current == row_current->TWOD_END_() ) {  // end of current row
+      ++row_current;                                // go to beginning of next
+      if ( row_current != row_end )                 // col is irrelevant at end
+        col_current = row_current->TWOD_BEGIN_();
+      else
+        break;                                      // don't go past row_end
+    }
+  }
+  iterator& operator++() {
+    assert(row_current != row_end);                 // how to ++ from there?
+    ++col_current;
+    advance_past_end();                 // in case col_current is at end()
+    return *this;
+  }
+  iterator& operator--() {
+    while ( row_current == row_end ||
+            col_current == row_current->TWOD_BEGIN_() ) {
+      assert(row_current != row_begin);
+      --row_current;
+      col_current = row_current->TWOD_END_();             // this is 1 too far
+    }
+    --col_current;
+    return *this;
+  }
+  iterator operator++(int)       { iterator tmp(*this); ++*this; return tmp; }
+  iterator operator--(int)       { iterator tmp(*this); --*this; return tmp; }
+
+  bool operator==(const iterator& it) const {
+    return ( row_begin == it.row_begin &&
+             row_end == it.row_end &&
+             row_current == it.row_current &&
+             (row_current == row_end || col_current == it.col_current) );
+  }
+  bool operator!=(const iterator& it) const { return !(*this == it); }
+};
+
+// We provide yet another version, to be as frugal with memory as
+// possible.  This one frees each block of memory as it finishes
+// iterating over it.  By the end, the entire table is freed.
+// For understandable reasons, you can only iterate over it once,
+// which is why it's an input iterator
+template <class containertype>
+class destructive_two_d_iterator {
+ public:
+  typedef destructive_two_d_iterator iterator;
+
+  typedef std::input_iterator_tag iterator_category;
+  // apparently some versions of VC++ have trouble with two ::'s in a typename
+  typedef typename containertype::value_type _tmp_vt;
+  typedef typename _tmp_vt::value_type value_type;
+  typedef typename _tmp_vt::difference_type difference_type;
+  typedef typename _tmp_vt::reference reference;
+  typedef typename _tmp_vt::pointer pointer;
+
+  destructive_two_d_iterator(typename containertype::iterator begin,
+                             typename containertype::iterator end,
+                             typename containertype::iterator curr)
+    : row_begin(begin), row_end(end), row_current(curr), col_current() {
+    if ( curr != end ) {
+      col_current = curr->TWOD_BEGIN_();
+      advance_past_end();                 // in case cur->begin() == cur->end()
+    }
+  }
+  destructive_two_d_iterator(typename containertype::iterator begin,
+                             typename containertype::iterator end,
+                             typename containertype::iterator curr,
+                             typename containertype::value_type::TWOD_ITER_ col)
+    : row_begin(begin), row_end(end), row_current(curr), col_current(col) {
+    advance_past_end();                 // in case cur->begin() == cur->end()
+  }
+  destructive_two_d_iterator()
+    : row_begin(), row_end(), row_current(), col_current() {
+  }
+
+  typename containertype::iterator row_begin, row_end, row_current;
+  typename containertype::value_type::TWOD_ITER_ col_current;
+
+  // This is the part that destroys
+  void advance_past_end() {          // used when col_current points to end()
+    while ( col_current == row_current->TWOD_END_() ) {  // end of current row
+      row_current->clear();                         // the destructive part
+      // It would be nice if we could decrement sparsetable->num_buckets here
+      ++row_current;                                // go to beginning of next
+      if ( row_current != row_end )                 // col is irrelevant at end
+        col_current = row_current->TWOD_BEGIN_();
+      else
+        break;                                      // don't go past row_end
+    }
+  }
+
+  // EVERYTHING FROM HERE DOWN IS THE SAME AS THE REGULAR ITERATOR
+  reference operator*() const    { return *col_current; }
+  pointer operator->() const     { return &(operator*()); }
+
+  iterator& operator++() {
+    assert(row_current != row_end);                 // how to ++ from there?
+    ++col_current;
+    advance_past_end();                 // in case col_current is at end()
+    return *this;
+  }
+  iterator operator++(int)       { iterator tmp(*this); ++*this; return tmp; }
+
+  bool operator==(const iterator& it) const {
+    return ( row_begin == it.row_begin &&
+             row_end == it.row_end &&
+             row_current == it.row_current &&
+             (row_current == row_end || col_current == it.col_current) );
+  }
+  bool operator!=(const iterator& it) const { return !(*this == it); }
+};
+
+#undef TWOD_BEGIN_
+#undef TWOD_END_
+#undef TWOD_ITER_
+#undef TWOD_CONST_ITER_
+
+
+
+
+// SPARSE-TABLE
+// ------------
+// The idea is that a table with (logically) t buckets is divided
+// into t/M *groups* of M buckets each.  (M is a constant set in
+// GROUP_SIZE for efficiency.)  Each group is stored sparsely.
+// Thus, inserting into the table causes some array to grow, which is
+// slow but still constant time.  Lookup involves doing a
+// logical-position-to-sparse-position lookup, which is also slow but
+// constant time.  The larger M is, the slower these operations are
+// but the less overhead (slightly).
+//
+// To store the sparse array, we store a bitmap B, where B[i] = 1 iff
+// bucket i is non-empty.  Then to look up bucket i we really look up
+// array[# of 1s before i in B].  This is constant time for fixed M.
+//
+// Terminology: the position of an item in the overall table (from
+// 1 .. t) is called its "location."  The logical position in a group
+// (from 1 .. M ) is called its "position."  The actual location in
+// the array (from 1 .. # of non-empty buckets in the group) is
+// called its "offset."
+
+template <class T, u_int16_t GROUP_SIZE, class Alloc>
+class sparsegroup {
+ private:
+  typedef typename Alloc::template rebind<T>::other value_alloc_type;
+
+ public:
+  // Basic types
+  typedef T value_type;
+  typedef Alloc allocator_type;
+  typedef typename value_alloc_type::reference reference;
+  typedef typename value_alloc_type::const_reference const_reference;
+  typedef typename value_alloc_type::pointer pointer;
+  typedef typename value_alloc_type::const_pointer const_pointer;
+
+  typedef table_iterator<sparsegroup<T, GROUP_SIZE, Alloc> > iterator;
+  typedef const_table_iterator<sparsegroup<T, GROUP_SIZE, Alloc> >
+      const_iterator;
+  typedef table_element_adaptor<sparsegroup<T, GROUP_SIZE, Alloc> >
+      element_adaptor;
+  typedef u_int16_t size_type;                  // max # of buckets
+  typedef int16_t difference_type;
+  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+  typedef std::reverse_iterator<iterator> reverse_iterator;   // from iterator.h
+
+  // These are our special iterators, that go over non-empty buckets in a
+  // group.  These aren't const-only because you can change non-empty bcks.
+  typedef pointer nonempty_iterator;
+  typedef const_pointer const_nonempty_iterator;
+  typedef std::reverse_iterator<nonempty_iterator> reverse_nonempty_iterator;
+  typedef std::reverse_iterator<const_nonempty_iterator> const_reverse_nonempty_iterator;
+
+  // Iterator functions
+  iterator begin()                      { return iterator(this, 0); }
+  const_iterator begin() const          { return const_iterator(this, 0); }
+  iterator end()                        { return iterator(this, size()); }
+  const_iterator end() const            { return const_iterator(this, size()); }
+  reverse_iterator rbegin()             { return reverse_iterator(end()); }
+  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
+  reverse_iterator rend()               { return reverse_iterator(begin()); }
+  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
+
+  // We'll have versions for our special non-empty iterator too
+  nonempty_iterator nonempty_begin()             { return group; }
+  const_nonempty_iterator nonempty_begin() const { return group; }
+  nonempty_iterator nonempty_end() {
+    return group + settings.num_buckets;
+  }
+  const_nonempty_iterator nonempty_end() const {
+    return group + settings.num_buckets;
+  }
+  reverse_nonempty_iterator nonempty_rbegin() {
+    return reverse_nonempty_iterator(nonempty_end());
+  }
+  const_reverse_nonempty_iterator nonempty_rbegin() const {
+    return const_reverse_nonempty_iterator(nonempty_end());
+  }
+  reverse_nonempty_iterator nonempty_rend() {
+    return reverse_nonempty_iterator(nonempty_begin());
+  }
+  const_reverse_nonempty_iterator nonempty_rend() const {
+    return const_reverse_nonempty_iterator(nonempty_begin());
+  }
+
+
+  // This gives us the "default" value to return for an empty bucket.
+  // We just use the default constructor on T, the template type
+  const_reference default_value() const {
+    static value_type defaultval = value_type();
+    return defaultval;
+  }
+
+
+ private:
+  // We need to do all this bit manipulation, of course.  ick
+  static size_type charbit(size_type i)  { return i >> 3; }
+  static size_type modbit(size_type i)   { return 1 << (i&7); }
+  int bmtest(size_type i) const    { return bitmap[charbit(i)] & modbit(i); }
+  void bmset(size_type i)          { bitmap[charbit(i)] |= modbit(i); }
+  void bmclear(size_type i)        { bitmap[charbit(i)] &= ~modbit(i); }
+
+  pointer allocate_group(size_type n) {
+    pointer retval = settings.allocate(n);
+    if (retval == NULL) {
+      // We really should use PRIuS here, but I don't want to have to add
+      // a whole new configure option, with concomitant macro namespace
+      // pollution, just to print this (unlikely) error message.  So I cast.
+      fprintf(stderr, "sparsehash FATAL ERROR: failed to allocate %lu groups\n",
+              static_cast<unsigned long>(n));
+      exit(1);
+    }
+    return retval;
+  }
+
+  void free_group() {
+    if (!group)  return;
+    pointer end_it = group + settings.num_buckets;
+    for (pointer p = group; p != end_it; ++p)
+      p->~value_type();
+    settings.deallocate(group, settings.num_buckets);
+    group = NULL;
+  }
+
+  static size_type bits_in_char(unsigned char c) {
+    // We could make these ints.  The tradeoff is size (eg does it overwhelm
+    // the cache?) vs efficiency in referencing sub-word-sized array elements.
+    static const char bits_in[256] = {
+      0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+      4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
+    };
+    return bits_in[c];
+  }
+
+ public:                         // get_iter() in sparsetable needs it
+  // We need a small function that tells us how many set bits there are
+  // in positions 0..i-1 of the bitmap.  It uses a big table.
+  // We make it static so templates don't allocate lots of these tables.
+  // There are lots of ways to do this calculation (called 'popcount').
+  // The 8-bit table lookup is one of the fastest, though this
+  // implementation suffers from not doing any loop unrolling.  See, eg,
+  //   http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html
+  //   http://gurmeetsingh.wordpress.com/2008/08/05/fast-bit-counting-routines/
+  static size_type pos_to_offset(const unsigned char *bm, size_type pos) {
+    size_type retval = 0;
+
+    // [Note: condition pos > 8 is an optimization; convince yourself we
+    // give exactly the same result as if we had pos >= 8 here instead.]
+    for ( ; pos > 8; pos -= 8 )                   // bm[0..pos/8-1]
+      retval += bits_in_char(*bm++);              // chars we want *all* bits in
+    return retval + bits_in_char(*bm & ((1 << pos)-1));    // char including pos
+  }
+
+  size_type pos_to_offset(size_type pos) const {  // not static but still const
+    return pos_to_offset(bitmap, pos);
+  }
+
+  // Returns the (logical) position in the bm[] array, i, such that
+  // bm[i] is the offset-th set bit in the array.  It is the inverse
+  // of pos_to_offset.  get_pos() uses this function to find the index
+  // of an nonempty_iterator in the table.  Bit-twiddling from
+  // http://hackersdelight.org/basics.pdf
+  static size_type offset_to_pos(const unsigned char *bm, size_type offset) {
+    size_type retval = 0;
+    // This is sizeof(this->bitmap).
+    const size_type group_size = (GROUP_SIZE-1) / 8 + 1;
+    for (size_type i = 0; i < group_size; i++) {   // forward scan
+      const size_type pop_count = bits_in_char(*bm);
+      if (pop_count > offset) {
+        unsigned char last_bm = *bm;
+        for (; offset > 0; offset--) {
+          last_bm &= (last_bm-1);  // remove right-most set bit
+        }
+        // Clear all bits to the left of the rightmost bit (the &),
+        // and then clear the rightmost bit but set all bits to the
+        // right of it (the -1).
+        last_bm = (last_bm & -last_bm) - 1;
+        retval += bits_in_char(last_bm);
+        return retval;
+      }
+      offset -= pop_count;
+      retval += 8;
+      bm++;
+    }
+    return retval;
+  }
+
+  size_type offset_to_pos(size_type offset) const {
+    return offset_to_pos(bitmap, offset);
+  }
+
+
+ public:
+  // Constructors -- default and copy -- and destructor
+  explicit sparsegroup(allocator_type& a) :
+      group(0), settings(alloc_impl<value_alloc_type>(a)) {
+    memset(bitmap, 0, sizeof(bitmap));
+  }
+  sparsegroup(const sparsegroup& x) : group(0), settings(x.settings) {
+    if ( settings.num_buckets ) {
+      group = allocate_group(x.settings.num_buckets);
+      std::uninitialized_copy(x.group, x.group + x.settings.num_buckets, group);
+    }
+    memcpy(bitmap, x.bitmap, sizeof(bitmap));
+  }
+  ~sparsegroup() { free_group(); }
+
+  // Operator= is just like the copy constructor, I guess
+  // TODO(austern): Make this exception safe. Handle exceptions in value_type's
+  // copy constructor.
+  sparsegroup &operator=(const sparsegroup& x) {
+    if ( &x == this ) return *this;                    // x = x
+    if ( x.settings.num_buckets == 0 ) {
+      free_group();
+    } else {
+      pointer p = allocate_group(x.settings.num_buckets);
+      std::uninitialized_copy(x.group, x.group + x.settings.num_buckets, p);
+      free_group();
+      group = p;
+    }
+    memcpy(bitmap, x.bitmap, sizeof(bitmap));
+    settings.num_buckets = x.settings.num_buckets;
+    return *this;
+  }
+
+  // Many STL algorithms use swap instead of copy constructors
+  void swap(sparsegroup& x) {
+    std::swap(group, x.group);                // defined in <algorithm>
+    for ( int i = 0; i < sizeof(bitmap) / sizeof(*bitmap); ++i )
+      std::swap(bitmap[i], x.bitmap[i]);      // swap not defined on arrays
+    std::swap(settings.num_buckets, x.settings.num_buckets);
+    // we purposefully don't swap the allocator, which may not be swap-able
+  }
+
+  // It's always nice to be able to clear a table without deallocating it
+  void clear() {
+    free_group();
+    memset(bitmap, 0, sizeof(bitmap));
+    settings.num_buckets = 0;
+  }
+
+  // Functions that tell you about size.  Alas, these aren't so useful
+  // because our table is always fixed size.
+  size_type size() const           { return GROUP_SIZE; }
+  size_type max_size() const       { return GROUP_SIZE; }
+  bool empty() const               { return false; }
+  // We also may want to know how many *used* buckets there are
+  size_type num_nonempty() const   { return settings.num_buckets; }
+
+
+  // get()/set() are explicitly const/non-const.  You can use [] if
+  // you want something that can be either (potentially more expensive).
+  const_reference get(size_type i) const {
+    if ( bmtest(i) )           // bucket i is occupied
+      return group[pos_to_offset(bitmap, i)];
+    else
+      return default_value();  // return the default reference
+  }
+
+  // TODO(csilvers): make protected + friend
+  // This is used by sparse_hashtable to get an element from the table
+  // when we know it exists.
+  const_reference unsafe_get(size_type i) const {
+    assert(bmtest(i));
+    return group[pos_to_offset(bitmap, i)];
+  }
+
+  // TODO(csilvers): make protected + friend
+  reference mutating_get(size_type i) {    // fills bucket i before getting
+    if ( !bmtest(i) )
+      set(i, default_value());
+    return group[pos_to_offset(bitmap, i)];
+  }
+
+  // Syntactic sugar.  It's easy to return a const reference.  To
+  // return a non-const reference, we need to use the assigner adaptor.
+  const_reference operator[](size_type i) const {
+    return get(i);
+  }
+
+  element_adaptor operator[](size_type i) {
+    return element_adaptor(this, i);
+  }
+
+ private:
+  // Create space at group[offset], assuming value_type has trivial
+  // copy constructor and destructor, and the allocator_type is
+  // the default libc_allocator_with_alloc.  (Really, we want it to have
+  // "trivial move", because that's what realloc and memmove both do.
+  // But there's no way to capture that using type_traits, so we
+  // pretend that move(x, y) is equivalent to "x.~T(); new(x) T(y);"
+  // which is pretty much correct, if a bit conservative.)
+  void set_aux(size_type offset, base::true_type) {
+    group = settings.realloc_or_die(group, settings.num_buckets+1);
+    // This is equivalent to memmove(), but faster on my Intel P4,
+    // at least with gcc4.1 -O2 / glibc 2.3.6.
+    for (size_type i = settings.num_buckets; i > offset; --i)
+      memcpy(group + i, group + i-1, sizeof(*group));
+  }
+
+  // Create space at group[offset], without special assumptions about value_type
+  // and allocator_type.
+  void set_aux(size_type offset, base::false_type) {
+    // This is valid because 0 <= offset <= num_buckets
+    pointer p = allocate_group(settings.num_buckets + 1);
+    std::uninitialized_copy(group, group + offset, p);
+    std::uninitialized_copy(group + offset, group + settings.num_buckets,
+                            p + offset + 1);
+    free_group();
+    group = p;
+  }
+
+ public:
+  // This returns a reference to the inserted item (which is a copy of val).
+  // TODO(austern): Make this exception safe: handle exceptions from
+  // value_type's copy constructor.
+  reference set(size_type i, const_reference val) {
+    size_type offset = pos_to_offset(bitmap, i);  // where we'll find (or insert)
+    if ( bmtest(i) ) {
+      // Delete the old value, which we're replacing with the new one
+      group[offset].~value_type();
+    } else {
+      typedef base::integral_constant<bool,
+          (base::has_trivial_copy<value_type>::value &&
+           base::has_trivial_destructor<value_type>::value &&
+           base::is_same<
+               allocator_type,
+               libc_allocator_with_realloc<value_type> >::value)>
+          realloc_and_memmove_ok; // we pretend mv(x,y) == "x.~T(); new(x) T(y)"
+      set_aux(offset, realloc_and_memmove_ok());
+      ++settings.num_buckets;
+      bmset(i);
+    }
+    // This does the actual inserting.  Since we made the array using
+    // malloc, we use "placement new" to just call the constructor.
+    new(&group[offset]) value_type(val);
+    return group[offset];
+  }
+
+  // We let you see if a bucket is non-empty without retrieving it
+  bool test(size_type i) const {
+    return bmtest(i) != 0;
+  }
+  bool test(iterator pos) const {
+    return bmtest(pos.pos) != 0;
+  }
+
+ private:
+  // Shrink the array, assuming value_type has trivial copy
+  // constructor and destructor, and the allocator_type is the default
+  // libc_allocator_with_alloc.  (Really, we want it to have "trivial
+  // move", because that's what realloc and memmove both do.  But
+  // there's no way to capture that using type_traits, so we pretend
+  // that move(x, y) is equivalent to ""x.~T(); new(x) T(y);"
+  // which is pretty much correct, if a bit conservative.)
+  void erase_aux(size_type offset, base::true_type) {
+    // This isn't technically necessary, since we know we have a
+    // trivial destructor, but is a cheap way to get a bit more safety.
+    group[offset].~value_type();
+    // This is equivalent to memmove(), but faster on my Intel P4,
+    // at lesat with gcc4.1 -O2 / glibc 2.3.6.
+    assert(settings.num_buckets > 0);
+    for (size_type i = offset; i < settings.num_buckets-1; ++i)
+      memcpy(group + i, group + i+1, sizeof(*group));  // hopefully inlined!
+    group = settings.realloc_or_die(group, settings.num_buckets-1);
+  }
+
+  // Shrink the array, without any special assumptions about value_type and
+  // allocator_type.
+  void erase_aux(size_type offset, base::false_type) {
+    // This is valid because 0 <= offset < num_buckets. Note the inequality.
+    pointer p = allocate_group(settings.num_buckets - 1);
+    std::uninitialized_copy(group, group + offset, p);
+    std::uninitialized_copy(group + offset + 1, group + settings.num_buckets,
+                            p + offset);
+    free_group();
+    group = p;
+  }
+
+ public:
+  // This takes the specified elements out of the group.  This is
+  // "undefining", rather than "clearing".
+  // TODO(austern): Make this exception safe: handle exceptions from
+  // value_type's copy constructor.
+  void erase(size_type i) {
+    if ( bmtest(i) ) {                         // trivial to erase empty bucket
+      size_type offset = pos_to_offset(bitmap,i); // where we'll find (or insert)
+      if ( settings.num_buckets == 1 ) {
+        free_group();
+        group = NULL;
+      } else {
+        typedef base::integral_constant<bool,
+            (base::has_trivial_copy<value_type>::value &&
+             base::has_trivial_destructor<value_type>::value &&
+             base::is_same<
+                 allocator_type,
+                 libc_allocator_with_realloc<value_type> >::value)>
+            realloc_and_memmove_ok; // pretend mv(x,y) == "x.~T(); new(x) T(y)"
+        erase_aux(offset, realloc_and_memmove_ok());
+      }
+      --settings.num_buckets;
+      bmclear(i);
+    }
+  }
+
+  void erase(iterator pos) {
+    erase(pos.pos);
+  }
+
+  void erase(iterator start_it, iterator end_it) {
+    // This could be more efficient, but to do so we'd need to make
+    // bmclear() clear a range of indices.  Doesn't seem worth it.
+    for ( ; start_it != end_it; ++start_it )
+      erase(start_it);
+  }
+
+
+  // I/O
+  // We support reading and writing groups to disk.  We don't store
+  // the actual array contents (which we don't know how to store),
+  // just the bitmap and size.  Meant to be used with table I/O.
+
+  template <typename OUTPUT> bool write_metadata(OUTPUT *fp) const {
+    // we explicitly set to u_int16_t
+    assert(sizeof(settings.num_buckets) == 2);
+    if ( !sparsehash_internal::write_bigendian_number(fp, settings.num_buckets,
+                                                      2) )
+      return false;
+    if ( !sparsehash_internal::write_data(fp, bitmap, sizeof(bitmap)) )
+      return false;
+    return true;
+  }
+
+  // Reading destroys the old group contents!  Returns true if all was ok.
+  template <typename INPUT> bool read_metadata(INPUT *fp) {
+    clear();
+    if ( !sparsehash_internal::read_bigendian_number(fp, &settings.num_buckets,
+                                                     2) )
+      return false;
+    if ( !sparsehash_internal::read_data(fp, bitmap, sizeof(bitmap)) )
+      return false;
+    // We'll allocate the space, but we won't fill it: it will be
+    // left as uninitialized raw memory.
+    group = allocate_group(settings.num_buckets);
+    return true;
+  }
+
+  // Again, only meaningful if value_type is a POD.
+  template <typename INPUT> bool read_nopointer_data(INPUT *fp) {
+     for ( nonempty_iterator it = nonempty_begin();
+           it != nonempty_end(); ++it ) {
+       if ( !sparsehash_internal::read_data(fp, &(*it), sizeof(*it)) )
+         return false;
+     }
+     return true;
+  }
+
+  // If your keys and values are simple enough, we can write them
+  // to disk for you.  "simple enough" means POD and no pointers.
+  // However, we don't try to normalize endianness.
+  template <typename OUTPUT> bool write_nopointer_data(OUTPUT *fp) const {
+    for ( const_nonempty_iterator it = nonempty_begin();
+          it != nonempty_end(); ++it ) {
+      if ( !sparsehash_internal::write_data(fp, &(*it), sizeof(*it)) )
+        return false;
+    }
+    return true;
+  }
+
+
+  // Comparisons.  We only need to define == and < -- we get
+  // != > <= >= via relops.h (which we happily included above).
+  // Note the comparisons are pretty arbitrary: we compare
+  // values of the first index that isn't equal (using default
+  // value for empty buckets).
+  bool operator==(const sparsegroup& x) const {
+    return ( settings.num_buckets == x.settings.num_buckets &&
+             memcmp(bitmap, x.bitmap, sizeof(bitmap)) == 0 &&
+             std::equal(begin(), end(), x.begin()) );    // from <algorithm>
+  }
+
+  bool operator<(const sparsegroup& x) const {      // also from <algorithm>
+    return std::lexicographical_compare(begin(), end(), x.begin(), x.end());
+  }
+  bool operator!=(const sparsegroup& x) const { return !(*this == x); }
+  bool operator<=(const sparsegroup& x) const { return !(x < *this); }
+  bool operator>(const sparsegroup& x) const { return x < *this; }
+  bool operator>=(const sparsegroup& x) const { return !(*this < x); }
+
+ private:
+  template <class A>
+  class alloc_impl : public A {
+   public:
+    typedef typename A::pointer pointer;
+    typedef typename A::size_type size_type;
+
+    // Convert a normal allocator to one that has realloc_or_die()
+    alloc_impl(const A& a) : A(a) { }
+
+    // realloc_or_die should only be used when using the default
+    // allocator (libc_allocator_with_realloc).
+    pointer realloc_or_die(pointer /*ptr*/, size_type /*n*/) {
+      fprintf(stderr, "realloc_or_die is only supported for "
+                      "libc_allocator_with_realloc\n");
+      exit(1);
+      return NULL;
+    }
+  };
+
+  // A template specialization of alloc_impl for
+  // libc_allocator_with_realloc that can handle realloc_or_die.
+  template <class A>
+  class alloc_impl<libc_allocator_with_realloc<A> >
+      : public libc_allocator_with_realloc<A> {
+   public:
+    typedef typename libc_allocator_with_realloc<A>::pointer pointer;
+    typedef typename libc_allocator_with_realloc<A>::size_type size_type;
+
+    alloc_impl(const libc_allocator_with_realloc<A>& a)
+        : libc_allocator_with_realloc<A>(a) { }
+
+    pointer realloc_or_die(pointer ptr, size_type n) {
+      pointer retval = this->reallocate(ptr, n);
+      if (retval == NULL) {
+//        fprintf(stderr, "sparsehash: FATAL ERROR: failed to reallocate "
+//                "%lu elements for ptr %p", static_cast<unsigned long>(n), ptr);
+        exit(1);
+      }
+      return retval;
+    }
+  };
+
+  // Package allocator with num_buckets to eliminate memory needed for the
+  // zero-size allocator.
+  // If new fields are added to this class, we should add them to
+  // operator= and swap.
+  class Settings : public alloc_impl<value_alloc_type> {
+   public:
+    Settings(const alloc_impl<value_alloc_type>& a, u_int16_t n = 0)
+        : alloc_impl<value_alloc_type>(a), num_buckets(n) { }
+    Settings(const Settings& s)
+        : alloc_impl<value_alloc_type>(s), num_buckets(s.num_buckets) { }
+
+    u_int16_t num_buckets;                    // limits GROUP_SIZE to 64K
+  };
+
+  // The actual data
+  pointer group;                              // (small) array of T's
+  Settings settings;                          // allocator and num_buckets
+  unsigned char bitmap[(GROUP_SIZE-1)/8 + 1]; // fancy math is so we round up
+};
+
+// We need a global swap as well
+template <class T, u_int16_t GROUP_SIZE, class Alloc>
+inline void swap(sparsegroup<T,GROUP_SIZE,Alloc> &x,
+                 sparsegroup<T,GROUP_SIZE,Alloc> &y) {
+  x.swap(y);
+}
+
+// ---------------------------------------------------------------------------
+
+
+template <class T, u_int16_t GROUP_SIZE = DEFAULT_SPARSEGROUP_SIZE,
+          class Alloc = libc_allocator_with_realloc<T> >
+class sparsetable {
+ private:
+  typedef typename Alloc::template rebind<T>::other value_alloc_type;
+  typedef typename Alloc::template rebind<
+      sparsegroup<T, GROUP_SIZE, value_alloc_type> >::other vector_alloc;
+
+ public:
+  // Basic types
+  typedef T value_type;                        // stolen from stl_vector.h
+  typedef Alloc allocator_type;
+  typedef typename value_alloc_type::size_type size_type;
+  typedef typename value_alloc_type::difference_type difference_type;
+  typedef typename value_alloc_type::reference reference;
+  typedef typename value_alloc_type::const_reference const_reference;
+  typedef typename value_alloc_type::pointer pointer;
+  typedef typename value_alloc_type::const_pointer const_pointer;
+  typedef table_iterator<sparsetable<T, GROUP_SIZE, Alloc> > iterator;
+  typedef const_table_iterator<sparsetable<T, GROUP_SIZE, Alloc> >
+      const_iterator;
+  typedef table_element_adaptor<sparsetable<T, GROUP_SIZE, Alloc> >
+      element_adaptor;
+  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+  typedef std::reverse_iterator<iterator> reverse_iterator;   // from iterator.h
+
+  // These are our special iterators, that go over non-empty buckets in a
+  // table.  These aren't const only because you can change non-empty bcks.
+  typedef two_d_iterator< std::vector< sparsegroup<value_type, GROUP_SIZE,
+                                                   value_alloc_type>,
+                                  vector_alloc> >
+     nonempty_iterator;
+  typedef const_two_d_iterator< std::vector< sparsegroup<value_type,
+                                                         GROUP_SIZE,
+                                                         value_alloc_type>,
+                                        vector_alloc> >
+     const_nonempty_iterator;
+  typedef std::reverse_iterator<nonempty_iterator> reverse_nonempty_iterator;
+  typedef std::reverse_iterator<const_nonempty_iterator> const_reverse_nonempty_iterator;
+  // Another special iterator: it frees memory as it iterates (used to resize)
+  typedef destructive_two_d_iterator< std::vector< sparsegroup<value_type,
+                                                               GROUP_SIZE,
+                                                               value_alloc_type>,
+                                              vector_alloc> >
+     destructive_iterator;
+
+  // Iterator functions
+  iterator begin()                      { return iterator(this, 0); }
+  const_iterator begin() const          { return const_iterator(this, 0); }
+  iterator end()                        { return iterator(this, size()); }
+  const_iterator end() const            { return const_iterator(this, size()); }
+  reverse_iterator rbegin()             { return reverse_iterator(end()); }
+  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
+  reverse_iterator rend()               { return reverse_iterator(begin()); }
+  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
+
+  // Versions for our special non-empty iterator
+  nonempty_iterator nonempty_begin()             {
+    return nonempty_iterator(groups.begin(), groups.end(), groups.begin());
+  }
+  const_nonempty_iterator nonempty_begin() const {
+    return const_nonempty_iterator(groups.begin(),groups.end(), groups.begin());
+  }
+  nonempty_iterator nonempty_end() {
+    return nonempty_iterator(groups.begin(), groups.end(), groups.end());
+  }
+  const_nonempty_iterator nonempty_end() const {
+    return const_nonempty_iterator(groups.begin(), groups.end(), groups.end());
+  }
+  reverse_nonempty_iterator nonempty_rbegin() {
+    return reverse_nonempty_iterator(nonempty_end());
+  }
+  const_reverse_nonempty_iterator nonempty_rbegin() const {
+    return const_reverse_nonempty_iterator(nonempty_end());
+  }
+  reverse_nonempty_iterator nonempty_rend() {
+    return reverse_nonempty_iterator(nonempty_begin());
+  }
+  const_reverse_nonempty_iterator nonempty_rend() const {
+    return const_reverse_nonempty_iterator(nonempty_begin());
+  }
+  destructive_iterator destructive_begin() {
+    return destructive_iterator(groups.begin(), groups.end(), groups.begin());
+  }
+  destructive_iterator destructive_end() {
+    return destructive_iterator(groups.begin(), groups.end(), groups.end());
+  }
+
+  typedef sparsegroup<value_type, GROUP_SIZE, allocator_type> group_type;
+  typedef std::vector<group_type, vector_alloc > group_vector_type;
+
+  typedef typename group_vector_type::reference GroupsReference;
+  typedef typename group_vector_type::const_reference GroupsConstReference;
+  typedef typename group_vector_type::iterator GroupsIterator;
+  typedef typename group_vector_type::const_iterator GroupsConstIterator;
+
+  // How to deal with the proper group
+  static size_type num_groups(size_type num) {   // how many to hold num buckets
+    return num == 0 ? 0 : ((num-1) / GROUP_SIZE) + 1;
+  }
+
+  u_int16_t pos_in_group(size_type i) const {
+    return static_cast<u_int16_t>(i % GROUP_SIZE);
+  }
+  size_type group_num(size_type i) const {
+    return i / GROUP_SIZE;
+  }
+  GroupsReference which_group(size_type i) {
+    return groups[group_num(i)];
+  }
+  GroupsConstReference which_group(size_type i) const {
+    return groups[group_num(i)];
+  }
+
+ public:
+  // Constructors -- default, normal (when you specify size), and copy
+  explicit sparsetable(size_type sz = 0, Alloc alloc = Alloc())
+      : groups(vector_alloc(alloc)), settings(alloc, sz) {
+    groups.resize(num_groups(sz), group_type(settings));
+  }
+  // We can get away with using the default copy constructor,
+  // and default destructor, and hence the default operator=.  Huzzah!
+
+  // Many STL algorithms use swap instead of copy constructors
+  void swap(sparsetable& x) {
+    std::swap(groups, x.groups);              // defined in stl_algobase.h
+    std::swap(settings.table_size, x.settings.table_size);
+    std::swap(settings.num_buckets, x.settings.num_buckets);
+  }
+
+  // It's always nice to be able to clear a table without deallocating it
+  void clear() {
+    GroupsIterator group;
+    for ( group = groups.begin(); group != groups.end(); ++group ) {
+      group->clear();
+    }
+    settings.num_buckets = 0;
+  }
+
+  // ACCESSOR FUNCTIONS for the things we templatize on, basically
+  allocator_type get_allocator() const {
+    return allocator_type(settings);
+  }
+
+
+  // Functions that tell you about size.
+  // NOTE: empty() is non-intuitive!  It does not tell you the number
+  // of not-empty buckets (use num_nonempty() for that).  Instead
+  // it says whether you've allocated any buckets or not.
+  size_type size() const           { return settings.table_size; }
+  size_type max_size() const       { return settings.max_size(); }
+  bool empty() const               { return settings.table_size == 0; }
+  // We also may want to know how many *used* buckets there are
+  size_type num_nonempty() const   { return settings.num_buckets; }
+
+  // OK, we'll let you resize one of these puppies
+  void resize(size_type new_size) {
+    groups.resize(num_groups(new_size), group_type(settings));
+    if ( new_size < settings.table_size) {
+      // lower num_buckets, clear last group
+      if ( pos_in_group(new_size) > 0 )     // need to clear inside last group
+        groups.back().erase(groups.back().begin() + pos_in_group(new_size),
+                            groups.back().end());
+      settings.num_buckets = 0;                   // refigure # of used buckets
+      GroupsConstIterator group;
+      for ( group = groups.begin(); group != groups.end(); ++group )
+        settings.num_buckets += group->num_nonempty();
+    }
+    settings.table_size = new_size;
+  }
+
+
+  // We let you see if a bucket is non-empty without retrieving it
+  bool test(size_type i) const {
+    assert(i < settings.table_size);
+    return which_group(i).test(pos_in_group(i));
+  }
+  bool test(iterator pos) const {
+    return which_group(pos.pos).test(pos_in_group(pos.pos));
+  }
+  bool test(const_iterator pos) const {
+    return which_group(pos.pos).test(pos_in_group(pos.pos));
+  }
+
+  // We only return const_references because it's really hard to
+  // return something settable for empty buckets.  Use set() instead.
+  const_reference get(size_type i) const {
+    assert(i < settings.table_size);
+    return which_group(i).get(pos_in_group(i));
+  }
+
+  // TODO(csilvers): make protected + friend
+  // This is used by sparse_hashtable to get an element from the table
+  // when we know it exists (because the caller has called test(i)).
+  const_reference unsafe_get(size_type i) const {
+    assert(i < settings.table_size);
+    assert(test(i));
+    return which_group(i).unsafe_get(pos_in_group(i));
+  }
+
+  // TODO(csilvers): make protected + friend element_adaptor
+  reference mutating_get(size_type i) {    // fills bucket i before getting
+    assert(i < settings.table_size);
+    typename group_type::size_type old_numbuckets = which_group(i).num_nonempty();
+    reference retval = which_group(i).mutating_get(pos_in_group(i));
+    settings.num_buckets += which_group(i).num_nonempty() - old_numbuckets;
+    return retval;
+  }
+
+  // Syntactic sugar.  As in sparsegroup, the non-const version is harder
+  const_reference operator[](size_type i) const {
+    return get(i);
+  }
+
+  element_adaptor operator[](size_type i) {
+    return element_adaptor(this, i);
+  }
+
+  // Needed for hashtables, gets as a nonempty_iterator.  Crashes for empty bcks
+  const_nonempty_iterator get_iter(size_type i) const {
+    assert(test(i));    // how can a nonempty_iterator point to an empty bucket?
+    return const_nonempty_iterator(
+      groups.begin(), groups.end(),
+      groups.begin() + group_num(i),
+      (groups[group_num(i)].nonempty_begin() +
+       groups[group_num(i)].pos_to_offset(pos_in_group(i))));
+  }
+  // For nonempty we can return a non-const version
+  nonempty_iterator get_iter(size_type i) {
+    assert(test(i));    // how can a nonempty_iterator point to an empty bucket?
+    return nonempty_iterator(
+      groups.begin(), groups.end(),
+      groups.begin() + group_num(i),
+      (groups[group_num(i)].nonempty_begin() +
+       groups[group_num(i)].pos_to_offset(pos_in_group(i))));
+  }
+
+  // And the reverse transformation.
+  size_type get_pos(const const_nonempty_iterator it) const {
+    difference_type current_row = it.row_current - it.row_begin;
+    difference_type current_col = (it.col_current -
+                                   groups[current_row].nonempty_begin());
+    return ((current_row * GROUP_SIZE) +
+            groups[current_row].offset_to_pos(current_col));
+  }
+
+
+  // This returns a reference to the inserted item (which is a copy of val)
+  // The trick is to figure out whether we're replacing or inserting anew
+  reference set(size_type i, const_reference val) {
+    assert(i < settings.table_size);
+    typename group_type::size_type old_numbuckets = which_group(i).num_nonempty();
+    reference retval = which_group(i).set(pos_in_group(i), val);
+    settings.num_buckets += which_group(i).num_nonempty() - old_numbuckets;
+    return retval;
+  }
+
+  // This takes the specified elements out of the table.  This is
+  // "undefining", rather than "clearing".
+  void erase(size_type i) {
+    assert(i < settings.table_size);
+    typename group_type::size_type old_numbuckets = which_group(i).num_nonempty();
+    which_group(i).erase(pos_in_group(i));
+    settings.num_buckets += which_group(i).num_nonempty() - old_numbuckets;
+  }
+
+  void erase(iterator pos) {
+    erase(pos.pos);
+  }
+
+  void erase(iterator start_it, iterator end_it) {
+    // This could be more efficient, but then we'd need to figure
+    // out if we spanned groups or not.  Doesn't seem worth it.
+    for ( ; start_it != end_it; ++start_it )
+      erase(start_it);
+  }
+
+
+  // We support reading and writing tables to disk.  We don't store
+  // the actual array contents (which we don't know how to store),
+  // just the groups and sizes.  Returns true if all went ok.
+
+ private:
+  // Every time the disk format changes, this should probably change too
+  typedef unsigned long MagicNumberType;
+  static const MagicNumberType MAGIC_NUMBER = 0x24687531;
+
+  // Old versions of this code write all data in 32 bits.  We need to
+  // support these files as well as having support for 64-bit systems.
+  // So we use the following encoding scheme: for values < 2^32-1, we
+  // store in 4 bytes in big-endian order.  For values > 2^32, we
+  // store 0xFFFFFFF followed by 8 bytes in big-endian order.  This
+  // causes us to mis-read old-version code that stores exactly
+  // 0xFFFFFFF, but I don't think that is likely to have happened for
+  // these particular values.
+  template <typename OUTPUT, typename IntType>
+  static bool write_32_or_64(OUTPUT* fp, IntType value) {
+    if ( value < 0xFFFFFFFFULL ) {        // fits in 4 bytes
+      if ( !sparsehash_internal::write_bigendian_number(fp, value, 4) )
+        return false;
+    } else {
+      if ( !sparsehash_internal::write_bigendian_number(fp, 0xFFFFFFFFUL, 4) )
+        return false;
+      if ( !sparsehash_internal::write_bigendian_number(fp, value, 8) )
+        return false;
+    }
+    return true;
+  }
+
+  template <typename INPUT, typename IntType>
+  static bool read_32_or_64(INPUT* fp, IntType *value) {  // reads into value
+    MagicNumberType first4 = 0;   // a convenient 32-bit unsigned type
+    if ( !sparsehash_internal::read_bigendian_number(fp, &first4, 4) )
+      return false;
+    if ( first4 < 0xFFFFFFFFULL ) {
+      *value = first4;
+    } else {
+      if ( !sparsehash_internal::read_bigendian_number(fp, value, 8) )
+        return false;
+    }
+    return true;
+  }
+
+ public:
+  // read/write_metadata() and read_write/nopointer_data() are DEPRECATED.
+  // Use serialize() and unserialize(), below, for new code.
+
+  template <typename OUTPUT> bool write_metadata(OUTPUT *fp) const {
+    if ( !write_32_or_64(fp, MAGIC_NUMBER) )  return false;
+    if ( !write_32_or_64(fp, settings.table_size) )  return false;
+    if ( !write_32_or_64(fp, settings.num_buckets) )  return false;
+
+    GroupsConstIterator group;
+    for ( group = groups.begin(); group != groups.end(); ++group )
+      if ( group->write_metadata(fp) == false )  return false;
+    return true;
+  }
+
+  // Reading destroys the old table contents!  Returns true if read ok.
+  template <typename INPUT> bool read_metadata(INPUT *fp) {
+    size_type magic_read = 0;
+    if ( !read_32_or_64(fp, &magic_read) )  return false;
+    if ( magic_read != MAGIC_NUMBER ) {
+      clear();                        // just to be consistent
+      return false;
+    }
+
+    if ( !read_32_or_64(fp, &settings.table_size) )  return false;
+    if ( !read_32_or_64(fp, &settings.num_buckets) )  return false;
+
+    resize(settings.table_size);                    // so the vector's sized ok
+    GroupsIterator group;
+    for ( group = groups.begin(); group != groups.end(); ++group )
+      if ( group->read_metadata(fp) == false )  return false;
+    return true;
+  }
+
+  // This code is identical to that for SparseGroup
+  // If your keys and values are simple enough, we can write them
+  // to disk for you.  "simple enough" means no pointers.
+  // However, we don't try to normalize endianness
+  bool write_nopointer_data(FILE *fp) const {
+    for ( const_nonempty_iterator it = nonempty_begin();
+          it != nonempty_end(); ++it ) {
+      if ( !fwrite(&*it, sizeof(*it), 1, fp) )  return false;
+    }
+    return true;
+  }
+
+  // When reading, we have to override the potential const-ness of *it
+  bool read_nopointer_data(FILE *fp) {
+    for ( nonempty_iterator it = nonempty_begin();
+          it != nonempty_end(); ++it ) {
+      if ( !fread(reinterpret_cast<void*>(&(*it)), sizeof(*it), 1, fp) )
+        return false;
+    }
+    return true;
+  }
+
+  // INPUT and OUTPUT must be either a FILE, *or* a C++ stream
+  //    (istream, ostream, etc) *or* a class providing
+  //    Read(void*, size_t) and Write(const void*, size_t)
+  //    (respectively), which writes a buffer into a stream
+  //    (which the INPUT/OUTPUT instance presumably owns).
+
+  typedef sparsehash_internal::pod_serializer<value_type> NopointerSerializer;
+
+  // ValueSerializer: a functor.  operator()(OUTPUT*, const value_type&)
+  template <typename ValueSerializer, typename OUTPUT>
+  bool serialize(ValueSerializer serializer, OUTPUT *fp) {
+    if ( !write_metadata(fp) )
+      return false;
+    for ( const_nonempty_iterator it = nonempty_begin();
+          it != nonempty_end(); ++it ) {
+      if ( !serializer(fp, *it) )  return false;
+    }
+    return true;
+  }
+
+  // ValueSerializer: a functor.  operator()(INPUT*, value_type*)
+  template <typename ValueSerializer, typename INPUT>
+  bool unserialize(ValueSerializer serializer, INPUT *fp) {
+    clear();
+    if ( !read_metadata(fp) )
+      return false;
+    for ( nonempty_iterator it = nonempty_begin();
+          it != nonempty_end(); ++it ) {
+      if ( !serializer(fp, &*it) )  return false;
+    }
+    return true;
+  }
+
+  // Comparisons.  Note the comparisons are pretty arbitrary: we
+  // compare values of the first index that isn't equal (using default
+  // value for empty buckets).
+  bool operator==(const sparsetable& x) const {
+    return ( settings.table_size == x.settings.table_size &&
+             settings.num_buckets == x.settings.num_buckets &&
+             groups == x.groups );
+  }
+
+  bool operator<(const sparsetable& x) const {
+    return std::lexicographical_compare(begin(), end(), x.begin(), x.end());
+  }
+  bool operator!=(const sparsetable& x) const { return !(*this == x); }
+  bool operator<=(const sparsetable& x) const { return !(x < *this); }
+  bool operator>(const sparsetable& x) const { return x < *this; }
+  bool operator>=(const sparsetable& x) const { return !(*this < x); }
+
+
+ private:
+  // Package allocator with table_size and num_buckets to eliminate memory
+  // needed for the zero-size allocator.
+  // If new fields are added to this class, we should add them to
+  // operator= and swap.
+  class Settings : public allocator_type {
+   public:
+    typedef typename allocator_type::size_type size_type;
+
+    Settings(const allocator_type& a, size_type sz = 0, size_type n = 0)
+        : allocator_type(a), table_size(sz), num_buckets(n) { }
+
+    Settings(const Settings& s)
+        : allocator_type(s),
+          table_size(s.table_size), num_buckets(s.num_buckets) { }
+
+    size_type table_size;          // how many buckets they want
+    size_type num_buckets;         // number of non-empty buckets
+  };
+
+  // The actual data
+  group_vector_type groups;        // our list of groups
+  Settings settings;               // allocator, table size, buckets
+};
+
+// We need a global swap as well
+template <class T, u_int16_t GROUP_SIZE, class Alloc>
+inline void swap(sparsetable<T,GROUP_SIZE,Alloc> &x,
+                 sparsetable<T,GROUP_SIZE,Alloc> &y) {
+  x.swap(y);
+}
+
+_END_GOOGLE_NAMESPACE_
+
+#endif  // UTIL_GTL_SPARSETABLE_H_
diff --git a/include/sparsehash/template_util.h b/include/sparsehash/template_util.h
new file mode 100644
index 0000000..6fec3d0
--- /dev/null
+++ b/include/sparsehash/template_util.h
@@ -0,0 +1,134 @@
+// Copyright 2005 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ----
+//
+// Template metaprogramming utility functions.
+//
+// This code is compiled directly on many platforms, including client
+// platforms like Windows, Mac, and embedded systems.  Before making
+// any changes here, make sure that you're not breaking any platforms.
+//
+//
+// The names choosen here reflect those used in tr1 and the boost::mpl
+// library, there are similar operations used in the Loki library as
+// well.  I prefer the boost names for 2 reasons:
+// 1.  I think that portions of the Boost libraries are more likely to
+// be included in the c++ standard.
+// 2.  It is not impossible that some of the boost libraries will be
+// included in our own build in the future.
+// Both of these outcomes means that we may be able to directly replace
+// some of these with boost equivalents.
+//
+#ifndef BASE_TEMPLATE_UTIL_H_
+#define BASE_TEMPLATE_UTIL_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+_START_GOOGLE_NAMESPACE_
+
+// Types small_ and big_ are guaranteed such that sizeof(small_) <
+// sizeof(big_)
+typedef char small_;
+
+struct big_ {
+  char dummy[2];
+};
+
+// Identity metafunction.
+template <class T>
+struct identity_ {
+  typedef T type;
+};
+
+// integral_constant, defined in tr1, is a wrapper for an integer
+// value. We don't really need this generality; we could get away
+// with hardcoding the integer type to bool. We use the fully
+// general integer_constant for compatibility with tr1.
+
+template<class T, T v>
+struct integral_constant {
+  static const T value = v;
+  typedef T value_type;
+  typedef integral_constant<T, v> type;
+};
+
+template <class T, T v> const T integral_constant<T, v>::value;
+
+
+// Abbreviations: true_type and false_type are structs that represent boolean
+// true and false values. Also define the boost::mpl versions of those names,
+// true_ and false_.
+typedef integral_constant<bool, true>  true_type;
+typedef integral_constant<bool, false> false_type;
+typedef true_type  true_;
+typedef false_type false_;
+
+// if_ is a templatized conditional statement.
+// if_<cond, A, B> is a compile time evaluation of cond.
+// if_<>::type contains A if cond is true, B otherwise.
+template<bool cond, typename A, typename B>
+struct if_{
+  typedef A type;
+};
+
+template<typename A, typename B>
+struct if_<false, A, B> {
+  typedef B type;
+};
+
+
+// type_equals_ is a template type comparator, similar to Loki IsSameType.
+// type_equals_<A, B>::value is true iff "A" is the same type as "B".
+//
+// New code should prefer base::is_same, defined in base/type_traits.h.
+// It is functionally identical, but is_same is the standard spelling.
+template<typename A, typename B>
+struct type_equals_ : public false_ {
+};
+
+template<typename A>
+struct type_equals_<A, A> : public true_ {
+};
+
+// and_ is a template && operator.
+// and_<A, B>::value evaluates "A::value && B::value".
+template<typename A, typename B>
+struct and_ : public integral_constant<bool, (A::value && B::value)> {
+};
+
+// or_ is a template || operator.
+// or_<A, B>::value evaluates "A::value || B::value".
+template<typename A, typename B>
+struct or_ : public integral_constant<bool, (A::value || B::value)> {
+};
+
+
+_END_GOOGLE_NAMESPACE_
+
+#endif  // BASE_TEMPLATE_UTIL_H_
diff --git a/include/sparsehash/type_traits.h b/include/sparsehash/type_traits.h
new file mode 100644
index 0000000..f909cf9
--- /dev/null
+++ b/include/sparsehash/type_traits.h
@@ -0,0 +1,342 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ----
+//
+// This code is compiled directly on many platforms, including client
+// platforms like Windows, Mac, and embedded systems.  Before making
+// any changes here, make sure that you're not breaking any platforms.
+//
+// Define a small subset of tr1 type traits. The traits we define are:
+//   is_integral
+//   is_floating_point
+//   is_pointer
+//   is_enum
+//   is_reference
+//   is_pod
+//   has_trivial_constructor
+//   has_trivial_copy
+//   has_trivial_assign
+//   has_trivial_destructor
+//   remove_const
+//   remove_volatile
+//   remove_cv
+//   remove_reference
+//   add_reference
+//   remove_pointer
+//   is_same
+//   is_convertible
+// We can add more type traits as required.
+
+#ifndef BASE_TYPE_TRAITS_H_
+#define BASE_TYPE_TRAITS_H_
+
+#include <sparsehash/internal/sparseconfig.h>
+#include <utility>                  // For pair
+
+#include <sparsehash/template_util.h>     // For true_type and false_type
+
+_START_GOOGLE_NAMESPACE_
+
+template <class T> struct is_integral;
+template <class T> struct is_floating_point;
+template <class T> struct is_pointer;
+// MSVC can't compile this correctly, and neither can gcc 3.3.5 (at least)
+#if !defined(_MSC_VER) && !(defined(__GNUC__) && __GNUC__ <= 3)
+// is_enum uses is_convertible, which is not available on MSVC.
+template <class T> struct is_enum;
+#endif
+template <class T> struct is_reference;
+template <class T> struct is_pod;
+template <class T> struct has_trivial_constructor;
+template <class T> struct has_trivial_copy;
+template <class T> struct has_trivial_assign;
+template <class T> struct has_trivial_destructor;
+template <class T> struct remove_const;
+template <class T> struct remove_volatile;
+template <class T> struct remove_cv;
+template <class T> struct remove_reference;
+template <class T> struct add_reference;
+template <class T> struct remove_pointer;
+template <class T, class U> struct is_same;
+#if !defined(_MSC_VER) && !(defined(__GNUC__) && __GNUC__ <= 3)
+template <class From, class To> struct is_convertible;
+#endif
+
+// is_integral is false except for the built-in integer types. A
+// cv-qualified type is integral if and only if the underlying type is.
+template <class T> struct is_integral : false_type { };
+template<> struct is_integral<bool> : true_type { };
+template<> struct is_integral<char> : true_type { };
+template<> struct is_integral<unsigned char> : true_type { };
+template<> struct is_integral<signed char> : true_type { };
+#if defined(_MSC_VER)
+// wchar_t is not by default a distinct type from unsigned short in
+// Microsoft C.
+// See http://msdn2.microsoft.com/en-us/library/dh8che7s(VS.80).aspx
+template<> struct is_integral<__wchar_t> : true_type { };
+#else
+template<> struct is_integral<wchar_t> : true_type { };
+#endif
+template<> struct is_integral<short> : true_type { };
+template<> struct is_integral<unsigned short> : true_type { };
+template<> struct is_integral<int> : true_type { };
+template<> struct is_integral<unsigned int> : true_type { };
+template<> struct is_integral<long> : true_type { };
+template<> struct is_integral<unsigned long> : true_type { };
+#ifdef HAVE_LONG_LONG
+template<> struct is_integral<long long> : true_type { };
+template<> struct is_integral<unsigned long long> : true_type { };
+#endif
+template <class T> struct is_integral<const T> : is_integral<T> { };
+template <class T> struct is_integral<volatile T> : is_integral<T> { };
+template <class T> struct is_integral<const volatile T> : is_integral<T> { };
+
+// is_floating_point is false except for the built-in floating-point types.
+// A cv-qualified type is integral if and only if the underlying type is.
+template <class T> struct is_floating_point : false_type { };
+template<> struct is_floating_point<float> : true_type { };
+template<> struct is_floating_point<double> : true_type { };
+template<> struct is_floating_point<long double> : true_type { };
+template <class T> struct is_floating_point<const T>
+    : is_floating_point<T> { };
+template <class T> struct is_floating_point<volatile T>
+    : is_floating_point<T> { };
+template <class T> struct is_floating_point<const volatile T>
+    : is_floating_point<T> { };
+
+// is_pointer is false except for pointer types. A cv-qualified type (e.g.
+// "int* const", as opposed to "int const*") is cv-qualified if and only if
+// the underlying type is.
+template <class T> struct is_pointer : false_type { };
+template <class T> struct is_pointer<T*> : true_type { };
+template <class T> struct is_pointer<const T> : is_pointer<T> { };
+template <class T> struct is_pointer<volatile T> : is_pointer<T> { };
+template <class T> struct is_pointer<const volatile T> : is_pointer<T> { };
+
+#if !defined(_MSC_VER) && !(defined(__GNUC__) && __GNUC__ <= 3)
+
+namespace internal {
+
+template <class T> struct is_class_or_union {
+  template <class U> static small_ tester(void (U::*)());
+  template <class U> static big_ tester(...);
+  static const bool value = sizeof(tester<T>(0)) == sizeof(small_);
+};
+
+// is_convertible chokes if the first argument is an array. That's why
+// we use add_reference here.
+template <bool NotUnum, class T> struct is_enum_impl
+    : is_convertible<typename add_reference<T>::type, int> { };
+
+template <class T> struct is_enum_impl<true, T> : false_type { };
+
+}  // namespace internal
+
+// Specified by TR1 [4.5.1] primary type categories.
+
+// Implementation note:
+//
+// Each type is either void, integral, floating point, array, pointer,
+// reference, member object pointer, member function pointer, enum,
+// union or class. Out of these, only integral, floating point, reference,
+// class and enum types are potentially convertible to int. Therefore,
+// if a type is not a reference, integral, floating point or class and
+// is convertible to int, it's a enum. Adding cv-qualification to a type
+// does not change whether it's an enum.
+//
+// Is-convertible-to-int check is done only if all other checks pass,
+// because it can't be used with some types (e.g. void or classes with
+// inaccessible conversion operators).
+template <class T> struct is_enum
+    : internal::is_enum_impl<
+          is_same<T, void>::value ||
+              is_integral<T>::value ||
+              is_floating_point<T>::value ||
+              is_reference<T>::value ||
+              internal::is_class_or_union<T>::value,
+          T> { };
+
+template <class T> struct is_enum<const T> : is_enum<T> { };
+template <class T> struct is_enum<volatile T> : is_enum<T> { };
+template <class T> struct is_enum<const volatile T> : is_enum<T> { };
+
+#endif
+
+// is_reference is false except for reference types.
+template<typename T> struct is_reference : false_type {};
+template<typename T> struct is_reference<T&> : true_type {};
+
+
+// We can't get is_pod right without compiler help, so fail conservatively.
+// We will assume it's false except for arithmetic types, enumerations,
+// pointers and cv-qualified versions thereof. Note that std::pair<T,U>
+// is not a POD even if T and U are PODs.
+template <class T> struct is_pod
+ : integral_constant<bool, (is_integral<T>::value ||
+                            is_floating_point<T>::value ||
+#if !defined(_MSC_VER) && !(defined(__GNUC__) && __GNUC__ <= 3)
+                            // is_enum is not available on MSVC.
+                            is_enum<T>::value ||
+#endif
+                            is_pointer<T>::value)> { };
+template <class T> struct is_pod<const T> : is_pod<T> { };
+template <class T> struct is_pod<volatile T> : is_pod<T> { };
+template <class T> struct is_pod<const volatile T> : is_pod<T> { };
+
+
+// We can't get has_trivial_constructor right without compiler help, so
+// fail conservatively. We will assume it's false except for: (1) types
+// for which is_pod is true. (2) std::pair of types with trivial
+// constructors. (3) array of a type with a trivial constructor.
+// (4) const versions thereof.
+template <class T> struct has_trivial_constructor : is_pod<T> { };
+template <class T, class U> struct has_trivial_constructor<std::pair<T, U> >
+  : integral_constant<bool,
+                      (has_trivial_constructor<T>::value &&
+                       has_trivial_constructor<U>::value)> { };
+template <class A, int N> struct has_trivial_constructor<A[N]>
+  : has_trivial_constructor<A> { };
+template <class T> struct has_trivial_constructor<const T>
+  : has_trivial_constructor<T> { };
+
+// We can't get has_trivial_copy right without compiler help, so fail
+// conservatively. We will assume it's false except for: (1) types
+// for which is_pod is true. (2) std::pair of types with trivial copy
+// constructors. (3) array of a type with a trivial copy constructor.
+// (4) const versions thereof.
+template <class T> struct has_trivial_copy : is_pod<T> { };
+template <class T, class U> struct has_trivial_copy<std::pair<T, U> >
+  : integral_constant<bool,
+                      (has_trivial_copy<T>::value &&
+                       has_trivial_copy<U>::value)> { };
+template <class A, int N> struct has_trivial_copy<A[N]>
+  : has_trivial_copy<A> { };
+template <class T> struct has_trivial_copy<const T> : has_trivial_copy<T> { };
+
+// We can't get has_trivial_assign right without compiler help, so fail
+// conservatively. We will assume it's false except for: (1) types
+// for which is_pod is true. (2) std::pair of types with trivial copy
+// constructors. (3) array of a type with a trivial assign constructor.
+template <class T> struct has_trivial_assign : is_pod<T> { };
+template <class T, class U> struct has_trivial_assign<std::pair<T, U> >
+  : integral_constant<bool,
+                      (has_trivial_assign<T>::value &&
+                       has_trivial_assign<U>::value)> { };
+template <class A, int N> struct has_trivial_assign<A[N]>
+  : has_trivial_assign<A> { };
+
+// We can't get has_trivial_destructor right without compiler help, so
+// fail conservatively. We will assume it's false except for: (1) types
+// for which is_pod is true. (2) std::pair of types with trivial
+// destructors. (3) array of a type with a trivial destructor.
+// (4) const versions thereof.
+template <class T> struct has_trivial_destructor : is_pod<T> { };
+template <class T, class U> struct has_trivial_destructor<std::pair<T, U> >
+  : integral_constant<bool,
+                      (has_trivial_destructor<T>::value &&
+                       has_trivial_destructor<U>::value)> { };
+template <class A, int N> struct has_trivial_destructor<A[N]>
+  : has_trivial_destructor<A> { };
+template <class T> struct has_trivial_destructor<const T>
+  : has_trivial_destructor<T> { };
+
+// Specified by TR1 [4.7.1]
+template<typename T> struct remove_const { typedef T type; };
+template<typename T> struct remove_const<T const> { typedef T type; };
+template<typename T> struct remove_volatile { typedef T type; };
+template<typename T> struct remove_volatile<T volatile> { typedef T type; };
+template<typename T> struct remove_cv {
+  typedef typename remove_const<typename remove_volatile<T>::type>::type type;
+};
+
+
+// Specified by TR1 [4.7.2] Reference modifications.
+template<typename T> struct remove_reference { typedef T type; };
+template<typename T> struct remove_reference<T&> { typedef T type; };
+
+template <typename T> struct add_reference { typedef T& type; };
+template <typename T> struct add_reference<T&> { typedef T& type; };
+
+// Specified by TR1 [4.7.4] Pointer modifications.
+template<typename T> struct remove_pointer { typedef T type; };
+template<typename T> struct remove_pointer<T*> { typedef T type; };
+template<typename T> struct remove_pointer<T* const> { typedef T type; };
+template<typename T> struct remove_pointer<T* volatile> { typedef T type; };
+template<typename T> struct remove_pointer<T* const volatile> {
+  typedef T type; };
+
+// Specified by TR1 [4.6] Relationships between types
+template<typename T, typename U> struct is_same : public false_type { };
+template<typename T> struct is_same<T, T> : public true_type { };
+
+// Specified by TR1 [4.6] Relationships between types
+#if !defined(_MSC_VER) && !(defined(__GNUC__) && __GNUC__ <= 3)
+namespace internal {
+
+// This class is an implementation detail for is_convertible, and you
+// don't need to know how it works to use is_convertible. For those
+// who care: we declare two different functions, one whose argument is
+// of type To and one with a variadic argument list. We give them
+// return types of different size, so we can use sizeof to trick the
+// compiler into telling us which function it would have chosen if we
+// had called it with an argument of type From.  See Alexandrescu's
+// _Modern C++ Design_ for more details on this sort of trick.
+
+template <typename From, typename To>
+struct ConvertHelper {
+  static small_ Test(To);
+  static big_ Test(...);
+  static From Create();
+};
+}  // namespace internal
+
+// Inherits from true_type if From is convertible to To, false_type otherwise.
+template <typename From, typename To>
+struct is_convertible
+    : integral_constant<bool,
+                        sizeof(internal::ConvertHelper<From, To>::Test(
+                                  internal::ConvertHelper<From, To>::Create()))
+                        == sizeof(small_)> {
+};
+#endif
+
+_END_GOOGLE_NAMESPACE_
+
+// Right now these macros are no-ops, and mostly just document the fact
+// these types are PODs, for human use.  They may be made more contentful
+// later.  The typedef is just to make it legal to put a semicolon after
+// these macros.
+#define DECLARE_POD(TypeName) typedef int Dummy_Type_For_DECLARE_POD
+#define DECLARE_NESTED_POD(TypeName) DECLARE_POD(TypeName)
+#define PROPAGATE_POD_FROM_TEMPLATE_ARGUMENT(TemplateName)             \
+    typedef int Dummy_Type_For_PROPAGATE_POD_FROM_TEMPLATE_ARGUMENT
+#define ENFORCE_POD(TypeName) typedef int Dummy_Type_For_ENFORCE_POD
+
+#endif  // BASE_TYPE_TRAITS_H_
diff --git a/lib/Analysis/Andersen/Andersen.cpp b/lib/Analysis/Andersen/Andersen.cpp
new file mode 100644
index 0000000..dd81c81
--- /dev/null
+++ b/lib/Analysis/Andersen/Andersen.cpp
@@ -0,0 +1,445 @@
+#include <llvm/IR/Dominators.h>
+#include <llvm/Analysis/LoopInfo.h>
+#include <llvm/Object/MachO.h>
+#include <llvm/Analysis/Andersen/ObjectiveCBinary.h>
+#include <llvm/IR/InstIterator.h>
+#include <llvm/Support/Debug.h>
+#include <llvm/IR/PatternMatch.h>
+#include "llvm/Analysis/Andersen/Andersen.h"
+
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Analysis/Andersen/StackAccessPass.h"
+#include "llvm/Analysis/Andersen/DetectParametersPass.h"
+
+#include "llvm/IR/Instructions.h"
+
+using namespace llvm;
+
+cl::opt<bool> DumpDebugInfo("dump-debug", cl::desc("Dump debug info into stderr"), cl::init(false), cl::Hidden);
+cl::opt<bool> DumpResultInfo("dump-result", cl::desc("Dump result info into stderr"), cl::init(false), cl::Hidden);
+cl::opt<bool> DumpConstraintInfo("dump-cons", cl::desc("Dump constraint info into stderr"), cl::init(false),
+                                 cl::Hidden);
+
+cl::opt<std::string> BinaryFile("binary", cl::desc(""), cl::init(""), cl::Hidden);
+
+cl::opt<std::string> UnhandledFile("unhandled", cl::desc(""), cl::init(""), cl::Hidden);
+
+Andersen::Andersen() : llvm::ModulePass(ID) {
+}
+
+
+void Andersen::getAnalysisUsage(AnalysisUsage &AU) const {
+  AU.setPreservesAll();
+//	AU.addRequired<DataLayoutPass>();
+  AU.addRequired<StackAccessPass>();
+  AU.addRequired<DetectParametersPass>();
+  AU.addRequired<DominatorTreeWrapperPass>();
+  AU.addRequired<LoopInfoWrapperPass>();
+}
+
+void Andersen::getAllAllocationSites(std::vector<const llvm::Value *> &allocSites) const {
+  nodeFactory.getAllocSites(allocSites);
+}
+
+bool Andersen::getPointsToSet(const llvm::Value *v, std::vector<const llvm::Value *> &ptsSet) const {
+  NodeIndex ptrIndex = nodeFactory.getValueNodeFor(v);
+  if (ptrIndex == AndersNodeFactory::InvalidIndex) {
+    ptrIndex = nodeFactory.getObjectNodeFor(v);
+  }
+  // We have no idea what v is...
+  if (ptrIndex == AndersNodeFactory::InvalidIndex || ptrIndex == nodeFactory.getUniversalPtrNode())
+    return false;
+
+  NodeIndex ptrTgt = nodeFactory.getMergeTarget(ptrIndex);
+  ptsSet.clear();
+
+  auto ptsItr = ptsGraph.find(ptrTgt);
+  if (ptsItr == ptsGraph.end()) {
+    // Can't find ptrTgt. The reason might be that ptrTgt is an undefined pointer. Dereferencing it is undefined behavior anyway, so we might just want to treat it as a nullptr pointer
+    return true;
+  }
+  for (auto v: ptsItr->second) {
+    if (v == nodeFactory.getNullObjectNode())
+      continue;
+
+    const llvm::Value *val = nodeFactory.getValueForNode(v);
+    if (val != nullptr)
+      ptsSet.push_back(val);
+  }
+  return true;
+}
+
+bool Andersen::runOnModule(Module &M) {
+  Mod = &M;
+  CallGraph = std::unique_ptr<SimpleCallGraph>(new SimpleCallGraph(M));
+//	dataLayout = &(getAnalysis<DataLayoutPass>().getDataLayout());
+
+  if (!BinaryFile.length())
+    llvm_unreachable("Binary file needs to be specified");
+  this->MachO = std::unique_ptr<ObjectiveCBinary>(new ObjectiveCBinary(BinaryFile));
+
+  if (!UnhandledFile.length())
+    unhandledFunctions = &nulls();
+  else {
+    std::error_code EC;
+
+    unhandledFunctions = new raw_fd_ostream(UnhandledFile, EC, sys::fs::F_None);
+
+    if (EC) {
+      errs() << EC.message() << '\n';
+      unhandledFunctions = &nulls();
+    }
+  }
+
+  nodeFactory.setDataLayout(dataLayout);
+
+  collectConstraints(M);
+
+  uint64_t NumConstraints = constraints.size();
+
+  for (auto &fun : M) {
+    if (ObjectiveC::CallHandlerBase::isObjectiveCMethod(fun.getName())) {
+      for (auto &i : fun.getEntryBlock()) {
+        if (i.getOpcode() != Instruction::Load)
+          continue;
+        const GetElementPtrInst *getElementPtrInst = dyn_cast<GetElementPtrInst>(i.getOperand(0));
+        if (!getElementPtrInst)
+          continue;
+        const ConstantInt *idx = dyn_cast<const ConstantInt>(getElementPtrInst->getOperand(2));
+        if (!idx)
+          continue;
+        if (idx->getZExtValue() != 5)
+          continue;
+        StringRef typeName = ObjectiveC::CallHandlerBase::getClassname(fun.getName());
+        NodeIndex valNode = nodeFactory.getValueNodeFor(&i);
+        if (valNode == AndersNodeFactory::InvalidIndex)
+          valNode = nodeFactory.createValueNode(&i);
+        NodeIndex objNode = nodeFactory.createObjectNode(&i);
+        if (objNode == AndersNodeFactory::InvalidIndex)
+          objNode = nodeFactory.createObjectNode(&i);
+        addConstraint(AndersConstraint::ADDR_OF, valNode, objNode);
+        setType((Value *) &i, typeName);
+        break;
+      }
+    }
+    for (auto &bb : fun) {
+      for (auto &i : bb) {
+        if (i.getOpcode() == Instruction::Load) {
+
+          Instruction *sext = nullptr;
+          if (PatternMatch::match(i.getOperand(0), PatternMatch::m_IntToPtr(
+            PatternMatch::m_BinOp(PatternMatch::m_Value(), PatternMatch::m_Instruction(sext))))) {
+            if (sext->getOpcode() != Instruction::SExt)
+              continue;
+            if (const LoadInst *loadInst = dyn_cast<const LoadInst>(sext->getOperand(0))) {
+              ConstantInt *constantInt = nullptr;
+              if (PatternMatch::match(loadInst->getOperand(0),
+                                      PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(constantInt)))) {
+
+                std::map<uint64_t, ObjectiveC::IVAR>::iterator ivar_it = getMachO().getIVARs().find(
+                  constantInt->getZExtValue());
+                if (ivar_it == getMachO().getIVARs().end()) {
+                  continue;
+                }
+
+                if (ivar_it->second.getType().size() == 0) {
+                  continue;
+                }
+
+                bool foundType = false;
+                std::vector<const Value *> ptsTo;
+                getPointsToSet(&i, ptsTo);
+
+                for (auto &p : ptsTo) {
+                  StringSet_t types;
+                  if (getType((Value *) p, types)) {
+                    for (auto &t : types) {
+                      if (t == ivar_it->second.getType()) {
+                        foundType = true;
+                        break;
+                      }
+                    }
+                  }
+                }
+
+                if (!foundType) {
+                  NodeIndex objIndex = nodeFactory.getObjectNodeFor(&i);
+                  if (objIndex == AndersNodeFactory::InvalidIndex) {
+                    objIndex = nodeFactory.createObjectNode(&i);
+                  }
+                  NodeIndex valIndex = nodeFactory.getValueNodeFor(&i);
+                  if (valIndex == AndersNodeFactory::InvalidIndex) {
+                    valIndex = nodeFactory.createValueNode(&i);
+                  }
+                  addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+                  setType(&i, ivar_it->second.getType());
+                }
+
+              }
+            }
+          }
+        } else if (i.getOpcode() == Instruction::Call) {
+          const CallInst *call = (const CallInst *) &i;
+          if (call->getCalledFunction() && call->getCalledFunction()->hasName() &&
+              call->getCalledFunction()->getName() == "objc_loadWeakRetained") {
+            DetectParametersPass::UserSet_t post_X0s = DetectParametersPass::getRegisterValuesAfterCall(5, call);
+            DetectParametersPass::UserSet_t pre_X0s = DetectParametersPass::getRegisterValuesBeforeCall(5, call);
+
+            for (auto &pre_x0 : pre_X0s) {
+              Instruction *loadInst = nullptr;
+              ConstantInt *constAddr = nullptr;
+              if (PatternMatch::match(pre_x0, PatternMatch::m_BinOp(PatternMatch::m_Value(),
+                                                                    PatternMatch::m_SExt(PatternMatch::m_Instruction(
+                                                                      loadInst)))) &&
+                  loadInst->getOpcode() == Instruction::Load &&
+                  PatternMatch::match(loadInst->getOperand(0),
+                                      PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(constAddr)))) {
+
+                std::map<uint64_t, ObjectiveC::IVAR>::iterator ivar_it = getMachO().getIVARs().find(
+                  constAddr->getZExtValue());
+                if (ivar_it == getMachO().getIVARs().end()) {
+                  continue;
+                }
+
+                if (ivar_it->second.getType().size() == 0) {
+                  continue;
+                }
+
+                for (auto &post_x0 : post_X0s) {
+                  bool foundType = false;
+                  std::vector<const Value *> ptsTo;
+                  getPointsToSet(post_x0, ptsTo);
+
+                  for (auto &p : ptsTo) {
+                    StringSet_t types;
+                    if (getType((Value *) p, types)) {
+                      for (auto &t : types) {
+                        if (t == ivar_it->second.getType()) {
+                          foundType = true;
+                          break;
+                        }
+                      }
+                    }
+                  }
+
+                  if (!foundType) {
+                    NodeIndex objIndex = nodeFactory.getObjectNodeFor(post_x0);
+                    if (objIndex == AndersNodeFactory::InvalidIndex) {
+                      objIndex = nodeFactory.createObjectNode(post_x0);
+                    }
+                    NodeIndex valIndex = nodeFactory.getValueNodeFor(post_x0);
+                    if (valIndex == AndersNodeFactory::InvalidIndex) {
+                      valIndex = nodeFactory.createValueNode(post_x0);
+                    }
+                    addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+                    setType(post_x0, ivar_it->second.getType());
+                  }
+                }
+              }
+            }
+
+          }
+        }
+      }
+    }
+  }
+  do {
+
+    errs() << "Optimize and solve constraints\n";
+
+
+    optimizeConstraints();
+
+
+    solveConstraints();
+
+
+    StackAccessPass *SAP = getAnalysisIfAvailable<StackAccessPass>();
+    if (!SAP)
+      SAP = &getAnalysis<StackAccessPass>();
+
+    stackOffsetMap.clear();
+
+    for (Function &f : M) {
+      if (f.isDeclaration() || f.isIntrinsic())
+        continue;
+
+      StackAccessPass::OffsetMap_t &Offsets = SAP->getOffsets(&f);
+
+      StackAccessPass::OffsetMap_t::iterator end = Offsets.end();
+
+      for (inst_iterator I_it = inst_begin(f); I_it != inst_end(f); ++I_it) {
+        const Instruction *I = &*I_it;
+        if (Offsets.find(I) == end)
+          continue;
+        if (!Offsets[I])
+          continue;
+        StackAccessPass::Int64List_t &OffsetList = *Offsets[I];
+
+        std::vector<const Value *> ptsTo;
+        getPointsToSet(I, ptsTo);
+        for (auto &ptsTo_it : ptsTo) {
+          for (int64_t O : OffsetList) {
+            stackOffsetMap[ptsTo_it].insert(std::pair<const Function *, int64_t>(&f, O));
+          }
+        }
+      }
+    }
+
+
+    std::deque<Instruction *> CallInsts = CallInstWorklist;
+    CallInstWorklist.clear();
+
+    std::deque<Function *> Functions = FunctionWorklist;
+    FunctionWorklist.clear();
+
+    errs() << "Add function call constraints\n";
+    while (CallInsts.size()) {
+      Instruction *i = CallInsts.front();
+      CallInsts.pop_front();
+
+      ImmutableCallSite cs(i);
+      addConstraintForCall(cs);
+    }
+    std::sort(constraints.begin(), constraints.end());
+    constraints.erase(std::unique(constraints.begin(), constraints.end()), constraints.end());
+
+    errs() << constraints.size() << " constraints\n";
+
+    if (constraints.size() == NumConstraints) {
+      errs() << "NO NEW CONSTRAINTS!!!\n";
+      break;
+    }
+    NumConstraints = constraints.size();
+
+  } while (CallInstWorklist.size() || FunctionWorklist.size());
+
+  if (DumpDebugInfo) {
+    errs() << "Unoptimized constraints\n";
+    dumpConstraintsPlainVanilla();
+  }
+
+  if (DumpConstraintInfo) {
+    errs() << "Optimized constraints\n";
+    dumpConstraints();
+  }
+
+  if (DumpDebugInfo) {
+    errs() << "\n";
+    errs() << "Solved constraints\n";
+    dumpPtsGraphPlainVanilla();
+  }
+
+  if (DumpResultInfo) {
+    nodeFactory.dumpNodeInfo();
+    errs() << "\n";
+    errs() << "Results\n";
+    dumpPtsGraphPlainVanilla();
+  }
+
+//    CallGraph->finalize();
+
+  DEBUG_WITH_TYPE("simple-callgraph",
+                  CallGraph->print(errs());
+  );
+//    assert(false);
+
+
+  unhandledFunctions->flush();
+
+  if (UnhandledFile.length())
+    delete (unhandledFunctions);
+
+
+  constraints.clear();
+
+
+  return false;
+}
+
+void Andersen::releaseMemory() {
+}
+
+void Andersen::dumpConstraint(const AndersConstraint &item) const {
+  NodeIndex dest = item.getDest();
+  NodeIndex src = item.getSrc();
+
+  switch (item.getType()) {
+    case AndersConstraint::COPY: {
+      nodeFactory.dumpNode(dest);
+      errs() << " = ";
+      nodeFactory.dumpNode(src);
+      break;
+    }
+    case AndersConstraint::LOAD: {
+      nodeFactory.dumpNode(dest);
+      errs() << " = *";
+      nodeFactory.dumpNode(src);
+      break;
+    }
+    case AndersConstraint::STORE: {
+      errs() << "*";
+      nodeFactory.dumpNode(dest);
+      errs() << " = ";
+      nodeFactory.dumpNode(src);
+      break;
+    }
+    case AndersConstraint::ADDR_OF: {
+      nodeFactory.dumpNode(dest);
+      errs() << " = &";
+      nodeFactory.dumpNode(src);
+    }
+  }
+
+  errs() << "\n";
+}
+
+void Andersen::dumpConstraints() const {
+  errs() << "\n----- Constraints -----\n";
+  for (auto const &item: constraints)
+    dumpConstraint(item);
+  errs() << "----- End of Print -----\n";
+}
+
+void Andersen::dumpConstraintsPlainVanilla() const {
+  for (auto const &item: constraints) {
+    errs() << item.getType() << " " << item.getDest() << " " << item.getSrc() << " 0\n";
+  }
+}
+
+void Andersen::dumpPtsGraphPlainVanilla() const {
+  for (unsigned i = 0, e = nodeFactory.getNumNodes(); i < e; ++i) {
+    NodeIndex rep = nodeFactory.getMergeTarget(i);
+    auto ptsItr = ptsGraph.find(rep);
+    if (ptsItr != ptsGraph.end()) {
+      errs() << i << " ";
+      for (auto v: ptsItr->second)
+        errs() << v << " ";
+      errs() << "\n";
+    }
+  }
+}
+
+void Andersen::setType(const llvm::Value *V, llvm::StringRef Typename) {
+  if (!Typename.size())
+    return;
+  typeLock.lock();
+  assert(V && Typename.size());
+  V = (Value *) nodeFactory.getAbstractLocation(V);
+  ObjectTypes[V].insert(Typename.str());
+  typeLock.unlock();
+}
+
+bool Andersen::getType(const llvm::Value *V, StringSet_t &Typename) {
+  std::map<const Value *, StringSet_t>::iterator O_it = ObjectTypes.find(V);
+  if (O_it == ObjectTypes.end())
+    return false;
+  Typename = O_it->second;
+  return true;
+}
+
+char Andersen::ID = 0;
+
+static RegisterPass<Andersen> X("anders", "Andersen's inclusion-based points-to analysis", true, true);
diff --git a/lib/Analysis/Andersen/AndersenAA.cpp b/lib/Analysis/Andersen/AndersenAA.cpp
new file mode 100644
index 0000000..ba297aa
--- /dev/null
+++ b/lib/Analysis/Andersen/AndersenAA.cpp
@@ -0,0 +1,152 @@
+#include <llvm/Target/TargetMachine.h>
+#include "llvm/Analysis/Andersen/AndersenAA.h"
+
+#include "llvm/IR/Module.h"
+
+using namespace llvm;
+
+static inline bool isSetContainingOnly(const AndersPtsSet& set, NodeIndex i)
+{
+	return (set.getSize() == 1) && (*set.begin() == i);
+}
+
+llvm::AliasResult AndersenAA::andersenAlias(const llvm::Value* v1, const llvm::Value* v2)
+{
+	NodeIndex n1 = (anders->nodeFactory).getMergeTarget((anders->nodeFactory).getValueNodeFor(v1));
+	NodeIndex n2 = (anders->nodeFactory).getMergeTarget((anders->nodeFactory).getValueNodeFor(v2));
+
+	if (n1 == n2)
+		return llvm::MustAlias;
+
+	auto itr1 = (anders->ptsGraph).find(n1), itr2 = (anders->ptsGraph).find(n2);
+	if (itr1 == (anders->ptsGraph).end() || itr2 == (anders->ptsGraph).end())
+		// We knows nothing about at least one of (v1, v2)
+		return llvm::MayAlias;
+
+	AndersPtsSet& s1 = itr1->second, s2 = itr2->second;
+	bool isNull1 = isSetContainingOnly(s1, (anders->nodeFactory).getNullObjectNode());
+	bool isNull2 = isSetContainingOnly(s2, (anders->nodeFactory).getNullObjectNode());
+	if (isNull1 || isNull2)
+		// If any of them is null, we know that they must not alias each other
+		return llvm::NoAlias;
+
+	if (s1.getSize() == 1 && s2.getSize() == 1 && *s1.begin() == *s2.begin())
+		return llvm::MustAlias;
+
+	// Compute the intersection of s1 and s2
+	for (auto const& idx: s1)
+	{
+		if (idx == (anders->nodeFactory).getNullObjectNode())
+			continue;
+		if (s2.has(idx))
+			return llvm::MayAlias;
+	}
+
+	return llvm::NoAlias;
+}
+
+llvm::AliasResult AndersenAA::alias(const MemoryLocation& l1, const MemoryLocation& l2)
+{
+	if (l1.Size == 0 || l2.Size == 0)
+		return NoAlias;
+
+	const Value* v1 = (l1.Ptr)->stripPointerCasts();
+	const Value* v2 = (l2.Ptr)->stripPointerCasts();
+
+	if (!v1->getType()->isPointerTy() || !v2->getType()->isPointerTy())
+		return NoAlias;
+
+	if (v1 == v2)
+		return MustAlias;
+
+	AliasResult andersResult = andersenAlias(v1, v2);
+	if (andersResult != MayAlias)
+		return andersResult;
+	else
+		return AliasAnalysis::alias(l1, l2);
+}
+
+void AndersenAA::deleteValue(llvm::Value* v)
+{
+	(anders->nodeFactory).removeNodeForValue(v);
+}
+
+void AndersenAA::copyValue(llvm::Value* from, llvm::Value* to)
+{
+	NodeIndex fromNode = (anders->nodeFactory).getValueNodeFor(from);
+	if (fromNode == AndersNodeFactory::InvalidIndex)
+		return;
+
+	NodeIndex toNode = (anders->nodeFactory).getValueNodeFor(to);
+	if (toNode == AndersNodeFactory::InvalidIndex)
+		toNode = (anders->nodeFactory).createValueNode(to);
+
+	auto fromItr = (anders->ptsGraph).find(fromNode);
+	if (fromItr == (anders->ptsGraph).end())
+		return;
+
+	(anders->ptsGraph)[toNode] = fromItr->second;
+}
+
+bool AndersenAA::pointsToConstantMemory(const MemoryLocation& loc, bool orLocal)
+{
+	NodeIndex node = (anders->nodeFactory).getValueNodeFor(loc.Ptr);
+	if (node == AndersNodeFactory::InvalidIndex)
+		return AliasAnalysis::pointsToConstantMemory(loc, orLocal);
+
+	auto itr = (anders->ptsGraph).find(node);
+	if (itr == (anders->ptsGraph).end())
+		// Not a pointer?
+		return AliasAnalysis::pointsToConstantMemory(loc, orLocal);
+
+	const AndersPtsSet& ptsSet = itr->second;
+	for (auto const& idx: ptsSet)
+	{
+		if (const Value* val = (anders->nodeFactory).getValueForNode(idx))
+		{
+			if (!isa<GlobalValue>(val) || (isa<GlobalVariable>(val) && !cast<GlobalVariable>(val)->isConstant()))
+        		return AliasAnalysis::pointsToConstantMemory(loc, orLocal);
+		}
+		else
+		{
+			if (idx != (anders->nodeFactory).getNullObjectNode())
+				return AliasAnalysis::pointsToConstantMemory(loc, orLocal);
+		}
+	}
+
+	return true;
+}
+
+//void AndersenAA::getAnalysisUsage(AnalysisUsage &AU) const
+//{
+//    ModulePass::getAnalysisUsage(AU);
+////	AliasAnalysis::getAnalysisUsage(AU);
+//	AU.addRequired<Andersen>();
+////	AU.addRequired<DataLayoutPass>();
+//	AU.setPreservesAll();
+//}
+
+//void* AndersenAA::getAdjustedAnalysisPointer(AnalysisID PI)
+//{
+//	if (PI == &ID)
+//		return (AliasAnalysis *)this;
+//	return this;
+//}
+
+bool AndersenAA::runOnModule(Module &M)
+{
+//	InitializeAliasAnalysis(this);
+
+	anders = &getAnalysis<Andersen>();
+    //FIXME:
+//	dataLayout = &(getAnalysis<DataLayoutPass>().getDataLayout());
+
+
+	return false;
+}
+
+
+
+char AndersenAA::ID = 0;
+//static RegisterPass<AndersenAA> X("anders-aa", "Andersen Alias Analysis", true, true);
+//static RegisterAnalysisGroup<AliasAnalysis> Y(X);
diff --git a/lib/Analysis/Andersen/CMakeLists.txt b/lib/Analysis/Andersen/CMakeLists.txt
new file mode 100644
index 0000000..5bdcd0b
--- /dev/null
+++ b/lib/Analysis/Andersen/CMakeLists.txt
@@ -0,0 +1,24 @@
+file(GLOB CallHandlerSRC
+        "CallHandler/*.cpp"
+        )
+
+add_llvm_loadable_module(LLVMStackAccessPass
+        DetectParametersPass.cpp
+        Andersen.cpp
+        AndersenAA.cpp
+        ConstraintCollect.cpp
+        ConstraintOptimize.cpp
+        ConstraintSolving.cpp
+        ExternalLibrary.cpp
+        NodeFactory.cpp
+        StackAccessPass.cpp
+        ObjectiveCBinary.cpp
+        ObjectiveCClassInfo.cpp
+        ObjCCallHandler.cpp
+        CallHandler/ObjCRuntimeCallHandler.cpp
+        NonVolatileRegistersPass.cpp
+        CleanUpPass.cpp
+        SimpleCallGraph.cpp
+        )
+
+add_dependencies(LLVMStackAccessPass LLVMAnalysis Object)
diff --git a/lib/Analysis/Andersen/CallHandler/ExternalHandler.h b/lib/Analysis/Andersen/CallHandler/ExternalHandler.h
new file mode 100644
index 0000000..ccfcb12
--- /dev/null
+++ b/lib/Analysis/Andersen/CallHandler/ExternalHandler.h
@@ -0,0 +1,3575 @@
+#ifndef LLVM_EXTERNALHANDLER_H
+#define LLVM_EXTERNALHANDLER_H
+
+namespace llvm {
+    namespace pointsto {
+namespace {
+int translateRegister(std::string RegName) {
+  if (RegName == "X0") 
+    return 5;
+  if (RegName == "X1") 
+    return 6;
+  if (RegName == "X2") 
+    return 7;
+  if (RegName == "X3") 
+    return 8;
+  if (RegName == "X4") 
+    return 9;
+  if (RegName == "X5") 
+    return 10;
+  if (RegName == "X6") 
+    return 11;
+  if (RegName == "X7") 
+    return 12;
+  llvm_unreachable("Unknown Register");
+}
+}
+void anonymous_1005(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "malloc"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1008(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSFileHandle fileHandleForReadingAtPath:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSFileHandle");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1019(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSFileHandle readDataOfLength:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1030(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[UITextField text]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1036(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[UITextView text]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1042(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[UILabel text]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1048(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString stringByTrimmingCharactersInSet:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1057(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString stringByAppendingString:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_106(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSData dataWithContentsOfURL:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1069(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString componentsSeparatedByString:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSArray");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_1081(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[UIView initWithFrame:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_1088(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[UIViewController initWithNibName:bundle:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_1095(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSNull null]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSNull");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1098(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[UIApplication sharedApplication]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "UIApplication");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1101(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSUserDefaults objectForKey:]"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_1108(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSUserDefaults setObject:forKey:]"
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_1115(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSKeyedArchiver archivedDataWithRootObject:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1121(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[UIAlertView textFieldAtIndex:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "UITextField");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_1127(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSDictionary objectForKey:]"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_1131(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSDictionary setObject:forKey:]"
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_1138(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSDictionary valueForKey:]"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_1142(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSDictionary setValue:forKey:]"
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_119(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSData dataWithData:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_132(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData mutableCopy]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_145(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData isEqual:]"
+}
+
+void anonymous_148(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData writeToFile:options:error:]"
+}
+
+void anonymous_149(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData dataWithBytes:length:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_162(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData data]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_17(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_autoreleaseReturnValue"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_170(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData dataWithBytesNoCopy:length:freeWhenDone:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_18(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_autorelease"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_183(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData dataWithContentsOfFile:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_19(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_retainAutoreleasedReturnValue"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_196(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData dataWithContentsOfFile:options:error:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_20(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_retainAutoreleaseReturnValue"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_209(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData dataWithContentsOfURL:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_21(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_retainAutorelease"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_22(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSObject retain]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_222(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData dataWithData:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_23(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSObject autorelease]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_235(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData dataWithCapacity:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_24(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_release"
+}
+
+void anonymous_243(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableData dataWithLength:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_25(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSObject release]"
+}
+
+void anonymous_251(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSMutableData mutableBytes]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_26(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSObject dealloc]"
+}
+
+void anonymous_260(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString string]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_266(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString stringWithString:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_27(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSObject respondsToSelector:]"
+}
+
+void anonymous_277(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString stringWithCString:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_288(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString stringWithCharacters:length:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_299(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString initWithData:encoding:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_311(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString initWithString:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_323(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString getCString:maxLength:encoding:]"
+{ //Check object
+DetectParametersPass::UserSet_t Reg = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+  for (auto Post_it = Reg.begin(); Post_it != Reg.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+if (objIndex != AndersNodeFactory::InvalidIndex)
+continue;    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNodeDummy(*Post_it, *CallInst->getParent()->getParent()->getParent());
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_33(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSData dataWithBytes:length:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_332(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]"
+{ //Check object
+DetectParametersPass::UserSet_t Reg = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+  for (auto Post_it = Reg.begin(); Post_it != Reg.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+if (objIndex != AndersNodeFactory::InvalidIndex)
+continue;    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNodeDummy(*Post_it, *CallInst->getParent()->getParent()->getParent());
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_341(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString cStringUsingEncoding:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_350(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString lowercaseString]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_361(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableString stringWithString:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_372(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableString stringWithCharacters:length:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_383(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSDictionary dictionaryWithContentsOfFile:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_389(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSDictionary dictionaryWithObject:forKey:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_398(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSDictionary dictionaryWithObjectsAndKeys:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_404(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSDictionary dictionary]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_410(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSDictionary dictionaryWithDictionary:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_416(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSDictionary dictionaryWithObjects:forKeys:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_422(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSDictionary dictionaryWithObjects:forKeys:count:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_428(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSDictionary initWithObjectsAndKeys:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_435(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSDictionary objectForKey:]"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_442(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSDictionary valueForKey:]"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_449(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableDictionary dictionaryWithContentsOfFile:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_455(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableDictionary dictionaryWithObject:forKey:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_46(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSData dataWithBytesNoCopy:length:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_464(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableDictionary dictionaryWithObjectsAndKeys:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_470(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableDictionary dictionary]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_476(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableDictionary dictionaryWithDictionary:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableDictionary");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_482(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSJSONSerialization dataWithJSONObject:options:error:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_488(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData bytes]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_500(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData getBytes:range:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_517(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData getBytes:length:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_537(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData subdataWithRange:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_550(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSMutableData setLength:]"
+}
+
+void anonymous_553(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSMutableData appendData:]"
+}
+
+void anonymous_565(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSMutableData appendBytes:length:]"
+}
+
+void anonymous_577(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData length]"
+}
+
+void anonymous_580(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString dataUsingEncoding:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_59(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSData data]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_593(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "memcpy"
+{ //Check object
+DetectParametersPass::UserSet_t Reg = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Reg.begin(); Post_it != Reg.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+if (objIndex != AndersNodeFactory::InvalidIndex)
+continue;    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNodeDummy(*Post_it, *CallInst->getParent()->getParent()->getParent());
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_604(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CCKeyDerivationPBKDF"
+{ //Check object
+DetectParametersPass::UserSet_t Reg = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X7"), CallInst);
+  for (auto Post_it = Reg.begin(); Post_it != Reg.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+if (objIndex != AndersNodeFactory::InvalidIndex)
+continue;    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNodeDummy(*Post_it, *CallInst->getParent()->getParent()->getParent());
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_621(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CCCalibratePBKDF"
+}
+
+void anonymous_626(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CCCryptorCreate"
+}
+
+void anonymous_627(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CCCryptorCreateWithMode"
+}
+
+void anonymous_631(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CCCrypt"
+}
+
+void anonymous_632(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CCCryptorUpdate"
+}
+
+void anonymous_645(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_setProperty_nonatomic_copy"
+}
+
+void anonymous_654(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_getProperty"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_668(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_setProperty_nonatomic"
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_67(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSData dataWithBytesNoCopy:length:freeWhenDone:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_680(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_setProperty_atomic"
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_692(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_setProperty"
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_704(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_loadWeakRetained"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_718(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString UTF8String]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "char");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_731(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSArray arrayWithArray:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSArray");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_734(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSArray arrayWithObject:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSArray");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_735(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSArray arrayWithObjects:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSArray");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_736(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSArray array]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSArray");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_737(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSArray objectAtIndex:]"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_747(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSArray objectAtIndexedSubscript:]"
+{ //Load operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);
+    }
+  }
+}
+}
+
+void anonymous_757(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableString stringWithCapacity:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_763(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableString stringWithUTF8String:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_764(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSMutableString string]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_765(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString stringWithCString:encoding:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_771(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString stringWithContentsOfFile:encoding:error:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_772(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString stringWithFormat:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_773(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString stringWithUTF8String:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_774(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSString stringWithCString:encoding:]"
+}
+
+void anonymous_781(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSObject init]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_788(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSMutableData init]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_789(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData initWithBytes:length:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_790(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData initWithBase64EncodedData:options:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_791(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData initWithContentsOfFile:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_792(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData initWithData:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_793(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData init]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_794(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData initWithBase64EncodedString:options:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_795(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString initWithBytes:length:encoding:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_796(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString initWithData:encoding:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_797(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString initWithFormat:]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_798(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSMutableDictionary init]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_799(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSDictionary init]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_8(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_retain"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_80(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSData dataWithContentsOfFile:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_800(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[UITableViewController init]"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_801(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData initWithBytes:length:]"
+}
+
+void anonymous_810(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData initWithBase64EncodedString:options:]"
+}
+
+void anonymous_816(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString copy]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_825(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSMutableString copy]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSMutableString");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_834(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSData copy]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_843(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CC_SHA256_Init"
+}
+
+void anonymous_847(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CC_SHA256_Update"
+}
+
+void anonymous_857(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CC_SHA256_Final"
+}
+
+void anonymous_864(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "arc4random"
+}
+
+void anonymous_870(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "SecRandomCopyBytes"
+{ //Check object
+DetectParametersPass::UserSet_t Reg = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), CallInst);
+  for (auto Post_it = Reg.begin(); Post_it != Reg.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+if (objIndex != AndersNodeFactory::InvalidIndex)
+continue;    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNodeDummy(*Post_it, *CallInst->getParent()->getParent()->getParent());
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_878(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_storeStrong"
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_888(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_storeWeak"
+{ //Store operation
+DetectParametersPass::UserSet_t Vals = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), CallInst);
+DetectParametersPass::UserSet_t Locs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {
+    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);
+    if (valIdx == AndersNodeFactory::InvalidIndex)
+      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);
+    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {
+      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);
+      if (locIdx == AndersNodeFactory::InvalidIndex)
+        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);
+      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);
+    }
+  }
+}
+}
+
+void anonymous_898(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_getClass"
+{ //Copy operation
+DetectParametersPass::UserSet_t From = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+DetectParametersPass::UserSet_t To = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {
+    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);
+    if (srcIdx == AndersNodeFactory::InvalidIndex)
+      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);
+    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {
+      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);
+      if (dstIdx == AndersNodeFactory::InvalidIndex)
+        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);
+      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+    }
+  }
+} //end copy
+}
+
+void anonymous_907(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "bzero"
+{ //Check object
+DetectParametersPass::UserSet_t Reg = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Reg.begin(); Post_it != Reg.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+if (objIndex != AndersNodeFactory::InvalidIndex)
+continue;    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNodeDummy(*Post_it, *CallInst->getParent()->getParent()->getParent());
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_915(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSBundle bundleWithPath:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSBundle");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_923(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSBundle bundleForClass:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSBundle");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_924(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSBundle mainBundle]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSBundle");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_925(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "NSLog"
+}
+
+void anonymous_926(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "__stack_chk_fail"
+}
+
+void anonymous_927(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_enumerationMutation"
+}
+
+void anonymous_928(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_terminate"
+}
+
+void anonymous_929(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_sync_exit"
+}
+
+void anonymous_93(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSData dataWithContentsOfFile:options:error:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSData");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_930(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_sync_enter"
+}
+
+void anonymous_931(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_exception_rethrow"
+}
+
+void anonymous_932(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_exception_throw"
+}
+
+void anonymous_933(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_destroyWeak"
+}
+
+void anonymous_934(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_end_catch"
+}
+
+void anonymous_935(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "objc_begin_catch"
+}
+
+void anonymous_936(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "_Znam"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_941(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "_Znwm"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_946(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "_ZnwmRKSt9nothrow_t"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_951(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CC_MD5"
+}
+
+void anonymous_958(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "CC_SHA256"
+}
+
+void anonymous_965(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "read"
+}
+
+void anonymous_971(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "open"
+}
+
+void anonymous_977(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "+[NSNumber numberWithInt:]"
+{ //Alloc operation
+DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), CallInst);
+  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);
+    if (valIndex == AndersNodeFactory::InvalidIndex)
+      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);
+    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);
+    if (objIndex == AndersNodeFactory::InvalidIndex)
+      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);
+    andersen->setType(*Post_it, "NSNumber");
+    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+  }
+}
+}
+
+void anonymous_987(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSNumber integerValue]"
+}
+
+void anonymous_993(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString intValue]"
+}
+
+void anonymous_999(llvm::Instruction *CallInst, Andersen *andersen) {
+//Handle "-[NSString integerValue]"
+}
+
+bool canHandleCall(const std::string &FName) {
+  if (FName == "+[NSArray arrayWithArray:]")
+    return true;
+  if (FName == "+[NSArray arrayWithObject:]")
+    return true;
+  if (FName == "+[NSArray arrayWithObjects:]")
+    return true;
+  if (FName == "+[NSArray array]")
+    return true;
+  if (FName == "+[NSBundle bundleForClass:]")
+    return true;
+  if (FName == "+[NSBundle bundleWithPath:]")
+    return true;
+  if (FName == "+[NSBundle mainBundle]")
+    return true;
+  if (FName == "+[NSData dataWithBytes:length:]")
+    return true;
+  if (FName == "+[NSData dataWithBytesNoCopy:length:]")
+    return true;
+  if (FName == "+[NSData dataWithBytesNoCopy:length:freeWhenDone:]")
+    return true;
+  if (FName == "+[NSData dataWithContentsOfFile:]")
+    return true;
+  if (FName == "+[NSData dataWithContentsOfFile:options:error:]")
+    return true;
+  if (FName == "+[NSData dataWithContentsOfURL:]")
+    return true;
+  if (FName == "+[NSData dataWithData:]")
+    return true;
+  if (FName == "+[NSData data]")
+    return true;
+  if (FName == "+[NSDictionary dictionaryWithContentsOfFile:]")
+    return true;
+  if (FName == "+[NSDictionary dictionaryWithDictionary:]")
+    return true;
+  if (FName == "+[NSDictionary dictionaryWithObject:forKey:]")
+    return true;
+  if (FName == "+[NSDictionary dictionaryWithObjects:forKeys:]")
+    return true;
+  if (FName == "+[NSDictionary dictionaryWithObjects:forKeys:count:]")
+    return true;
+  if (FName == "+[NSDictionary dictionaryWithObjectsAndKeys:]")
+    return true;
+  if (FName == "+[NSDictionary dictionary]")
+    return true;
+  if (FName == "+[NSFileHandle fileHandleForReadingAtPath:]")
+    return true;
+  if (FName == "+[NSJSONSerialization dataWithJSONObject:options:error:]")
+    return true;
+  if (FName == "+[NSKeyedArchiver archivedDataWithRootObject:]")
+    return true;
+  if (FName == "+[NSMutableData dataWithBytes:length:]")
+    return true;
+  if (FName == "+[NSMutableData dataWithBytesNoCopy:length:freeWhenDone:]")
+    return true;
+  if (FName == "+[NSMutableData dataWithCapacity:]")
+    return true;
+  if (FName == "+[NSMutableData dataWithContentsOfFile:]")
+    return true;
+  if (FName == "+[NSMutableData dataWithContentsOfFile:options:error:]")
+    return true;
+  if (FName == "+[NSMutableData dataWithContentsOfURL:]")
+    return true;
+  if (FName == "+[NSMutableData dataWithData:]")
+    return true;
+  if (FName == "+[NSMutableData dataWithLength:]")
+    return true;
+  if (FName == "+[NSMutableData data]")
+    return true;
+  if (FName == "+[NSMutableDictionary dictionaryWithContentsOfFile:]")
+    return true;
+  if (FName == "+[NSMutableDictionary dictionaryWithDictionary:]")
+    return true;
+  if (FName == "+[NSMutableDictionary dictionaryWithObject:forKey:]")
+    return true;
+  if (FName == "+[NSMutableDictionary dictionaryWithObjectsAndKeys:]")
+    return true;
+  if (FName == "+[NSMutableDictionary dictionary]")
+    return true;
+  if (FName == "+[NSMutableString stringWithCapacity:]")
+    return true;
+  if (FName == "+[NSMutableString stringWithCharacters:length:]")
+    return true;
+  if (FName == "+[NSMutableString stringWithString:]")
+    return true;
+  if (FName == "+[NSMutableString stringWithUTF8String:]")
+    return true;
+  if (FName == "+[NSMutableString string]")
+    return true;
+  if (FName == "+[NSNull null]")
+    return true;
+  if (FName == "+[NSNumber numberWithInt:]")
+    return true;
+  if (FName == "+[NSString stringWithCString:]")
+    return true;
+  if (FName == "+[NSString stringWithCString:encoding:]")
+    return true;
+  if (FName == "+[NSString stringWithCharacters:length:]")
+    return true;
+  if (FName == "+[NSString stringWithContentsOfFile:encoding:error:]")
+    return true;
+  if (FName == "+[NSString stringWithFormat:]")
+    return true;
+  if (FName == "+[NSString stringWithString:]")
+    return true;
+  if (FName == "+[NSString stringWithUTF8String:]")
+    return true;
+  if (FName == "+[NSString string]")
+    return true;
+  if (FName == "+[UIApplication sharedApplication]")
+    return true;
+  if (FName == "-[NSArray objectAtIndex:]")
+    return true;
+  if (FName == "-[NSArray objectAtIndexedSubscript:]")
+    return true;
+  if (FName == "-[NSData bytes]")
+    return true;
+  if (FName == "-[NSData copy]")
+    return true;
+  if (FName == "-[NSData getBytes:length:]")
+    return true;
+  if (FName == "-[NSData getBytes:range:]")
+    return true;
+  if (FName == "-[NSData initWithBase64EncodedData:options:]")
+    return true;
+  if (FName == "-[NSData initWithBase64EncodedString:options:]")
+    return true;
+  if (FName == "-[NSData initWithBytes:length:]")
+    return true;
+  if (FName == "-[NSData initWithContentsOfFile:]")
+    return true;
+  if (FName == "-[NSData initWithData:]")
+    return true;
+  if (FName == "-[NSData init]")
+    return true;
+  if (FName == "-[NSData isEqual:]")
+    return true;
+  if (FName == "-[NSData length]")
+    return true;
+  if (FName == "-[NSData mutableCopy]")
+    return true;
+  if (FName == "-[NSData subdataWithRange:]")
+    return true;
+  if (FName == "-[NSData writeToFile:options:error:]")
+    return true;
+  if (FName == "-[NSDictionary initWithObjectsAndKeys:]")
+    return true;
+  if (FName == "-[NSDictionary init]")
+    return true;
+  if (FName == "-[NSDictionary objectForKey:]")
+    return true;
+  if (FName == "-[NSDictionary setObject:forKey:]")
+    return true;
+  if (FName == "-[NSDictionary setValue:forKey:]")
+    return true;
+  if (FName == "-[NSDictionary valueForKey:]")
+    return true;
+  if (FName == "-[NSFileHandle readDataOfLength:]")
+    return true;
+  if (FName == "-[NSMutableData appendBytes:length:]")
+    return true;
+  if (FName == "-[NSMutableData appendData:]")
+    return true;
+  if (FName == "-[NSMutableData init]")
+    return true;
+  if (FName == "-[NSMutableData mutableBytes]")
+    return true;
+  if (FName == "-[NSMutableData setLength:]")
+    return true;
+  if (FName == "-[NSMutableDictionary init]")
+    return true;
+  if (FName == "-[NSMutableString copy]")
+    return true;
+  if (FName == "-[NSNumber integerValue]")
+    return true;
+  if (FName == "-[NSObject autorelease]")
+    return true;
+  if (FName == "-[NSObject dealloc]")
+    return true;
+  if (FName == "-[NSObject init]")
+    return true;
+  if (FName == "-[NSObject release]")
+    return true;
+  if (FName == "-[NSObject respondsToSelector:]")
+    return true;
+  if (FName == "-[NSObject retain]")
+    return true;
+  if (FName == "-[NSString UTF8String]")
+    return true;
+  if (FName == "-[NSString cStringUsingEncoding:]")
+    return true;
+  if (FName == "-[NSString componentsSeparatedByString:]")
+    return true;
+  if (FName == "-[NSString copy]")
+    return true;
+  if (FName == "-[NSString dataUsingEncoding:]")
+    return true;
+  if (FName == "-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]")
+    return true;
+  if (FName == "-[NSString getCString:maxLength:encoding:]")
+    return true;
+  if (FName == "-[NSString initWithBytes:length:encoding:]")
+    return true;
+  if (FName == "-[NSString initWithData:encoding:]")
+    return true;
+  if (FName == "-[NSString initWithFormat:]")
+    return true;
+  if (FName == "-[NSString initWithString:]")
+    return true;
+  if (FName == "-[NSString intValue]")
+    return true;
+  if (FName == "-[NSString integerValue]")
+    return true;
+  if (FName == "-[NSString lowercaseString]")
+    return true;
+  if (FName == "-[NSString stringByAppendingString:]")
+    return true;
+  if (FName == "-[NSString stringByTrimmingCharactersInSet:]")
+    return true;
+  if (FName == "-[NSUserDefaults objectForKey:]")
+    return true;
+  if (FName == "-[NSUserDefaults setObject:forKey:]")
+    return true;
+  if (FName == "-[UIAlertView textFieldAtIndex:]")
+    return true;
+  if (FName == "-[UILabel text]")
+    return true;
+  if (FName == "-[UITableViewController init]")
+    return true;
+  if (FName == "-[UITextField text]")
+    return true;
+  if (FName == "-[UITextView text]")
+    return true;
+  if (FName == "-[UIView initWithFrame:]")
+    return true;
+  if (FName == "-[UIViewController initWithNibName:bundle:]")
+    return true;
+  if (FName == "CCCalibratePBKDF")
+    return true;
+  if (FName == "CCCrypt")
+    return true;
+  if (FName == "CCCryptorCreate")
+    return true;
+  if (FName == "CCCryptorCreateWithMode")
+    return true;
+  if (FName == "CCCryptorUpdate")
+    return true;
+  if (FName == "CCKeyDerivationPBKDF")
+    return true;
+  if (FName == "CC_MD5")
+    return true;
+  if (FName == "CC_SHA256")
+    return true;
+  if (FName == "CC_SHA256_Final")
+    return true;
+  if (FName == "CC_SHA256_Init")
+    return true;
+  if (FName == "CC_SHA256_Update")
+    return true;
+  if (FName == "NSLog")
+    return true;
+  if (FName == "SecRandomCopyBytes")
+    return true;
+  if (FName == "_Znam")
+    return true;
+  if (FName == "_Znwm")
+    return true;
+  if (FName == "_ZnwmRKSt9nothrow_t")
+    return true;
+  if (FName == "__stack_chk_fail")
+    return true;
+  if (FName == "arc4random")
+    return true;
+  if (FName == "bzero")
+    return true;
+  if (FName == "malloc")
+    return true;
+  if (FName == "memcpy")
+    return true;
+  if (FName == "objc_autorelease")
+    return true;
+  if (FName == "objc_autoreleaseReturnValue")
+    return true;
+  if (FName == "objc_begin_catch")
+    return true;
+  if (FName == "objc_destroyWeak")
+    return true;
+  if (FName == "objc_end_catch")
+    return true;
+  if (FName == "objc_enumerationMutation")
+    return true;
+  if (FName == "objc_exception_rethrow")
+    return true;
+  if (FName == "objc_exception_throw")
+    return true;
+  if (FName == "objc_getClass")
+    return true;
+  if (FName == "objc_getProperty")
+    return true;
+  if (FName == "objc_loadWeakRetained")
+    return true;
+  if (FName == "objc_release")
+    return true;
+  if (FName == "objc_retain")
+    return true;
+  if (FName == "objc_retainAutorelease")
+    return true;
+  if (FName == "objc_retainAutoreleaseReturnValue")
+    return true;
+  if (FName == "objc_retainAutoreleasedReturnValue")
+    return true;
+  if (FName == "objc_setProperty")
+    return true;
+  if (FName == "objc_setProperty_atomic")
+    return true;
+  if (FName == "objc_setProperty_nonatomic")
+    return true;
+  if (FName == "objc_setProperty_nonatomic_copy")
+    return true;
+  if (FName == "objc_storeStrong")
+    return true;
+  if (FName == "objc_storeWeak")
+    return true;
+  if (FName == "objc_sync_enter")
+    return true;
+  if (FName == "objc_sync_exit")
+    return true;
+  if (FName == "objc_terminate")
+    return true;
+  if (FName == "open")
+    return true;
+  if (FName == "read")
+    return true;
+  return false;
+}
+
+bool handleCall(llvm::Instruction *CallInst, Andersen *andersen, const std::string &FName) {
+  if (FName == "+[NSArray arrayWithArray:]") {
+    anonymous_731(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSArray arrayWithObject:]") {
+    anonymous_734(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSArray arrayWithObjects:]") {
+    anonymous_735(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSArray array]") {
+    anonymous_736(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSBundle bundleForClass:]") {
+    anonymous_923(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSBundle bundleWithPath:]") {
+    anonymous_915(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSBundle mainBundle]") {
+    anonymous_924(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytes:length:]") {
+    anonymous_33(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytesNoCopy:length:]") {
+    anonymous_46(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytesNoCopy:length:freeWhenDone:]") {
+    anonymous_67(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfFile:]") {
+    anonymous_80(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfFile:options:error:]") {
+    anonymous_93(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfURL:]") {
+    anonymous_106(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSData dataWithData:]") {
+    anonymous_119(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSData data]") {
+    anonymous_59(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithContentsOfFile:]") {
+    anonymous_383(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithDictionary:]") {
+    anonymous_410(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObject:forKey:]") {
+    anonymous_389(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjects:forKeys:]") {
+    anonymous_416(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjects:forKeys:count:]") {
+    anonymous_422(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjectsAndKeys:]") {
+    anonymous_398(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionary]") {
+    anonymous_404(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSFileHandle fileHandleForReadingAtPath:]") {
+    anonymous_1008(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSJSONSerialization dataWithJSONObject:options:error:]") {
+    anonymous_482(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSKeyedArchiver archivedDataWithRootObject:]") {
+    anonymous_1115(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithBytes:length:]") {
+    anonymous_149(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithBytesNoCopy:length:freeWhenDone:]") {
+    anonymous_170(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithCapacity:]") {
+    anonymous_235(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfFile:]") {
+    anonymous_183(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfFile:options:error:]") {
+    anonymous_196(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfURL:]") {
+    anonymous_209(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithData:]") {
+    anonymous_222(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithLength:]") {
+    anonymous_243(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableData data]") {
+    anonymous_162(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithContentsOfFile:]") {
+    anonymous_449(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithDictionary:]") {
+    anonymous_476(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithObject:forKey:]") {
+    anonymous_455(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithObjectsAndKeys:]") {
+    anonymous_464(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionary]") {
+    anonymous_470(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithCapacity:]") {
+    anonymous_757(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithCharacters:length:]") {
+    anonymous_372(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithString:]") {
+    anonymous_361(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithUTF8String:]") {
+    anonymous_763(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSMutableString string]") {
+    anonymous_764(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSNull null]") {
+    anonymous_1095(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSNumber numberWithInt:]") {
+    anonymous_977(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCString:]") {
+    anonymous_277(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCString:encoding:]") {
+    anonymous_765(CallInst, andersen);
+    anonymous_774(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCharacters:length:]") {
+    anonymous_288(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSString stringWithContentsOfFile:encoding:error:]") {
+    anonymous_771(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSString stringWithFormat:]") {
+    anonymous_772(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSString stringWithString:]") {
+    anonymous_266(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSString stringWithUTF8String:]") {
+    anonymous_773(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[NSString string]") {
+    anonymous_260(CallInst, andersen);
+    return true;
+  }
+  if (FName == "+[UIApplication sharedApplication]") {
+    anonymous_1098(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSArray objectAtIndex:]") {
+    anonymous_737(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSArray objectAtIndexedSubscript:]") {
+    anonymous_747(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData bytes]") {
+    anonymous_488(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData copy]") {
+    anonymous_834(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData getBytes:length:]") {
+    anonymous_517(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData getBytes:range:]") {
+    anonymous_500(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData initWithBase64EncodedData:options:]") {
+    anonymous_790(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData initWithBase64EncodedString:options:]") {
+    anonymous_794(CallInst, andersen);
+    anonymous_810(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData initWithBytes:length:]") {
+    anonymous_789(CallInst, andersen);
+    anonymous_801(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData initWithContentsOfFile:]") {
+    anonymous_791(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData initWithData:]") {
+    anonymous_792(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData init]") {
+    anonymous_793(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData isEqual:]") {
+    anonymous_145(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData length]") {
+    anonymous_577(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData mutableCopy]") {
+    anonymous_132(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData subdataWithRange:]") {
+    anonymous_537(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSData writeToFile:options:error:]") {
+    anonymous_148(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSDictionary initWithObjectsAndKeys:]") {
+    anonymous_428(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSDictionary init]") {
+    anonymous_799(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSDictionary objectForKey:]") {
+    anonymous_1127(CallInst, andersen);
+    anonymous_435(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSDictionary setObject:forKey:]") {
+    anonymous_1131(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSDictionary setValue:forKey:]") {
+    anonymous_1142(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSDictionary valueForKey:]") {
+    anonymous_1138(CallInst, andersen);
+    anonymous_442(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSFileHandle readDataOfLength:]") {
+    anonymous_1019(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSMutableData appendBytes:length:]") {
+    anonymous_565(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSMutableData appendData:]") {
+    anonymous_553(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSMutableData init]") {
+    anonymous_788(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSMutableData mutableBytes]") {
+    anonymous_251(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSMutableData setLength:]") {
+    anonymous_550(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSMutableDictionary init]") {
+    anonymous_798(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSMutableString copy]") {
+    anonymous_825(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSNumber integerValue]") {
+    anonymous_987(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSObject autorelease]") {
+    anonymous_23(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSObject dealloc]") {
+    anonymous_26(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSObject init]") {
+    anonymous_781(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSObject release]") {
+    anonymous_25(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSObject respondsToSelector:]") {
+    anonymous_27(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSObject retain]") {
+    anonymous_22(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString UTF8String]") {
+    anonymous_718(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString cStringUsingEncoding:]") {
+    anonymous_341(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString componentsSeparatedByString:]") {
+    anonymous_1069(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString copy]") {
+    anonymous_816(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString dataUsingEncoding:]") {
+    anonymous_580(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]") {
+    anonymous_332(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString getCString:maxLength:encoding:]") {
+    anonymous_323(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString initWithBytes:length:encoding:]") {
+    anonymous_795(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString initWithData:encoding:]") {
+    anonymous_299(CallInst, andersen);
+    anonymous_796(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString initWithFormat:]") {
+    anonymous_797(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString initWithString:]") {
+    anonymous_311(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString intValue]") {
+    anonymous_993(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString integerValue]") {
+    anonymous_999(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString lowercaseString]") {
+    anonymous_350(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString stringByAppendingString:]") {
+    anonymous_1057(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSString stringByTrimmingCharactersInSet:]") {
+    anonymous_1048(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSUserDefaults objectForKey:]") {
+    anonymous_1101(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[NSUserDefaults setObject:forKey:]") {
+    anonymous_1108(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[UIAlertView textFieldAtIndex:]") {
+    anonymous_1121(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[UILabel text]") {
+    anonymous_1042(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[UITableViewController init]") {
+    anonymous_800(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[UITextField text]") {
+    anonymous_1030(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[UITextView text]") {
+    anonymous_1036(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[UIView initWithFrame:]") {
+    anonymous_1081(CallInst, andersen);
+    return true;
+  }
+  if (FName == "-[UIViewController initWithNibName:bundle:]") {
+    anonymous_1088(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CCCalibratePBKDF") {
+    anonymous_621(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CCCrypt") {
+    anonymous_631(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CCCryptorCreate") {
+    anonymous_626(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CCCryptorCreateWithMode") {
+    anonymous_627(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CCCryptorUpdate") {
+    anonymous_632(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CCKeyDerivationPBKDF") {
+    anonymous_604(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CC_MD5") {
+    anonymous_951(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CC_SHA256") {
+    anonymous_958(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CC_SHA256_Final") {
+    anonymous_857(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CC_SHA256_Init") {
+    anonymous_843(CallInst, andersen);
+    return true;
+  }
+  if (FName == "CC_SHA256_Update") {
+    anonymous_847(CallInst, andersen);
+    return true;
+  }
+  if (FName == "NSLog") {
+    anonymous_925(CallInst, andersen);
+    return true;
+  }
+  if (FName == "SecRandomCopyBytes") {
+    anonymous_870(CallInst, andersen);
+    return true;
+  }
+  if (FName == "_Znam") {
+    anonymous_936(CallInst, andersen);
+    return true;
+  }
+  if (FName == "_Znwm") {
+    anonymous_941(CallInst, andersen);
+    return true;
+  }
+  if (FName == "_ZnwmRKSt9nothrow_t") {
+    anonymous_946(CallInst, andersen);
+    return true;
+  }
+  if (FName == "__stack_chk_fail") {
+    anonymous_926(CallInst, andersen);
+    return true;
+  }
+  if (FName == "arc4random") {
+    anonymous_864(CallInst, andersen);
+    return true;
+  }
+  if (FName == "bzero") {
+    anonymous_907(CallInst, andersen);
+    return true;
+  }
+  if (FName == "malloc") {
+    anonymous_1005(CallInst, andersen);
+    return true;
+  }
+  if (FName == "memcpy") {
+    anonymous_593(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_autorelease") {
+    anonymous_18(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_autoreleaseReturnValue") {
+    anonymous_17(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_begin_catch") {
+    anonymous_935(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_destroyWeak") {
+    anonymous_933(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_end_catch") {
+    anonymous_934(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_enumerationMutation") {
+    anonymous_927(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_exception_rethrow") {
+    anonymous_931(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_exception_throw") {
+    anonymous_932(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_getClass") {
+    anonymous_898(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_getProperty") {
+    anonymous_654(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_loadWeakRetained") {
+    anonymous_704(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_release") {
+    anonymous_24(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_retain") {
+    anonymous_8(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_retainAutorelease") {
+    anonymous_21(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_retainAutoreleaseReturnValue") {
+    anonymous_20(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_retainAutoreleasedReturnValue") {
+    anonymous_19(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_setProperty") {
+    anonymous_692(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_setProperty_atomic") {
+    anonymous_680(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_setProperty_nonatomic") {
+    anonymous_668(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_setProperty_nonatomic_copy") {
+    anonymous_645(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_storeStrong") {
+    anonymous_878(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_storeWeak") {
+    anonymous_888(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_sync_enter") {
+    anonymous_930(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_sync_exit") {
+    anonymous_929(CallInst, andersen);
+    return true;
+  }
+  if (FName == "objc_terminate") {
+    anonymous_928(CallInst, andersen);
+    return true;
+  }
+  if (FName == "open") {
+    anonymous_971(CallInst, andersen);
+    return true;
+  }
+  if (FName == "read") {
+    anonymous_965(CallInst, andersen);
+    return true;
+  }
+  return false;
+}
+
+    }
+}
+
+#endif //LLVM_EXTERNALHANDLER_H
+
diff --git a/lib/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.cpp b/lib/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.cpp
new file mode 100644
index 0000000..8311636
--- /dev/null
+++ b/lib/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.cpp
@@ -0,0 +1,1321 @@
+#include <llvm/IR/PatternMatch.h>
+#include "llvm/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.h"
+
+#include "llvm/IR/Constants.h"
+#include "llvm/Analysis/Andersen/Andersen.h"
+
+#include <vector>
+#include <llvm/Transforms/Scalar.h>
+#include <llvm/Analysis/Andersen/SimpleCallGraph.h>
+#include <llvm/Analysis/Andersen/StackAccessPass.h>
+#include <llvm/ADT/StringExtras.h>
+#include <sstream>
+#include "llvm/IR/InstIterator.h"
+
+#include "llvm/Support/Debug.h"
+#include "ExternalHandler.h"
+#include "../../../LLVMSlicer/Languages/LLVM.h"
+
+
+using namespace llvm;
+using namespace llvm::ObjectiveC;
+
+#define DEBUG_TYPE "objc_runtime"
+
+cl::opt<bool> FastEnum("fast-enum", cl::desc("Handles Objective-C fast enum functions"), cl::init(false), cl::Hidden);
+
+bool CallHandlerBase::isSelf(Instruction *v, Andersen *andersen) {
+    //This may get called with ConstantInts...
+    if (!v)
+        return false;
+
+    //When something points to a class it can't point to 'self'...
+    if (v->getOpcode() == Instruction::Load &&
+        PatternMatch::match(v->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt()))) {
+        return false;
+    }
+
+    const Function *F = v->getParent()->getParent();
+
+    Value *RegPtr = nullptr;
+    Value *Self = nullptr;
+    const BasicBlock &EntryBB = F->getEntryBlock();
+    for (BasicBlock::const_iterator I_it = EntryBB.getInstList().begin();
+         I_it != EntryBB.getInstList().end(); ++I_it) {
+        if (I_it->getOpcode() == Instruction::GetElementPtr) {
+            if (ConstantInt *Idx = dyn_cast<ConstantInt>(I_it->getOperand(2))) {
+                if (Idx->getZExtValue() == 5) {
+                    RegPtr = (Value*)&*I_it;
+                }
+            } else {
+                llvm_unreachable("The index should be a constant int...");
+            }
+        } else if (RegPtr && I_it->getOpcode() == Instruction::Load) {
+            if (I_it->getOperand(0) == RegPtr) {
+                Self = (Value*)&*I_it;
+                break;
+            }
+        }
+    }
+
+
+    if (!Self) {
+        return false;
+        llvm_unreachable("Can't find self value");
+    }
+
+    if (Self == v) {
+        return true;
+    }
+
+    Function *f = v->getParent()->getParent();
+
+    StackAccessPass *SAP = andersen->getAnalysisIfAvailable<StackAccessPass>();
+    if (!SAP)
+        SAP = &andersen->getAnalysis<StackAccessPass>();
+
+    StackAccessPass::OffsetMap_t &Offsets = SAP->getOffsets(v->getParent()->getParent());
+
+    std::vector<int64_t> StoredAtOffsets;
+
+    for (auto &O_it : Offsets) {
+
+        bool self_stored = false;
+
+        for (auto &U_it : O_it.first->uses()) {
+            if (const Instruction *ItoP = dyn_cast<const IntToPtrInst>(U_it.getUser())) {
+                for (auto &IU_it : ItoP->uses()) {
+                    if (const StoreInst *Store = dyn_cast<const StoreInst>(IU_it.getUser())) {
+                        if (Store->getOperand(0) == Self) {
+                            self_stored = true;
+                            if (!O_it.second)
+                                continue;
+                            for (auto &Off_it : *O_it.second) {
+                                StoredAtOffsets.push_back(Off_it);
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (self_stored) {
+
+
+        }
+    }
+
+    StackAccessPass::OffsetValueListMap_t &OffsetValues = SAP->getOffsetValues(f);
+
+    std::set<const Value*> checked;
+
+    for (size_t i = 0; i < StoredAtOffsets.size(); ++i) {
+        int64_t O = StoredAtOffsets[i];
+//    for (auto &O : StoredAtOffsets) {
+        if (OffsetValues.find(O) == OffsetValues.end())
+            continue;
+
+        for (auto &V : *OffsetValues[O]) {
+            for (auto &U_it : V->uses()) {
+                if (const Instruction *ItoP = dyn_cast<const IntToPtrInst>(U_it.getUser())) {
+                    for (auto &IU_it : ItoP->uses()) {
+                        if (const LoadInst *Load = dyn_cast<const LoadInst>(IU_it.getUser())) {
+                            if (checked.find(Load) != checked.end())
+                                continue;
+                            checked.insert(Load);
+                            if (Load == v) {
+                                return true;
+                            } else {
+                                for (auto &LU_it : Load->uses()) {
+                                    if (const StoreInst *Store = dyn_cast<const StoreInst>(LU_it.getUser())) {
+                                        if (const IntToPtrInst *StoreItoP = dyn_cast<IntToPtrInst>(Store->getOperand(1))) {
+                                            if (SAP->getOffsets(f)[StoreItoP->getOperand(0)]) {
+                                                StackAccessPass::Int64List_t StoreOffsets = *SAP->getOffsets(
+                                                        f)[StoreItoP->getOperand(0)];
+                                                StoredAtOffsets.insert(StoredAtOffsets.end(), StoreOffsets.begin(),
+                                                                       StoreOffsets.end());
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    std::vector<const Value*> SelfPtsTo;
+    andersen->getPointsToSet(Self, SelfPtsTo);
+    std::vector<const Value*> X0PtsTo;
+    andersen->getPointsToSet(v, X0PtsTo);
+
+
+    for (std::vector<const Value*>::iterator Self_it = SelfPtsTo.begin(); Self_it != SelfPtsTo.end(); ++Self_it) {
+        for (std::vector<const Value*>::iterator X0_it = X0PtsTo.begin(); X0_it != X0PtsTo.end(); ++X0_it) {
+            if (*X0_it == *Self_it)
+                return true;
+        }
+    }
+
+
+    return false;
+}
+
+StringRef CallHandlerBase::getClassname(StringRef F) {
+    assert(isObjectiveCMethod(F));
+    StringRef Name = F;
+    Name = Name.substr(2);
+    size_t i = Name.find(" ");
+    return Name.substr(0, i);
+}
+
+StringRef CallHandlerBase::getMethodname(StringRef F) {
+    assert(isObjectiveCMethod(F));
+    StringRef Name = F;
+    size_t space = Name.find(" ");
+    Name = Name.substr(space + 1);
+    Name = Name.substr(0, Name.size() - 1);
+    return Name;
+}
+
+bool CallHandlerBase::isObjectiveCMethod(StringRef F) {
+    return (F.startswith_lower("+[") || F.startswith_lower("-["));
+}
+
+
+bool objcMsgSend::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    //TODO: for now we just add all instructions to the worklist. already handled ones should be skipped (check callgraph)
+    andersen->addToWorklist((Instruction*)CallInst);
+
+    DetectParametersPass::UserSet_t X0Values = DetectParametersPass::getRegisterValuesBeforeCall(5, CallInst);
+    DetectParametersPass::UserSet_t X1Values = DetectParametersPass::getRegisterValuesBeforeCall(6, CallInst);
+
+
+    for (DetectParametersPass::UserSet_t::iterator X0_it = X0Values.begin(); X0_it != X0Values.end(); ++X0_it) {
+        User *X0 = *X0_it;
+        for (DetectParametersPass::UserSet_t::iterator X1_it = X1Values.begin(); X1_it != X1Values.end(); ++X1_it) {
+            User *X1 = *X1_it;
+
+            Instruction *X0Inst = dyn_cast<Instruction>(X0);
+            Instruction *X1Inst = dyn_cast<Instruction>(X1);
+
+            std::vector<const Value *> X0PT;
+            andersen->getPointsToSet(X0, X0PT);
+            std::vector<const Value *> X1PT;
+            andersen->getPointsToSet(X1, X1PT);
+
+            for (std::vector<const Value *>::iterator X0PT_it = X0PT.begin(); X0PT_it != X0PT.end(); ++X0PT_it) {
+
+                auto handleLambda = [&](StringRef Classname, bool Meta) {
+                    for (std::vector<const Value *>::iterator X1PT_it = X1PT.begin(); X1PT_it != X1PT.end(); ++X1PT_it) {
+                        if (ConstantDataArray *ClassData = dyn_cast<ConstantDataArray>((Value*)*X1PT_it)) {
+                            StringRef Methodname = ClassData->getAsString();
+                            handleCall(Classname, Methodname, Meta, (Instruction*)CallInst, X0, X1, andersen);
+                        }
+                    }
+                };
+
+                StringRef Classname;
+                Andersen::StringSet_t Classnames;
+                bool Meta = false;
+                if (ConstantDataArray *ClassData = dyn_cast<ConstantDataArray>((Value*)*X0PT_it)) {
+                    Classname = ClassData->getAsString();
+                    Meta = true;
+                    handleLambda(Classname, Meta);
+                } else if (andersen->getType((Value*)*X0PT_it, Classnames)) {
+                    for (auto &className_it : Classnames) {
+                        handleLambda(className_it, Meta);
+                    }
+                } else {
+                    continue;
+                }
+
+            }
+
+
+            if (isObjectiveCMethod(CallInst->getParent()->getParent()->getName()) && isSelf(dyn_cast<Instruction>(X0), andersen)) {
+                if (X1PT.size()) {
+                    StringRef ClassName = getClassname(CallInst->getParent()->getParent()->getName());
+                    bool Meta = CallInst->getParent()->getParent()->getName().startswith("+");
+                    for (std::vector<const Value *>::iterator X1PT_it = X1PT.begin(); X1PT_it != X1PT.end(); ++X1PT_it) {
+                        if (ConstantDataArray *ClassData = dyn_cast<ConstantDataArray>((Value*)*X1PT_it)) {
+                            StringRef Methodname = ClassData->getAsString();
+                            handleCall(ClassName, Methodname, Meta, (Instruction*)CallInst, X0, X1, andersen);
+                        }
+                    }
+                }
+            }
+
+            return true;
+
+            StringRef ClassName;
+            bool ClassMethod = false;
+            if (X0Inst && X0Inst->getOpcode() == Instruction::Load) {
+                uint64_t ClassAddress;
+                if (PatternMatch::match(X0Inst->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(ClassAddress)))) {
+                    if (andersen->getMachO().getClass(ClassAddress, ClassName)) {
+                        ClassMethod = true;
+                    } else {
+                        //TODO: check if it points to a class
+                        return false;
+                    }
+                }
+            }
+
+            StringRef SelectorName;
+            if (X1Inst && X1Inst->getOpcode() == Instruction::Load) {
+                uint64_t SelectorAddress;
+                if (PatternMatch::match(X1Inst->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(SelectorAddress)))) {
+                    if (andersen->getMachO().getSelector(SelectorAddress, SelectorName)) {
+
+                    } else {
+                        assert(false);
+                    }
+                }
+            }
+
+            if (ClassMethod && ClassName.size()) {
+                if (SelectorName == "alloc" || SelectorName == "new" || SelectorName == "allocWithZone:") {
+                    StringRef AllocMethod = (StringRef("+[") + ClassName + StringRef(" ") + SelectorName + StringRef("]")).str();
+                    if (!andersen->getCallGraph().containtsEdge(CallInst, AllocMethod)) {
+//                        errs() << AllocMethod << "\n";
+                        andersen->getCallGraph().addCallEdge(CallInst, AllocMethod);
+
+                        DetectParametersPass::UserSet_t X0Post = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+                        for (DetectParametersPass::UserSet_t::iterator X0Post_it = X0Post.begin(); X0Post_it != X0Post.end(); ++X0Post_it) {
+                            NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*X0Post_it);
+                            if (valIndex == AndersNodeFactory::InvalidIndex)
+                                valIndex = andersen->getNodeFactory().createValueNode(*X0Post_it);
+                            NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*X0Post_it);
+                            if (objIndex == AndersNodeFactory::InvalidIndex)
+                                objIndex = andersen->getNodeFactory().createObjectNode(*X0Post_it);
+                            assert(valIndex != AndersNodeFactory::InvalidIndex && objIndex != AndersNodeFactory::InvalidIndex);
+//                            andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+                            andersen->setType(*X0Post_it, ClassName);
+                            andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+                        }
+                    }
+                }
+            } else {
+                std::vector<const Value *> PtsTo;
+                andersen->getPointsToSet(X0, PtsTo);
+
+                for (unsigned i = 0; i < PtsTo.size(); ++i) {
+                    const Value *P = PtsTo[i];
+                    Andersen::StringSet_t C;
+                    if (!andersen->getType((Value*)P, C)) {
+                        continue;
+                    }
+                    for (auto &type_it : C) {
+                        std::deque<std::string> Candidates = andersen->getMachO().getMethodCandidates(type_it, SelectorName, ClassMethod);
+                        bool h = false;
+                        for (std::deque<std::string>::iterator C_it = Candidates.begin(); C_it != Candidates.end(); ++C_it) {
+                            if (Function *F = CallInst->getParent()->getParent()->getParent()->getFunction(*C_it)) {
+                                andersen->addConstraintsForCall((Instruction*)CallInst, F);
+                                h = true;
+                                break;
+                            } else if (CallHandlerManager::getInstance().handleFunctionCall(CallInst, *C_it, andersen)) {
+                                h = true;
+                                break;
+                            }
+                        }
+                        if (!h && Candidates.size()) {
+                            errs() << "Can't find method: " << Candidates.back() << "\n";
+                        }
+                    }
+
+                }
+             }
+
+//            if (isObjectiveCMethod(CallInst->getParent()->getParent()->getName()) && isSelf(dyn_cast<Instruction>(X0))) {
+//                std::deque<std::string> Candidates = andersen->getMachO().getMethodCandidates(getClassname((Function*)CallInst->getParent()->getParent()->getName()), SelectorName, CallInst->getParent()->getParent()->getName().startswith("+"));
+//                bool h = false;
+//                for (std::deque<std::string>::iterator C_it = Candidates.begin(); C_it != Candidates.end(); ++C_it) {
+//                    if (Function *F = CallInst->getParent()->getParent()->getParent()->getFunction(*C_it)) {
+//                        andersen->addConstraintsForCall((Instruction*)CallInst, F);
+//                        h = true;
+//                        break;
+//                    } else if (CallHandlerManager::getInstance().handleFunctionCall(CallInst, *C_it, andersen)) {
+//                        h = true;
+//                        break;
+//                    }
+//                }
+//                if (!h && Candidates.size()) {
+//                    errs() << "Can't find method: " << Candidates.back() << "\n";
+//                }
+//            }
+        }
+    }
+
+    return true;
+}
+
+void objcMsgSend::handleCall(StringRef ClassName, StringRef MethodName, bool Meta, Instruction *CallInst, Value *X0, Value *X1, Andersen *andersen) {
+
+    if (Meta && (MethodName == "alloc" || MethodName == "new" || MethodName == "allocWithZone:")) {
+        StringRef AllocMethod = (StringRef("+[") + ClassName + StringRef(" ") + MethodName + StringRef("]")).str();
+        if (!andersen->getCallGraph().containtsEdge(CallInst, AllocMethod)) {
+//                        errs() << AllocMethod << "\n";
+            andersen->getCallGraph().addCallEdge(CallInst, AllocMethod);
+
+            DetectParametersPass::UserSet_t X0Post = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+            for (DetectParametersPass::UserSet_t::iterator X0Post_it = X0Post.begin(); X0Post_it != X0Post.end(); ++X0Post_it) {
+                NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*X0Post_it);
+                if (valIndex == AndersNodeFactory::InvalidIndex)
+                    valIndex = andersen->getNodeFactory().createValueNode(*X0Post_it);
+                NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*X0Post_it);
+                if (objIndex == AndersNodeFactory::InvalidIndex)
+                    objIndex = andersen->getNodeFactory().createObjectNode(*X0Post_it);
+                assert(valIndex != AndersNodeFactory::InvalidIndex && objIndex != AndersNodeFactory::InvalidIndex);
+//                            andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+                andersen->setType(*X0Post_it, ClassName);
+                andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+            }
+        }
+        return;
+    }
+
+    bool HandledCall = false;
+    std::deque<std::string> Candidates = andersen->getMachO().getMethodCandidates(ClassName.str(), MethodName.str(), Meta);
+
+    for (std::deque<std::string>::iterator C_it = Candidates.begin(); C_it != Candidates.end(); ++C_it) {
+        if (Function *F = CallInst->getParent()->getParent()->getParent()->getFunction(*C_it)) {
+            andersen->addConstraintsForCall((Instruction *) CallInst, F);
+            HandledCall = true;
+            break;
+        } else if (CallHandlerManager::getInstance().handleFunctionCall(CallInst, *C_it, andersen)) {
+            HandledCall = true;
+            break;
+        }
+    }
+
+    if (!HandledCall && Candidates.size()) {
+        andersen->addUnhandled(Candidates.front(), CallInst);
+    }
+}
+
+
+
+bool objcInit::shouldHandleCall(std::string &F) {
+//    return F.startswith("-") && (F.find("init") != StringRef::npos);
+    return true;
+}
+
+
+bool objcInit::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    if (andersen->getCallGraph().containtsEdge(CallInst, F))
+        return true;
+    DetectParametersPass::UserSet_t X0Values = DetectParametersPass::getRegisterValuesBeforeCall(5, CallInst);
+    DetectParametersPass::UserSet_t X0Post = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+
+    if (!X0Values.size() || !X0Post.size())
+        return false;
+
+//    errs() << F << "\n";
+
+    andersen->getCallGraph().addCallEdge(CallInst, F);
+
+    for (DetectParametersPass::UserSet_t::iterator X0_it = X0Values.begin(); X0_it != X0Values.end(); ++X0_it) {
+        for (DetectParametersPass::UserSet_t::iterator X0Post_it = X0Post.begin(); X0Post_it != X0Post.end(); ++X0Post_it) {
+            NodeIndex srcIndex = andersen->getNodeFactory().getValueNodeFor(*X0_it);
+            if (srcIndex == AndersNodeFactory::InvalidIndex)
+                srcIndex = andersen->getNodeFactory().createValueNode(*X0_it);
+            NodeIndex dstIndex = andersen->getNodeFactory().getValueNodeFor(*X0Post_it);
+            if (dstIndex == AndersNodeFactory::InvalidIndex)
+                dstIndex = andersen->getNodeFactory().createValueNode(*X0Post_it);
+            andersen->addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+        }
+    }
+    return true;
+}
+
+bool objcARC::shouldHandleCall(std::string &F) {
+    return false;
+    return F == "objc_retain" ||
+           F == "objc_release" ||
+            F == "objc_retainAutoreleasedReturnValue";
+}
+
+bool objcARC::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    if (andersen->getCallGraph().containtsEdge(CallInst, F))
+        return true;
+    DetectParametersPass::UserSet_t X0Values = DetectParametersPass::getRegisterValuesBeforeCall(5, CallInst);
+    DetectParametersPass::UserSet_t X0Post = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+
+    if (!X0Values.size() || !X0Post.size())
+        return false;
+
+//    errs() << F << "\n";
+
+    andersen->getCallGraph().addCallEdge(CallInst, F);
+
+    for (DetectParametersPass::UserSet_t::iterator X0_it = X0Values.begin(); X0_it != X0Values.end(); ++X0_it) {
+        for (DetectParametersPass::UserSet_t::iterator X0Post_it = X0Post.begin(); X0Post_it != X0Post.end(); ++X0Post_it) {
+            NodeIndex srcIndex = andersen->getNodeFactory().getValueNodeFor(*X0_it);
+            if (srcIndex == AndersNodeFactory::InvalidIndex)
+                srcIndex = andersen->getNodeFactory().createValueNode(*X0_it);
+            NodeIndex dstIndex = andersen->getNodeFactory().getValueNodeFor(*X0Post_it);
+            if (dstIndex == AndersNodeFactory::InvalidIndex)
+                dstIndex = andersen->getNodeFactory().createValueNode(*X0Post_it);
+            andersen->addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+        }
+    }
+    return true;
+}
+
+
+bool dispatchBlock::shouldHandleCall(std::string &F) {
+    if (F == "dispatch_async" ||
+            F == "dispatch_sync" ||
+            F == "dispatch_once" ||
+            F == "dispatch_after" ||
+            F == "-[NSOperationQueue addOperationWithBlock:]")
+        return true;
+    return false;
+}
+bool dispatchBlock::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    std::unique_lock<std::mutex> lock(handlerLock);
+    bool handled = false;
+
+    andersen->addToWorklist((Instruction*)CallInst);
+
+    uint64_t blockReg = 0;
+    if (F == "dispatch_async" || F == "dispatch_sync" || F == "dispatch_once") {
+        blockReg = 6;
+    } else if (F == "dispatch_after" || F == "-[NSOperationQueue addOperationWithBlock:]") {
+        blockReg = 7;
+    }
+    assert(blockReg);
+
+    DetectParametersPass::UserSet_t Block = DetectParametersPass::getRegisterValuesBeforeCall(blockReg, CallInst);
+    for (DetectParametersPass::UserSet_t::iterator Block_it = Block.begin(); Block_it != Block.end(); ++Block_it) {
+
+        std::vector<const Value*> PtsTo;
+        andersen->getPointsToSet(*(Block_it), PtsTo);
+        for (std::vector<const Value*>::iterator PtsTo_it = PtsTo.begin(); PtsTo_it != PtsTo.end(); ++PtsTo_it) {
+//            (*Block_it)->dump();
+
+            const Value *loc = andersen->getNodeFactory().getLocation(*PtsTo_it);
+            if (const ConstantInt *constant = dyn_cast<const ConstantInt>(loc)) {
+                int64_t BlockAddressLocation = constant->getZExtValue() + 16;
+                uint64_t BlockAddress = andersen->getMachO().getRAWData<uint64_t>(BlockAddressLocation);
+
+                std::string FName = andersen->getMachO().getFunctionName(BlockAddress);
+
+                if (andersen->getCallGraph().containtsEdge(CallInst, FName))
+                    return true;
+                andersen->getCallGraph().addCallEdge(CallInst, FName);
+                handled = true;
+
+                continue;
+            }
+
+            Andersen::FunctionIntPairSet_t &fs = andersen->getStackOffsets()[*PtsTo_it];
+            StackAccessPass &StackAccess = andersen->getAnalysis<StackAccessPass>();
+
+            for (auto &fs_it : fs) {
+                StackAccessPass::OffsetValueListMap_t &OffsetValues = StackAccess.getOffsetValues((Function*)fs_it.first);
+
+                int64_t BlockAddress = fs_it.second + 16;
+
+                if (!OffsetValues[BlockAddress])
+                    continue;
+
+                StackAccessPass::ValueList_t &FunctionAddress = *OffsetValues[BlockAddress];
+
+                for (StackAccessPass::ValueList_t::iterator FAV_it = FunctionAddress.begin(); FAV_it != FunctionAddress.end(); ++FAV_it) {
+                    std::vector<const Value*> FunctionAddressCandidates;
+                    andersen->getPointsToSet(*FAV_it, FunctionAddressCandidates);
+                    for (std::vector<const Value*>::iterator FAC_it = FunctionAddressCandidates.begin(); FAC_it != FunctionAddressCandidates.end(); ++FAC_it) {
+                        Andersen::FunctionIntPairSet_t blockStackOffsets = andersen->getStackOffsets()[*FAC_it];
+                        for (auto &blockOffset_it : blockStackOffsets) {
+                            if (!StackAccess.getOffsetValues((Function*)blockOffset_it.first)[blockOffset_it.second])
+                                continue;
+                            StackAccessPass::ValueList_t &Vals = *StackAccess.getOffsetValues((Function*)blockOffset_it.first)[blockOffset_it.second];
+                            for (auto &V_it : Vals) {
+                                for (Value::const_use_iterator ITPUse_it = V_it->use_begin();
+                                     ITPUse_it != V_it->use_end(); ++ITPUse_it) {
+                                    if (Instruction *I = dyn_cast<Instruction>(ITPUse_it->getUser())) {
+                                        if (I->getOpcode() != Instruction::IntToPtr)
+                                            continue;
+                                        for (Value::const_use_iterator STUse_it = I->use_begin();
+                                             STUse_it != I->use_end(); ++STUse_it) {
+                                            if (Instruction *I2 = dyn_cast<Instruction>(STUse_it->getUser())) {
+                                                if (I2->getOpcode() != Instruction::Store)
+                                                    continue;
+                                                if (ConstantInt *Address = dyn_cast<ConstantInt>(I2->getOperand(0))) {
+//                                                    errs() << utohexstr(Address->getZExtValue()) << "\n";
+                                                    std::string FName = andersen->getMachO().getFunctionName(
+                                                            Address->getZExtValue());
+//                                                    errs() << FName << "\n";
+                                                    Function *F = andersen->getModule().getFunction(FName);
+                                                    if (andersen->getCallGraph().containtsEdge(CallInst, FName))
+                                                        return true;
+                                                    andersen->getCallGraph().addCallEdge(CallInst, FName);
+                                                    handled = true;
+
+                                                    if (!F)
+                                                        continue;
+                                                    std::set<uint64_t> SPIdx;
+                                                    SPIdx.insert(5);
+                                                    DetectParametersPass::ParameterAccessPairSet_t StackParams = andersen->getAnalysis<DetectParametersPass>().getStackParameters(*F, SPIdx);
+
+//                                                    int64_t StackSize = StackAccess.getStackPointerValue(
+//                                                            (Instruction *) *Block_it, false);
+                                                    int64_t StackSize = fs_it.second;
+                                                    for (DetectParametersPass::ParameterAccessPairSet_t::iterator PA_it = StackParams.begin();
+                                                         PA_it != StackParams.end(); ++PA_it) {
+                                                        Instruction *address = andersen->findSetStackParameterInstruction(
+                                                                (Instruction *) CallInst, *PA_it, StackSize);
+                                                        if (!address)
+                                                            continue;
+                                                        andersen->findAliases(address, true, 5);
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+
+                                }
+                            }
+                        }
+
+                    }
+                }
+
+
+            }
+
+            continue;
+
+            Function *Func = (Function*)((Instruction*)(*Block_it))->getParent()->getParent();
+
+            StackAccessPass::OffsetMap_t &Offsets = StackAccess.getOffsets(Func);
+            StackAccessPass::OffsetValueListMap_t &OffsetValues = StackAccess.getOffsetValues(Func);
+
+            StackAccessPass::Int64List_t &BlockOffsets = *Offsets[*Block_it];
+
+            for (StackAccessPass::Int64List_t::iterator BO_it = BlockOffsets.begin(); BO_it != BlockOffsets.end(); ++BO_it) {
+                int64_t BlockAddress = *BO_it + 16;
+
+                StackAccessPass::ValueList_t &FunctionAddress = *OffsetValues[BlockAddress];
+
+                for (StackAccessPass::ValueList_t::iterator FAV_it = FunctionAddress.begin(); FAV_it != FunctionAddress.end(); ++FAV_it) {
+                    std::vector<const Value*> FunctionAddressCandidates;
+                    andersen->getPointsToSet(*FAV_it, FunctionAddressCandidates);
+                    for (std::vector<const Value*>::iterator FAC_it = FunctionAddressCandidates.begin(); FAC_it != FunctionAddressCandidates.end(); ++FAC_it) {
+                        for (Value::const_use_iterator ITPUse_it = (*FAC_it)->use_begin(); ITPUse_it != (*FAC_it)->use_end(); ++ITPUse_it) {
+                            if (Instruction *I = dyn_cast<Instruction>(ITPUse_it->getUser())) {
+                                if (I->getOpcode() != Instruction::IntToPtr)
+                                    continue;
+                                for (Value::const_use_iterator STUse_it = I->use_begin(); STUse_it != I->use_end(); ++ STUse_it) {
+                                    if (Instruction *I2 = dyn_cast<Instruction>(STUse_it->getUser())) {
+                                        if (I2->getOpcode() != Instruction::Store)
+                                            continue;
+                                        if (ConstantInt *Address = dyn_cast<ConstantInt>(I2->getOperand(0))) {
+                                            errs() << utohexstr(Address->getZExtValue()) << "\n";
+                                            std::string FName = andersen->getMachO().getFunctionName(Address->getZExtValue());
+                                            errs() << FName << "\n";
+                                            Function *F = andersen->getModule().getFunction(FName);
+                                            if (andersen->getCallGraph().containtsEdge(CallInst, FName))
+                                                return true;
+                                            andersen->getCallGraph().addCallEdge(CallInst, FName);
+
+                                            if (!F)
+                                                continue;
+                                            std::set<uint64_t> SPIdx;
+                                            SPIdx.insert(5);
+                                            DetectParametersPass::ParameterAccessPairSet_t StackParams = andersen->getAnalysis<DetectParametersPass>(*F).getStackParameters(*F, SPIdx);
+
+                                            int64_t StackSize = StackAccess.getStackPointerValue((Instruction*)*Block_it, false);
+                                            for (DetectParametersPass::ParameterAccessPairSet_t::iterator PA_it = StackParams.begin(); PA_it != StackParams.end(); ++PA_it) {
+                                                andersen->findSetStackParameterInstruction((Instruction*)CallInst, *PA_it, StackSize);
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+
+                        }
+                    }
+                }
+
+
+            }
+        }
+
+    }
+
+
+
+    return handled;
+}
+
+bool retainBlock::shouldHandleCall(std::string &F) {
+    if (F == "objc_retainBlock")
+        return true;
+    return false;
+}
+bool retainBlock::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    andersen->addToWorklist((Instruction*)CallInst);
+
+    DetectParametersPass::UserSet_t Block = DetectParametersPass::getRegisterValuesBeforeCall(5, CallInst);
+    for (DetectParametersPass::UserSet_t::iterator Block_it = Block.begin(); Block_it != Block.end(); ++Block_it) {
+        std::vector<const Value*> PtsTo;
+        andersen->getPointsToSet(*(Block_it), PtsTo);
+        for (std::vector<const Value*>::iterator PtsTo_it = PtsTo.begin(); PtsTo_it != PtsTo.end(); ++PtsTo_it) {
+            andersen->addBlock((Value*)*PtsTo_it);
+        }
+    }
+    if (Preserved.find(CallInst) == Preserved.end()) {
+        Preserved.insert(CallInst);
+        andersen->preserveRegisterValue((Instruction *) CallInst, 5);
+    }
+    return true;
+}
+
+bool specialAllocs::shouldHandleCall(std::string &F) {
+    return false;
+}
+bool specialAllocs::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    return false;
+}
+
+bool ClassHandler::shouldHandleCall(std::string &F) {
+    if (isObjectiveCMethod(F) && getMethodname(F) == "class")
+        return true;
+    return false;
+}
+bool ClassHandler::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    if (andersen->getCallGraph().containtsEdge(CallInst, F)) {
+        return true;
+    }
+    andersen->getCallGraph().addCallEdge(CallInst, F);
+    DetectParametersPass::UserSet_t X0Post = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+    ConstantDataArray *ClassName = (ConstantDataArray*)ConstantDataArray::getString(getGlobalContext(), getClassname(F), false);
+    NodeIndex DO = andersen->getNodeFactory().getObjectNodeFor(ClassName);
+    if (DO == AndersNodeFactory::InvalidIndex) {
+        DO = andersen->getNodeFactory().createObjectNode(ClassName);
+    }
+    for (DetectParametersPass::UserSet_t::iterator X0Post_it = X0Post.begin(); X0Post_it != X0Post.end(); ++X0Post_it) {
+        NodeIndex DV = andersen->getNodeFactory().getValueNodeFor(*X0Post_it);
+        if (DV == AndersNodeFactory::InvalidIndex)
+            DV = andersen->getNodeFactory().createValueNode(*X0Post_it);
+        andersen->addConstraint(AndersConstraint::ADDR_OF, DV, DO);
+    }
+    return true;
+}
+
+bool ExternalHandler::shouldHandleCall(std::string &F) {
+    if (llvm::pointsto::canHandleCall(F) && isObjectiveCMethod(F)) {
+        return true;
+    }
+    if (llvm::pointsto::canHandleCall(F))
+        return true;
+    return false;
+}
+bool ExternalHandler::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    if (!andersen->getCallGraph().containtsEdge(CallInst, F)) {
+//                        errs() << AllocMethod << "\n";
+
+
+        if (llvm::pointsto::handleCall((Instruction *) CallInst, andersen, F)) {
+            andersen->getCallGraph().addCallEdge(CallInst, F);
+        } else {
+            return false;
+        }
+    }
+    return true;
+}
+
+bool MsgSendSuper::shouldHandleCall(std::string &F) {
+    if (F == "objc_msgSendSuper2") {
+        return true;
+    }
+    return false;
+}
+bool MsgSendSuper::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    andersen->addToWorklist((Instruction*)CallInst);
+
+    DetectParametersPass::UserSet_t PreX0 = DetectParametersPass::getRegisterValuesBeforeCall(5, CallInst);
+    DetectParametersPass::UserSet_t PreX1 = DetectParametersPass::getRegisterValuesBeforeCall(6, CallInst);
+
+    DetectParametersPass::UserSet_t PreX0Replace;
+
+    typedef std::tuple<std::string, std::string, bool> CallInfos_t;
+    std::vector<CallInfos_t> calls;
+
+    for (auto &pre_it : PreX0) {
+        std::vector<const Value*> PtsTo;
+        andersen->getPointsToSet(pre_it, PtsTo);
+        for (auto &pts_it : PtsTo) {
+            bool cond1 = false;
+            for (BasicBlock::const_reverse_iterator I_it = CallInst->getParent()->rbegin(); I_it != CallInst->getParent()->rend(); ++I_it) {
+                if (&*I_it == CallInst) {
+                    cond1 = true;
+                }
+                if (!cond1) {
+                    continue;
+                }
+                if (const StoreInst *store = dyn_cast<const StoreInst>(&*I_it)) {
+                    if (const IntToPtrInst *ItoP = dyn_cast<const IntToPtrInst>(store->getOperand(1))) {
+                        if (andersen->pointsTo(ItoP, pts_it)) {
+                            if (!andersen->getAnalysis<StackAccessPass>().getOffsets((Function*)ItoP->getParent()->getParent())[ItoP->getOperand(0)]) {
+                                llvm_unreachable("'self' not stored on stack???");
+                            }
+
+                            StackAccessPass::Int64List_t &Offsets = *andersen->getAnalysis<StackAccessPass>().getOffsets((Function*)ItoP->getParent()->getParent())[ItoP->getOperand(0)];
+
+                            bool cond2 = false;
+                            for (BasicBlock::const_iterator I2_it = CallInst->getParent()->begin(); I2_it != CallInst->getParent()->end() && &*I2_it != CallInst; ++I2_it) {
+                                if (&*I2_it == store) {
+                                    cond2 = true;
+                                }
+                                if (!cond2) {
+                                    continue;
+                                }
+                                if (const StoreInst *store2 = dyn_cast<const StoreInst>(&*I2_it)) {
+                                    if (const IntToPtrInst *ItoP2 = dyn_cast<const IntToPtrInst>(store2->getOperand(1))) {
+                                        if (!andersen->getAnalysis<StackAccessPass>().getOffsets(
+                                                (Function *) ItoP->getParent()->getParent())[ItoP2->getOperand(0)]) {
+                                            continue;
+                                        }
+                                        StackAccessPass::Int64List_t &Offsets2 = *andersen->getAnalysis<StackAccessPass>().getOffsets(
+                                                (Function *) ItoP2->getParent()->getParent())[ItoP2->getOperand(0)];
+
+                                        bool intersect = false;
+                                        for (auto O1 : Offsets) {
+                                            for (auto O2 : Offsets2) {
+                                                if (O1 == (O2 - 8)) {
+                                                    intersect = true;
+                                                    break;
+                                                }
+                                            }
+                                        }
+                                        if (intersect) {
+                                            PreX0Replace.insert((Instruction*)store);
+                                            std::vector<const Value*> Super;
+                                            andersen->getPointsToSet(store2->getOperand(0), Super);
+
+                                            for (auto &super_it : Super) {
+                                                if (const ConstantDataArray *superDataArray = dyn_cast<const ConstantDataArray>(super_it)) {
+                                                    for (auto &preX1_it : PreX1) {
+                                                        std::vector<const Value*> Sel;
+                                                        andersen->getPointsToSet(preX1_it, Sel);
+                                                        for (auto &sel_it : Sel) {
+                                                            if (const ConstantDataArray *selector = dyn_cast<const ConstantDataArray>(sel_it)) {
+                                                                std::string methodName = "-[" + superDataArray->getAsString().str() + " " + selector->getAsString().str() + "]";
+
+                                                                CallInfos_t infos;
+                                                                std::get<0>(infos) = superDataArray->getAsString();
+                                                                std::get<1>(infos) = selector->getAsString().str();
+
+                                                                //FIXME: check for meta class
+                                                                std::get<2>(infos) = false;
+                                                                calls.push_back(infos);
+
+                                                            }
+                                                        }
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    if (PreX0Replace.size()) {
+        DetectParametersPass::setSpecialPreSet(CallInst, 5, PreX0Replace);
+    }
+
+    for (auto &infos : calls) {
+        bool HandledCall = false;
+        std::deque<std::string> Candidates = andersen->getMachO().getMethodCandidates(std::get<0>(infos), std::get<1>(infos), std::get<2>(infos));
+
+        for (std::deque<std::string>::iterator C_it = Candidates.begin(); C_it != Candidates.end(); ++C_it) {
+            StringRef MethodName = CallHandlerBase::getMethodname(*C_it);
+            if (MethodName == "allocWithZone:") {
+                if (!isObjectiveCMethod(CallInst->getParent()->getParent()->getName()))
+                    continue;
+                StringRef ClassName = CallHandlerBase::getClassname(CallInst->getParent()->getParent()->getName());
+
+
+                StringRef AllocMethod = (StringRef("+[") + ClassName + StringRef(" ") + MethodName + StringRef("]")).str();
+                if (!andersen->getCallGraph().containtsEdge(CallInst, AllocMethod)) {
+//                        errs() << AllocMethod << "\n";
+                    andersen->getCallGraph().addCallEdge(CallInst, AllocMethod);
+
+                    DetectParametersPass::UserSet_t X0Post = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+                    for (DetectParametersPass::UserSet_t::iterator X0Post_it = X0Post.begin(); X0Post_it != X0Post.end(); ++X0Post_it) {
+                        NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*X0Post_it);
+                        if (valIndex == AndersNodeFactory::InvalidIndex)
+                            valIndex = andersen->getNodeFactory().createValueNode(*X0Post_it);
+                        NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*X0Post_it);
+                        if (objIndex == AndersNodeFactory::InvalidIndex)
+                            objIndex = andersen->getNodeFactory().createObjectNode(*X0Post_it);
+                        assert(valIndex != AndersNodeFactory::InvalidIndex && objIndex != AndersNodeFactory::InvalidIndex);
+//                            andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+                        andersen->setType(*X0Post_it, ClassName);
+                        andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);
+                    }
+                    HandledCall = true;
+                    continue;
+                }
+            }
+            if (Function *F = CallInst->getParent()->getParent()->getParent()->getFunction(*C_it)) {
+                andersen->addConstraintsForCall((Instruction *) CallInst, F);
+                HandledCall = true;
+                break;
+            } else if (CallHandlerManager::getInstance().handleFunctionCall(CallInst, *C_it, andersen)) {
+                HandledCall = true;
+                break;
+            }
+        }
+
+        if (!HandledCall && Candidates.size()) {
+            std::unique_lock<std::mutex> lock(andersen->getOutputLock());
+            andersen->addUnhandled(Candidates.front(), CallInst);
+        }
+    }
+
+    return true;
+}
+
+
+bool CopyProperty::shouldHandleCall(std::string &F) {
+    if (F == "objc_setProperty_nonatomic_copy") {
+        return true;
+    }
+    return false;
+}
+bool CopyProperty::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    andersen->addToWorklist((Instruction*)CallInst);
+
+    if (!andersen->getCallGraph().containtsEdge(CallInst, F)) {
+//        andersen->getCallGraph().addCallEdge(CallInst, F);
+    }
+    DetectParametersPass::UserSet_t dst = DetectParametersPass::getRegisterValuesBeforeCall(8, CallInst);
+    for (auto &pre : DetectParametersPass::getRegisterValuesBeforeCall(7, CallInst)) {
+        std::vector<const Value*> prePts;
+        andersen->getPointsToSet(pre, prePts);
+        for (auto &pts : prePts) {
+            if (CallInst->getParent()->getParent()->getName() == "-[FormViewController setCancelPressed:]") {
+                assert(true);
+            }
+            Andersen::StringSet_t types;
+            if (andersen->getType((Value*)pts, types)) {
+                for (auto &type : types) {
+                    std::string copyFunction = "-[" + type + " copy]";
+                    if (andersen->getCallGraph().containtsEdge(CallInst, copyFunction)) {
+                        continue;
+                    }
+                    andersen->getCallGraph().addCallEdge(CallInst, copyFunction);
+
+                    Value *dummy = andersen->getNodeFactory().createDummy(andersen->getModule());
+                    andersen->setType(dummy, type);
+
+                    NodeIndex objIdx = andersen->getNodeFactory().createObjectNode(dummy);
+                    NodeIndex valIdx = andersen->getNodeFactory().createValueNode(dummy);
+
+                    andersen->addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);
+
+                    for (auto &d : dst) {
+                        NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(d);
+                        assert(dstIdx != AndersNodeFactory::InvalidIndex);
+                        andersen->addConstraint(AndersConstraint::STORE, dstIdx, valIdx);
+
+                        NodeIndex dummyLoad = andersen->getNodeFactory().getValueNodeFor(CallInst);
+                        if (dummyLoad == AndersNodeFactory::InvalidIndex)
+                            dummyLoad = andersen->getNodeFactory().createValueNode(CallInst);
+                        andersen->addConstraint(AndersConstraint::LOAD, dummyLoad, dstIdx);
+                    }
+                }
+            }
+        }
+    }
+    return true;
+}
+
+
+
+bool NSArray::shouldHandleCall(std::string &F) {
+    if (F == "+[NSArray arrayWithObjects:count:]"){
+        return FastEnum && true;
+    }
+    if (F == "-[NSArray countByEnumeratingWithState:objects:count:]")
+        return FastEnum && true;
+    return false;
+}
+bool NSArray::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+
+    andersen->addToWorklist((Instruction*)CallInst);
+    if (andersen->getCallGraph().containtsEdge(CallInst, F))
+        return true;
+    andersen->getCallGraph().addCallEdge(CallInst, F);
+
+    if (CallHandlerBase::getMethodname(F) == "countByEnumeratingWithState:objects:count:") {
+        handleFastEnum(CallInst, andersen);
+        return true;
+    }
+
+    DetectParametersPass::UserSet_t returnValues = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+    if (returnValues.size() != 1) {
+        errs() << "Can't have more than one return value here...\n";
+        llvm_unreachable("");
+    }
+
+    Value *returnValue = *(returnValues.begin());
+    NodeIndex arrayObjIdx = andersen->getNodeFactory().getObjectNodeFor(returnValue);
+    if (arrayObjIdx == AndersNodeFactory::InvalidIndex)
+        arrayObjIdx = andersen->getNodeFactory().createObjectNode(returnValue);
+    NodeIndex arrayValIdx = andersen->getNodeFactory().getValueNodeFor(returnValue);
+    if (arrayValIdx == AndersNodeFactory::InvalidIndex)
+        arrayValIdx = andersen->getNodeFactory().createValueNode(returnValue);
+
+    andersen->addConstraint(AndersConstraint::ADDR_OF, arrayValIdx, arrayObjIdx);
+    andersen->setType(returnValue, "NSArray");
+
+    DetectParametersPass::UserSet_t objects = DetectParametersPass::getRegisterValuesBeforeCall(7, CallInst);
+    DetectParametersPass::UserSet_t numObjects = DetectParametersPass::getRegisterValuesBeforeCall(8, CallInst);
+
+    StackAccessPass &SAP = andersen->getAnalysis<StackAccessPass>();
+
+    StackAccessPass::OffsetMap_t &stackOffsets = SAP.getOffsets((Function*)CallInst->getParent()->getParent());
+    StackAccessPass::OffsetValueListMap_t &stackOffsetValues = SAP.getOffsetValues((Function*)CallInst->getParent()->getParent());
+
+    for (auto &objectParam : objects) {
+        //The passed objects should all be stored on the stack in this case
+        if (stackOffsets.find(objectParam) != stackOffsets.end()) {
+            for (auto &num : numObjects) {
+                const ConstantInt *constNumObjects = dyn_cast<const ConstantInt>(num);
+
+                //We can only handle this correct if this number is static
+                //TODO: probably add the first object anyways.
+                if (!constNumObjects)
+                    continue;
+
+                for (auto &startStackOffset : *stackOffsets[objectParam]) {
+                    for (unsigned stackOffset = 0; stackOffset < constNumObjects->getZExtValue(); ++stackOffset) {
+                        if (stackOffsetValues.find(startStackOffset + (8 * stackOffset)) == stackOffsetValues.end())
+                            continue;
+                        for (auto &offsetValue : *stackOffsetValues[startStackOffset + (8 * stackOffset)]) {
+                            NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(offsetValue);
+                            if (valIdx == AndersNodeFactory::InvalidIndex)
+                                valIdx = andersen->getNodeFactory().createValueNode(offsetValue);
+                            //COPY because the object is already stored on the stack (STORE constraint)
+                            //instead of a LOAD-STORE construct COPY works as well
+                            andersen->addConstraint(AndersConstraint::COPY, arrayValIdx, valIdx);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+void NSArray::handleFastEnum(const Instruction *CallInst, Andersen *andersen)
+{
+    DetectParametersPass::UserSet_t contextValues = DetectParametersPass::getRegisterValuesBeforeCall(7, CallInst);
+    DetectParametersPass::UserSet_t arrayValues = DetectParametersPass::getRegisterValuesBeforeCall(5, CallInst);
+
+    StackAccessPass &SAP = andersen->getAnalysis<StackAccessPass>();
+
+    StackAccessPass::OffsetMap_t &stackOffsets = SAP.getOffsets((Function*)CallInst->getParent()->getParent());
+    StackAccessPass::OffsetValueListMap_t &stackOffsetValues = SAP.getOffsetValues((Function*)CallInst->getParent()->getParent());
+
+    for (auto &array : arrayValues) {
+
+        NodeIndex arrayValIdx = andersen->getNodeFactory().getValueNodeFor(array);
+        if (arrayValIdx == AndersNodeFactory::InvalidIndex)
+            arrayValIdx = andersen->getNodeFactory().createValueNode(array);
+
+        for (auto &contextValue : contextValues) {
+            if (stackOffsets.find(contextValue) != stackOffsets.end()) {
+                for (uint64_t stackOffset : *stackOffsets[contextValue]) {
+                    //The passed 'context' struct has this pointer at offset 8
+                    uint64_t objectsStart = stackOffset + 8;
+
+                    if (stackOffsetValues.find(objectsStart) == stackOffsetValues.end())
+                        continue;
+
+                    //'Forward pattern matching'
+                    for (auto &offsetValue : *stackOffsetValues[objectsStart]) {
+                        for (auto offsetUser : offsetValue->users()) {
+                            const IntToPtrInst *offsetUserInst = dyn_cast<const IntToPtrInst>(offsetUser);
+                            if (!offsetUserInst)
+                                continue;
+                            for (auto iToPUser : offsetUserInst->users()) {
+                                const LoadInst *iToPUserInst = dyn_cast<const LoadInst>(iToPUser);
+                                if (!iToPUserInst)
+                                    continue;
+                                for (auto loadUser : iToPUser->users()) {
+                                    const AddOperator *loadUserInst = dyn_cast<const AddOperator>(loadUser);
+                                    if (!loadUserInst)
+                                        continue;
+                                    ConstantInt *shl = nullptr;
+                                    if (!PatternMatch::match(loadUserInst->getOperand(1),
+                                                             PatternMatch::m_Shl(PatternMatch::m_Value(),
+                                                                                 PatternMatch::m_ConstantInt())) ||
+                                        (shl && shl->getZExtValue() != 3))
+                                        continue;
+                                    for (auto addUser : loadUserInst->users()) {
+                                        const IntToPtrInst *addUserInst = dyn_cast<const IntToPtrInst>(addUser);
+                                        if (!addUserInst)
+                                            continue;
+                                        for (auto iToP2User : addUserInst->users()) {
+                                            const LoadInst *loadFromArray = dyn_cast<const LoadInst>(iToP2User);
+                                            if (!loadFromArray)
+                                                continue;
+                                            NodeIndex loadValIdx = andersen->getNodeFactory().getValueNodeFor(loadFromArray);
+                                            if (loadValIdx == AndersNodeFactory::InvalidIndex)
+                                                loadValIdx = andersen->getNodeFactory().createValueNode(loadFromArray);
+                                            andersen->addConstraint(AndersConstraint::LOAD, loadValIdx, arrayValIdx);
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            } else {
+                //TODO: but usually this should not happen....
+            }
+        }
+    }
+}
+
+bool UIControlTarget::shouldHandleCall(std::string &F) {
+    if (F == "-[UIControl addTarget:action:forControlEvents:]"){
+        return true;
+    }
+    return false;
+}
+bool UIControlTarget::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+//    errs() << CallInst->getParent()->getParent()->getName() << "\n";
+    if (andersen->getCallGraph().containtsEdge(CallInst, F))
+        return true;
+    andersen->getCallGraph().addCallEdge(CallInst, F);
+
+    const Module *module = CallInst->getParent()->getParent()->getParent();
+
+    DetectParametersPass::UserSet_t controls = DetectParametersPass::getRegisterValuesBeforeCall(5, CallInst);
+    DetectParametersPass::UserSet_t targets = DetectParametersPass::getRegisterValuesBeforeCall(7, CallInst);
+    DetectParametersPass::UserSet_t selectors = DetectParametersPass::getRegisterValuesBeforeCall(8, CallInst);
+
+    Andersen::StringSet_t controlTypes;
+
+    auto setType = [andersen](const Function *fun, uint64_t regNo, std::string type) {
+        for (auto &inst : fun->getEntryBlock()) {
+            const LoadInst *load = dyn_cast<const LoadInst>(&inst);
+            if (!load)
+                continue;
+            const GetElementPtrInst *getElementPtrInst = dyn_cast<const GetElementPtrInst>(load->getOperand(0));
+            if (!getElementPtrInst)
+                continue;
+            const ConstantInt *idx = dyn_cast<const ConstantInt>(getElementPtrInst->getOperand(2));
+            if (!idx || idx->getZExtValue() != regNo)
+                continue;
+
+            NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(&inst);
+            if (valIdx == AndersNodeFactory::InvalidIndex)
+                valIdx = andersen->getNodeFactory().createValueNode(&inst);
+            NodeIndex objIdx = andersen->getNodeFactory().getObjectNodeFor(&inst);
+            if (objIdx == AndersNodeFactory::InvalidIndex)
+                objIdx = andersen->getNodeFactory().createObjectNode(&inst);
+            andersen->addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);
+            andersen->setType((Value*)&inst, type);
+            break;
+        }
+    };
+
+    for (auto &control : controls) {
+        std::vector<const Value*> controlPtsToSet;
+        andersen->getPointsToSet(control, controlPtsToSet);
+        for (auto &controlPtsTo : controlPtsToSet) {
+            Andersen::StringSet_t tmpTypes;
+            andersen->getType((Value*)controlPtsTo, tmpTypes);
+            controlTypes.insert(tmpTypes.begin(), tmpTypes.end());
+        }
+    }
+
+    for (auto &target : targets) {
+        std::vector<const Value*> targetPtsToSet;
+        andersen->getPointsToSet(target, targetPtsToSet);
+        for (auto &targetPtsTo : targetPtsToSet) {
+            Andersen::StringSet_t targetTypes;
+            andersen->getType((Value*)targetPtsTo, targetTypes);
+            for (auto &targetType : targetTypes) {
+                for (auto &selector : selectors) {
+                    std::vector<const Value*> selectorPtsToSet;
+                    andersen->getPointsToSet(selector, selectorPtsToSet);
+                    for (auto &selectorPtsTo : selectorPtsToSet) {
+                        const ConstantDataArray *selectorName = dyn_cast<const ConstantDataArray>(selectorPtsTo);
+                        if (!selectorName)
+                            continue;
+
+                        std::stringstream ss;
+                        ss << "-[";
+                        ss << targetType;
+                        ss << " ";
+                        ss << selectorName->getAsString().str();
+                        ss << "]";
+                        std::string targetMethod = ss.str();
+
+                        const Function *targetFun = module->getFunction(targetMethod);
+                        if (!targetFun)
+                            continue;
+                        for (auto &controlType : controlTypes) {
+                            setType(targetFun, 7, controlType);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+bool UIAppDelegate::shouldHandleCall(std::string &F) {
+    if (F == "-[UIApplication delegate]"){
+        return true;
+    }
+    return false;
+}
+bool UIAppDelegate::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    if (andersen->getCallGraph().containtsEdge(CallInst ,F))
+        return true;
+    andersen->getCallGraph().addCallEdge(CallInst, F);
+
+    DetectParametersPass::UserSet_t delegateRegs = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+
+    for (auto &c : andersen->getMachO().getClasses()) {
+        if (!c.second || c.second->getType() != ObjectiveC::Initialized)
+            continue;
+        for (auto &p : ((ObjectiveC::Class*)c.second.get())->getProtocolList()) {
+            if (p == "UIApplicationDelegate") {
+
+                for (auto delegateReg : delegateRegs) {
+                    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(delegateReg);
+                    if (valIdx == AndersNodeFactory::InvalidIndex)
+                        valIdx = andersen->getNodeFactory().createValueNode(delegateReg);
+                    NodeIndex objIdx = andersen->getNodeFactory().getObjectNodeFor(delegateReg);
+                    if (objIdx == AndersNodeFactory::InvalidIndex)
+                        objIdx = andersen->getNodeFactory().createObjectNode(delegateReg);
+                    andersen->addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);
+                    andersen->setType(delegateReg, c.second->getClassName().str());
+                }
+            }
+        }
+    }
+    return true;
+}
+
+bool NSUserDefaults::shouldHandleCall(std::string &F) {
+    if (F == "+[NSUserDefaults standardUserDefaults]"){
+        return true;
+    }
+    return false;
+}
+bool NSUserDefaults::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    if (andersen->getCallGraph().containtsEdge(CallInst, F)) {
+        return true;
+    }
+    andersen->getCallGraph().addCallEdge(CallInst, F);
+
+    if (!singleton) {
+        singleton = andersen->getNodeFactory().createDummy(*(Module*)CallInst->getParent()->getParent()->getParent());
+        andersen->setType(singleton, "NSUserDefaults");
+    }
+
+    DetectParametersPass::UserSet_t returnRegs = DetectParametersPass::getRegisterValuesAfterCall(5, CallInst);
+
+    for (auto &returnReg : returnRegs) {
+        NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(returnReg);
+        if (valIdx == AndersNodeFactory::InvalidIndex)
+            valIdx = andersen->getNodeFactory().createValueNode(returnReg);
+        NodeIndex objIdx = andersen->getNodeFactory().getObjectNodeFor(singleton);
+        if (objIdx == AndersNodeFactory::InvalidIndex)
+            objIdx = andersen->getNodeFactory().createObjectNode(singleton);
+        andersen->addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);
+    }
+
+    return true;
+}
+
+bool SecItemCopyAdd::shouldHandleCall(std::string &F) {
+    if (F == "SecItemCopyMatching"){
+        return true;
+    }
+    return false;
+}
+bool SecItemCopyAdd::run(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    if (andersen->getCallGraph().containtsEdge(CallInst, F))
+        return true;
+    andersen->addToWorklist((Instruction*)CallInst);
+    DetectParametersPass::UserSet_t PreX1 = DetectParametersPass::getRegisterValuesBeforeCall(6, CallInst);
+    for (auto &X1 : PreX1) {
+        std::vector<const Value*> ptsToSet1;
+        andersen->getPointsToSet(X1, ptsToSet1);
+        for (auto &pts1 : ptsToSet1) {
+            std::vector<const Value*> ptsToSet2;
+            andersen->getPointsToSet(andersen->getNodeFactory().getLocation(pts1), ptsToSet2);
+
+            if (ptsToSet2.size() == 0) {
+                Value *dummy = andersen->getNodeFactory().createDummy(*(Module*)CallInst->getParent()->getParent()->getParent());
+                NodeIndex objIdx = andersen->getNodeFactory().createObjectNode(dummy);
+                NodeIndex valIdx = andersen->getNodeFactory().createValueNode(dummy);
+                andersen->addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);
+
+                NodeIndex valIdx1 = andersen->getNodeFactory().getValueNodeFor(andersen->getNodeFactory().getLocation(pts1));
+                if (valIdx1 == AndersNodeFactory::InvalidIndex) {
+                    valIdx1 = andersen->getNodeFactory().createValueNode(andersen->getNodeFactory().getLocation(pts1));
+                }
+
+                andersen->addConstraint(AndersConstraint::STORE, valIdx, valIdx1);
+                andersen->setType(dummy, "NSData");
+                andersen->setType(dummy, "NSDictionary");
+                andersen->getCallGraph().addCallEdge(CallInst, F);
+            }
+
+            bool hasNSData = false;
+            bool hasNSDict = false;
+            for (auto &pts2 : ptsToSet2) {
+                Andersen::StringSet_t types;
+                andersen->getType((Value*)pts2, types);
+                for (auto &t : types) {
+                    if (t == "NSData") {
+                        hasNSData = true;
+                    }
+                    if (t == "NSDictionary") {
+                        hasNSDict = true;
+                    }
+                }
+
+                if (hasNSData && hasNSDict) {
+                    andersen->getCallGraph().addCallEdge(CallInst, F);
+                }
+
+                if (!hasNSData)
+                    andersen->setType((Value*)pts2, "NSData");
+                if (!hasNSDict)
+                    andersen->setType((Value*)pts2, "NSDictionary");
+            }
+
+        }
+    }
+    return true;
+}
diff --git a/lib/Analysis/Andersen/CleanUpPass.cpp b/lib/Analysis/Andersen/CleanUpPass.cpp
new file mode 100644
index 0000000..b666faf
--- /dev/null
+++ b/lib/Analysis/Andersen/CleanUpPass.cpp
@@ -0,0 +1,66 @@
+#include "llvm/Analysis/Andersen/CleanUpPass.h"
+
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/InstIterator.h"
+#include <set>
+#include <string>
+#include "llvm/Support/raw_ostream.h"
+
+using namespace llvm;
+
+
+bool CleanUpPass::runOnModule(Module &M) {
+
+    std::set<std::string> functions;
+    functions.insert("objc_release");
+    functions.insert("objc_retainAutoreleasedReturnValue");
+    functions.insert("objc_autorelease");
+    functions.insert("objc_retainAutorelease");
+    functions.insert("objc_retain");
+    functions.insert("objc_autoreleaseReturnValue");
+
+    std::set<Instruction*> toRemove;
+
+    size_t totalCalls = 0;
+
+    for (auto &f : M.functions()) {
+
+        for (inst_iterator i_it = inst_begin(f); i_it != inst_end(f); ++i_it) {
+
+            if (i_it->getOpcode() == Instruction::Call) {
+                totalCalls++;
+                CallInst *callInst = dyn_cast<CallInst>(&*i_it);
+                Function *calledFunction = callInst->getCalledFunction();
+                if (calledFunction) {
+                    if (calledFunction->hasName() && functions.find(calledFunction->getName()) != functions.end()) {
+                        toRemove.insert(callInst);
+                    }
+                }
+            }
+
+
+        }
+    }
+
+    errs() << "Remove " << toRemove.size() << " calls " <<  (toRemove.size()*100)/totalCalls << "%\n";
+
+    for (auto &r : toRemove) {
+//                r->eraseFromParent();
+                r->removeFromParent();
+    }
+
+    for (auto &f : functions) {
+        Function *fun = M.getFunction(f);
+        if (fun) {
+            fun->removeFromParent();
+        }
+    }
+
+    return true;
+}
+
+char CleanUpPass::ID = 0;
+static RegisterPass<CleanUpPass> X("cleanup", "", true, false);
diff --git a/lib/Analysis/Andersen/ConstraintCollect.cpp b/lib/Analysis/Andersen/ConstraintCollect.cpp
new file mode 100644
index 0000000..8510aa0
--- /dev/null
+++ b/lib/Analysis/Andersen/ConstraintCollect.cpp
@@ -0,0 +1,1822 @@
+#include <llvm/IR/CFG.h>
+#include <llvm/Analysis/Andersen/StackAccessPass.h>
+#include <llvm/IR/Dominators.h>
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/ADT/StringExtras.h>
+#include <thread>
+#include <future>
+#include <utility>
+#include <iostream>
+#include <vector>
+#include <type_traits>
+#include "llvm/Analysis/Andersen/Andersen.h"
+
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/IR/PatternMatch.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Analysis/ValueTracking.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Analysis/Andersen/ObjCCallHandler.h"
+#include "../../LLVMSlicer/Languages/LLVM.h"
+
+#define DECOMPILED
+#define DEBUG_TYPE "constraint_collect"
+
+
+#define CREATE_OBJECT_CONSTRAINT(instruction, type) \
+    NodeIndex valIdx = nodeFactory.getValueNodeFor(instruction);\
+    if (valIdx == AndersNodeFactory::InvalidIndex)\
+        valIdx = nodeFactory.createValueNode(instruction);\
+    NodeIndex objIdx = nodeFactory.getObjectNodeFor(instruction);\
+    if (objIdx == AndersNodeFactory::InvalidIndex)\
+        objIdx = nodeFactory.createObjectNode(instruction);\
+    addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);\
+    setType(instruction, type);\
+//    addDummyHelper(nodeFactory.getAbstractLocation(instruction));
+
+#define FIND_REG_ANDSET(fun, regNo, type)\
+    for (auto &i : fun->getEntryBlock()) {\
+        if (i.getOpcode() == Instruction::Load) {\
+            if (GetElementPtrInst *getElem = dyn_cast<GetElementPtrInst>(i.getOperand(0))) {\
+                if (ConstantInt *idx = dyn_cast<ConstantInt>(getElem->getOperand(2))) {\
+                    if (idx->getZExtValue() == regNo) {\
+                        CREATE_OBJECT_CONSTRAINT(&i, type)\
+                        break;\
+                    }\
+                }\
+            }\
+        }\
+    }
+
+#define SET_PARAM_TYPE(meta, c, m, regNo, type) \
+{\
+    char buffer[512];\
+    sprintf(buffer, "%s[%s %s]", (meta ? "+" : "-"), c, m);\
+    Function *_f = Mod->getFunction(StringRef(buffer));\
+    if (_f) {\
+        FIND_REG_ANDSET(_f, regNo, type)\
+    }\
+}
+
+#define PROTOCOL_METHOD(meta, c, m, p, regNo, type) \
+if (protocolName == p) {\
+SET_PARAM_TYPE(meta, c, m, regNo, type)\
+}
+
+using namespace llvm;
+
+void Andersen::addProtocolConstraints(std::string className, std::string protocolName) {
+//    PROTOCOL_METHOD(false, className.data(), "application:didFinishLaunchingWithOptions:", "UIApplicationDelegate", 7, "NSabc")
+//    PROTOCOL_METHOD(false, className.data(), "textFieldDidEndEditing:", "UITextFieldDelegate", 7, "UITextField")
+//    PROTOCOL_METHOD(false, className.data(), "textFieldShouldBeginEditing:", "UITextFieldDelegate", 7, "UITextField")
+//    PROTOCOL_METHOD(false, className.data(), "textFieldDidBeginEditing:", "UITextFieldDelegate", 7, "UITextField")
+//    PROTOCOL_METHOD(false, className.data(), "textFieldShouldEndEditing:", "UITextFieldDelegate", 7, "UITextField")
+//    PROTOCOL_METHOD(false, className.data(), "textField:shouldChangeCharactersInRange:replacementString:", "UITextFieldDelegate", 7, "UITextField")
+//    PROTOCOL_METHOD(false, className.data(), "textField:shouldChangeCharactersInRange:replacementString:", "UITextFieldDelegate", 9, "NSString")
+//    PROTOCOL_METHOD(false, className.data(), "textFieldShouldClear:", "UITextFieldDelegate", 7, "UITextField")
+//    PROTOCOL_METHOD(false, className.data(), "textFieldShouldReturn:", "UITextFieldDelegate", 7, "UITextField")
+
+  ObjectiveCBinary::ProtocolMap_t::iterator prot_it = MachO->getProtocols().find(protocolName);
+  if (prot_it == MachO->getProtocols().end())
+    return;
+
+  for (auto &m : prot_it->second.getInstanceMethods()) {
+    for (auto &r : m.getRegTypes()) {
+      PROTOCOL_METHOD(false, className.data(), m.getMethodname().data(), protocolName.data(), r.first, r.second.data());
+    }
+  }
+}
+
+
+
+// CollectConstraints - This stage scans the program, adding a constraint to the Constraints list for each instruction in the program that induces a constraint, and setting up the initial points-to graph.
+
+void Andersen::collectConstraints(Module &M) {
+  errs() << "Collect constraints\n";
+  // First, the universal ptr points to universal obj, and the universal obj points to itself
+  addConstraint(AndersConstraint::ADDR_OF,
+                nodeFactory.getUniversalPtrNode(), nodeFactory.getUniversalObjNode());
+  addConstraint(AndersConstraint::STORE,
+                nodeFactory.getUniversalObjNode(), nodeFactory.getUniversalObjNode());
+
+  // Next, the null pointer points to the null object.
+  addConstraint(AndersConstraint::ADDR_OF,
+                nodeFactory.getNullPtrNode(), nodeFactory.getNullObjectNode());
+
+  // Next, add any constraints on global variables. Associate the address of the global object as pointing to the memory for the global: &G = <G memory>
+  collectConstraintsForGlobals(M);
+
+  for (auto &c : MachO->getClasses()) {
+    if (!c.second || c.second->getType() != ObjectiveC::Initialized) {
+      continue;
+    }
+    ObjectiveCBinary::ClassPtr_t ClassPtr = std::static_pointer_cast<ObjectiveC::Class>(c.second);
+    for (auto &p : ClassPtr->getProtocolList()) {
+      addProtocolConstraints(c.second->getClassName(), p);
+    }
+  }
+
+  // Here is a notable points before we proceed:
+  // For functions with non-local linkage type, theoretically we should not trust anything that get passed to it or get returned by it. However, precision will be seriously hurt if we do that because if we do not run a -internalize pass before the -anders pass, almost every function is marked external. We'll just assume that even external linkage will not ruin the analysis result first
+  size_t handled = 0;
+  const Function *currentFunction = nullptr;
+
+
+  for (auto const &f: M) {
+    currentFunction = &f;
+    handled++;
+
+    if (f.isDeclaration() || f.isIntrinsic())
+      continue;
+
+    if (f.getName() == "main_init_regset" ||
+        f.getName() == "main_fini_regset" ||
+        f.getName() == "main" ||
+        f.getName() == "-[AppDelegate window]")
+      continue;
+
+    DEBUG(errs() << "Process function: \"" << f.getName() << "\"\n");
+
+    // Scan the function body
+    // A visitor pattern might help modularity, but it needs more boilerplate codes to set up, and it breaks down the main logic into pieces
+
+    // First, create a value node for each instruction with pointer type. It is necessary to do the job here rather than on-the-fly because an instruction may refer to the value node definied before it (e.g. phi nodes)
+    for (const_inst_iterator itr = inst_begin(f), ite = inst_end(f); itr != ite; ++itr) {
+      auto inst = itr.getInstructionIterator();
+      if (inst->getType()->isPointerTy())
+        nodeFactory.createValueNode(inst);
+    }
+
+    // Now, collect constraint for each relevant instruction
+    for (const_inst_iterator itr = inst_begin(f), ite = inst_end(f); itr != ite; ++itr) {
+      auto inst = itr.getInstructionIterator();
+      collectConstraintsForInstruction(inst);
+    }
+  }
+}
+
+void Andersen::collectConstraintsForGlobals(Module &M) {
+  // Create a pointer and an object for each global variable
+  for (auto const &globalVal: M.globals()) {
+    NodeIndex gVal = nodeFactory.createValueNode(&globalVal);
+    NodeIndex gObj = nodeFactory.createObjectNode(&globalVal);
+    addConstraint(AndersConstraint::ADDR_OF, gVal, gObj);
+  }
+
+  // Functions and function pointers are also considered global
+  for (auto const &f: M) {
+    // If f is an addr-taken function, create a pointer and an object for it
+    if (f.hasAddressTaken()) {
+      NodeIndex fVal = nodeFactory.createValueNode(&f);
+      NodeIndex fObj = nodeFactory.createObjectNode(&f);
+      addConstraint(AndersConstraint::ADDR_OF, fVal, fObj);
+    }
+
+    if (f.isDeclaration() || f.isIntrinsic())
+      continue;
+
+    // Create return node
+    if (f.getFunctionType()->getReturnType()->isPointerTy()) {
+      nodeFactory.createReturnNode(&f);
+    }
+
+    // Create vararg node
+    if (f.getFunctionType()->isVarArg())
+      nodeFactory.createVarargNode(&f);
+
+    // Add nodes for all formal arguments.
+    for (Function::const_arg_iterator itr = f.arg_begin(), ite = f.arg_end(); itr != ite; ++itr) {
+      if (isa<PointerType>(itr->getType()))
+        nodeFactory.createValueNode(itr);
+    }
+  }
+
+  // Init globals here since an initializer may refer to a global var/func below it
+  for (auto const &globalVal: M.globals()) {
+    NodeIndex gObj = nodeFactory.getObjectNodeFor(&globalVal);
+    assert(gObj != AndersNodeFactory::InvalidIndex && "Cannot find global object!");
+
+    if (globalVal.hasDefinitiveInitializer()) {
+      addGlobalInitializerConstraints(gObj, globalVal.getInitializer());
+    }
+    else {
+      // If it doesn't have an initializer (i.e. it's defined in another translation unit), it points to the universal set.
+      addConstraint(AndersConstraint::COPY,
+                    gObj, nodeFactory.getUniversalObjNode());
+    }
+  }
+}
+
+void Andersen::addGlobalInitializerConstraints(NodeIndex objNode, const Constant *c) {
+  //errs() << "Called with node# = " << objNode << ", initializer = " << *c << "\n";
+  if (c->getType()->isSingleValueType()) {
+    if (isa<PointerType>(c->getType())) {
+      NodeIndex rhsNode = nodeFactory.getObjectNodeForConstant(c);
+      assert(rhsNode != AndersNodeFactory::InvalidIndex && "rhs node not found");
+      addConstraint(AndersConstraint::ADDR_OF, objNode, rhsNode);
+    }
+  }
+  else if (c->isNullValue()) {
+    addConstraint(AndersConstraint::COPY, objNode, nodeFactory.getNullObjectNode());
+  }
+  else if (!isa<UndefValue>(c)) {
+    // Since we are doing field-insensitive analysis, all objects in the array/struct are pointed-to by the 1st-field pointer
+    assert(isa<ConstantArray>(c) || isa<ConstantDataSequential>(c) || isa<ConstantStruct>(c));
+
+    for (unsigned i = 0, e = c->getNumOperands(); i != e; ++i)
+      addGlobalInitializerConstraints(objNode, cast<Constant>(c->getOperand(i)));
+  }
+}
+
+void Andersen::collectConstraintsForInstruction(const Instruction *inst) {
+  switch (inst->getOpcode()) {
+    case Instruction::Alloca: {
+      NodeIndex valNode = nodeFactory.getValueNodeFor(inst);
+      assert(valNode != AndersNodeFactory::InvalidIndex && "Failed to find alloca value node");
+      NodeIndex objNode = nodeFactory.createObjectNode(inst);
+      addConstraint(AndersConstraint::ADDR_OF, valNode, objNode);
+      break;
+    }
+    case Instruction::Call:
+    case Instruction::Invoke: {
+//			ImmutableCallSite cs(inst);
+//			assert(cs && "Something wrong with callsite?");
+
+//			addConstraintForCall(cs);
+
+      addToWorklist((Instruction *) inst);
+
+      break;
+    }
+    case Instruction::Ret: {
+      if (inst->getNumOperands() > 0 && inst->getOperand(0)->getType()->isPointerTy()) {
+        NodeIndex retIndex = nodeFactory.getReturnNodeFor(inst->getParent()->getParent());
+        assert(retIndex != AndersNodeFactory::InvalidIndex && "Failed to find return node");
+        NodeIndex valIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+        assert(valIndex != AndersNodeFactory::InvalidIndex && "Failed to find return value node");
+        addConstraint(AndersConstraint::COPY, retIndex, valIndex);
+      }
+      break;
+    }
+    case Instruction::Load: {
+      if (inst->getName() == "X8_5901") {
+        assert(true);
+      }
+      if (dyn_cast<GetElementPtrInst>(inst->getOperand(0))) {
+        break;
+      }
+
+      if (inst->getType()->isPointerTy() && false) {
+        NodeIndex opIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+        assert(opIndex != AndersNodeFactory::InvalidIndex && "Failed to find load operand node");
+        NodeIndex valIndex = nodeFactory.getValueNodeFor(inst);
+        assert(valIndex != AndersNodeFactory::InvalidIndex && "Failed to find load value node");
+        addConstraint(AndersConstraint::LOAD, valIndex, opIndex);
+      } else {
+
+        std::vector<const Value *> operands;
+
+        if (PHINode *phi = dyn_cast<PHINode>(inst->getOperand(0))) {
+          for (unsigned i = 0; i < phi->getNumIncomingValues(); ++i) {
+            operands.push_back(phi->getIncomingValue(i));
+          }
+        } else if (SelectInst *selct = dyn_cast<SelectInst>(inst->getOperand(0))) {
+          operands.push_back(selct->getOperand(1));
+          operands.push_back(selct->getOperand(2));
+        } else {
+          operands.push_back(inst->getOperand(0));
+        }
+
+
+        for (unsigned i = 0; i < operands.size(); ++i) {
+          const Value *op = operands[i];
+          //Null pointer does not need to be handled
+          if (dyn_cast<const ConstantPointerNull>(op)) {
+            continue;
+          }
+
+          Value *Base = nullptr;
+          Instruction *IVARPtr = nullptr;
+          if (PatternMatch::match(op, PatternMatch::m_IntToPtr(PatternMatch::m_BinOp(PatternMatch::m_Value(Base),
+                                                                                     PatternMatch::m_SExt(
+                                                                                       PatternMatch::m_Instruction(
+                                                                                         IVARPtr)))))) {
+
+            std::vector<const Instruction *> ivarOps;
+            ivarOps.push_back(IVARPtr);
+
+            std::set<const Value *> visited;
+            for (unsigned opNum = 0; opNum < ivarOps.size(); ++opNum) {
+              if (visited.find(ivarOps[opNum]) != visited.end())
+                continue;
+              visited.insert(ivarOps[opNum]);
+              if (const PHINode *phi = dyn_cast<const PHINode>(ivarOps[opNum])) {
+                for (unsigned i = 0; i < phi->getNumIncomingValues(); ++i) {
+                  const Instruction *in = dyn_cast<const Instruction>(phi->getIncomingValue(i));
+                  if (!in)
+                    continue;
+                  ivarOps.push_back(in);
+                }
+                continue;
+              }
+
+              if (!isa<ConstantInt>(Base) && ivarOps[opNum]->getOpcode() == Instruction::Load) {
+                NodeIndex srcIndex = nodeFactory.getValueNodeFor(ivarOps[opNum]);
+                if (srcIndex == AndersNodeFactory::InvalidIndex)
+                  srcIndex = nodeFactory.createValueNode(ivarOps[opNum]);
+                assert(srcIndex != AndersNodeFactory::InvalidIndex);
+                NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst);
+                if (dstIndex == AndersNodeFactory::InvalidIndex) {
+                  dstIndex = nodeFactory.createValueNode(inst);
+                }
+                addConstraint(AndersConstraint::LOAD, dstIndex, srcIndex);
+              }
+            }
+
+            continue;
+          }
+
+
+          NodeIndex valIndex = nodeFactory.getValueNodeFor(inst);
+          if (valIndex == AndersNodeFactory::InvalidIndex) {
+            valIndex = nodeFactory.createValueNode(inst);
+//                    addConstraint(AndersConstraint::ADDR_OF, valIndex, nodeFactory.createObjectNode(inst));
+          }
+          NodeIndex opIndex = nodeFactory.getValueNodeFor(((Instruction *) op)->getOperand(0));
+          if (opIndex == AndersNodeFactory::InvalidIndex) {
+            //FIXME
+            opIndex = nodeFactory.createValueNode(((Instruction *) op)->getOperand(0));
+          }
+          assert(opIndex != AndersNodeFactory::InvalidIndex && "Failed to find load operand node");
+
+//
+          assert(valIndex != AndersNodeFactory::InvalidIndex && "Failed to find load value node");
+
+          ConstantInt *Const;
+          if (PatternMatch::match(op, PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(Const)))) {
+
+            addConstraintsForConstIntToPtr((Instruction *) op, Const);
+            NodeIndex idx2 = nodeFactory.getValueNodeFor(op);
+
+
+            uint64_t content = MachO->getRAWData<uint64_t>(Const->getZExtValue());
+            if (MachO->isCFString(content)) {
+
+              Value *stringAddress = ConstantInt::get(IntegerType::get(getGlobalContext(), 64), content);
+              NodeIndex stringValIdx = nodeFactory.getValueNodeFor(stringAddress);
+              if (stringValIdx == AndersNodeFactory::InvalidIndex)
+                stringValIdx = nodeFactory.createValueNode(stringAddress);
+              NodeIndex stringObjIdx = nodeFactory.getObjectNodeFor(stringAddress);
+              if (stringObjIdx == AndersNodeFactory::InvalidIndex) {
+                stringObjIdx = nodeFactory.createObjectNodeDummy(stringAddress,
+                                                                 *(Module *) inst->getParent()->getParent()->getParent());
+//                                stringObjIdx = nodeFactory.createObjectNode(stringAddress);
+              }
+              addConstraint(AndersConstraint::ADDR_OF, valIndex, stringObjIdx);
+//                            addConstraint(AndersConstraint::STORE, idx2, stringValIdx);
+//                            addConstraint(AndersConstraint::LOAD, valIndex, idx2);
+              setType(stringAddress, "NSString");
+              continue;
+            }
+
+            std::string sectionName = MachO->getSectionName(Const->getZExtValue());
+            //"bss" section?
+            if (sectionName == "" || sectionName == "__bss" || sectionName == "__common") {
+              addConstraint(AndersConstraint::LOAD, valIndex, idx2);
+            } else {
+              addConstraint(AndersConstraint::COPY, valIndex, idx2);
+            }
+            continue;
+
+          }
+
+//                if (!PatternMatch::match(inst->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_Value()))) {
+          addConstraint(AndersConstraint::LOAD, valIndex, opIndex);
+//                    break;
+//                }
+        }
+
+
+      }
+      break;
+    }
+    case Instruction::Store: {
+      if (inst->getOperand(0)->getName() == "X8_5901") {
+        assert(true);
+      }
+      if (dyn_cast<GetElementPtrInst>(inst->getOperand(1))) {
+        if (dyn_cast<ConstantInt>(inst->getOperand(0))) {
+          //Do nothing
+        } else {
+
+          //Check if the (maybe) stored parameter is a stack address that does not get accessed
+          //in this function (this happens if it is only used as parameter)
+          StackAccessPass &SAP = getAnalysis<StackAccessPass>();
+          Function *f = (Function *) inst->getParent()->getParent();
+
+          StackAccessPass::OffsetMap_t &Offsets = SAP.getOffsets(f);
+          if (Offsets.find(inst->getOperand(0)) != Offsets.end()) {
+            if (handledAliases.find(inst->getOperand(0)) == handledAliases.end()) {
+              NodeIndex valIdx = nodeFactory.getValueNodeFor(inst->getOperand(0));
+              if (valIdx == AndersNodeFactory::InvalidIndex)
+                valIdx = nodeFactory.createValueNode(inst->getOperand(0));
+              NodeIndex objIdx = nodeFactory.getObjectNodeFor(inst->getOperand(0));
+              if (objIdx == AndersNodeFactory::InvalidIndex)
+                objIdx = nodeFactory.createObjectNodeDummy(inst->getOperand(0), *Mod);
+              addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);
+              findAliases(inst->getOperand(0), true);
+              handledAliases.insert(inst->getOperand(0));
+            }
+          }
+
+          break;
+        }
+      }
+
+      ConstantInt *constDst = NULL;
+      if (PatternMatch::match(inst->getOperand(1), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(constDst)))) {
+        addConstraintsForConstIntToPtr(inst->getOperand(1), constDst);
+//                NodeIndex addrValIndex = nodeFactory.getValueNodeFor(constDst);
+//                if (addrValIndex == AndersNodeFactory::InvalidIndex)
+//                    addrValIndex = nodeFactory.createValueNode(constDst);
+//                NodeIndex objIndex = nodeFactory.getObjectNodeFor(constDst);
+//                if (objIndex == AndersNodeFactory::InvalidIndex)
+//                    objIndex = nodeFactory.createObjectNodeDummy(constDst, *(Module*)inst->getParent()->getParent()->getParent());
+//
+//                NodeIndex ptrValIndex = nodeFactory.getValueNodeFor(inst->getOperand(1));
+//                if (ptrValIndex == AndersNodeFactory::InvalidIndex)
+//                    ptrValIndex = nodeFactory.createValueNode(inst->getOperand(1));
+//
+//                addConstraint(AndersConstraint::ADDR_OF, addrValIndex, objIndex);
+//                addConstraint(AndersConstraint::COPY, ptrValIndex, addrValIndex);
+      }
+      if (inst->getOperand(0)->getType()->isPointerTy()) {
+        NodeIndex srcIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+        assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find store src node");
+        NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst->getOperand(1));
+        assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find store dst node");
+        addConstraint(AndersConstraint::STORE, dstIndex, srcIndex);
+      } else {
+//
+//                if (isa<ConstantInt>(inst->getOperand(0))) {
+//                    break;
+//                }
+//                inst->dump();
+//                NodeIndex srcIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+//                if (srcIndex == AndersNodeFactory::InvalidIndex) {
+//                    std::set<const BasicBlock*> V;
+//                    Instruction *x = nullptr;
+//                    if (findPointer(inst->getOperand(0), inst, V, &x)) {
+//                        srcIndex = nodeFactory.createValueNode(x);
+//                        addConstraint(AndersConstraint::ADDR_OF, srcIndex, nodeFactory.createObjectNode(inst->getOperand(0)));
+//                    } else {
+//                        srcIndex = nodeFactory.createValueNode(inst->getOperand(0));
+//                        addConstraint(AndersConstraint::ADDR_OF, srcIndex, nodeFactory.createObjectNode(inst->getOperand(0)));
+//                    }
+//                }
+//                assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find store src node");
+//                NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst->getOperand(1));
+//
+//                assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find store dst node");
+//                addConstraint(AndersConstraint::STORE, dstIndex, srcIndex);
+//                errs() << "STORE: " << srcIndex << "->" << dstIndex << "\n";
+
+        //Addresses should obviously only be integer values...
+        if (isa<ConstantFP>(inst->getOperand(0))) {
+          break;
+        }
+
+        //Assume all constant integers are pointers
+        if (isa<ConstantInt>(inst->getOperand(0)) && inst->getOperand(0)->getType()->getPrimitiveSizeInBits() <= 64) {
+          ConstantInt *C = dyn_cast<ConstantInt>(inst->getOperand(0));
+          //TODO:
+          if (C->getZExtValue() >= 0x100000000) {
+            if (C->getZExtValue() == 4295082136) {
+              assert(true);
+            }
+            if (MachO->isSelectorRef(C->getZExtValue())) {
+              std::string selName = MachO->getString(C->getZExtValue());
+              ConstantDataArray *PointsToData = (ConstantDataArray *) ConstantDataArray::getString(getGlobalContext(),
+                                                                                                   selName, false);
+              NodeIndex dataObject = nodeFactory.getObjectNodeFor(PointsToData);
+              if (dataObject == AndersNodeFactory::InvalidIndex) {
+                dataObject = nodeFactory.createObjectNode(PointsToData);
+              }
+
+              NodeIndex dstIdx = nodeFactory.getValueNodeFor(inst->getOperand(0));
+              if (dstIdx == AndersNodeFactory::InvalidIndex) {
+                dstIdx = nodeFactory.createValueNode(inst->getOperand(0));
+              }
+
+              addConstraint(AndersConstraint::ADDR_OF, dstIdx, dataObject);
+            } else {
+              NodeIndex valIdx = nodeFactory.getValueNodeFor(inst->getOperand(0));
+              if (valIdx == AndersNodeFactory::InvalidIndex) {
+                valIdx = nodeFactory.createValueNode(inst->getOperand(0));
+              }
+              NodeIndex objIdx = nodeFactory.getObjectNodeFor(inst->getOperand(0));
+              if (objIdx == AndersNodeFactory::InvalidIndex) {
+                objIdx = nodeFactory.createObjectNodeDummy(inst->getOperand(0),
+                                                           *(Module *) inst->getParent()->getParent()->getParent());
+//                            objIdx = nodeFactory.createObjectNode(inst->getOperand(0));
+              }
+              addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);
+              if (MachO->isCFString(C->getZExtValue())) {
+                //TODO: should we mark this one as const somehow?
+                setType(inst->getOperand(0), "NSString");
+              }
+            }
+          }
+        }
+
+        Value *Base = nullptr;
+        Instruction *IVARPtr = nullptr;
+        if (PatternMatch::match(inst->getOperand(1), PatternMatch::m_IntToPtr(
+          PatternMatch::m_BinOp(PatternMatch::m_Value(Base),
+                                PatternMatch::m_SExt(PatternMatch::m_Instruction(IVARPtr)))))) {
+          if (!isa<ConstantInt>(Base) && IVARPtr->getOpcode() == Instruction::Load) {
+            NodeIndex dstIndex = nodeFactory.getValueNodeFor(IVARPtr);
+            if (dstIndex == AndersNodeFactory::InvalidIndex)
+              dstIndex = nodeFactory.createValueNode(IVARPtr);
+            assert(dstIndex != AndersNodeFactory::InvalidIndex);
+            NodeIndex srcIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+            if (srcIndex == AndersNodeFactory::InvalidIndex) {
+              srcIndex = nodeFactory.createValueNode(inst->getOperand(0));
+            }
+            addConstraint(AndersConstraint::STORE, dstIndex, srcIndex);
+
+            NodeIndex iToPIdx = nodeFactory.getValueNodeFor(inst->getOperand(1));
+            if (iToPIdx == AndersNodeFactory::InvalidIndex)
+              iToPIdx = nodeFactory.createValueNode(inst->getOperand(1));
+            addConstraint(AndersConstraint::COPY, iToPIdx, dstIndex);
+          }
+          break;
+        }
+
+
+        if (PatternMatch::match(inst->getOperand(1), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt()))) {
+          //I don't think this is possible!?
+          NodeIndex srcIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+          if (srcIndex == AndersNodeFactory::InvalidIndex) {
+            srcIndex = nodeFactory.createValueNode(inst->getOperand(0));
+          }
+          NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst->getOperand(1));
+          if (dstIndex == AndersNodeFactory::InvalidIndex) {
+            dstIndex = nodeFactory.createValueNode(inst->getOperand(1));
+          }
+          addConstraint(AndersConstraint::STORE, dstIndex, srcIndex);
+          break;
+        }
+
+        if (dyn_cast<GetElementPtrInst>(inst->getOperand(1)))
+          break;
+
+        NodeIndex srcIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+        if (srcIndex == AndersNodeFactory::InvalidIndex) {
+          srcIndex = nodeFactory.createValueNode(inst->getOperand(0));
+        }
+        assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find store dst node");
+        NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst->getOperand(1));
+        assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find store dst node");
+
+        addConstraint(AndersConstraint::STORE, dstIndex, srcIndex);
+      }
+      break;
+    }
+    case Instruction::GetElementPtr: {
+      assert(inst->getType()->isPointerTy());
+      /*
+// P1 = getelementptr P2, ... --> <Copy/P1/P2>
+NodeIndex srcIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find gep src node");
+NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst);
+assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find gep dst node");
+
+addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+      */
+      break;
+    }
+    case Instruction::PHI: {
+      if (inst->getType()->isPointerTy()) {
+//                const PHINode *phiInst = cast<PHINode>(inst);
+//                for (unsigned i = 0, e = phiInst->getNumIncomingValues(); i != e; ++i) {
+//                    if (const Instruction *inInst = dyn_cast<const Instruction>(phiInst->getIncomingValue(i))) {
+//                        if (inInst->getOpcode() != Instruction::Load) {
+//                            assert(false);
+//                        }
+//                    } else {
+//                        assert(false);
+//                    }
+//                }
+        break;
+      } else {
+        const PHINode *phiInst = cast<PHINode>(inst);
+        NodeIndex dstIndex = nodeFactory.getValueNodeFor(phiInst);
+        if (dstIndex == AndersNodeFactory::InvalidIndex)
+          dstIndex = nodeFactory.createValueNode(phiInst);
+        for (unsigned i = 0, e = phiInst->getNumIncomingValues(); i != e; ++i) {
+          if (isa<ConstantFP>(phiInst->getIncomingValue(i))) {
+            continue;
+          }
+          NodeIndex srcIndex = nodeFactory.getValueNodeFor(phiInst->getIncomingValue(i));
+          if (srcIndex == AndersNodeFactory::InvalidIndex) {
+            srcIndex = nodeFactory.createValueNode(phiInst->getIncomingValue(i));
+          }
+          assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find phi src node");
+          addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+        }
+      }
+//			if (inst->getType()->isPointerTy())
+//			{
+//				const PHINode* phiInst = cast<PHINode>(inst);
+//				NodeIndex dstIndex = nodeFactory.getValueNodeFor(phiInst);
+//				assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find phi dst node");
+//				for (unsigned i = 0, e = phiInst->getNumIncomingValues(); i != e; ++i)
+//				{
+//					NodeIndex srcIndex = nodeFactory.getValueNodeFor(phiInst->getIncomingValue(i));
+//                    if (srcIndex == AndersNodeFactory::InvalidIndex) {
+//                        srcIndex = nodeFactory.createValueNode(phiInst->getIncomingValue(i));
+//                    }
+//					assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find phi src node");
+//					addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+//				}
+//			}
+      break;
+    }
+    case Instruction::BitCast: {
+      if (inst->getType()->isPointerTy()) {
+        NodeIndex srcIndex = nodeFactory.getValueNodeFor(inst->getOperand(0));
+        assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find bitcast src node");
+        NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst);
+        assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find bitcast dst node");
+        addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+      }
+      break;
+    }
+    case Instruction::IntToPtr: {
+      assert(inst->getType()->isPointerTy());
+
+      // Get the node index for dst
+      NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst);
+      assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find inttoptr dst node");
+
+      // We use pattern matching to look for a matching ptrtoint
+      Value *operand = inst->getOperand(0);
+
+      // Pointer copy: Y = inttoptr (ptrtoint X)
+      Value *srcValue = nullptr;
+      if (PatternMatch::match(operand, PatternMatch::m_PtrToInt(PatternMatch::m_Value(srcValue)))) {
+        NodeIndex srcIndex = nodeFactory.getValueNodeFor(srcValue);
+        assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find inttoptr src node");
+        addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+        break;
+      }
+
+      // Pointer arithmetic: Y = inttoptr (ptrtoint (X) + offset)
+      if (PatternMatch::match(operand,
+                              PatternMatch::m_Add(
+                                PatternMatch::m_PtrToInt(
+                                  PatternMatch::m_Value(srcValue)),
+                                PatternMatch::m_Value()))) {
+        NodeIndex srcIndex = nodeFactory.getValueNodeFor(srcValue);
+        assert(srcIndex != AndersNodeFactory::InvalidIndex && "Failed to find inttoptr src node");
+        addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+        break;
+      }
+
+
+      std::vector<const Value *> opList;
+      opList.push_back(operand);
+
+      for (unsigned i = 0; i < opList.size(); ++i) {
+        if (const Instruction *I = dyn_cast<const Instruction>(opList[i])) {
+          if (I->getOpcode() == Instruction::Select) {
+            opList.push_back(I->getOperand(1));
+            opList.push_back(I->getOperand(2));
+            continue;
+          }
+        }
+
+        const Value *op = opList[i];
+
+        if (const ConstantInt *Const = dyn_cast<const ConstantInt>(op)) {
+          addConstraintsForConstIntToPtr((Value *) inst, Const);
+          continue;
+        }
+
+        //TODO: handle offsets stored in registers...
+        uint64_t ConstantOffset = 0;
+        if (PatternMatch::match((Value *) op, PatternMatch::m_Add(PatternMatch::m_Value(srcValue),
+                                                                  PatternMatch::m_ConstantInt(ConstantOffset))) ||
+            PatternMatch::match((Value *) op, PatternMatch::m_Add(PatternMatch::m_Value(srcValue), PatternMatch::m_SExt(
+              PatternMatch::m_ConstantInt(ConstantOffset)))) ||
+            (PatternMatch::match((Value *) op, PatternMatch::m_Value(srcValue)) &&
+             !PatternMatch::match((Value *) op, PatternMatch::m_BinOp()))) {
+
+//                NodeIndex valNode = nodeFactory.getValueNodeFor(inst);
+//                assert(valNode != AndersNodeFactory::InvalidIndex);
+//                NodeIndex objNode = nodeFactory.getObjectNodeFor(op);
+//                if (objNode == AndersNodeFactory::InvalidIndex) {
+//                    objNode = nodeFactory.createObjectNode(op);
+//                }
+//                addConstraint(AndersConstraint::ADDR_OF, valNode, objNode);
+//                inst->dump();
+//                findAliases(op);
+//                break;
+          //Check if this pointer value was loaded from memory and then load the pointers that were stored there
+//                if (Instruction *SrcInst = dyn_cast<Instruction>(srcValue)) {
+//                    if (SrcInst->getOpcode() == Instruction::Load) {
+//                        //TODO: handle offsets that differ from zero
+//                        if (ConstantOffset == 0) {
+//                            NodeIndex srcIndex = nodeFactory.getValueNodeFor(SrcInst->getOperand(0));
+//                            assert(srcIndex != AndersNodeFactory::InvalidIndex);
+//                            addConstraint(AndersConstraint::LOAD, dstIndex, srcIndex);
+//                        } else {
+//                            //Overestimate...
+//                            if (Instruction *SrcAddress = dyn_cast<Instruction>(SrcInst->getOperand(0))) {
+//                                if (SrcAddress->isBinaryOp()) {
+//                                    //Let's take the first operand as 'base'
+//                                    Value *Base = SrcAddress->getOperand(0);
+//                                    assert(false);
+//                                }
+//                            }
+//                        }
+//                        break;
+//                    }
+//                }
+          NodeIndex srcIndex = nodeFactory.getValueNodeFor(op);
+          if (srcIndex == AndersNodeFactory::InvalidIndex) {
+            srcIndex = nodeFactory.createValueNode(op);
+
+          }
+          //FIXME: is this only needed if a new object is created?
+          NodeIndex objNode = nodeFactory.getObjectNodeFor(op);
+          if (objNode == AndersNodeFactory::InvalidIndex && handledAliases.find(op) == handledAliases.end()) {
+//                        objNode = nodeFactory.createObjectNode(op);
+//                    objNode = nodeFactory.createObjectNodeDummy(op, *Mod);
+//                            objNode = nodeFactory.createObjectNode(op);
+            objNode = nodeFactory.createObjectNodeDummy(op, getModule());
+            findAliases(op);
+          }
+          if (handledAliases.find(op) == handledAliases.end()) {
+            handledAliases.insert(op);
+            addConstraint(AndersConstraint::ADDR_OF, srcIndex, objNode);
+          }
+
+          addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+          continue;
+        } else {
+          Value *Offset = NULL;
+          if (PatternMatch::match(op, PatternMatch::m_BinOp(
+            PatternMatch::m_BinOp(PatternMatch::m_Value(srcValue), PatternMatch::m_Value(Offset)),
+            PatternMatch::m_Value()))) {
+            Value *Base = ((Instruction *) op)->getOperand(0);
+
+            NodeIndex srcIndex = nodeFactory.getValueNodeFor(Base);
+            if (srcIndex == AndersNodeFactory::InvalidIndex) {
+              srcIndex = nodeFactory.createValueNode(Base);
+            }
+            NodeIndex objNode = nodeFactory.getObjectNodeFor(Base);
+            if (objNode == AndersNodeFactory::InvalidIndex) {
+              objNode = nodeFactory.createObjectNodeDummy(Base, *Mod);
+//                            objNode = nodeFactory.createObjectNode(Base);
+            }
+            addConstraint(AndersConstraint::ADDR_OF, srcIndex, objNode);
+            addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+//                    addConstraint(AndersConstraint::COPY, valNode, dstIndex);
+            findAliases(Base, true);
+
+            continue;
+          } else if (((Instruction *) ((Instruction *) op)->getOperand(0))->getOpcode() == Instruction::PHI) {
+            DEBUG_WITH_TYPE("err", errs() << "HANDLE PHI BASE NODE: ";
+              ((Instruction *) op)->getOperand(0)->print(errs());
+              errs() << "\n";);
+//                    assert(false);
+          } else {
+//                        Instruction *base = nullptr;
+//                        Instruction *offset = nullptr;
+//                        if (PatternMatch::match(op, PatternMatch::m_BinOp(PatternMatch::m_Instruction(base), PatternMatch::m_Instruction(offset)))) {
+//                            NodeIndex valNode = nodeFactory.getValueNodeFor(inst);
+//                            assert(valNode != AndersNodeFactory::InvalidIndex);
+//                            NodeIndex srcIndex = nodeFactory.getValueNodeFor(base);
+//                            if (srcIndex == AndersNodeFactory::InvalidIndex) {
+//                                srcIndex = nodeFactory.createValueNode(base);
+//                            }
+//                            NodeIndex objNode = nodeFactory.getObjectNodeFor(base);
+//                            if (objNode == AndersNodeFactory::InvalidIndex) {
+//                                objNode = nodeFactory.createObjectNodeDummy(base, *Mod);
+////                            objNode = nodeFactory.createObjectNode(Base);
+//                            }
+//                            addConstraint(AndersConstraint::ADDR_OF, srcIndex, objNode);
+//                            addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+////                    addConstraint(AndersConstraint::COPY, valNode, dstIndex);
+//                            findAliases(base, true);
+//
+//                            continue;
+//                        }
+////                        op->dump();
+////                        assert(false);
+          }
+        }
+        // Otherwise, we really don't know what dst points to
+        addConstraint(AndersConstraint::COPY, dstIndex, nodeFactory.getUniversalPtrNode());
+
+      }
+
+      break;
+    }
+    case Instruction::Select: {
+      if (inst->getType()->isDoubleTy() || inst->getType()->isFloatTy() || inst->getType()->isFloatingPointTy()) {
+        break;
+      }
+      if (inst->getType()->isPointerTy()) {
+        ConstantInt *Const;
+        if (PatternMatch::match(inst->getOperand(1), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(Const)))) {
+          addConstraintsForConstIntToPtr(inst->getOperand(1), Const);
+        }
+
+
+        if (PatternMatch::match(inst->getOperand(2), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(Const)))) {
+          addConstraintsForConstIntToPtr(inst->getOperand(2), Const);
+        }
+
+      }
+      NodeIndex srcIndex1 = nodeFactory.getValueNodeFor(inst->getOperand(1));
+      if (srcIndex1 == AndersNodeFactory::InvalidIndex)
+        srcIndex1 = nodeFactory.createValueNode(inst->getOperand(1));
+      assert(srcIndex1 != AndersNodeFactory::InvalidIndex && "Failed to find select src node 1");
+      NodeIndex srcIndex2 = nodeFactory.getValueNodeFor(inst->getOperand(2));
+      if (srcIndex2 == AndersNodeFactory::InvalidIndex)
+        srcIndex2 = nodeFactory.createValueNode(inst->getOperand(2));
+      assert(srcIndex2 != AndersNodeFactory::InvalidIndex && "Failed to find select src node 2");
+      NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst);
+      if (dstIndex == AndersNodeFactory::InvalidIndex)
+        dstIndex = nodeFactory.createValueNode(inst);
+      assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find select dst node");
+      addConstraint(AndersConstraint::COPY, dstIndex, srcIndex1);
+      addConstraint(AndersConstraint::COPY, dstIndex, srcIndex2);
+      break;
+    }
+    case Instruction::VAArg: {
+      if (inst->getType()->isPointerTy()) {
+        NodeIndex dstIndex = nodeFactory.getValueNodeFor(inst);
+        assert(dstIndex != AndersNodeFactory::InvalidIndex && "Failed to find va_arg dst node");
+        NodeIndex vaIndex = nodeFactory.getVarargNodeFor(inst->getParent()->getParent());
+        assert(vaIndex != AndersNodeFactory::InvalidIndex && "Failed to find vararg node");
+        addConstraint(AndersConstraint::COPY, dstIndex, vaIndex);
+      }
+      break;
+    }
+    case Instruction::ExtractValue:
+    case Instruction::InsertValue: {
+      if (!inst->getType()->isPointerTy())
+        break;
+    }
+      // We have no intention to support exception-handling in the near future
+    case Instruction::LandingPad:
+    case Instruction::Resume:
+      // Atomic instructions can be modeled by their non-atomic counterparts. To be supported
+    case Instruction::AtomicRMW:
+    case Instruction::AtomicCmpXchg: {
+      DEBUG(errs() << *inst << "\n");
+      assert(false && "not implemented yet");
+    }
+    case Instruction::Add: {
+      //Check if a IVAR is accessed
+      Instruction *load = nullptr;
+      if (PatternMatch::match(inst, PatternMatch::m_BinOp(PatternMatch::m_Value(),
+                                                          PatternMatch::m_SExt(PatternMatch::m_Instruction(load))))) {
+        ConstantInt *address = nullptr;
+        if (PatternMatch::match(load->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(address)))) {
+          NodeIndex srcIdx = nodeFactory.getValueNodeFor(load->getOperand(0));
+          if (srcIdx == AndersNodeFactory::InvalidIndex)
+            srcIdx = nodeFactory.createValueNode(load->getOperand(0));
+          NodeIndex dstIdx = nodeFactory.getValueNodeFor(inst);
+          if (dstIdx == AndersNodeFactory::InvalidIndex)
+            dstIdx = nodeFactory.createValueNode(inst);
+          addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+        }
+      }
+      break;
+    }
+    case Instruction::SExt: {
+      if (const LoadInst *load = dyn_cast<const LoadInst>(inst->getOperand(0))) {
+        if (PatternMatch::match(load->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt()))) {
+          NodeIndex srcIdx = nodeFactory.getValueNodeFor(inst->getOperand(0));
+          if (srcIdx == AndersNodeFactory::InvalidIndex)
+            srcIdx = nodeFactory.createValueNode(inst->getOperand(0));
+          NodeIndex dstIdx = nodeFactory.getValueNodeFor(inst);
+          if (dstIdx == AndersNodeFactory::InvalidIndex)
+            dstIdx = nodeFactory.createValueNode(inst);
+          addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);
+        }
+      }
+      break;
+    }
+    default: {
+      DEBUG(errs() << *inst << "\n");
+      assert(!inst->getType()->isPointerTy() && "pointer-related inst not handled!");
+      break;
+    }
+  }
+}
+
+// There are two types of constraints to add for a function call:
+// - ValueNode(callsite) = ReturnNode(call target)
+// - ValueNode(formal arg) = ValueNode(actual arg)
+void Andersen::addConstraintForCall(ImmutableCallSite cs) {
+#ifdef DECOMPILED
+  if (Function *f = (Function *) cs.getCalledFunction())    // Direct call
+  {
+    DEBUG(errs() << "Call: " << cs.getCaller()->getName() << " -> " << cs.getCalledFunction()->getName() << "\n");
+    if (f->isDeclaration()) // || f->isIntrinsic())    // External library call
+    {
+      if (!f->isIntrinsic()) {
+//            errs() << cs.getCalledFunction()->getName() << "\n";
+        if (getSuccInBlock(cs.getInstruction())->getName() == "LR_7786") {
+          assert(true);
+        }
+        std::string functionName = cs.getCalledFunction()->getName().str();
+        if (!ObjectiveC::getGlobalCallHandlerManager().handleFunctionCall(cs.getInstruction(),
+                                                                          functionName, this)) {
+          std::unique_lock<std::mutex> lock(outputLock);
+          addUnhandled(cs.getCalledFunction()->getName(), cs.getInstruction());
+//                    *unhandledFunctions << "Can't handle call: " << cs.getCalledFunction()->getName() << "\n";
+        }
+//            assert(false);
+      }
+    } else { // Internal call
+      addToWorklist((Instruction *) cs.getInstruction());
+      addConstraintsForCall((CallInst *) cs.getInstruction(), f);
+    }
+  } else {
+    if (const CallInst *Call = dyn_cast<const CallInst>(cs.getInstruction())) {
+      if (Call->getCalledValue()->getType()->isPointerTy()) {
+        addToWorklist((Instruction *) Call);
+        Instruction *LoadInst = nullptr;
+        if (PatternMatch::match(Call->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_Instruction(LoadInst))) &&
+            LoadInst && LoadInst->getOpcode() == Instruction::Load) {
+          Value *BlockBase = nullptr;
+          if (PatternMatch::match(LoadInst->getOperand(0), PatternMatch::m_IntToPtr(
+            PatternMatch::m_BinOp(PatternMatch::m_Value(BlockBase), PatternMatch::m_ConstantInt())))) {
+            const Value *B = nullptr;
+            if (isBlock(dyn_cast<Instruction>(BlockBase), B)) {
+              assert(B);
+              handleBlock(Call, B);
+            }
+          }
+        } else {
+          if (const Instruction *CV_Inst = dyn_cast<const Instruction>(Call->getCalledValue())) {
+
+            std::vector<const llvm::Value *> PtsTo;
+            getPointsToSet(CV_Inst->getOperand(0), PtsTo);
+            for (auto P : PtsTo) {
+              const ConstantDataArray *ConstData = dyn_cast<const ConstantDataArray>(P);
+              if (!ConstData)
+                continue;
+              std::string FName = ConstData->getAsString();
+              Function *F = Mod->getFunction(FName);
+              if (F && !F->isIntrinsic() && !F->isDeclaration()) {
+                addConstraintsForCall(Call, F);
+              } else {
+                if (!ObjectiveC::getGlobalCallHandlerManager().handleFunctionCall(Call, FName, this)) {
+                  std::unique_lock<std::mutex> lock(outputLock);
+                  addUnhandled(FName, Call);
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+#else
+  if (const Function* f = cs.getCalledFunction())	// Direct call
+  {
+    if (f->isDeclaration() || f->isIntrinsic())	// External library call
+    {
+      // Handle libraries separately
+      if (addConstraintForExternalLibrary(cs, f))
+        return;
+      else	// Unresolved library call: ruin everything!
+      {
+        errs() << "Unresolved ext function: " << f->getName() << "\n";
+        if (cs.getType()->isPointerTy())
+        {
+          NodeIndex retIndex = nodeFactory.getValueNodeFor(cs.getInstruction());
+          assert(retIndex != AndersNodeFactory::InvalidIndex && "Failed to find ret node!");
+          addConstraint(AndersConstraint::COPY, retIndex, nodeFactory.getUniversalPtrNode());
+        }
+        for (ImmutableCallSite::arg_iterator itr = cs.arg_begin(), ite = cs.arg_end(); itr != ite; ++itr)
+        {
+          Value* argVal = *itr;
+          if (argVal->getType()->isPointerTy())
+          {
+            NodeIndex argIndex = nodeFactory.getValueNodeFor(argVal);
+            assert(argIndex != AndersNodeFactory::InvalidIndex && "Failed to find arg node!");
+            addConstraint(AndersConstraint::COPY, argIndex, nodeFactory.getUniversalPtrNode());
+          }
+        }
+      }
+    }
+    else	// Non-external function call
+    {
+      if (cs.getType()->isPointerTy())
+      {
+        NodeIndex retIndex = nodeFactory.getValueNodeFor(cs.getInstruction());
+        assert(retIndex != AndersNodeFactory::InvalidIndex && "Failed to find ret node!");
+        //errs() << f->getName() << "\n";
+        NodeIndex fRetIndex = nodeFactory.getReturnNodeFor(f);
+        assert(fRetIndex != AndersNodeFactory::InvalidIndex && "Failed to find function ret node!");
+        addConstraint(AndersConstraint::COPY, retIndex, fRetIndex);
+      }
+      // The argument constraints
+      addArgumentConstraintForCall(cs, f);
+    }
+  }
+  else	// Indirect call
+  {
+    // We do the simplest thing here: just assume the returned value can be anything :)
+    if (cs.getType()->isPointerTy())
+    {
+      NodeIndex retIndex = nodeFactory.getValueNodeFor(cs.getInstruction());
+      assert(retIndex != AndersNodeFactory::InvalidIndex && "Failed to find ret node!");
+      addConstraint(AndersConstraint::COPY, retIndex, nodeFactory.getUniversalPtrNode());
+    }
+
+    // For argument constraints, first search through all addr-taken functions: any function that takes can take as many variables is a potential candidate
+    const Module* M = cs.getInstruction()->getParent()->getParent()->getParent();
+    for (auto const& f: *M)
+    {
+      NodeIndex funPtrIndex = nodeFactory.getValueNodeFor(&f);
+      if (funPtrIndex == AndersNodeFactory::InvalidIndex)
+        // Not an addr-taken function
+        continue;
+
+      if (!f.getFunctionType()->isVarArg() && f.arg_size() != cs.arg_size())
+        // #arg mismatch
+        continue;
+
+      if (f.isDeclaration() || f.isIntrinsic())	// External library call
+      {
+        if (addConstraintForExternalLibrary(cs, &f))
+          continue;
+        else
+        {
+          // Pollute everything
+          for (ImmutableCallSite::arg_iterator itr = cs.arg_begin(), ite = cs.arg_end(); itr != ite; ++itr)
+          {
+            NodeIndex argIndex = nodeFactory.getValueNodeFor(*itr);
+            assert(argIndex != AndersNodeFactory::InvalidIndex && "Failed to find arg node!");
+            addConstraint(AndersConstraint::COPY, argIndex, nodeFactory.getUniversalPtrNode());
+          }
+        }
+      }
+      else
+        addArgumentConstraintForCall(cs, &f);
+    }
+  }
+#endif
+}
+
+void Andersen::addConstraintsForCall(const llvm::Instruction *Inst, const llvm::Function *F) {
+  if (
+    Inst->getParent()->getParent()->getName() == "-[RNEncryptor initWithSettings:encryptionKey:HMACKey:IV:handler:]" &&
+    F->getName() == "-[RNCryptorEngine initWithOperation:settings:key:IV:error:]") {
+    assert(true);
+  }
+  if (CallGraph->containtsEdge(Inst, F->getName()))
+    return;
+
+  CallGraph->addCallEdge(Inst, F->getName());
+  DetectParametersPass *DetectParams = getAnalysisIfAvailable<DetectParametersPass>();
+  if (!DetectParams)
+    DetectParams = &getAnalysis<DetectParametersPass>();
+  StackAccessPass *StackAccess = getAnalysisIfAvailable<StackAccessPass>();
+  if (!StackAccess)
+    StackAccess = &getAnalysis<StackAccessPass>();
+  DetectParametersPass::ParameterAccessPairSet_t S = DetectParams->getParameterStackOffsets(F);
+  if (S.size()) {
+    int64_t StackSize = StackAccess->getStackPointerValue(Inst);
+    for (DetectParametersPass::ParameterAccessPairSet_t::iterator PA_it = S.begin();
+         PA_it != S.end(); ++PA_it) {
+      if (StackSize != -1U)
+        findSetStackParameterInstruction((Instruction *) Inst, *PA_it, StackSize);
+    }
+  }
+  DetectParametersPass::ParameterAccessPairSet_t R = DetectParams->getParameterRegisterIndexes(F);
+  for (DetectParametersPass::ParameterAccessPairSet_t::iterator PA_it = R.begin(); PA_it != R.end(); ++PA_it) {
+    findSetRegisterParameterInstruction((Instruction *) Inst, *PA_it);
+  }
+
+  DetectParametersPass::ParameterAccessPairSet_t Return = DetectParams->getReturnRegisterIndexes(F);
+  for (DetectParametersPass::ParameterAccessPairSet_t::iterator Ret_it = Return.begin();
+       Ret_it != Return.end(); ++Ret_it) {
+
+    DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(Ret_it->first, Inst);
+    for (DetectParametersPass::UserSet_t::iterator P_it = Post.begin(); P_it != Post.end(); ++P_it) {
+
+      assert(isa<StoreInst>(Ret_it->second));
+      NodeIndex srcIndex = nodeFactory.getValueNodeFor(Ret_it->second->getOperand(0));
+      if (srcIndex == AndersNodeFactory::InvalidIndex)
+        srcIndex = nodeFactory.createValueNode(Ret_it->second->getOperand(0));
+      NodeIndex dstIndex = nodeFactory.getValueNodeFor(*P_it);
+      if (dstIndex == AndersNodeFactory::InvalidIndex)
+        dstIndex = nodeFactory.createValueNode(*P_it);
+      addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+    }
+  }
+  /*
+  for (unsigned i = 5; i < 14; ++i) {
+      if (!copyParameter(Inst, F, i))
+          preserveRegisterValue(Inst, i);
+  }*/
+}
+
+void Andersen::addArgumentConstraintForCall(ImmutableCallSite cs, const Function *f) {
+  Function::const_arg_iterator fItr = f->arg_begin();
+  ImmutableCallSite::arg_iterator aItr = cs.arg_begin();
+  while (fItr != f->arg_end() && aItr != cs.arg_end()) {
+    const Argument *formal = fItr;
+    const Value *actual = *aItr;
+
+    if (formal->getType()->isPointerTy()) {
+      NodeIndex fIndex = nodeFactory.getValueNodeFor(formal);
+      assert(fIndex != AndersNodeFactory::InvalidIndex && "Failed to find formal arg node!");
+      if (actual->getType()->isPointerTy()) {
+        NodeIndex aIndex = nodeFactory.getValueNodeFor(actual);
+        assert(aIndex != AndersNodeFactory::InvalidIndex && "Failed to find actual arg node!");
+        addConstraint(AndersConstraint::COPY, fIndex, aIndex);
+      }
+      else
+        addConstraint(AndersConstraint::COPY, fIndex, nodeFactory.getUniversalPtrNode());
+    }
+    ++fItr, ++aItr;
+  }
+
+  // Copy all pointers passed through the varargs section to the varargs node
+  if (f->getFunctionType()->isVarArg()) {
+    while (aItr != cs.arg_end()) {
+      const Value *actual = *aItr;
+      if (actual->getType()->isPointerTy()) {
+        NodeIndex aIndex = nodeFactory.getValueNodeFor(actual);
+        assert(aIndex != AndersNodeFactory::InvalidIndex && "Failed to find actual arg node!");
+        NodeIndex vaIndex = nodeFactory.getVarargNodeFor(f);
+        assert(vaIndex != AndersNodeFactory::InvalidIndex && "Failed to find vararg node!");
+        addConstraint(AndersConstraint::COPY, vaIndex, aIndex);
+      }
+
+      ++aItr;
+    }
+  }
+}
+
+bool Andersen::findAliases(const llvm::Value *Address, bool Sharp, uint64_t SPIdx) {
+  static std::mutex aliasLock;
+  std::unique_lock<std::mutex> lock(aliasLock);
+  if (const Instruction *Inst = dyn_cast<const Instruction>(Address)) {
+    Function &F = *((Function *) Inst->getParent()->getParent());
+    StackAccessPass *StackAccess = getAnalysisIfAvailable<StackAccessPass>();
+    if (!StackAccess)
+      StackAccess = &getAnalysis<StackAccessPass>();
+    StackAccessPass::OffsetMap_t OffsetsTmp;
+    StackAccessPass::OffsetValueListMap_t OffsetValuesTmp;
+    if (SPIdx != 3) {
+      std::set<uint64_t> SPSet;
+      SPSet.insert(SPIdx);
+      StackAccess->runOnFunction(F, OffsetsTmp, OffsetValuesTmp, SPSet);
+    }
+    StackAccessPass::OffsetMap_t &Offsets = SPIdx == 3 ? StackAccess->getOffsets(&F) : OffsetsTmp;
+    StackAccessPass::OffsetValueListMap_t &OffsetValues =
+      SPIdx == 3 ? StackAccess->getOffsetValues(&F) : OffsetValuesTmp;
+
+    if (Sharp) {
+      if (Offsets[Address] == nullptr) {
+        return false;
+      }
+      for (StackAccessPass::Int64List_t::iterator Offset_it = Offsets[Address]->begin();
+           Offset_it != Offsets[Address]->end(); ++Offset_it) {
+        for (StackAccessPass::ValueList_t::iterator V_it = OffsetValues[*Offset_it]->begin();
+             V_it != OffsetValues[*Offset_it]->end(); ++V_it) {
+          if (Address == *V_it)
+            continue;
+          NodeIndex idxA = nodeFactory.getValueNodeFor(Address);
+          assert(idxA != AndersNodeFactory::InvalidIndex);
+          NodeIndex idxB = nodeFactory.getValueNodeFor(*V_it);
+          if (idxB == AndersNodeFactory::InvalidIndex) {
+            idxB = nodeFactory.createValueNode(*V_it);
+          }
+          addConstraint(AndersConstraint::COPY, idxB, idxA);
+          handledAliases.insert(*V_it);
+        }
+      }
+    } else {
+      return false;
+      int64_t min = INT64_MAX;
+      if (!Offsets[Address]) {
+        DEBUG_WITH_TYPE("err", errs() << "CANT FIND ANY BASE POINTER: ";
+          Address->print(errs());
+          errs() << "\n";);
+        min = INT64_MIN;
+      } else {
+        for (StackAccessPass::Int64List_t::iterator Offset_it = Offsets[Address]->begin();
+             Offset_it != Offsets[Address]->end(); ++Offset_it) {
+          if (*Offset_it < min)
+            min = *Offset_it;
+        }
+      }
+      for (StackAccessPass::OffsetValueListMap_t::iterator OV_it = OffsetValues.begin();
+           OV_it != OffsetValues.end(); ++OV_it) {
+        if (OV_it->first >= min) {
+          if (!OffsetValues[OV_it->first]) {
+//                        errs() << "Can't find offset values\n";
+//                        errs() << F.getName() << "\n";
+            continue;
+          }
+          for (StackAccessPass::ValueList_t::iterator V_it = OffsetValues[OV_it->first]->begin();
+               V_it != OffsetValues[OV_it->first]->end(); ++V_it) {
+            if (Address == *V_it)
+              continue;
+            NodeIndex idxA = nodeFactory.getValueNodeFor(Address);
+            assert(idxA != AndersNodeFactory::InvalidIndex);
+            NodeIndex idxB = nodeFactory.getValueNodeFor(*V_it);
+            if (idxB == AndersNodeFactory::InvalidIndex) {
+              idxB = nodeFactory.createValueNode(*V_it);
+            }
+            addConstraint(AndersConstraint::COPY, idxB, idxA);
+            //TODO: should we insert this into handled aliases?
+          }
+        }
+      }
+    }
+  }
+  return false;
+}
+
+
+Instruction *Andersen::findSetStackParameterInstruction(Instruction *CallInst,
+                                                        DetectParametersPass::ParameterAccessPair_t Parameter,
+                                                        int64_t StackSize, int64_t CopyInParent) {
+  Value *Address = nullptr;
+  if (Parameter.second->getOpcode() == Instruction::Load) {
+    if (Instruction *AddressPtr = dyn_cast<Instruction>(Parameter.second->getOperand(0))) {
+      if (AddressPtr->getOpcode() == Instruction::IntToPtr) {
+        Address = AddressPtr->getOperand(0);
+      }
+    }
+  } else if (Parameter.second->getOpcode() == Instruction::Store) {
+    if (Instruction *AddressPtr = dyn_cast<Instruction>(Parameter.second->getOperand(1))) {
+      if (AddressPtr->getOpcode() == Instruction::IntToPtr) {
+        Address = AddressPtr->getOperand(0);
+      }
+    }
+  }
+  assert(Address);
+  Function *F = (Function *) CallInst->getParent()->getParent();
+  int64_t Offset = Parameter.first + StackSize;
+  StackAccessPass *StackAccess = getAnalysisIfAvailable<StackAccessPass>();
+  if (!StackAccess)
+    StackAccess = &getAnalysis<StackAccessPass>();
+  StackAccessPass::OffsetValueListMap_t &ValueMap = StackAccess->getOffsetValues(F);
+  if (ValueMap[Offset] == nullptr) {
+    return nullptr;
+  }
+  StackAccessPass::ValueList_t &Values = *ValueMap[Offset];
+  if (!Values.size())
+    llvm_unreachable("Can't find Instruction that sets the parameter");
+
+  NodeIndex idxA = nodeFactory.getValueNodeFor(*Values.begin());
+  if (idxA == AndersNodeFactory::InvalidIndex) {
+    idxA = nodeFactory.createValueNode(*Values.begin());
+  }
+  assert(idxA != AndersNodeFactory::InvalidIndex);
+  NodeIndex idxB = nodeFactory.getValueNodeFor(Address);
+  if (idxB == AndersNodeFactory::InvalidIndex) {
+    idxB = nodeFactory.createValueNode(Address);
+  }
+  addConstraint(AndersConstraint::COPY, idxB, idxA);
+
+  if (CopyInParent) {
+    for (StackAccessPass::ValueList_t::iterator V_it = Values.begin(); V_it != Values.end(); ++V_it) {
+      for (Value::const_use_iterator IU_it = (*V_it)->use_begin(); IU_it != (*V_it)->use_end(); ++IU_it) {
+        Instruction *ItoP = dyn_cast<Instruction>(IU_it->getUser());
+        if (!ItoP || ItoP->getOpcode() != Instruction::IntToPtr)
+          continue;
+        for (Value::use_iterator SU_it = ItoP->use_begin(); SU_it != ItoP->use_end(); ++SU_it) {
+          StoreInst *S = dyn_cast<StoreInst>(SU_it->getUser());
+          if (!S)
+            continue;
+
+          StackAccessPass::OffsetMap_t &Offsets = StackAccess->getOffsets(F);
+          for (StackAccessPass::Int64List_t::iterator O_it = Offsets[S->getOperand(0)]->begin();
+               O_it != Offsets[S->getOperand(0)]->end(); ++O_it) {
+            int64_t O1 = *O_it + 8;
+            int64_t O2 = *O_it + CopyInParent;
+            if (ValueMap[O1] == nullptr)
+              continue;
+            if (ValueMap[O2] == nullptr)
+              continue;
+            StackAccessPass::ValueList_t &VList1 = *ValueMap[O1];
+            StackAccessPass::ValueList_t &VList2 = *ValueMap[O2];
+            assert(VList1.size() && VList2.size());
+
+            for (StackAccessPass::ValueList_t::iterator V1_it = VList1.begin(); V1_it != VList1.end(); ++V1_it) {
+              for (Value::const_use_iterator V1U_it = (*V1_it)->use_begin(); V1U_it != (*V1_it)->use_end(); ++V1U_it) {
+                IntToPtrInst *ItoP = dyn_cast<IntToPtrInst>(V1U_it->getUser());
+                if (!ItoP)
+                  continue;
+                for (Value::use_iterator ItoPU_it = ItoP->use_begin(); ItoPU_it != ItoP->use_end(); ++ItoPU_it) {
+                  LoadInst *LI = dyn_cast<LoadInst>(ItoPU_it->getUser());
+                  if (!LI)
+                    continue;
+                  for (Value::use_iterator LIU_it = LI->use_begin(); LIU_it != LI->use_end(); ++LIU_it) {
+                    Instruction *AI = dyn_cast<Instruction>(LIU_it->getUser());
+                    if (!AI || AI->getOpcode() != Instruction::Add)
+                      continue;
+                    ConstantInt *C = dyn_cast<ConstantInt>(AI->getOperand(1));
+                    if (!C)
+                      continue;
+                    if ((int64_t) C->getZExtValue() != CopyInParent)
+                      continue;
+                    NodeIndex dst = nodeFactory.getValueNodeFor(AI);
+                    NodeIndex src = nodeFactory.getValueNodeFor(*VList2.begin());
+                    addConstraint(AndersConstraint::COPY, dst, src);
+                    addConstraint(AndersConstraint::COPY, idxB, src);
+                  }
+                }
+              }
+            }
+
+          }
+        }
+      }
+    }
+  }
+  return Address ? dyn_cast<Instruction>(Address) : nullptr;
+}
+
+Instruction *Andersen::findSetRegisterParameterInstruction(Instruction *CallInst,
+                                                           DetectParametersPass::ParameterAccessPair_t Parameter) {
+  std::unique_lock<std::mutex> lock(paramLock);
+  StackAccessPass::OffsetMap_t OffsetMap_param;
+  StackAccessPass::OffsetValueListMap_t OffsetValueListMap_param;
+  std::set<uint64_t> SPIdx;
+  SPIdx.insert(Parameter.first);
+  StackAccessPass::runOnFunction(*Parameter.second->getParent()->getParent(), OffsetMap_param,
+                                 OffsetValueListMap_param, SPIdx);
+
+  StackAccessPass *SAP = &getAnalysis<StackAccessPass>();
+
+  StackAccessPass::OffsetMap_t &OffsetMap_caller = SAP->getOffsets(CallInst->getParent()->getParent());
+  StackAccessPass::OffsetValueListMap_t &OffsetValueListMap_caller = SAP->getOffsetValues(
+    CallInst->getParent()->getParent());
+
+  std::set<int64_t> OffsetsToFind;
+
+  //Check if this parameters is used as base pointer (structs do it like this)
+  for (auto &OV_it : OffsetValueListMap_param) {
+    //The first element in a struct is handled like a 'normal' variable
+    if (OV_it.first == 0) {
+      continue;
+    }
+    OffsetsToFind.insert(OV_it.first);
+  }
+
+  DetectParametersPass::UserSet_t Pre = DetectParametersPass::getRegisterValuesBeforeCall(Parameter.first, CallInst);
+  assert(Pre.size() > 0);
+  for (DetectParametersPass::UserSet_t::iterator Pre_it = Pre.begin(); Pre_it != Pre.end(); ++Pre_it) {
+    NodeIndex dstIndex = nodeFactory.getValueNodeFor(Parameter.second);
+    if (dstIndex == AndersNodeFactory::InvalidIndex)
+      dstIndex = nodeFactory.createValueNode(Parameter.second);
+    NodeIndex srcIndex = nodeFactory.getValueNodeFor(*Pre_it);
+    if (srcIndex == AndersNodeFactory::InvalidIndex)
+      srcIndex = nodeFactory.createValueNode(*Pre_it);
+    addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+
+    if (OffsetMap_caller.find(*Pre_it) != OffsetMap_caller.end()) {
+      //This means that this is a stack address
+      if (!OffsetMap_caller[*Pre_it])
+        continue;
+      if (OffsetMap_caller[*Pre_it]->size()) {
+        std::vector<const Value *> ptsTo;
+        getPointsToSet(*Pre_it, ptsTo);
+        if (ptsTo.size() == 0) {
+          NodeIndex valIdx = nodeFactory.getValueNodeFor(*Pre_it);
+          assert(valIdx != AndersNodeFactory::InvalidIndex);
+          NodeIndex objIdx = nodeFactory.createObjectNodeDummy(*Pre_it, *Mod);
+          addConstraint(AndersConstraint::ADDR_OF, valIdx, objIdx);
+          if (handledAliases.find(*Pre_it) == handledAliases.end()) {
+            findAliases(*Pre_it, true);
+          }
+        }
+      }
+      for (auto &O : OffsetsToFind) {
+        for (auto &O_C : *OffsetMap_caller[*Pre_it]) {
+          int Find = O_C + O;
+          if (OffsetValueListMap_caller[Find]) {
+            for (auto &OV_caller : *OffsetValueListMap_caller[Find]) {
+              for (auto &OV_param : *OffsetValueListMap_param[O]) {
+                NodeIndex dstIndex2 = nodeFactory.getValueNodeFor(OV_param);
+                if (dstIndex2 == AndersNodeFactory::InvalidIndex)
+                  dstIndex2 = nodeFactory.createValueNode(OV_param);
+                NodeIndex srcIndex2 = nodeFactory.getValueNodeFor(OV_caller);
+                if (srcIndex2 == AndersNodeFactory::InvalidIndex)
+                  srcIndex2 = nodeFactory.createValueNode(OV_caller);
+                addConstraint(AndersConstraint::COPY, dstIndex2, srcIndex2);
+              }
+            }
+          } else {
+            DEBUG(errs() << "Offset: " << O << "\n";
+                    errs() << Parameter.second->getParent()->getParent()->getName() << "\n";);
+//                        assert(false && "Struct was not accessed?");
+          }
+        }
+      }
+    } else if (OffsetsToFind.size()) {
+      //TODO: dynamically allocated structs, "forwarded" structs: structs that are already paramters in the calling function (and the location requested here may not be accessed in the caller)
+//            assert(false && "Structs in registers are not handled yet");
+    }
+  }
+
+////    DominatorTree &DomTree = getAnalysis<DominatorTreeWrapperPass>(*CallInst->getParent()->getParent()).getDomTree();
+//    DominatorTreeWrapperPass *DomTreePass = getAnalysisIfAvailable<DominatorTreeWrapperPass>();
+//    if (!DomTreePass)
+//        DomTreePass = &getAnalysis<DominatorTreeWrapperPass>(*CallInst->getParent()->getParent());
+//    DominatorTree &DomTree = DomTreePass->getDomTree();
+//    if (Parameter.second->getOpcode() == Instruction::Load) {
+//        if (GetElementPtrInst *Inst = dyn_cast<GetElementPtrInst>(Parameter.second->getOperand(0))) {
+//            if (ConstantInt *IdxValue = dyn_cast<ConstantInt>(Inst->getOperand(2))) {
+//                for (BasicBlock::InstListType::iterator I_it = CallInst->getParent()->getParent()->getEntryBlock().begin();
+//                        I_it != CallInst->getParent()->getParent()->getEntryBlock().end();
+//                        ++I_it) {
+//                    if (I_it->getOpcode() == Instruction::GetElementPtr) {
+//                        if (I_it->getOperand(2) == IdxValue) {
+//                            Instruction *LastLoad = nullptr;
+//                            for (Value::const_use_iterator U_it = I_it->use_begin();
+//                                    U_it != I_it->use_end();
+//                                    ++U_it) {
+//                                if (((Instruction*)U_it->getUser())->getOpcode() == Instruction::Store) {
+//                                    if (DomTree.dominates((Instruction*)U_it->getUser(), CallInst)) {
+//                                        if (LastLoad == nullptr || DomTree.dominates(LastLoad, (Instruction*)U_it->getUser())) {
+//                                            LastLoad = (Instruction*)U_it->getUser();
+//                                        }
+//                                    }
+//                                }
+//                            }
+//                            assert(LastLoad);
+//
+//                            NodeIndex idxA = nodeFactory.getValueNodeFor(LastLoad->getOperand(0));
+//                            if (idxA == AndersNodeFactory::InvalidIndex) {
+//                                idxA = nodeFactory.createValueNode(LastLoad->getOperand(0));
+//                            }
+//                            assert(idxA != AndersNodeFactory::InvalidIndex);
+//                            NodeIndex idxB = nodeFactory.getValueNodeFor(Parameter.second);
+//                            if (idxB == AndersNodeFactory::InvalidIndex) {
+//                                idxB = nodeFactory.createValueNode(Parameter.second);
+//                            }
+//                            addConstraint(AndersConstraint::COPY, idxB, idxA);
+//                        }
+//                    }
+//                }
+//            }
+//        }
+//    }
+  return nullptr;
+}
+
+void Andersen::addConstraintsForConstIntToPtr(const llvm::Value *IntToPtr, const llvm::ConstantInt *Const) {
+  uint64_t V = 0;
+  if (!MachO->getValue(Const->getZExtValue(), V)) {
+//        return;
+  }
+
+  if (Const->getZExtValue() == 4295225424) {
+    assert(true);
+  }
+  //FIXME: If no pointer was set (the address referenced here is 0x0) should we use the pointer address instead?
+//    ConstantInt *Dummy = ConstantInt::get(getGlobalContext(), APInt(64, V ? V : Const->getZExtValue()));
+
+  bool isIVAR = false;
+  if (MachO->isIVAR(Const->getZExtValue())) {
+    isIVAR = true;
+    ivarMap[Const->getZExtValue()] = IntToPtr;
+  }
+
+  std::string Data = MachO->getString(V ? V : Const->getZExtValue());
+  Value *PointsToData = nullptr;
+  if (Data.size() > 0 && !isIVAR) {
+    PointsToData = (ConstantDataArray *) ConstantDataArray::getString(getGlobalContext(), Data, false);
+  } else {
+    if (nodeFactory.getAbstractLocation(Const) != Const) {
+
+    } else {
+      nodeFactory.createObjectNodeDummy(Const, *Mod);
+    }
+    PointsToData = (Value *) nodeFactory.getAbstractLocation(Const);
+//        if (DummyMap.find(Const) == DummyMap.end()) {
+//            PointsToData = new llvm::GlobalVariable(*Mod, llvm::IntegerType::get(llvm::getGlobalContext(), 1), false, llvm::GlobalVariable::ExternalLinkage,
+//                                                    nullptr);
+//
+//            DummyMap[Const] = PointsToData;
+//        } else {
+//            PointsToData = DummyMap[Const];
+//        }
+  }
+
+
+  NodeIndex dataObject = nodeFactory.getObjectNodeFor(PointsToData);
+  if (dataObject == AndersNodeFactory::InvalidIndex) {
+    dataObject = nodeFactory.createObjectNode(PointsToData);
+  }
+
+  NodeIndex dstIdx = nodeFactory.getValueNodeFor(IntToPtr);
+  if (dstIdx == AndersNodeFactory::InvalidIndex) {
+    dstIdx = nodeFactory.createValueNode(IntToPtr);
+  }
+
+  addConstraint(AndersConstraint::ADDR_OF, dstIdx, dataObject);
+
+/*
+
+//    if (MachO->isIVAR(V ? V : Const->getZExtValue()))
+//        return;
+
+
+
+    NodeIndex DV = nodeFactory.getValueNodeFor(Dummy);
+    NodeIndex DO = nodeFactory.getObjectNodeFor(PointsToData);
+    if (DO == AndersNodeFactory::InvalidIndex) {
+        DO = nodeFactory.createObjectNode(PointsToData);
+    }
+    if (DV == AndersNodeFactory::InvalidIndex) {
+        DV = nodeFactory.createValueNode(Dummy);
+    }
+    addConstraint(AndersConstraint::ADDR_OF, DV, DO);
+
+    NodeIndex  C = nodeFactory.getValueNodeFor(Const);
+    if (C == AndersNodeFactory::InvalidIndex) {
+        C = nodeFactory.createValueNode(Const);
+        addConstraint(AndersConstraint::ADDR_OF, C, nodeFactory.createObjectNode(Const));
+    }
+    addConstraint(AndersConstraint::STORE, C, DV);
+//
+//    addConstraint(AndersConstraint::ADDR_OF, C, nodeFactory.getObjectNodeFor(Const) == AndersNodeFactory::InvalidIndex ? nodeFactory.createObjectNode(Const) : nodeFactory.getObjectNodeFor(Const));
+
+    assert(isa<User>(IntToPtr));
+    NodeIndex ItoP = nodeFactory.getValueNodeFor(((User*)IntToPtr)->getOperand(0));
+    if (ItoP == AndersNodeFactory::InvalidIndex) {
+        ItoP = nodeFactory.createValueNode(((User*)IntToPtr)->getOperand(0));
+    }
+    addConstraint(AndersConstraint::LOAD, ItoP, C);
+
+    NodeIndex dstIdx = nodeFactory.getValueNodeFor(IntToPtr);
+    if (dstIdx == AndersNodeFactory::InvalidIndex) {
+        dstIdx = nodeFactory.createValueNode(IntToPtr);
+    }
+    addConstraint(AndersConstraint::COPY, dstIdx, ItoP);*/
+}
+
+void Andersen::preserveRegisterValue(llvm::Instruction *CallInst, uint64_t RegNo) {
+  DetectParametersPass::UserSet_t Pre = DetectParametersPass::getRegisterValuesBeforeCall(RegNo, CallInst);
+  DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(RegNo, CallInst);
+
+  for (DetectParametersPass::UserSet_t::iterator Pre_it = Pre.begin(); Pre_it != Pre.end(); ++Pre_it) {
+    const Instruction *PreInst = dyn_cast<const Instruction>(*Pre_it);
+
+    if (!PreInst) // || PreInst->getParent() != CallInst->getParent())
+      continue;
+    for (DetectParametersPass::UserSet_t::iterator Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+      const Instruction *PostInst = dyn_cast<const Instruction>(*Post_it);
+      if (!PostInst) // || PostInst->getParent() != CallInst->getParent())
+        continue;
+
+      NodeIndex srcIndex = nodeFactory.getValueNodeFor(PreInst);
+      if (srcIndex == AndersNodeFactory::InvalidIndex)
+        srcIndex = nodeFactory.createValueNode(PreInst);
+      NodeIndex dstIndex = nodeFactory.getValueNodeFor(PostInst);
+      if (dstIndex == AndersNodeFactory::InvalidIndex)
+        dstIndex = nodeFactory.createValueNode(PostInst);
+      addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+    }
+  }
+}
+
+
+bool Andersen::copyParameter(llvm::Instruction *CallInst, llvm::Function *F, uint64_t RegNo) {
+  BasicBlock *ExitBB = nullptr;
+  for (Function::iterator BB_it = F->begin(); BB_it != F->end(); ++BB_it) {
+    if (BB_it->getTerminator()->getOpcode() == Instruction::Ret) {
+//        if (BB_it->getName().startswith("exit_")) {
+      ExitBB = &*BB_it;
+      break;
+    }
+  }
+
+  if (!ExitBB) {
+//        errs() << "No 'return' found in: " << F->getName() << "\n";
+    return false;
+  }
+
+  assert(ExitBB);
+
+  Value *Prev = nullptr;
+
+  for (Instruction *I = ExitBB->getTerminator(); I != &ExitBB->front(); I = I->getPrevNode()) {
+    if (I->getOpcode() == Instruction::Store) {
+      Instruction *Address = dyn_cast<Instruction>(I->getOperand(1));
+      if (Address && Address->getOpcode() == Instruction::GetElementPtr) {
+        if (ConstantInt *Idx = dyn_cast<ConstantInt>(Address->getOperand(2))) {
+          if (Idx->getZExtValue() == RegNo) {
+            Prev = I->getOperand(0);
+            break;
+          }
+        }
+      }
+    }
+  }
+
+
+  if (!Prev)
+    return false;
+
+  DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(RegNo, CallInst);
+
+  for (DetectParametersPass::UserSet_t::iterator Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+    NodeIndex srcIndex = nodeFactory.getValueNodeFor(Prev);
+    if (srcIndex == AndersNodeFactory::InvalidIndex)
+      srcIndex = nodeFactory.createValueNode(Prev);
+    NodeIndex dstIndex = nodeFactory.getValueNodeFor(&**Post_it);
+    if (dstIndex == AndersNodeFactory::InvalidIndex)
+      dstIndex = nodeFactory.createValueNode(&**Post_it);
+    addConstraint(AndersConstraint::COPY, dstIndex, srcIndex);
+  }
+
+  return false;
+}
+
+bool Andersen::isBlock(const llvm::Instruction *Inst, const llvm::Value *&B) {
+  if (!Inst)
+    return false;
+  if (dyn_cast<Instruction>(Inst)) {
+    std::vector<const Value *> PtsTo;
+    getPointsToSet(Inst, PtsTo);
+
+    for (std::vector<const Value *>::iterator PtsTo_it = PtsTo.begin(); PtsTo_it != PtsTo.end(); ++PtsTo_it) {
+      const Instruction *I = dyn_cast<const Instruction>(*PtsTo_it);
+      if (!I)
+        continue;
+      StackAccessPass &SAP = getAnalysis<StackAccessPass>();
+      StackAccessPass::OffsetMap_t &Offsets = SAP.getOffsets(((Instruction *) (*PtsTo_it))->getParent()->getParent());
+      StackAccessPass::OffsetValueListMap_t &OffsetValues = SAP.getOffsetValues(
+        ((Instruction *) (*PtsTo_it))->getParent()->getParent());
+      if (!Offsets[*PtsTo_it])
+        continue;
+      for (StackAccessPass::Int64List_t::iterator O_it = Offsets[*PtsTo_it]->begin();
+           O_it != Offsets[*PtsTo_it]->end(); ++O_it) {
+        for (StackAccessPass::ValueList_t::iterator V_it = OffsetValues[*O_it]->begin();
+             V_it != OffsetValues[*O_it]->end(); ++V_it) {
+          for (std::set<Value *>::iterator B_it = Blocks.begin(); B_it != Blocks.end(); ++B_it) {
+            if (*B_it == *V_it) {
+              B = *B_it;
+              return true;
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+void Andersen::addBlock(llvm::Value *B) {
+  Blocks.insert(B);
+}
+
+bool Andersen::handleBlock(const Instruction *Call, const Value *Block) {
+  std::vector<const Value *> PtsTo;
+  getPointsToSet(Block, PtsTo);
+  for (std::vector<const Value *>::iterator PtsTo_it = PtsTo.begin(); PtsTo_it != PtsTo.end(); ++PtsTo_it) {
+
+    const Function *Func = cast<const Instruction>((*PtsTo_it))->getParent()->getParent();
+    StackAccessPass &StackAccess = getAnalysis<StackAccessPass>();
+
+    StackAccessPass::OffsetMap_t &Offsets = StackAccess.getOffsets(Func);
+    StackAccessPass::OffsetValueListMap_t &OffsetValues = StackAccess.getOffsetValues(Func);
+
+    StackAccessPass::Int64List_t &BlockOffsets = *Offsets[*PtsTo_it];
+
+    for (StackAccessPass::Int64List_t::iterator BO_it = BlockOffsets.begin(); BO_it != BlockOffsets.end(); ++BO_it) {
+      //Address of the function of this block has an offset of 16 to the block object
+      int64_t BlockAddress = *BO_it + 16;
+
+      StackAccessPass::ValueList_t &FunctionAddress = *OffsetValues[BlockAddress];
+
+      for (StackAccessPass::ValueList_t::iterator FAV_it = FunctionAddress.begin();
+           FAV_it != FunctionAddress.end(); ++FAV_it) {
+        std::vector<const Value *> FunctionAddressCandidates;
+        getPointsToSet(*FAV_it, FunctionAddressCandidates);
+        for (std::vector<const Value *>::iterator FAC_it = FunctionAddressCandidates.begin();
+             FAC_it != FunctionAddressCandidates.end(); ++FAC_it) {
+          for (Value::const_use_iterator ITPUse_it = (*FAC_it)->use_begin();
+               ITPUse_it != (*FAC_it)->use_end(); ++ITPUse_it) {
+            if (Instruction *I = dyn_cast<Instruction>(ITPUse_it->getUser())) {
+              if (I->getOpcode() != Instruction::IntToPtr)
+                continue;
+              for (Value::const_use_iterator STUse_it = I->use_begin(); STUse_it != I->use_end(); ++STUse_it) {
+                if (Instruction *I2 = dyn_cast<Instruction>(STUse_it->getUser())) {
+                  if (I2->getOpcode() != Instruction::Store)
+                    continue;
+                  if (ConstantInt *Address = dyn_cast<ConstantInt>(I2->getOperand(0))) {
+
+                    std::string FName = getMachO().getFunctionName(Address->getZExtValue());
+
+                    Function *F = getModule().getFunction(FName);
+                    if (getCallGraph().containtsEdge(Call, FName))
+                      return true;
+                    getCallGraph().addCallEdge(Call, FName);
+
+                    if (!F)
+                      continue;
+                    std::set<uint64_t> SPIdx;
+                    SPIdx.insert(5);
+                    DetectParametersPass::ParameterAccessPairSet_t StackParams = getAnalysis<DetectParametersPass>(
+                      *F).getStackParameters(*F, SPIdx);
+
+                    int64_t StackSize = StackAccess.getStackPointerValue((Instruction *) Block, false);
+                    for (DetectParametersPass::ParameterAccessPairSet_t::iterator PA_it = StackParams.begin();
+                         PA_it != StackParams.end(); ++PA_it) {
+                      if (PA_it->second->getOpcode() == Instruction::Load) {
+                        for (Value::use_iterator BU_it = PA_it->second->use_begin();
+                             BU_it != PA_it->second->use_end(); ++BU_it) {
+                          Instruction *BU = dyn_cast<Instruction>(BU_it->getUser());
+                          if (BU->getOpcode() == Instruction::Add) {
+                            ConstantInt *O = dyn_cast<ConstantInt>(BU->getOperand(1));
+                            if (O && O->getZExtValue() == 8) {
+                              for (Value::use_iterator BU2_it = BU->use_begin(); BU2_it != BU->use_end(); ++BU2_it) {
+                                Instruction *BU2 = dyn_cast<Instruction>(BU2_it->getUser());
+                                if (BU2->getOpcode() != Instruction::IntToPtr)
+                                  continue;
+                                for (Value::use_iterator BU3_it = BU2->use_begin();
+                                     BU3_it != BU2->use_end(); ++BU3_it) {
+                                  Instruction *BU3 = dyn_cast<Instruction>(BU3_it->getUser());
+                                  if (!BU3 || BU3->getOpcode() != Instruction::Load)
+                                    continue;
+                                  for (Value::use_iterator BU4_it = BU3->use_begin();
+                                       BU4_it != BU3->use_end(); ++BU4_it) {
+                                    Instruction *BU4 = dyn_cast<Instruction>(BU4_it->getUser());
+                                    if (!BU4 || BU4->getOpcode() != Instruction::Add)
+                                      continue;
+                                    ConstantInt *O2 = dyn_cast<ConstantInt>(BU4->getOperand(1));
+                                    if (!O2)
+                                      continue;
+                                    for (Value::use_iterator BU5_it = BU4->use_begin();
+                                         BU5_it != BU4->use_end(); ++BU5_it) {
+                                      Instruction *BU5 = dyn_cast<Instruction>(BU5_it->getUser());
+                                      if (BU5->getOpcode() != Instruction::IntToPtr)
+                                        continue;
+                                      for (Value::use_iterator BU6_it = BU5->use_begin();
+                                           BU6_it != BU5->use_end(); ++BU6_it) {
+                                        Instruction *BU6 = dyn_cast<Instruction>(BU6_it->getUser());
+                                        if (!BU6 || !(BU6->getOpcode() == Instruction::Load ||
+                                                      BU6->getOpcode() == Instruction::Store))
+                                          continue;
+                                        findSetStackParameterInstruction((Instruction *) Block,
+                                                                         DetectParametersPass::ParameterAccessPair_t(
+                                                                           PA_it->first, BU6), StackSize,
+                                                                         O2->getZExtValue());
+                                      }
+                                    }
+                                  }
+                                }
+                              }
+                            }
+                          }
+                        }
+                      }
+                      findSetStackParameterInstruction((Instruction *) Block, *PA_it, StackSize);
+                    }
+                  }
+                }
+              }
+            }
+
+          }
+        }
+      }
+
+
+    }
+  }
+
+  return false;
+}
+
+
+bool Andersen::isDummyHelper(const llvm::Value *val) {
+  return dummyHelpers.find(val) != dummyHelpers.end();
+}
\ No newline at end of file
diff --git a/lib/Analysis/Andersen/ConstraintOptimize.cpp b/lib/Analysis/Andersen/ConstraintOptimize.cpp
new file mode 100644
index 0000000..3b11c3b
--- /dev/null
+++ b/lib/Analysis/Andersen/ConstraintOptimize.cpp
@@ -0,0 +1,598 @@
+#include "llvm/Analysis/Andersen/Andersen.h"
+#include "llvm/Analysis/Andersen/CycleDetector.h"
+#include "llvm/Analysis/Andersen/SparseBitVectorGraph.h"
+
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/DenseSet.h"
+#include "llvm/ADT/SparseBitVector.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/ToolOutputFile.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/FileSystem.h"
+
+#include <deque>
+#include <unordered_map>
+#include <set>
+
+using namespace llvm;
+
+cl::opt<bool> EnableHVN("enable-hvn", cl::desc("Enable the HVN constraint optimization"));
+cl::opt<bool> EnableHU("enable-hu", cl::desc("Enable the HU constraint optimization"));
+
+namespace {
+
+struct SparseBitVectorHash
+{
+	std::size_t operator() (const SparseBitVector<>& vec) const
+	{
+		std::size_t ret = 0;
+		for (auto const& idx: vec)
+			ret ^= idx;
+		return ret;
+	}
+};
+
+struct SparseBitVectorKeyEqual
+{
+	bool operator() (const SparseBitVector<>& lhs, const SparseBitVector<>& rhs) const
+	{
+		return lhs == rhs;
+	}
+};
+
+// There is something in common in HVN and HU. Put all the shared stuffs in the base class here
+class ConstraintOptimizer: public CycleDetector<SparseBitVectorGraph>
+{
+protected:
+	std::vector<AndersConstraint>& constraints;
+	AndersNodeFactory& nodeFactory;
+
+	// The predecessor graph
+	SparseBitVectorGraph predGraph;
+	// Nodes that must be treated conservatively (i.e. never merge with others)
+	// Note that REF nodes and ADR nodes are all automatically indirect nodes. This set only keep track of indirect nodes that are not REF or ADR
+	DenseSet<NodeIndex> indirectNodes;
+
+	// Map from NodeIndex to Pointer Equivalence Class
+	DenseMap<NodeIndex, unsigned> peLabel;
+	// Current pointer equivalence class number
+	unsigned pointerEqClass;
+
+	// Store the "representative" (or "leader") when there is a merge in the cycle. Note that this is different from AndersNode::mergeTarget, which will be set AFTER the optimization
+	DenseMap<NodeIndex, NodeIndex> mergeTarget;
+
+	// During variable substitution, we create unknowns to represent the unknown value that is a dereference of a variable.  These nodes are known as "ref" nodes (since they represent the value of dereferences)
+	// Return the node index of the "ref node" (used to represent *n) of n.
+	// We won't actually create that ref node. We cannot use the NodeIndex of that refNode to index into nodeFactory
+	NodeIndex getRefNodeIndex(NodeIndex n) const
+	{
+		assert(n < nodeFactory.getNumNodes());
+		return n + nodeFactory.getNumNodes();
+	}
+
+	// Return the node index of the "adr node" (used to represent &n) of n. Only addr-taken vars can be adr-ed
+	// We won't actually create that adr node. We cannot use the NodeIndex of that adrNode to index into nodeFactory
+	NodeIndex getAdrNodeIndex(NodeIndex n) const
+	{
+		assert(n < nodeFactory.getNumNodes());
+		return n + 2 * nodeFactory.getNumNodes();
+	}
+
+	void buildPredecessorGraph()
+	{
+		for (auto const& c: constraints)
+		{
+			NodeIndex srcTgt = nodeFactory.getMergeTarget(c.getSrc());
+			NodeIndex dstTgt = nodeFactory.getMergeTarget(c.getDest());
+			switch (c.getType())
+			{
+				case AndersConstraint::ADDR_OF:
+				{
+					indirectNodes.insert(srcTgt);
+					// Dest = &src edge
+					predGraph.insertEdge(dstTgt, getAdrNodeIndex(srcTgt));
+					// *Dest = src edge
+					predGraph.insertEdge(getRefNodeIndex(dstTgt), srcTgt);
+					break;
+				}
+				case AndersConstraint::LOAD:
+				{
+					// dest = *src edge
+					predGraph.insertEdge(dstTgt, getRefNodeIndex(srcTgt));
+					break;
+				}
+				case AndersConstraint::STORE:
+				{
+					// *dest = src edge
+					predGraph.insertEdge(getRefNodeIndex(dstTgt), srcTgt);
+					break;
+				}
+				case AndersConstraint::COPY:
+				{
+					// Dest = Src edge
+					predGraph.insertEdge(dstTgt, srcTgt);
+					// *Dest = *Src edge
+					predGraph.insertEdge(getRefNodeIndex(dstTgt), getRefNodeIndex(srcTgt));
+					break;
+				}
+			}
+		}
+	}
+
+	void printPredecessorGraphNode(raw_ostream& os, NodeIndex n) const
+	{
+		if (n >= nodeFactory.getNumNodes() * 2)
+			os << "<ADR> ";
+		else if (n >= nodeFactory.getNumNodes())
+			os << "<REF> ";
+		os << "[Node " << n % nodeFactory.getNumNodes() << "]";
+	}
+
+	void dumpPredecessorGraph() const
+	{
+		errs() << "\n----- Predecessor Graph -----\n";
+		for (auto const& mapping: predGraph)
+		{
+			printPredecessorGraphNode(errs(), mapping.first);
+			errs()<< "  -->  ";
+			const SparseBitVectorGraphNode& sNode = mapping.second;
+			for (auto const& idx: sNode)
+			{
+				printPredecessorGraphNode(errs(), idx);
+				errs() << ", ";
+			}
+			errs() << '\n';
+		}
+		errs() << "----- End of Print -----\n";
+	}
+
+	void writePredecessorGraphToFile() const
+	{
+		std::error_code errInfo;
+		tool_output_file outFile("dots/pred.dot", errInfo, sys::fs::F_Text);
+		if (errInfo)
+		{
+			errs() << errInfo.message() << '\n';
+			return;
+		}
+
+		raw_fd_ostream& os = outFile.os();
+		os << "digraph G {\n";
+		std::deque<bool> hasLabel(nodeFactory.getNumNodes() * 3, false);
+		for (auto const& mapping: predGraph)
+		{
+			if (!hasLabel[mapping.first])
+			{
+				os << "\tnode" << mapping.first << " [label = \"";
+				printPredecessorGraphNode(os, mapping.first);
+				os << "\"]\n";
+				hasLabel[mapping.first] = true;
+			}
+			const SparseBitVectorGraphNode& sNode = mapping.second;
+			for (auto const& idx: sNode)
+			{
+				if (!hasLabel[idx])
+				{
+					os << "\tnode" << idx << " [label = \"";
+					printPredecessorGraphNode(os, idx);
+					os << "\"]\n";
+					hasLabel[idx] = true;
+				}
+				os << "\tnode" << idx << " -> " << "node" << mapping.first << '\n';
+			}
+		}
+		os << "}\n";
+
+		outFile.keep();
+	}
+
+	NodeIndex getMergeTargetRep(NodeIndex idx)
+	{
+		while (true)
+		{
+			auto itr = mergeTarget.find(idx);
+			if (itr == mergeTarget.end())
+				break;
+			else
+				idx = itr->second;
+		}
+
+		return idx;
+	}
+
+	NodeType* getRep(NodeIndex idx) override
+	{
+		return predGraph.getOrInsertNode(getMergeTargetRep(idx));
+	}
+	// Specify how to process the non-rep nodes if a cycle is found
+	void processNodeOnCycle(const NodeType* node, const NodeType* repNode) override
+	{
+		NodeIndex nodeIdx = node->getNodeIndex();
+		NodeIndex repIdx = repNode->getNodeIndex();
+		mergeTarget[nodeIdx] = getMergeTargetRep(repIdx);
+		if (repIdx < nodeFactory.getNumNodes() && (indirectNodes.count(nodeIdx) || nodeIdx > nodeFactory.getNumNodes()))
+			indirectNodes.insert(repIdx);
+
+		predGraph.mergeEdge(repIdx, nodeIdx);
+	}
+
+	// Specify how to process the rep nodes if a cycle is found
+	void processCycleRepNode(const NodeType* node) override
+	{
+		propagateLabel(node->getNodeIndex());
+	}
+
+	void rewriteConstraint()
+	{
+		// Since only direct VAR nodes can be assigned non-unique labels, there are only three cases to consider: VAR+VAR, VAR+REF, and VAR+ADR
+		// - For VAR+VAR, just merge one node into the other
+		// - For VAR+REF, certainly we want to replace the REF node with the VAR node. This will definitely cut down the analysis time because we have one less indirect node to worry about
+		// - For VAR+ADR, we want to replace the VAR node with the ADR node because the latter is more straightforward
+
+		std::vector<NodeIndex> revLabelMap(pointerEqClass, AndersNodeFactory::InvalidIndex);
+		// Scan all the VAR nodes to see if any of them have the same label as other VAR nodes. We have to perform the merge before constraint rewriting
+
+		for (auto const& mapping: peLabel)
+		{
+			NodeIndex node = mapping.first;
+			if (node >= nodeFactory.getNumNodes())
+				continue;
+
+			if (nodeFactory.getMergeTarget(node) != node)
+				continue;
+
+			unsigned iLabel = mapping.second;
+			if (revLabelMap[iLabel] == AndersNodeFactory::InvalidIndex)
+				revLabelMap[iLabel] = node;
+			else if (iLabel != 0)	// We have already found a VAR or ADR node with the same label. Note we must exclude label 0 since it's special and cannot be merged
+			{
+				//errs() << "MERGE " << i << "with" << revLabelMap[iLabel] << "\n";
+				nodeFactory.mergeNode(revLabelMap[iLabel], node);
+			}
+		}
+
+		// Collect all peLabels that are assigned to ADR nodes
+		for (auto const& mapping: peLabel)
+		{
+			NodeIndex node = mapping.first;
+			if (node < nodeFactory.getNumNodes() * 2)
+				continue;
+
+			NodeIndex varNode = node - nodeFactory.getNumNodes() * 2;
+			if (nodeFactory.getMergeTarget(varNode) != varNode)
+				continue;
+			revLabelMap[mapping.second] = node;
+		}
+
+		// Now scan all constraints and see if we can simplify them
+		std::vector<AndersConstraint> newConstraints;
+		for (auto const& c: constraints)
+		{
+			// First, if the lhs has label 0 (non-ptr), ignore this constraint
+			if (peLabel[c.getDest()] == 0)
+				continue;
+
+			// Change the lhs to its mergeTarget
+			NodeIndex destTgt = nodeFactory.getMergeTarget(c.getDest());
+			// Change the rhs to its merge target
+			NodeIndex srcTgt = nodeFactory.getMergeTarget(c.getSrc());
+			switch (c.getType())
+			{
+				case AndersConstraint::ADDR_OF:
+				{
+					// We don't want to replace src with srcTgt because, after all, the address of a variable is NOT the same as the address of another variable
+					newConstraints.emplace_back(AndersConstraint::ADDR_OF, destTgt, c.getSrc());
+
+					break;
+				}
+				case AndersConstraint::LOAD:
+				{
+					// If the src is a non-ptr, ignore this constraint
+					if (peLabel[srcTgt] == 0)
+						break;
+					// If the rhs is equivalent to some ADR node, then we are able to replace the load with a copy
+					NodeIndex srcTgtTgt = revLabelMap[peLabel[srcTgt]];
+					if (srcTgtTgt > nodeFactory.getNumNodes())
+					{
+						srcTgtTgt %= nodeFactory.getNumNodes();
+						//errs() << "REPLACE " << srcTgt << " with &" << srcTgtTgt << "\n";
+						if (srcTgtTgt != destTgt)
+							newConstraints.emplace_back(AndersConstraint::COPY, destTgt, srcTgtTgt);
+					}
+					else
+					{
+						assert(srcTgtTgt == srcTgt);
+						newConstraints.emplace_back(AndersConstraint::LOAD, destTgt, srcTgt);
+					}
+
+					break;
+				}
+				case AndersConstraint::STORE:
+				{
+					// If the lhs is equivalent to some ADR node, then we are able to replace the store with a copy
+					NodeIndex destTgtTgt = revLabelMap[peLabel[destTgt]];
+					if (destTgtTgt > nodeFactory.getNumNodes())
+					{
+						destTgtTgt %= nodeFactory.getNumNodes();
+						//errs() << "REPLACE " << destTgt << " with &" << destTgtTgt << "\n";
+						if (destTgtTgt != srcTgt)
+							newConstraints.emplace_back(AndersConstraint::COPY, destTgtTgt, srcTgt);
+					}
+					else
+					{
+						assert(destTgtTgt == destTgt);
+						newConstraints.emplace_back(AndersConstraint::STORE, destTgt, srcTgt);
+					}
+
+					break;
+				}
+				case AndersConstraint::COPY:
+				{
+					// Remove useless constraint "A=A"
+					if (destTgt == srcTgt)
+						break;
+
+					// If the src is a non-ptr, ignore this constraint
+					if (peLabel[srcTgt] == 0)
+						break;
+
+					// If the rhs is equivalent to some ADR node, then we are able to replace the copy with an addr_of
+					NodeIndex srcTgtTgt = revLabelMap[peLabel[srcTgt]];
+					if (srcTgtTgt > nodeFactory.getNumNodes())
+					{
+						srcTgtTgt %= nodeFactory.getNumNodes();
+						//errs() << "REPLACE " << srcTgt << " with &" << srcTgtTgt << "\n";
+						newConstraints.emplace_back(AndersConstraint::ADDR_OF, destTgt, srcTgtTgt);
+					}
+					else
+					{
+						newConstraints.emplace_back(AndersConstraint::COPY, destTgt, srcTgt);
+					}
+
+					break;
+				}
+			}
+		}
+
+		// There may be repetitive constraints. Uniquify them
+		std::set<AndersConstraint> constraintSet(newConstraints.begin(), newConstraints.end());
+		constraints.assign(constraintSet.begin(), constraintSet.end());
+	}
+
+	virtual void releaseMemory()
+	{
+		indirectNodes.clear();
+		peLabel.clear();
+		mergeTarget.clear();
+		predGraph.releaseMemory();
+		releaseSCCMemory();
+	}
+
+	virtual void propagateLabel(NodeIndex node) = 0;
+public:
+	ConstraintOptimizer(std::vector<AndersConstraint>& c, AndersNodeFactory& n): constraints(c), nodeFactory(n), pointerEqClass(1)
+	{
+		// Build a predecessor graph.  This is like our constraint graph with the edges going in the opposite direction, and there are edges for all the constraints, instead of just copy constraints.  We also build implicit edges for constraints are implied but not explicit.  I.E for the constraint a = &b, we add implicit edges *a = b.  This helps us capture more cycles
+		buildPredecessorGraph();
+	}
+
+	void run() override
+	{
+		// Now run Tarjan's SCC algorithm to find cycles, condense predGraph, and explore possible equivalance relations
+		runOnGraph(&predGraph);
+
+		// For all nodes on the same cycle: assign their representative's pe label to them
+		for (auto const& mapping: mergeTarget)
+			peLabel[mapping.first] = peLabel[getMergeTargetRep(mapping.second)];
+
+		/*for (unsigned i = 0; i < peLabel.size(); ++i)
+		{
+			printPredecessorGraphNode(errs(), i);
+			errs() << ", peLabel = " << peLabel[i] << "\n";
+		}*/
+
+		// We've done labelling. Now rewrite all constraints
+		rewriteConstraint();
+	}
+};
+
+// The technique used here is described in "Exploiting Pointer and Location Equivalence to Optimize Pointer Analysis. In the 14th International Static Analysis Symposium (SAS), August 2007." It is known as the "HVN" algorithm, and is equivalent to value numbering the collapsed constraint graph without evaluating unions. This is used as a pre-pass to HU in order to resolve first order pointer dereferences and speed up/reduce memory usage of HU. Running both is equivalent to HRU without the iteration
+// Since there are just too much bookkeeping info during HVN, we wrap all the logic of HVN into a single class here.
+class HVNOptimizer: public ConstraintOptimizer
+{
+private:
+	// Map from a set of NodeIndex to Pointer Equivalence Class
+	std::unordered_map<SparseBitVector<>, unsigned, SparseBitVectorHash, SparseBitVectorKeyEqual> setLabel;
+
+	void propagateLabel(NodeIndex node) override
+	{
+		// Indirect node always gets a unique label
+		if (node >= nodeFactory.getNumNodes() || indirectNodes.count(node))
+		{
+			peLabel[node] = pointerEqClass++;
+			return;
+		}
+
+		// Scan through the predecessor edges and examine what labels they have
+		bool allSame = true;
+		unsigned lastSeenLabel = 0;
+		SparseBitVector<> predLabels;
+		const SparseBitVectorGraphNode* sNode = predGraph.getNodeWithIndex(node);
+		if (sNode != nullptr)
+		{
+			for (auto const& pred: *sNode)
+			{
+				NodeIndex predRep = getMergeTargetRep(pred);
+				unsigned predRepLabel = peLabel[predRep];
+				// Ignore labels that are equal to us or non-pointers
+				if (predRep == node || predRepLabel == 0)
+					continue;
+
+				if (lastSeenLabel == 0)
+					lastSeenLabel = predRepLabel;
+				else if (allSame && predRepLabel != lastSeenLabel)
+					allSame = false;
+
+				predLabels.set(predRepLabel);
+			}
+		}
+
+		// We either have a non-pointer, a copy of an existing node, or a new node. Assign the appropriate pointer equivalence label.
+		if (predLabels.empty())
+			peLabel[node] = 0;
+		else if (allSame)
+			peLabel[node] = lastSeenLabel;
+		else
+		{
+			auto labelItr = setLabel.find(predLabels);
+			if (labelItr != setLabel.end())
+			{
+				peLabel[node] = labelItr->second;
+			}
+			else
+			{
+				setLabel.insert(std::make_pair(std::move(predLabels), pointerEqClass));
+				peLabel[node] = pointerEqClass;
+				++pointerEqClass;
+			}
+		}
+	}
+
+public:
+	HVNOptimizer(std::vector<AndersConstraint>& c, AndersNodeFactory& n): ConstraintOptimizer(c, n) {}
+
+	void releaseMemory() override
+	{
+		ConstraintOptimizer::releaseMemory();
+		setLabel.clear();
+	}
+};
+
+// The technique used here is described in "Exploiting Pointer and Location Equivalence to Optimize Pointer Analysis. In the 14th International Static Analysis Symposium (SAS), August 2007."  It is known as the "HU" algorithm, and is equivalent to value numbering the collapsed constraint graph including evaluating unions.
+class HUOptimizer: public ConstraintOptimizer
+{
+private:
+	// Map from a set of NodeIndex to Pointer Equivalence Class
+	std::unordered_map<SparseBitVector<>, unsigned, SparseBitVectorHash, SparseBitVectorKeyEqual> setLabel;
+	// Map from NodeIndex to its offline pts-set
+	DenseMap<unsigned, SparseBitVector<>> ptsSet;
+
+	// Try to assign a single label to node. Return true if the assignment succeeds
+	bool assignLabel(NodeIndex node)
+	{
+		// ADR nodes get a unique label and a pts-set that contains the corresponding VAR node
+		if (node >= nodeFactory.getNumNodes() * 2)
+		{
+			peLabel[node] = pointerEqClass++;
+			ptsSet[node].set(node - nodeFactory.getNumNodes() * 2);
+			return true;
+		}
+
+		// REF nodes get a unique label and a pts-set that contains itself (which can never collide with VAR nodes)
+		if (node >= nodeFactory.getNumNodes())
+		{
+			peLabel[node] = pointerEqClass++;
+			ptsSet[node].set(node);
+			return true;
+		}
+
+		// Indirect VAR nodes get a unique label and a pts-set that contains its corresponding ADR node (which can never collide with VAR and REF nodes)
+		if (indirectNodes.count(node))
+		{
+			peLabel[node] = pointerEqClass++;
+			ptsSet[node].set(getAdrNodeIndex(node));
+			return true;
+		}
+
+		return false;
+	}
+
+	void propagateLabel(NodeIndex node) override
+	{
+		if (assignLabel(node))
+			return;
+
+		// Direct VAR nodes need more careful examination
+		SparseBitVector<>& myPtsSet = ptsSet[node];
+		SparseBitVectorGraphNode* sNode = predGraph.getNodeWithIndex(node);
+		if (sNode != nullptr)
+		{
+			for (auto const& pred: *sNode)
+			{
+				// Be careful! Any insertion to ptsSet here will invalidate myPtsSet
+				NodeIndex predRep = getMergeTargetRep(pred);
+				auto itr = ptsSet.find(predRep);
+				if (itr != ptsSet.end())
+					myPtsSet |= (itr->second);
+			}
+		}
+
+		//errs() << "ptsSet [" << node << "] = ";
+		//for (auto v: myPtsSet)
+		//	errs() << v << ", ";
+		//errs() << "\n";
+
+		// If the ptsSet is empty, assign a label of zero
+		if (myPtsSet.empty())
+			peLabel[node] = 0;
+		// Otherwise, see if we have seen this pattern before
+		else
+		{
+			auto labelItr = setLabel.find(myPtsSet);
+			if (labelItr != setLabel.end())
+			{
+				peLabel[node] = labelItr->second;
+			}
+			else
+			{
+				setLabel.insert(std::make_pair(myPtsSet, pointerEqClass));
+				peLabel[node] = pointerEqClass;
+				++pointerEqClass;
+			}
+		}
+	}
+public:
+	HUOptimizer(std::vector<AndersConstraint>& c, AndersNodeFactory& n): ConstraintOptimizer(c, n) {}
+
+	void releaseMemory() override
+	{
+		ConstraintOptimizer::releaseMemory();
+		ptsSet.clear();
+		setLabel.clear();
+	}
+};
+
+}	// end of anonymous namespace
+
+// Optimize the constraints by performing offline variable substitution
+void Andersen::optimizeConstraints()
+{
+	//errs() << "\n#constraints = " << constraints.size() << "\n";
+	//dumpConstraints();
+
+	// First, let's do HVN
+	// There is an additional assumption here that before HVN, we have not merged any two nodes. Might fix that in the future
+	if (EnableHVN)
+	{
+		HVNOptimizer hvn(constraints, nodeFactory);
+		hvn.run();
+	}
+
+	//nodeFactory.dumpRepInfo();
+	//dumpConstraints();
+
+	//errs() << "#constraints = " << constraints.size() << "\n";
+
+	// Next, do HU
+	// There is an additional assumption here that before HU, the predecessor graph will have no cycle. Might fix that in the future
+	if (EnableHU)
+	{
+		HUOptimizer hu(constraints, nodeFactory);
+		hu.run();
+	}
+
+	//nodeFactory.dumpRepInfo();
+	//dumpConstraints();
+
+	//errs() << "#constraints = " << constraints.size() << "\n";
+}
diff --git a/lib/Analysis/Andersen/ConstraintSolving.cpp b/lib/Analysis/Andersen/ConstraintSolving.cpp
new file mode 100644
index 0000000..c92e371
--- /dev/null
+++ b/lib/Analysis/Andersen/ConstraintSolving.cpp
@@ -0,0 +1,679 @@
+#include "llvm/Analysis/Andersen/Andersen.h"
+#include "llvm/Analysis/Andersen/CycleDetector.h"
+#include "llvm/Analysis/Andersen/SparseBitVectorGraph.h"
+
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/DenseSet.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/ADT/iterator_range.h"
+#include "llvm/Support/CommandLine.h"
+
+#include <queue>
+#include <map>
+
+using namespace llvm;
+
+cl::opt<bool> EnableHCD("enable-hcd", cl::desc("Enable the hybrid cycle detection algorithm"));
+cl::opt<bool> EnableLCD("enable-lcd", cl::desc("Enable the lazy cycle detection algorithm"));
+
+namespace {
+
+// This class represent the constraint graph
+class ConstraintGraphNode
+{
+private:
+	NodeIndex idx;
+
+	// We use set rather than SmallSet because we need the capability of iteration
+	typedef std::set<NodeIndex> NodeSet;
+	NodeSet copyEdges, loadEdges, storeEdges;
+
+	bool insertCopyEdge(NodeIndex dst)
+	{
+		return copyEdges.insert(dst).second;
+	}
+	bool removeCopyEdge(NodeIndex dst)
+	{
+		return copyEdges.erase(dst);
+	}
+	bool insertLoadEdge(NodeIndex dst)
+	{
+		return loadEdges.insert(dst).second;
+	}
+	bool removeLoadEdge(NodeIndex dst)
+	{
+		return loadEdges.erase(dst);
+	}
+	bool insertStoreEdge(NodeIndex dst)
+	{
+		return storeEdges.insert(dst).second;
+	}
+	bool removeStoreEdge(NodeIndex dst)
+	{
+		return storeEdges.erase(dst);
+	}
+	bool isEmpty() const
+	{
+		return copyEdges.empty() && loadEdges.empty() && storeEdges.empty();
+	}
+
+	void mergeEdges(const ConstraintGraphNode& other)
+	{
+		copyEdges.insert(other.copyEdges.begin(), other.copyEdges.end());
+		loadEdges.insert(other.loadEdges.begin(), other.loadEdges.end());
+		storeEdges.insert(other.storeEdges.begin(), other.storeEdges.end());
+	}
+
+	ConstraintGraphNode(NodeIndex i): idx(i) {}
+public:
+	typedef NodeSet::iterator iterator;
+	typedef NodeSet::const_iterator const_iterator;
+
+	NodeIndex getNodeIndex() const { return idx; }
+
+	bool replaceCopyEdge(NodeIndex oldIdx, NodeIndex newIdx)
+	{
+		return removeCopyEdge(oldIdx) && insertCopyEdge(newIdx);
+	}
+	bool replaceLoadEdge(NodeIndex oldIdx, NodeIndex newIdx)
+	{
+		return removeLoadEdge(oldIdx) && insertLoadEdge(newIdx);
+	}
+	bool replaceStoreEdge(NodeIndex oldIdx, NodeIndex newIdx)
+	{
+		return removeStoreEdge(oldIdx) && insertStoreEdge(newIdx);
+	}
+
+	iterator begin() { return copyEdges.begin(); }
+	iterator end() { return copyEdges.end(); }
+	const_iterator begin() const { return copyEdges.begin(); }
+	const_iterator end() const { return copyEdges.end(); }
+
+	const_iterator load_begin() const { return loadEdges.begin(); }
+	const_iterator load_end() const { return loadEdges.end(); }
+	llvm::iterator_range<const_iterator> loads() const
+	{
+		return llvm::iterator_range<const_iterator>(load_begin(), load_end());
+	}
+
+	const_iterator store_begin() const { return storeEdges.begin(); }
+	const_iterator store_end() const { return storeEdges.end(); }
+	llvm::iterator_range<const_iterator> stores() const
+	{
+		return llvm::iterator_range<const_iterator>(store_begin(), store_end());
+	}
+
+	friend class ConstraintGraph;
+};
+
+class ConstraintGraph
+{
+private:
+	typedef std::map<NodeIndex, ConstraintGraphNode> NodeMapTy;
+	NodeMapTy graph;
+public:
+	typedef NodeMapTy::iterator iterator;
+	typedef NodeMapTy::const_iterator const_iterator;
+
+	ConstraintGraph() {}
+
+	bool insertCopyEdge(NodeIndex src, NodeIndex dst)
+	{
+		auto itr = graph.find(src);
+		if (itr == graph.end())
+		{
+			ConstraintGraphNode srcNode(src);
+			srcNode.insertCopyEdge(dst);
+			graph.insert(std::make_pair(src, std::move(srcNode)));
+			return true;
+		}
+		else
+			return (itr->second).insertCopyEdge(dst);
+	}
+
+	bool insertLoadEdge(NodeIndex src, NodeIndex dst)
+	{
+		auto itr = graph.find(src);
+		if (itr == graph.end())
+		{
+			ConstraintGraphNode srcNode(src);
+			srcNode.insertLoadEdge(dst);
+			graph.insert(std::make_pair(src, std::move(srcNode)));
+			return true;
+		}
+		else
+			return (itr->second).insertLoadEdge(dst);
+	}
+
+	bool insertStoreEdge(NodeIndex src, NodeIndex dst)
+	{
+		auto itr = graph.find(src);
+		if (itr == graph.end())
+		{
+			ConstraintGraphNode srcNode(src);
+			srcNode.insertStoreEdge(dst);
+			graph.insert(std::make_pair(src, std::move(srcNode)));
+			return true;
+		}
+		else
+			return (itr->second).insertStoreEdge(dst);
+	}
+
+	void mergeNodes(NodeIndex dst, NodeIndex src)
+	{
+		auto itr = graph.find(src);
+		if (itr == graph.end())
+			return;
+
+		const ConstraintGraphNode& srcNode = itr->second;
+		itr = graph.find(dst);
+		if (itr == graph.end())
+		{
+			ConstraintGraphNode dstNode(dst);
+			graph.insert(std::make_pair(dst, srcNode));
+		}
+		else
+			(itr->second).mergeEdges(srcNode);
+	}
+
+	void deleteNode(NodeIndex idx)
+	{
+		graph.erase(idx);
+	}
+
+	ConstraintGraphNode* getNodeWithIndex(NodeIndex idx)
+	{
+		auto itr = graph.find(idx);
+		if (itr == graph.end())
+			return nullptr;
+		else
+			return &(itr->second);
+	}
+
+	ConstraintGraphNode* getOrInsertNode(NodeIndex idx)
+	{
+		auto itr = graph.find(idx);
+		if (itr == graph.end())
+		{
+			ConstraintGraphNode newNode(idx);
+			itr = graph.insert(std::make_pair(idx, newNode)).first;
+		}
+		return &(itr->second);
+	}
+
+	iterator begin() { return graph.begin(); }
+	iterator end() { return graph.end(); }
+	const_iterator begin() const { return graph.begin(); }
+	const_iterator end() const { return graph.end(); }
+};
+
+}	// Temporary end of anonymous namespace
+
+// Specialize the AnderGraphTraits for ConstraintGraph
+template <> class AndersGraphTraits<ConstraintGraph>
+{
+public:
+	typedef ConstraintGraphNode NodeType;
+	typedef MapValueIterator<ConstraintGraph::const_iterator> NodeIterator;
+	typedef ConstraintGraphNode::iterator ChildIterator;
+
+	static inline ChildIterator child_begin(const NodeType* n)
+	{
+		return n->begin();
+	}
+	static inline ChildIterator child_end(const NodeType* n)
+	{
+		return n->end();
+	}
+
+	static inline NodeIterator node_begin(const ConstraintGraph* g)
+	{
+		return NodeIterator(g->begin());
+	}
+	static inline NodeIterator node_end(const ConstraintGraph* g)
+	{
+		return NodeIterator(g->end());
+	}
+};
+
+namespace {
+
+void collapseNodes(NodeIndex dst, NodeIndex src, AndersNodeFactory& nodeFactory, std::map<NodeIndex, AndersPtsSet>& ptsGraph, ConstraintGraph& constraintGraph)
+{
+	if (dst == src)
+		return;
+
+	// Node merge
+	nodeFactory.mergeNode(dst, src);
+	if (ptsGraph.count(src))
+		ptsGraph[dst].unionWith(ptsGraph[src]);
+	constraintGraph.mergeNodes(dst, src);
+
+	// We don't need the node cycleIdx any more
+	ptsGraph.erase(src);
+	constraintGraph.deleteNode(src);
+}
+
+// The worklist for our analysis
+class AndersWorkList
+{
+private:
+	// The FIFO queue
+	std::queue<NodeIndex> list;
+	// Avoid duplicate entries in FIFO queue
+	llvm::SmallSet<NodeIndex, 16> set;
+public:
+	AndersWorkList() {}
+	void enqueue(NodeIndex elem)
+	{
+		if (!set.count(elem))
+		{
+			list.push(elem);
+			set.insert(elem);
+		}
+	}
+	NodeIndex dequeue()
+	{
+		assert(!list.empty() && "Trying to dequeue an empty queue!");
+		NodeIndex ret = list.front();
+		list.pop();
+		set.erase(ret);
+		return ret;
+	}
+	bool isEmpty() const { return list.empty(); }
+};
+
+// The technique used here is described in "The Ant and the Grasshopper: Fast and Accurate Pointer Analysis for Millions of Lines of Code. In Programming Language Design and Implementation (PLDI), June 2007." It is known as the "HCD" (Hybrid Cycle Detection) algorithm. It is called a hybrid because it performs an offline analysis and uses its results during the solving (online) phase. This is just the offline portion
+class OfflineCycleDetector: public CycleDetector<SparseBitVectorGraph>
+{
+private:
+	// The node factory
+	AndersNodeFactory& nodeFactory;
+
+	// The offline constraint graph
+	SparseBitVectorGraph offlineGraph;
+	// If a mapping <p, q> is in this map, it means that *p and q are in the same cycle in the offline constraint graph, and anything that p points to during the online constraint solving phase can be immediately collapse with q
+	DenseMap<NodeIndex, NodeIndex> collapseMap;
+	// Holds the pairs of VAR nodes that we are going to merge together
+	DenseMap<NodeIndex, NodeIndex> mergeMap;
+	// Used to collect the scc nodes on a cycle
+	SparseBitVector<> scc;
+
+	// Return the node index of the "ref node" (used to represent *n) of n.
+	// We won't actually create that ref node. We cannot use the NodeIndex of that refNode to index into nodeFactory
+	NodeIndex getRefNodeIndex(NodeIndex n) const
+	{
+		return n + nodeFactory.getNumNodes();
+	}
+
+	void buildOfflineConstraintGraph(const std::vector<AndersConstraint>& constraints)
+	{
+		for (auto const& c: constraints)
+		{
+			NodeIndex srcTgt = nodeFactory.getMergeTarget(c.getSrc());
+			NodeIndex dstTgt = nodeFactory.getMergeTarget(c.getDest());
+			switch (c.getType())
+			{
+				case AndersConstraint::ADDR_OF:
+					break;
+				case AndersConstraint::LOAD:
+				{
+					offlineGraph.insertEdge(getRefNodeIndex(srcTgt), dstTgt);
+					break;
+				}
+				case AndersConstraint::STORE:
+				{
+					offlineGraph.insertEdge(srcTgt, getRefNodeIndex(dstTgt));
+					break;
+				}
+				case AndersConstraint::COPY:
+				{
+					offlineGraph.insertEdge(srcTgt, dstTgt);
+					break;
+				}
+			}
+		}
+	}
+
+	NodeType* getRep(NodeIndex idx) override
+	{
+		return offlineGraph.getOrInsertNode(idx);
+	}
+
+	// Specify how to process the non-rep nodes if a cycle is found
+	void processNodeOnCycle(const NodeType* node, const NodeType* repNode) override
+	{
+		scc.set(node->getNodeIndex());
+	}
+
+	// Specify how to process the rep nodes if a cycle is found
+	void processCycleRepNode(const NodeType* node) override
+	{
+		// A trivial cycle is not interesting
+		if (scc.count() == 0)
+			return;
+
+		scc.set(node->getNodeIndex());
+
+		// The representative is the first non-ref node
+		NodeIndex repNode = scc.find_first();
+		assert(repNode < nodeFactory.getNumNodes() && "The SCC didn't have a non-Ref node!");
+		for (auto itr = ++scc.begin(), ite = scc.end(); itr != ite; ++itr)
+		{
+			NodeIndex cycleNode = *itr;
+			if (cycleNode > nodeFactory.getNumNodes())
+				// For REF nodes, insert it to the collapse map
+				collapseMap[cycleNode - nodeFactory.getNumNodes()] = repNode;
+			else
+				// For VAR nodes, insert it to the merge map
+				// We don't merge the nodes immediately to avoid affecting the DFS
+				mergeMap[cycleNode] = repNode;
+		}
+
+		scc.clear();
+	}
+
+public:
+	OfflineCycleDetector(const std::vector<AndersConstraint>& cs, AndersNodeFactory& n): nodeFactory(n)
+	{
+		// Build the offline constraint graph first before we move on
+		buildOfflineConstraintGraph(cs);
+	}
+
+  virtual ~OfflineCycleDetector() {}
+
+	void run() override
+	{
+		runOnGraph(&offlineGraph);
+
+		// Merge the nodes in mergeMap
+		for (auto const& mapping: mergeMap)
+			nodeFactory.mergeNode(mapping.second, mapping.first);
+
+		// We don't need these structures any more. The only thing we keep should be those info that are necessary to answer collapsing target queries
+		mergeMap.clear();
+		offlineGraph.releaseMemory();
+		releaseSCCMemory();
+	}
+
+	// Return InvalidIndex if no collapse target found
+	NodeIndex getCollapseTarget(NodeIndex n)
+	{
+		auto itr = collapseMap.find(n);
+		if (itr == collapseMap.end())
+			return AndersNodeFactory::InvalidIndex;
+		else
+			return itr->second;
+	}
+};
+
+void buildConstraintGraph(ConstraintGraph& cGraph, const std::vector<AndersConstraint>& constraints, AndersNodeFactory& nodeFactory, std::map<NodeIndex, AndersPtsSet>& ptsGraph)
+{
+	for (auto const& c: constraints)
+	{
+		NodeIndex srcTgt = nodeFactory.getMergeTarget(c.getSrc());
+		NodeIndex dstTgt = nodeFactory.getMergeTarget(c.getDest());
+		switch (c.getType())
+		{
+			case AndersConstraint::ADDR_OF:
+			{
+				// We don't want to replace src with srcTgt because, after all, the address of a variable is NOT the same as the address of another variable
+				ptsGraph[dstTgt].insert(c.getSrc());
+				break;
+			}
+			case AndersConstraint::LOAD:
+			{
+				cGraph.insertLoadEdge(srcTgt, dstTgt);
+				break;
+			}
+			case AndersConstraint::STORE:
+			{
+				cGraph.insertStoreEdge(dstTgt, srcTgt);
+				break;
+			}
+			case AndersConstraint::COPY:
+			{
+				cGraph.insertCopyEdge(srcTgt, dstTgt);
+				break;
+			}
+		}
+	}
+}
+
+class OnlineCycleDetector: public CycleDetector<ConstraintGraph>
+{
+private:
+	AndersNodeFactory& nodeFactory;
+	ConstraintGraph& constraintGraph;
+	std::map<NodeIndex, AndersPtsSet>& ptsGraph;
+	const DenseSet<NodeIndex>& candidates;
+
+	NodeType* getRep(NodeIndex idx) override
+	{
+		return constraintGraph.getOrInsertNode(nodeFactory.getMergeTarget(idx));
+	}
+	// Specify how to process the non-rep nodes if a cycle is found
+	void processNodeOnCycle(const NodeType* node, const NodeType* repNode) override
+	{
+		NodeIndex repIdx = nodeFactory.getMergeTarget(repNode->getNodeIndex());
+		NodeIndex cycleIdx = nodeFactory.getMergeTarget(node->getNodeIndex());
+		//errs() << "Collapse node " << cycleIdx << " with node " << repIdx << "\n";
+
+		collapseNodes(repIdx, cycleIdx, nodeFactory, ptsGraph, constraintGraph);
+	}
+	// Specify how to process the rep nodes if a cycle is found
+	void processCycleRepNode(const NodeType* node) override
+	{
+		// Do nothing, I guess?
+	}
+
+public:
+	OnlineCycleDetector(AndersNodeFactory& n, ConstraintGraph& co, std::map<NodeIndex, AndersPtsSet>& p, const DenseSet<NodeIndex>& ca): nodeFactory(n), constraintGraph(co), ptsGraph(p), candidates(ca) {}
+
+  virtual ~OnlineCycleDetector() {}
+
+	void run() override
+	{
+		// Perform cycle detection on for nodes on the candidate list
+		for (auto node: candidates)
+			runOnNode(node);
+	}
+};
+
+}	// end of anonymous namespace
+
+/// solveConstraints - This stage iteratively processes the constraints list
+/// propagating constraints (adding edges to the Nodes in the points-to graph)
+/// until a fixed point is reached.
+///
+/// We use a variant of the technique called "Lazy Cycle Detection", which is
+/// described in "The Ant and the Grasshopper: Fast and Accurate Pointer
+/// Analysis for Millions of Lines of Code. In Programming Language Design and
+/// Implementation (PLDI), June 2007."
+/// The paper describes performing cycle detection one node at a time, which can
+/// be expensive if there are no cycles, but there are long chains of nodes that
+/// it heuristically believes are cycles (because it will DFS from each node
+/// without state from previous nodes).
+/// Instead, we use the heuristic to build a worklist of nodes to check, then
+/// cycle detect them all at the same time to do this more cheaply.  This
+/// catches cycles slightly later than the original technique did, but does it
+/// make significantly cheaper.
+void Andersen::solveConstraints()
+{
+	// We'll do offline HCD first
+	OfflineCycleDetector offlineInfo(constraints, nodeFactory);
+	if (EnableHCD)
+		offlineInfo.run();
+
+	// Now build the constraint graph
+	ConstraintGraph constraintGraph;
+	buildConstraintGraph(constraintGraph, constraints, nodeFactory, ptsGraph);
+	// The constraint vector is useless now
+//	constraints.clear();
+
+	// We switch between two work lists instead of relying on only one work list
+	AndersWorkList workList1, workList2;
+	// The "current" and the "next" work list
+	AndersWorkList *currWorkList = &workList1, *nextWorkList = &workList2;
+	// The set of nodes that LCD believes might be on a cycle
+	DenseSet<NodeIndex> cycleCandidates;
+	// The set of edges that LCD believes not on a cycle
+	DenseSet<std::pair<NodeIndex, NodeIndex>> checkedEdges;
+
+	// Scan the node list, add it to work list if the node a representative and can contribute to the calculation right now.
+	for (auto const& mapping: ptsGraph)
+	{
+		NodeIndex node = mapping.first;
+		if (nodeFactory.getMergeTarget(node) == node && constraintGraph.getNodeWithIndex(node) != nullptr)
+			currWorkList->enqueue(node);
+	}
+
+	while (!currWorkList->isEmpty())
+	{
+		// Iteration begins
+
+		// First we've got to check if there is any cycle candidates in the last iteration. If there is, detect and collapse cycle
+		if (EnableLCD && !cycleCandidates.empty())
+		{
+			// Detect and collapse cycles online
+			OnlineCycleDetector cycleDetector(nodeFactory, constraintGraph, ptsGraph, cycleCandidates);
+			cycleDetector.run();
+			cycleCandidates.clear();
+		}
+
+		while (!currWorkList->isEmpty())
+		{
+			NodeIndex node = currWorkList->dequeue();
+			node = nodeFactory.getMergeTarget(node);
+			//errs() << "Examining node " << node << "\n";
+
+			ConstraintGraphNode* cNode = constraintGraph.getNodeWithIndex(node);
+			if (cNode == nullptr)
+				continue;
+
+			auto ptsItr = ptsGraph.find(node);
+			if (ptsItr != ptsGraph.end())
+			{
+				// Check indirect constraints and add copy edge to the constraint graph if necessary
+				const AndersPtsSet& ptsSet = ptsItr->second;
+
+				// This is where we perform HCD: check if node has a collapse target, and if it does, merge them immediately
+				if (EnableHCD)
+				{
+					NodeIndex collapseTarget = offlineInfo.getCollapseTarget(node);
+					if (collapseTarget != AndersNodeFactory::InvalidIndex)
+					{
+						//errs() << "node = " << node << ", collapseTgt = " << collapseTarget << "\n";
+						NodeIndex ctRep = nodeFactory.getMergeTarget(collapseTarget);
+						// Here we have to pay special attention to whether the node points-to itself.
+						bool mergeSelf = false;
+						for (auto v: ptsSet)
+						{
+							NodeIndex vRep = nodeFactory.getMergeTarget(v);
+							if (vRep == node)
+							{
+								mergeSelf = true;
+								continue;
+							}
+							collapseNodes(ctRep, vRep, nodeFactory, ptsGraph, constraintGraph);
+						}
+
+						if (mergeSelf)
+						{
+							collapseNodes(ctRep, node, nodeFactory, ptsGraph, constraintGraph);
+							// If the node collapsing succeeds, we can't proceed here because node no longer exists. Push ctRep to the worklist and proceed
+							if (ctRep != node)
+							{
+								nextWorkList->enqueue(ctRep);
+								continue;
+							}
+						}
+					}
+				}
+
+				for (auto v: ptsSet)
+				{
+					DenseMap<NodeIndex, NodeIndex> updateMap;
+
+					NodeIndex vRep = nodeFactory.getMergeTarget(v);
+					for (auto const& dst: cNode->loads())
+					{
+						NodeIndex tgtNode = nodeFactory.getMergeTarget(dst);
+						//errs() << "Examining load edge " << node << " -> " << tgtNode << "\n";
+						if (constraintGraph.insertCopyEdge(vRep, tgtNode))
+						{
+							//errs() << "\tInsert copy edge " << v << " -> " << tgtNode << "\n";
+							nextWorkList->enqueue(vRep);
+						}
+
+						// If we find that dst has been merged to elsewhere, remember this fact to update the constraint graph later
+						if (tgtNode != dst)
+							updateMap[dst] = tgtNode;
+					}
+
+					// Now perform the load edge updates
+					for (auto const& mapping: updateMap)
+						cNode->replaceLoadEdge(mapping.first, mapping.second);
+					updateMap.clear();
+
+					for (auto const& dst: cNode->stores())
+					{
+						NodeIndex tgtNode = nodeFactory.getMergeTarget(dst);
+						if (constraintGraph.insertCopyEdge(tgtNode, vRep))
+						{
+							//errs() << "\tInsert copy edge " << tgtNode << " -> " << v << "\n";
+							nextWorkList->enqueue(tgtNode);
+						}
+
+						// If we find that dst has been merged to elsewhere, remember this fact to update the constraint graph later
+						if (tgtNode != dst)
+							updateMap[dst] = tgtNode;
+					}
+
+					// Now perform the store edge updates
+					for (auto const& mapping: updateMap)
+						cNode->replaceStoreEdge(mapping.first, mapping.second);
+				}
+
+				DenseMap<NodeIndex, NodeIndex> updateMap;
+				// Finally, it's time to propagate pts-to info along the copy edges
+				for (auto const& dst: *cNode)
+				{
+					NodeIndex tgtNode = nodeFactory.getMergeTarget(dst);
+					if (node == tgtNode)
+						continue;
+					AndersPtsSet& tgtPtsSet = ptsGraph[tgtNode];
+
+					//errs() << "pts[" << tgtNode << "] |= pts[" << node << "]\n";
+					bool isChanged =  tgtPtsSet.unionWith(ptsSet);
+
+					if (isChanged)
+					{
+						nextWorkList->enqueue(tgtNode);
+					}
+					else if (EnableLCD)
+					{
+						// This is where we do lazy cycle detection.
+						// If this is a cycle candidate (equal points-to sets and this particular edge has not been cycle-checked previously), add to the list to check for cycles on the next iteration
+						auto edgePair = std::make_pair(node, tgtNode);
+						if (!checkedEdges.count(edgePair) && ptsSet == tgtPtsSet)
+						{
+							checkedEdges.insert(edgePair);
+							cycleCandidates.insert(tgtNode);
+						}
+					}
+
+					if (tgtNode != dst)
+						updateMap[dst] = tgtNode;
+				}
+
+				// Now perform the copy edge updates
+				for (auto const& mapping: updateMap)
+					cNode->replaceCopyEdge(mapping.first, mapping.second);
+			}
+		}
+		// Swap the current and the next worklist
+		std::swap(currWorkList, nextWorkList);
+	}
+}
diff --git a/lib/Analysis/Andersen/DetectParametersPass.cpp b/lib/Analysis/Andersen/DetectParametersPass.cpp
new file mode 100644
index 0000000..63858d2
--- /dev/null
+++ b/lib/Analysis/Andersen/DetectParametersPass.cpp
@@ -0,0 +1,434 @@
+#include <llvm/IR/InstIterator.h>
+#include "llvm/Analysis/Andersen/DetectParametersPass.h"
+
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Constants.h"
+
+#include "llvm/Analysis/Andersen/StackAccessPass.h"
+#include "llvm/IR/Dominators.h"
+#include "llvm/Support/Debug.h"
+
+using namespace llvm;
+
+#define DEBUG_TYPE "detect_params"
+
+char DetectParametersPass::ID = 0;
+static RegisterPass<DetectParametersPass> X("detect-param", "Detect Parameters", true, true);
+
+DetectParametersPass::InstRegUserSet_t DetectParametersPass::specialPreSets;
+
+std::mutex DetectParametersPass::passLock;
+
+void DetectParametersPass::getAnalysisUsage(AnalysisUsage &AU) const {
+  AU.setPreservesAll();
+
+  AU.addRequired<StackAccessPass>();
+  AU.addRequired<DominatorTreeWrapperPass>();
+}
+
+bool DetectParametersPass::runOnModule(Module &M) {
+  for (auto &F : M.functions()) {
+    if (F.isDeclaration() || F.isIntrinsic())
+      continue;
+    StackOffsets[&F] = std::unique_ptr<ParameterAccessPairSet_t>(new ParameterAccessPairSet_t());
+    RegisterIndexes[&F] = std::unique_ptr<ParameterAccessPairSet_t>(new ParameterAccessPairSet_t());
+    ReturnIndexes[&F] = std::unique_ptr<ParameterAccessPairSet_t>(new ParameterAccessPairSet_t());
+    DEBUG(errs() << "Find parameters for: " << F.getName() << "\n");
+    CurrentFunction = &F;
+    for (BasicBlock::InstListType::iterator I_it = F.getEntryBlock().begin();
+         I_it != F.getEntryBlock().end();
+         ++I_it) {
+      if (I_it->getOpcode() == Instruction::GetElementPtr) {
+        if (ConstantInt *IdxValue = dyn_cast<ConstantInt>(I_it->getOperand(2))) {
+          if (isParameterRegister(IdxValue->getZExtValue())) {
+            Instruction *LoadInst = nullptr;
+            if (readBeforeWrite(&*I_it, LoadInst)) {
+              DEBUG(errs() << "PARAMETER: " << I_it->getName() << "(" << LoadInst->getName() << ")\n");
+              RegisterIndexes[&F]->insert(ParameterAccessPair_t(IdxValue->getZExtValue(), LoadInst));
+            }
+          }
+        }
+      }
+    }
+
+    std::set<uint64_t> HandledReturns;
+    for (Function::iterator BB_it = F.begin(); BB_it != F.end(); ++BB_it) {
+      if (BB_it->getTerminator()->getOpcode() != Instruction::Ret)
+        continue;
+      for (Instruction *I = BB_it->getTerminator(); I != &BB_it->front(); I = I->getPrevNode()) {
+        if (I->getOpcode() != Instruction::Store)
+          continue;
+        Instruction *Ptr = (Instruction *) I->getOperand(1);
+        if (Ptr->getOpcode() != Instruction::GetElementPtr)
+          continue;
+        ConstantInt *Idx = dyn_cast<ConstantInt>(Ptr->getOperand(2));
+        if (!Idx)
+          continue;
+//            if (Idx->getZExtValue() == 5 || Idx->getZExtValue() ==13) {
+        if (Idx->getZExtValue() == 5) {
+          if (HandledReturns.find(Idx->getZExtValue()) == HandledReturns.end()) {
+            ReturnIndexes[&F]->insert(ParameterAccessPair_t(Idx->getZExtValue(), I));
+            HandledReturns.insert(Idx->getZExtValue());
+          }
+        }
+      }
+
+    }
+
+    StackAccessPass::OffsetValueListMap_t &OffsetValues = getAnalysis<StackAccessPass>().getOffsetValues(&F);
+    const DominatorTree &DomTree = getAnalysis<DominatorTreeWrapperPass>(F).getDomTree();
+
+    for (StackAccessPass::OffsetValueListMap_t::iterator OV_it = OffsetValues.begin();
+         OV_it != OffsetValues.end();
+         ++OV_it) {
+
+      InstructionList_t LoadInstruction, StoreInstructions;
+
+      if (!OV_it->second) {
+        //FIXME: why can this happen???
+        continue;
+      }
+
+      for (StackAccessPass::ValueList_t::iterator V_it = OV_it->second->begin();
+           V_it != OV_it->second->end();
+           ++V_it) {
+        assert(isa<Instruction>(*V_it));
+        getMemoryOperations((Instruction *) *V_it, LoadInstruction, StoreInstructions);
+      }
+
+      bool isParameter = false;
+      Instruction *LoadParam = nullptr;
+      for (InstructionList_t::iterator L_it = LoadInstruction.begin(); L_it != LoadInstruction.end(); ++L_it) {
+        bool dominatesAll = true;
+        for (InstructionList_t::iterator S_it = StoreInstructions.begin();
+             S_it != StoreInstructions.end(); ++S_it) {
+          if (!DomTree.dominates(*L_it, *S_it)) {
+            dominatesAll = false;
+            break;
+          }
+        }
+        if (dominatesAll) {
+          isParameter = true;
+          LoadParam = *L_it;
+          break;
+        }
+      }
+
+      if (isParameter) {
+        DEBUG(errs() << "PARAMETER: " << OV_it->first << "\n");
+//            StackOffsets[&F]->insert(OV_it->first);
+        StackOffsets[&F]->insert(ParameterAccessPair_t(OV_it->first, LoadParam));
+      }
+
+    }
+  }
+  return false;
+}
+
+//TODO: add SIMD registers here
+bool DetectParametersPass::isParameterRegister(uint64_t Idx) {
+  if (Idx >= 5 && Idx <= 13) {
+    return true;
+  }
+  return false;
+}
+
+bool DetectParametersPass::isStackRegister(uint64_t Idx) {
+  return Idx == 3 ? true : false;
+}
+
+bool DetectParametersPass::readBeforeWrite(Instruction *Inst, Instruction *&LoadInst) {
+  for (Instruction *I = Inst; I != I->getParent()->getTerminator(); I = I->getNextNode()) {
+    if (I->getOpcode() == Instruction::Load && I->getOperand(0) == Inst) {
+      LoadInst = I;
+      break;
+    }
+    if (I->getOpcode() == Instruction::Call)
+      break;
+  }
+
+  if (!LoadInst)
+    return false;
+
+  return true;
+
+//    for (Value::const_use_iterator U_it = LoadInst->use_begin(); U_it != LoadInst->use_end(); ++U_it) {
+//        if (Instruction *Use = dyn_cast<Instruction>(U_it->getUser())) {
+//            Use->dump();
+//            if (Use->getOpcode() != Instruction::Store)
+//                return true;
+//            if (Use->getOperand(1) != Inst)
+//                return true;
+//        }
+//    }
+//    return false;
+}
+
+void DetectParametersPass::getMemoryOperations(Instruction *Address,
+                                               InstructionList_t &Load,
+                                               InstructionList_t &Store) {
+  for (Value::const_use_iterator U_it = Address->use_begin(); U_it != Address->use_end(); ++U_it) {
+    if (Instruction *Inst = dyn_cast<Instruction>(U_it->getUser())) {
+      //TODO: now only the addresses are considered that are directly converted to a pointer
+      //variable offsets won't be recognized here
+      switch (Inst->getOpcode()) {
+        default:
+          break;
+//                    assert(false);
+        case Instruction::Load:
+          Load.push_back(Inst);
+          break;
+        case Instruction::Store:
+          Store.push_back(Inst);
+          break;
+        case Instruction::IntToPtr:
+          getMemoryOperations(Inst, Load, Store);
+          break;
+      }
+    } else {
+      assert(false);
+    }
+  }
+
+}
+
+DetectParametersPass::UserSet_t DetectParametersPass::getRegisterValuesAfterCall(const uint64_t RegNo,
+                                                                                 const Instruction *Inst) {
+  std::set<const BasicBlock *> visited;
+  return getRegisterValuesAfterCall(RegNo, Inst, visited);
+}
+
+DetectParametersPass::UserSet_t DetectParametersPass::getRegisterValuesAfterCall(const uint64_t RegNo,
+                                                                                 const Instruction *Inst,
+                                                                                 std::set<const BasicBlock *> &visited) {
+
+  if (visited.find(Inst->getParent()) != visited.end()) {
+    return UserSet_t();
+  }
+  visited.insert(Inst->getParent());
+
+  const Value *RegPtr = nullptr;
+  const BasicBlock &EntryBB = Inst->getParent()->getParent()->getEntryBlock();
+  for (BasicBlock::const_iterator I_it = EntryBB.begin(); I_it != EntryBB.end(); ++I_it) {
+    if (I_it->getOpcode() == Instruction::GetElementPtr) {
+      if (ConstantInt *Idx = dyn_cast<ConstantInt>(I_it->getOperand(2))) {
+        if (Idx->getZExtValue() == RegNo) {
+          RegPtr = &*I_it;
+          break;
+        }
+      } else {
+        llvm_unreachable("The index should be a constant int...");
+      }
+    }
+  }
+
+  if (!RegPtr) {
+    assert(false);
+    UserSet_t Result;
+    return Result;
+  }
+
+  const Instruction *LastVal = nullptr;
+
+  for (const Instruction *I = Inst; I != Inst->getParent()->getTerminator(); I = I->getNextNode()) {
+    if (I->getOpcode() == Instruction::Load && I->getOperand(0) == RegPtr) {
+      LastVal = I;
+      break;
+    }
+  }
+
+  if (!LastVal) {
+    //We consider only a single successor here because the value should be accessed before a branch instruction (and only those have multiple successors)
+    //TODO: check this if this is true (e.g. allocate two object before a branch and access one in each of the paths)
+    if (Inst->getParent()->getTerminator()->getOpcode() == Instruction::Br &&
+        Inst->getParent()->getTerminator()->getNumOperands() == 1) {
+      if (BasicBlock *B = dyn_cast<BasicBlock>(Inst->getParent()->getTerminator()->getOperand(0))) {
+        return DetectParametersPass::getRegisterValuesAfterCall(RegNo, &B->front(), visited);
+      }
+    }
+    return UserSet_t();
+  }
+
+  UserSet_t Result;
+  assert(isa<User>(LastVal));
+  //FIXME: change UserSet_t to contain const values
+  Result.insert(dyn_cast<User>((Value *) LastVal));
+  return Result;
+}
+
+DetectParametersPass::UserSet_t DetectParametersPass::getRegisterValuesBeforeCall(const uint64_t RegNo,
+                                                                                  const Instruction *Inst,
+                                                                                  std::set<const BasicBlock *> &visited,
+                                                                                  const bool GetStores) {
+  //Prevents infinite loops
+  if (visited.find(Inst->getParent()) != visited.end()) {
+    return UserSet_t();
+  }
+  visited.insert(Inst->getParent());
+
+  const Function *F = Inst->getParent()->getParent();
+  Value *RegPtr = nullptr;
+//    BasicBlock &EntryBB = Inst->getParent()->getParent()->getEntryBlock();
+//    for (BasicBlock::iterator I_it = EntryBB.begin(); I_it != EntryBB.end(); ++I_it) {
+//        if (I_it->getOpcode() == Instruction::GetElementPtr) {
+//            if (ConstantInt *Idx = dyn_cast<ConstantInt>(I_it->getOperand(2))) {
+//                if (Idx->getZExtValue() == RegNo) {
+//                    RegPtr = &*I_it;
+//                    break;
+//                }
+//            } else {
+//                llvm_unreachable("The index should be a constant int...");
+//            }
+//        }
+//    }
+
+  const Value *regSet = F->arg_begin();
+
+  for (const_inst_iterator I_it = inst_begin(F); I_it != inst_end(F); ++I_it) {
+    if (I_it->getOpcode() == Instruction::GetElementPtr) {
+      if (I_it->getOperand(0) != regSet)
+        continue;
+      if (ConstantInt *Idx = dyn_cast<ConstantInt>(I_it->getOperand(2))) {
+        if (Idx->getZExtValue() == RegNo) {
+          RegPtr = (Instruction *) &*I_it;
+          break;
+        }
+      } else {
+        llvm_unreachable("The index should be a constant int...");
+      }
+    }
+  }
+
+  if (!RegPtr) {
+//        assert(false);
+    UserSet_t Result;
+    return Result;
+  }
+
+  const Value *LastVal = nullptr;
+
+  for (const Instruction *I = Inst; ; I = I->getPrevNode()) {
+    if (I->getOpcode() == Instruction::Store && I->getOperand(1) == RegPtr) {
+      if (GetStores)
+        LastVal = I;
+      else
+        LastVal = I->getOperand(0);
+
+      break;
+    }
+    if (I == &I->getParent()->front())
+      break;
+  }
+
+  if (!LastVal) {
+    UserSet_t predResults;
+    for (const_pred_iterator pred_it = pred_begin(Inst->getParent());
+         pred_it != pred_end(Inst->getParent()); ++pred_it) {
+      UserSet_t R = getRegisterValuesBeforeCall(RegNo, (*pred_it)->getTerminator(), visited, GetStores);
+      predResults.insert(R.begin(), R.end());
+    }
+    if (predResults.size() == 0) {
+      assert(true);
+    }
+    return predResults;
+    errs() << RegNo << "\n";
+    errs() << Inst->getParent()->getParent()->getName() << "\n";
+    errs() << Inst->getParent()->getName() << "\n";
+    Inst->dump();
+    llvm_unreachable("Can't find store for this register");
+  }
+
+  UserSet_t Result;
+  assert(isa<User>(LastVal));
+  //FIXME: change this to const
+  Result.insert(dyn_cast<User>((Value *) LastVal));
+  return Result;
+}
+
+void DetectParametersPass::setSpecialPreSet(const Instruction *inst, uint64_t RegNo, UserSet_t set) {
+  passLock.lock();
+  specialPreSets[inst][RegNo] = set;
+  passLock.unlock();
+}
+
+DetectParametersPass::UserSet_t DetectParametersPass::getRegisterValuesBeforeCall(const uint64_t RegNo,
+                                                                                  const Instruction *Inst,
+                                                                                  const bool GetStores) {
+  std::unique_lock<std::mutex> lock(passLock);
+  InstRegUserSet_t::iterator irus_it = specialPreSets.find(Inst);
+  if (irus_it != specialPreSets.end()) {
+    RegUserSet_t::iterator rus_it = irus_it->second.find(RegNo);
+    if (rus_it != irus_it->second.end()) {
+      if (GetStores) {
+        return rus_it->second;
+      } else {
+        UserSet_t pre;
+        for (auto &u : rus_it->second) {
+          assert(isa<const User>(u));
+          pre.insert(dyn_cast<User>(u->getOperand(0)));
+        }
+        return pre;
+      }
+    }
+  }
+  std::set<const BasicBlock *> visited;
+  UserSet_t Results = DetectParametersPass::getRegisterValuesBeforeCall(RegNo, Inst, visited, GetStores);
+  assert(Results.size() || Inst->getParent()->getParent()->getName() == "_EXTERNAL_");
+  return Results;
+}
+
+DetectParametersPass::ParameterAccessPairSet_t DetectParametersPass::getStackParameters(Function &F,
+                                                                                        std::set<uint64_t> SPIdx) {
+  std::unique_lock<std::mutex> lock(passLock);
+  StackAccessPass::OffsetValueListMap_t OffsetValues;
+  StackAccessPass::OffsetMap_t Offsets;
+  StackAccessPass *SAP = getAnalysisIfAvailable<StackAccessPass>();
+  if (!SAP)
+    SAP = &getAnalysis<StackAccessPass>();
+  SAP->runOnFunction(F, Offsets, OffsetValues, SPIdx);
+  DominatorTreeWrapperPass *DTP = getAnalysisIfAvailable<DominatorTreeWrapperPass>();
+  if (!DTP)
+    DTP = &getAnalysis<DominatorTreeWrapperPass>(F);
+  const DominatorTree &DomTree = DTP->getDomTree();
+
+  ParameterAccessPairSet_t StackParameters;
+
+  for (StackAccessPass::OffsetValueListMap_t::iterator OV_it = OffsetValues.begin();
+       OV_it != OffsetValues.end();
+       ++OV_it) {
+
+    InstructionList_t LoadInstruction, StoreInstructions;
+
+    for (StackAccessPass::ValueList_t::iterator V_it = OV_it->second->begin();
+         V_it != OV_it->second->end();
+         ++V_it) {
+      assert(isa<Instruction>(*V_it));
+      getMemoryOperations((Instruction *) *V_it, LoadInstruction, StoreInstructions);
+    }
+
+    bool isParameter = false;
+    Instruction *LoadParam = nullptr;
+    for (InstructionList_t::iterator L_it = LoadInstruction.begin(); L_it != LoadInstruction.end(); ++L_it) {
+      bool dominatesAll = true;
+      for (InstructionList_t::iterator S_it = StoreInstructions.begin(); S_it != StoreInstructions.end(); ++S_it) {
+        if (!DomTree.dominates(*L_it, *S_it)) {
+          dominatesAll = false;
+          break;
+        }
+      }
+      if (dominatesAll) {
+        isParameter = true;
+        LoadParam = *L_it;
+        break;
+      }
+    }
+
+    if (isParameter) {
+      DEBUG(errs() << "PARAMETER: " << OV_it->first << "\n");
+//            StackOffsets[&F]->insert(OV_it->first);
+      StackParameters.insert(ParameterAccessPair_t(OV_it->first, LoadParam));
+    }
+
+  }
+  return StackParameters;
+}
diff --git a/lib/Analysis/Andersen/ExternalLibrary.cpp b/lib/Analysis/Andersen/ExternalLibrary.cpp
new file mode 100644
index 0000000..479e735
--- /dev/null
+++ b/lib/Analysis/Andersen/ExternalLibrary.cpp
@@ -0,0 +1,226 @@
+#include "llvm/Analysis/Andersen/Andersen.h"
+
+#include "llvm/IR/Module.h"
+#include "llvm/IR/CallSite.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Analysis/ValueTracking.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include <cstring>
+
+using namespace llvm;
+
+static const char* noopFuncs[] = {
+	"log", "log10", "exp", "exp2", "exp10", "strcmp", "strncmp", "strlen",
+	"atoi", "atof",	"atol", "atoll", "remove", "unlink", "rename", "memcmp", "free",
+	"execl", "execlp", "execle", "execv", "execvp", "chmod",
+	"puts", "write", "open", "create", "truncate", "chdir", "mkdir", "rmdir",
+	"read", "pipe",	"wait", "time",	"stat", "fstat", "lstat", "strtod",	"strtof",
+	"strtold", "fopen", "fdopen", "fflush", "feof", "fileno", "clearerr", "rewind",
+	"ftell", "ferror", "fgetc",	"fgetc", "_IO_getc", "fwrite", "fread",	"fgets",
+	"ungetc", "fputc", "fputs", "putc",	"ftell", "rewind", "_IO_putc", "fseek",
+	"fgetpos", "fsetpos", "printf", "fprintf", "sprintf", "vprintf", "vfprintf",
+	"vsprintf", "scanf", "fscanf", "sscanf", "__assert_fail", "modf", "putchar",
+	"isalnum", "isalpha", "isascii", "isatty", "isblank", "iscntrl", "isdigit",
+	"isgraph", "islower", "isprint", "ispunct", "isspace", "isupper", "iswalnum",
+	"iswalpha", "iswctype", "iswdigit", "iswlower", "iswspace", "iswprint",
+	"iswupper", "sin", "cos", "sinf", "cosf", "asin", "acos", "tan", "atan",
+	"fabs", "pow", "floor", "ceil", "sqrt", "sqrtf", "hypot",
+	"random", "tolower","toupper", "towlower", "towupper", "system", "clock",
+	"exit", "abort", "gettimeofday", "settimeofday", "sleep", "ctime",
+	"strspn", "strcspn", "localtime", "strftime",
+	"qsort", "popen", "pclose",
+	"rand", "rand_r", "srand", "seed48", "drand48", "lrand48", "srand48",
+	"__isoc99_sscanf", "__isoc99_fscanf", "fclose", "close", "perror",
+	"strerror", // this function returns an extenal static pointer
+	"__errno_location", "__ctype_b_loc", "abs", "difftime", "setbuf",
+	"_ZdlPv", "_ZdaPv",	// delete and delete[]
+	"fesetround", "fegetround", "fetestexcept", "feraiseexcept", "feclearexcept",
+	"llvm.bswap.i16", "llvm.bswap.i32", "llvm.ctlz.i64",
+	"llvm.lifetime.start", "llvm.lifetime.end", "llvm.stackrestore",
+	"memset", "llvm.memset.i32", "llvm.memset.p0i8.i32", "llvm.memset.i64",
+	"llvm.memset.p0i8.i64", "llvm.va_end",
+	// The following functions might not be NOOP. They need to be removed from this list in the future
+	"setrlimit", "getrlimit",
+	nullptr
+};
+
+static const char* mallocFuncs[] = {
+	"malloc", "valloc", "calloc",
+	"_Znwj", "_ZnwjRKSt9nothrow_t", "_Znwm", "_ZnwmRKSt9nothrow_t",
+	"_Znaj", "_ZnajRKSt9nothrow_t", "_Znam", "_ZnamRKSt9nothrow_t",
+	"strdup", "strndup",
+	"getenv",
+	"memalign", "posix_memalign",
+	nullptr
+};
+
+static const char* reallocFuncs[] = {
+	"realloc", "strtok", "strtok_r", "getcwd",
+	nullptr
+};
+
+static const char* retArg0Funcs[] = {
+	"fgets", "gets", "stpcpy",  "strcat", "strchr", "strcpy",
+	"strerror_r", "strncat", "strncpy", "strpbrk", "strptime", "strrchr", "strstr",
+	nullptr
+};
+
+static const char* retArg1Funcs[] = {
+	// Actually the return value of signal() will NOT alias its second argument, but if you call it twice the return values may alias. We're making conservative assumption here
+	"signal",
+	nullptr
+};
+
+static const char* retArg2Funcs[] = {
+	"freopen",
+	nullptr
+};
+
+static const char* memcpyFuncs[] = {
+	"llvm.memcpy.i32", "llvm.memcpy.p0i8.p0i8.i32", "llvm.memcpy.i64",
+	"llvm.memcpy.p0i8.p0i8.i64", "llvm.memmove.i32", "llvm.memmove.p0i8.p0i8.i32",
+	"llvm.memmove.i64", "llvm.memmove.p0i8.p0i8.i64",
+	"memccpy", "memmove", "bcopy",
+	nullptr
+};
+
+static const char* convertFuncs[] = {
+	"strtod", "strtof", "strtol", "strtold", "strtoll", "strtoul",
+	nullptr
+};
+
+static bool lookupName(const char* table[], const char* str)
+{
+	for (unsigned i = 0; table[i] != nullptr; ++i)
+	{
+		if (strcmp(table[i], str) == 0)
+			return true;
+	}
+	return false;
+}
+
+// This function identifies if the external callsite is a library function call, and add constraint correspondingly
+// If this is a call to a "known" function, add the constraints and return true. If this is a call to an unknown function, return false.
+bool Andersen::addConstraintForExternalLibrary(ImmutableCallSite cs, const Function* f)
+{
+	assert(f != nullptr && "called function is nullptr!");
+	assert((f->isDeclaration() || f->isIntrinsic()) && "Not an external function!");
+
+	// These functions don't induce any points-to constraints
+	if (lookupName(noopFuncs, f->getName().data()))
+		return true;
+
+	// Realloc-like library is a little different: if the first argument is nullptr, then it behaves like retArg0Funcs; otherwise, it behaves like mallocFuncs
+	bool isReallocLike = lookupName(reallocFuncs, f->getName().data());
+
+	// Library calls that might allocate memory.
+	if (lookupName(mallocFuncs, f->getName().data()) || (isReallocLike && !isa<ConstantPointerNull>(cs.getArgument(0))))
+	{
+		const Instruction* inst = cs.getInstruction();
+
+		// Create the obj node
+		NodeIndex objIndex = nodeFactory.createObjectNode(inst);
+
+		// Get the pointer node
+		NodeIndex ptrIndex = nodeFactory.getValueNodeFor(inst);
+		if (ptrIndex == AndersNodeFactory::InvalidIndex)
+		{
+			// Must be something like posix_memalign()
+			if (cs.getCalledFunction()->getName() == "posix_memalign")
+			{
+				ptrIndex = nodeFactory.getValueNodeFor(cs.getArgument(0));
+				assert(ptrIndex != AndersNodeFactory::InvalidIndex && "Failed to find arg0 node");
+				addConstraint(AndersConstraint::STORE, ptrIndex, objIndex);
+			}
+			else
+				assert(false && "unrecognized malloc call");
+		}
+		else
+		{
+			// Normal malloc-like call
+			addConstraint(AndersConstraint::ADDR_OF, ptrIndex, objIndex);
+		}
+
+		return true;
+	}
+
+	if (lookupName(retArg0Funcs, f->getName().data()) || (isReallocLike && isa<ConstantPointerNull>(cs.getArgument(0))))
+	{
+		NodeIndex retIndex = nodeFactory.getValueNodeFor(cs.getInstruction());
+		assert(retIndex != AndersNodeFactory::InvalidIndex && "Failed to find call site node");
+		NodeIndex arg0Index = nodeFactory.getValueNodeFor(cs.getArgument(0));
+		assert(arg0Index != AndersNodeFactory::InvalidIndex && "Failed to find arg0 node");
+		addConstraint(AndersConstraint::COPY, retIndex, arg0Index);
+		return true;
+	}
+
+	if (lookupName(retArg1Funcs, f->getName().data()))
+	{
+		NodeIndex retIndex = nodeFactory.getValueNodeFor(cs.getInstruction());
+		assert(retIndex != AndersNodeFactory::InvalidIndex && "Failed to find call site node");
+		NodeIndex arg1Index = nodeFactory.getValueNodeFor(cs.getArgument(1));
+		assert(arg1Index != AndersNodeFactory::InvalidIndex && "Failed to find arg1 node");
+		addConstraint(AndersConstraint::COPY, retIndex, arg1Index);
+		return true;
+	}
+
+	if (lookupName(retArg2Funcs, f->getName().data()))
+	{
+		NodeIndex retIndex = nodeFactory.getValueNodeFor(cs.getInstruction());
+		assert(retIndex != AndersNodeFactory::InvalidIndex && "Failed to find call site node");
+		NodeIndex arg2Index = nodeFactory.getValueNodeFor(cs.getArgument(2));
+		assert(arg2Index != AndersNodeFactory::InvalidIndex && "Failed to find arg2 node");
+		addConstraint(AndersConstraint::COPY, retIndex, arg2Index);
+		return true;
+	}
+
+	if (lookupName(memcpyFuncs, f->getName().data()))
+	{
+		NodeIndex arg0Index = nodeFactory.getValueNodeFor(cs.getArgument(0));
+		assert(arg0Index != AndersNodeFactory::InvalidIndex && "Failed to find arg0 node");
+		NodeIndex arg1Index = nodeFactory.getValueNodeFor(cs.getArgument(1));
+		assert(arg1Index != AndersNodeFactory::InvalidIndex && "Failed to find arg1 node");
+
+		NodeIndex tempIndex = nodeFactory.createValueNode();
+		addConstraint(AndersConstraint::LOAD, tempIndex, arg1Index);
+		addConstraint(AndersConstraint::STORE, arg0Index, tempIndex);
+
+		// Don't forget the return value
+		NodeIndex retIndex = nodeFactory.getValueNodeFor(cs.getInstruction());
+		if (retIndex != AndersNodeFactory::InvalidIndex)
+			addConstraint(AndersConstraint::COPY, retIndex, arg0Index);
+
+		return true;
+	}
+
+	if (lookupName(convertFuncs, f->getName().data()))
+	{
+		if (!isa<ConstantPointerNull>(cs.getArgument(1)))
+		{
+			NodeIndex arg0Index = nodeFactory.getValueNodeFor(cs.getArgument(0));
+			assert(arg0Index != AndersNodeFactory::InvalidIndex && "Failed to find arg0 node");
+			NodeIndex arg1Index = nodeFactory.getValueNodeFor(cs.getArgument(1));
+			assert(arg1Index != AndersNodeFactory::InvalidIndex && "Failed to find arg1 node");
+			addConstraint(AndersConstraint::STORE, arg0Index, arg1Index);
+		}
+
+		return true;
+	}
+
+	if (f->getName() == "llvm.va_start")
+	{
+		const Instruction* inst = cs.getInstruction();
+		const Function* parentF = inst->getParent()->getParent();
+		assert(parentF->getFunctionType()->isVarArg());
+		NodeIndex arg0Index = nodeFactory.getValueNodeFor(cs.getArgument(0));
+		assert(arg0Index != AndersNodeFactory::InvalidIndex && "Failed to find arg0 node");
+		NodeIndex vaIndex = nodeFactory.getVarargNodeFor(parentF);
+		assert(vaIndex != AndersNodeFactory::InvalidIndex && "Failed to find va node");
+		addConstraint(AndersConstraint::ADDR_OF, arg0Index, vaIndex);
+
+		return true;
+	}
+
+	return false;
+}
diff --git a/lib/Analysis/Andersen/LLVMBuild.txt b/lib/Analysis/Andersen/LLVMBuild.txt
new file mode 100644
index 0000000..55b54fd
--- /dev/null
+++ b/lib/Analysis/Andersen/LLVMBuild.txt
@@ -0,0 +1,22 @@
+;===- ./lib/Analysis/LLVMBuild.txt -----------------------------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Library
+name = Andersen
+parent = Analysis
+required_libraries = Core Support Object
diff --git a/lib/Analysis/Andersen/NodeFactory.cpp b/lib/Analysis/Andersen/NodeFactory.cpp
new file mode 100644
index 0000000..52b2f52
--- /dev/null
+++ b/lib/Analysis/Andersen/NodeFactory.cpp
@@ -0,0 +1,328 @@
+#include "llvm/Analysis/Andersen/NodeFactory.h"
+
+#include "llvm/IR/Constants.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/Analysis/ValueTracking.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include <limits>
+
+using namespace llvm;
+
+const unsigned AndersNodeFactory::InvalidIndex = std::numeric_limits<unsigned int>::max();
+
+AndersNodeFactory::AndersNodeFactory(): dataLayout(nullptr)
+{
+	// Note that we can't use std::vector::emplace_back() here because AndersNode's constructors are private hence std::vector cannot see it
+
+	// Node #0 is always the universal ptr: the ptr that we don't know anything about.
+	nodes.push_back(AndersNode(AndersNode::VALUE_NODE, 0));
+	// Node #0 is always the universal obj: the obj that we don't know anything about.
+	nodes.push_back(AndersNode(AndersNode::OBJ_NODE, 1));
+	// Node #2 always represents the null pointer.
+	nodes.push_back(AndersNode(AndersNode::VALUE_NODE, 2));
+	// Node #3 is the object that null pointer points to
+	nodes.push_back(AndersNode(AndersNode::OBJ_NODE, 3));
+
+	assert(nodes.size() == 4);
+}
+
+NodeIndex AndersNodeFactory::createValueNode(const Value* val)
+{
+    nodeLock.lock();
+    NodeIndex i = getValueNodeFor(val);
+    if (i != InvalidIndex) {
+        nodeLock.unlock();
+        return i;
+    }
+	//errs() << "inserting " << *val << "\n";
+	unsigned nextIdx = nodes.size();
+	nodes.push_back(AndersNode(AndersNode::VALUE_NODE, nextIdx, val));
+	if (val != nullptr)
+	{
+		assert(!valueNodeMap.count(val) && "Trying to insert two mappings to revValueNodeMap!");
+		valueNodeMap[val] = nextIdx;
+	}
+    nodeLock.unlock();
+	return nextIdx;
+}
+
+NodeIndex AndersNodeFactory::createObjectNode(const Value* val)
+{
+    if (const Instruction *inst = dyn_cast<const Instruction>(val)) {
+        return createObjectNodeDummy(inst, *(Module*)inst->getParent()->getParent()->getParent());
+    }
+    nodeLock.lock();
+    unsigned nextIdx;
+//    if (const Instruction *inst = dyn_cast<const Instruction>(val)) {
+//        nextIdx = createObjectNodeDummy(val, *(Module*)inst->getParent()->getParent()->getParent());
+//    } else {
+        NodeIndex i = getObjectNodeFor(val);
+        if (i != InvalidIndex) {
+            nodeLock.unlock();
+            return i;
+        }
+        nextIdx = nodes.size();
+        nodes.push_back(AndersNode(AndersNode::OBJ_NODE, nextIdx, val));
+        if (val != nullptr)
+        {
+            assert(!objNodeMap.count(val) && "Trying to insert two mappings to revObjNodeMap!");
+            objNodeMap[val] = nextIdx;
+        }
+//    }
+
+    nodeLock.unlock();
+	return nextIdx;
+}
+
+NodeIndex AndersNodeFactory::createReturnNode(const llvm::Function* f)
+{
+	unsigned nextIdx = nodes.size();
+	nodes.push_back(AndersNode(AndersNode::VALUE_NODE, nextIdx, f));
+
+	assert(!returnMap.count(f) && "Trying to insert two mappings to returnMap!");
+	returnMap[f] = nextIdx;
+
+	return nextIdx;
+}
+
+NodeIndex AndersNodeFactory::createVarargNode(const llvm::Function* f)
+{
+	unsigned nextIdx = nodes.size();
+	nodes.push_back(AndersNode(AndersNode::OBJ_NODE, nextIdx, f));
+
+	assert(!varargMap.count(f) && "Trying to insert two mappings to varargMap!");
+	varargMap[f] = nextIdx;
+
+	return nextIdx;
+}
+
+NodeIndex AndersNodeFactory::getValueNodeFor(const Value* val) const
+{
+	if (const Constant* c = dyn_cast<Constant>(val))
+		if (!isa<GlobalValue>(c))
+			return getValueNodeForConstant(c);
+
+    if (val->getName() == "X0_56") {
+        assert(true);
+    }
+
+	//errs() << "looking up " << *val << "\n";
+	auto itr = valueNodeMap.find(val);
+	if (itr == valueNodeMap.end())
+		return InvalidIndex;
+	else {
+        return itr->second;
+    }
+}
+
+NodeIndex AndersNodeFactory::getValueNodeForConstant(const llvm::Constant* c) const
+{
+//	assert(isa<PointerType>(c->getType()) && "Not a constant pointer!");
+
+	if (isa<ConstantPointerNull>(c) || isa<UndefValue>(c))
+    	return getNullPtrNode();
+    else if (const GlobalValue* gv = dyn_cast<GlobalValue>(c))
+    	return getValueNodeFor(gv);
+    else if (const ConstantExpr* ce = dyn_cast<ConstantExpr>(c))
+    {
+		switch (ce->getOpcode())
+		{
+			// Pointer to any field within a struct is treated as a pointer to the first field
+			case Instruction::GetElementPtr:
+				return getValueNodeFor(c->getOperand(0));
+			case Instruction::IntToPtr:
+			case Instruction::PtrToInt: {
+//				return getUniversalPtrNode();
+                auto itr = valueNodeMap.find(c);
+                if (itr == valueNodeMap.end())
+                    return InvalidIndex;
+                else
+                    return itr->second;
+            }
+			case Instruction::BitCast:
+				return getValueNodeForConstant(ce->getOperand(0));
+			default:
+				errs() << "Constant Expr not yet handled: " << *ce << "\n";
+				llvm_unreachable(0);
+		}
+	} else if (isa<IntegerType>(c->getType())) {
+        auto itr = valueNodeMap.find(c);
+        if (itr == valueNodeMap.end())
+            return InvalidIndex;
+        else
+            return itr->second;
+    } else if (isa<ConstantFP>(c)) {
+        return InvalidIndex;
+    }
+    c->dump();
+	llvm_unreachable("Unknown constant pointer!");
+	return InvalidIndex;
+}
+
+NodeIndex AndersNodeFactory::getObjectNodeFor(const Value* val) const
+{
+    if (dummyMap.find(val) != dummyMap.end()) {
+        return getObjectNodeFor(dummyMap.find(val)->second);
+    }
+	if (const Constant* c = dyn_cast<Constant>(val))
+		if (!isa<GlobalValue>(c))
+			return getObjectNodeForConstant(c);
+
+	auto itr = objNodeMap.find(val);
+	if (itr == objNodeMap.end())
+		return InvalidIndex;
+	else
+		return itr->second;
+}
+
+NodeIndex AndersNodeFactory::getObjectNodeForConstant(const llvm::Constant* c) const
+{
+//	assert(isa<PointerType>(c->getType()) && "Not a constant pointer!");
+
+	if (isa<ConstantPointerNull>(c))
+		return getNullObjectNode();
+	else if (const GlobalValue* gv = dyn_cast<GlobalValue>(c))
+		return getObjectNodeFor(gv);
+	else if (const ConstantExpr* ce = dyn_cast<ConstantExpr>(c))
+	{
+		switch (ce->getOpcode())
+		{
+			// Pointer to any field within a struct is treated as a pointer to the first field
+			case Instruction::GetElementPtr:
+				return getObjectNodeForConstant(ce->getOperand(0));
+			case Instruction::IntToPtr:
+			case Instruction::PtrToInt:
+				return getUniversalObjNode();
+			case Instruction::BitCast:
+				return getObjectNodeForConstant(ce->getOperand(0));
+			default:
+				errs() << "Constant Expr not yet handled: " << *ce << "\n";
+				llvm_unreachable(0);
+		}
+	} else if (isa<IntegerType>(c->getType()) || isa<ConstantDataArray>(c)) {
+        auto itr = objNodeMap.find(c);
+        if (itr == objNodeMap.end())
+            return InvalidIndex;
+        else
+            return itr->second;
+    } else
+        return InvalidIndex;
+
+	llvm_unreachable("Unknown constant pointer!");
+	return InvalidIndex;
+}
+
+NodeIndex AndersNodeFactory::getReturnNodeFor(const llvm::Function* f) const
+{
+	auto itr = returnMap.find(f);
+	if (itr == returnMap.end())
+		return InvalidIndex;
+	else
+		return itr->second;
+}
+
+NodeIndex AndersNodeFactory::getVarargNodeFor(const llvm::Function* f) const
+{
+	auto itr = varargMap.find(f);
+	if (itr == varargMap.end())
+		return InvalidIndex;
+	else
+		return itr->second;
+}
+
+void AndersNodeFactory::mergeNode(NodeIndex n0, NodeIndex n1)
+{
+	assert(n0 < nodes.size() && n1 < nodes.size());
+	nodes[n1].mergeTarget = n0;
+}
+
+NodeIndex AndersNodeFactory::getMergeTarget(NodeIndex n)
+{
+	assert(n < nodes.size());
+	NodeIndex ret = nodes[n].mergeTarget;
+	if (ret != n)
+	{
+		std::vector<NodeIndex> path(1, n);
+		while (ret != nodes[ret].mergeTarget)
+		{
+			path.push_back(ret);
+			ret = nodes[ret].mergeTarget;
+		}
+		for (auto idx: path)
+			nodes[idx].mergeTarget = ret;
+	}
+	assert(ret < nodes.size());
+	return ret;
+}
+
+NodeIndex AndersNodeFactory::getMergeTarget(NodeIndex n) const
+{
+	assert (n < nodes.size());
+	NodeIndex ret = nodes[n].mergeTarget;
+	while (ret != nodes[ret].mergeTarget)
+		ret = nodes[ret].mergeTarget;
+	return ret;
+}
+
+void AndersNodeFactory::getAllocSites(std::vector<const llvm::Value*>& allocSites) const
+{
+	allocSites.clear();
+	allocSites.reserve(objNodeMap.size());
+	for (auto const& mapping: objNodeMap)
+		allocSites.push_back(mapping.first);
+}
+
+void AndersNodeFactory::dumpNode(NodeIndex idx) const
+{
+	const AndersNode& n = nodes.at(idx);
+	if (n.type == AndersNode::VALUE_NODE)
+		errs() << "[V ";
+	else if (n.type == AndersNode::OBJ_NODE)
+		errs() << "[O ";
+	else {
+        assert(false && "Wrong type number!");
+    }
+	errs() << "#" << n.idx << "]";
+}
+
+void AndersNodeFactory::dumpNodeInfo() const
+{
+	errs() << "\n----- Print AndersNodeFactory Info -----\n";
+	for (auto const& node: nodes)
+	{
+		dumpNode(node.getIndex());
+		errs() << ", val = ";
+		const Value* val = node.getValue();
+		if (val == nullptr)
+			errs() << "nullptr";
+		else if (isa<Function>(val))
+			errs() << "  <func> " << val->getName();
+		else if (isa<Instruction>(val)) {
+            val->print(errs());
+            errs() << ((Instruction*)val)->getParent()->getParent()->getName();
+        } else
+			errs() << *val;
+		errs() << "\n";
+	}
+
+	errs() << "\nReturn Map:\n";
+	for (auto const& mapping: returnMap)
+		errs() << mapping.first->getName() << "  -->>  [Node #" << mapping.second << "]\n";
+	errs() << "\nVararg Map:\n";
+	for (auto const& mapping: varargMap)
+		errs() << mapping.first->getName() << "  -->>  [Node #" << mapping.second << "]\n";
+	errs() << "----- End of Print -----\n";
+}
+
+void AndersNodeFactory::dumpRepInfo() const
+{
+	errs() << "\n----- Print Node Merge Info -----\n";
+	for (NodeIndex i = 0, e = nodes.size(); i < e; ++i)
+	{
+		NodeIndex rep = getMergeTarget(i);
+		if (rep != i)
+			errs() << i << " -> " << rep << "\n";
+	}
+	errs() << "----- End of Print -----\n";
+}
diff --git a/lib/Analysis/Andersen/NonVolatileRegistersPass.cpp b/lib/Analysis/Andersen/NonVolatileRegistersPass.cpp
new file mode 100644
index 0000000..05f491c
--- /dev/null
+++ b/lib/Analysis/Andersen/NonVolatileRegistersPass.cpp
@@ -0,0 +1,134 @@
+#include <llvm/IR/Function.h>
+#include "llvm/Analysis/Andersen/NonVolatileRegistersPass.h"
+
+#include <set>
+#include <llvm/IR/Constants.h>
+#include <llvm/IR/Module.h>
+#include <llvm/Support/raw_ostream.h>
+#include <llvm/IR/Instructions.h>
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+using namespace llvm;
+
+
+bool NonVolatileRegistersPass::runOnModule(Module &M) {
+    for (Module::iterator F_it = M.begin(); F_it != M.end(); ++F_it) {
+        Function &F = *F_it;
+        if (F.isDeclaration() || F.isIntrinsic()) {
+            continue;
+        }
+        std::set<Value *> NonVolatileAndStackPointers;
+        std::set<Value *> NonVolatilePointers;
+
+        BasicBlock &Entry = F.getEntryBlock();
+        for (BasicBlock::iterator I_it = Entry.begin(); I_it != Entry.end(); ++I_it) {
+            if (I_it->getOpcode() == Instruction::GetElementPtr) {
+                if (ConstantInt *ConstIdx = dyn_cast<ConstantInt>(I_it->getOperand(2))) {
+                    if (isNonVolatile(ConstIdx->getZExtValue())) {
+                        NonVolatileAndStackPointers.insert(&*I_it);
+                        NonVolatilePointers.insert(&*I_it);
+                    } else if (isStack(ConstIdx->getZExtValue())) {
+                        NonVolatileAndStackPointers.insert(&*I_it);
+                    }
+                }
+            }
+        }
+
+        for (Function::iterator BB_it = F.begin(); BB_it != F.end(); ++BB_it) {
+            if (!hasCall(*BB_it))
+                continue;
+            for (BasicBlock::iterator I_it = BB_it->begin(); I_it != BB_it->end(); ++I_it) {
+                if (I_it->getOpcode() == Instruction::Store) {
+                    std::set<Value *>::iterator S_it = NonVolatileAndStackPointers.find(I_it->getOperand(1));
+                    if (S_it != NonVolatileAndStackPointers.end()) {
+                        replaceLoaded(&*I_it);
+                    }
+                }
+            }
+        }
+
+        std::set<Instruction*> toRemove;
+
+        for (auto &ptr : NonVolatilePointers) {
+
+            for (auto ptrUser : ptr->users()) {
+                if (StoreInst *storeInst = dyn_cast<StoreInst>(ptrUser)) {
+                    toRemove.insert(storeInst);
+                }
+            }
+        }
+
+        for (auto &r : toRemove) {
+            r->dropAllReferences();
+            r->removeFromParent();
+//                r->dump();
+        }
+    }
+}
+
+bool NonVolatileRegistersPass::hasCall(const BasicBlock &BB) {
+    for (BasicBlock::const_iterator I_it = BB.begin(); I_it != BB.end(); ++I_it) {
+        if (I_it->getOpcode() == Instruction::Call) {
+            return true;
+        }
+    }
+    return false;
+}
+
+bool NonVolatileRegistersPass::isNonVolatile(uint64_t Idx) {
+    switch (Idx) {
+        default:
+            break;
+        case 24:
+        case 25:
+        case 26:
+        case 27:
+        case 28:
+        case 29:
+        case 30:
+        case 31:
+        case 32:
+        case 33:
+            return true;
+    }
+    return false;
+}
+
+bool NonVolatileRegistersPass::isStack(uint64_t Idx) {
+    switch (Idx) {
+        default:
+            break;
+        case 3:
+        case 0:
+            return true;
+    }
+    return false;
+}
+
+void NonVolatileRegistersPass::replaceLoaded(Instruction *StoreInst) {
+    Value *Ptr = StoreInst->getOperand(1);
+    Value *V = StoreInst->getOperand(0);
+    if (!V)
+        StoreInst->dump();
+    assert(V);
+
+    BasicBlock *BB = StoreInst->getParent();
+    Instruction *Load = nullptr;
+    for (BasicBlock::iterator I_it = BB->begin(); I_it != BB->end(); ++I_it) {
+        if (I_it->getOpcode() == Instruction::Load && I_it->getOperand(0) == Ptr) {
+            Load = &*I_it;
+        }
+    }
+
+    if (!Load)
+        return;
+
+//    for (Value::const_use_iterator U_it = Load->use_begin(); U_it != Load->use_end(); ++U_it) {
+//
+//    }
+    if (Load != V)
+        Load->replaceAllUsesWith(V);
+}
+
+char NonVolatileRegistersPass::ID = 0;
+static RegisterPass<NonVolatileRegistersPass> X("nonvolatile", "", true, false);
diff --git a/lib/Analysis/Andersen/ObjCCallHandler.cpp b/lib/Analysis/Andersen/ObjCCallHandler.cpp
new file mode 100644
index 0000000..a0570e8
--- /dev/null
+++ b/lib/Analysis/Andersen/ObjCCallHandler.cpp
@@ -0,0 +1,76 @@
+#include <memory>
+#include <llvm/IR/Value.h>
+#include "llvm/Analysis/Andersen/ObjCCallHandler.h"
+
+#include "llvm/Support/ManagedStatic.h"
+#include "llvm/IR/CallSite.h"
+
+#include "llvm/Analysis/Andersen/CallHandler/ObjCRuntimeCallHandler.h"
+#include "../../LLVMSlicer/Languages/LLVM.h"
+
+using namespace llvm;
+using namespace llvm::ObjectiveC;
+
+static std::unique_ptr<CallHandlerManager> GlobalCallHandlerManager(new CallHandlerManager());
+
+std::mutex CallHandlerManager::initLock;
+//static llvm::ManagedStatic<CallHandlerManager> GlobalCallHandlerManager;
+
+CallHandlerManager &llvm::ObjectiveC::getGlobalCallHandlerManager() {
+    return CallHandlerManager::getInstance();
+}
+
+CallHandlerManager &CallHandlerManager::getInstance() {
+    initLock.lock();
+    static CallHandlerManager *Instance = nullptr;
+    if (!Instance) {
+        Instance = new CallHandlerManager();
+        Instance->registerCallHandler<objcMsgSend>();
+        Instance->registerCallHandler<MsgSendSuper>();
+        Instance->registerCallHandler<dispatchBlock>();
+        Instance->registerCallHandler<CopyProperty>();
+                Instance->registerCallHandler<retainBlock>();
+//        Instance->registerCallHandler<objcARC>();
+//        Instance->registerCallHandler<objcPreserveX0>();
+//        Instance->registerCallHandler<objcPreserveNone>();
+//        Instance->registerCallHandler<specialAllocs>();
+        Instance->registerCallHandler<ClassHandler>();
+        Instance->registerCallHandler<ExternalHandler>();
+        Instance->registerCallHandler<NSArray>();
+        Instance->registerCallHandler<UIControlTarget>();
+        Instance->registerCallHandler<UIAppDelegate>();
+        Instance->registerCallHandler<NSUserDefaults>();
+        Instance->registerCallHandler<SecItemCopyAdd>();
+
+//        Instance->registerCallHandler<Dummy>();
+
+//        Instance->registerCallHandler<objcInit>();
+//        Instance->registerCallHandler<DummyHandler>();
+    }
+    initLock.unlock();
+    return *Instance;
+}
+
+bool CallHandlerManager::handleFunctionCall(const Instruction *CallInst, std::string &F, Andersen *andersen) {
+    for (CallHandlerList_t::iterator CH_it = CallHandlers.begin(); CH_it != CallHandlers.end(); ++CH_it) {
+        if ((*CH_it)->shouldHandleCall(F)) {
+            if ((*CH_it)->run(CallInst, F, andersen))
+                return true;
+        }
+    }
+    return false;
+}
+
+CallHandlerManager::CallHandlerPtr_t CallHandlerManager::getCallHandler(StringRef &FunctionName) {
+    for (CallHandlerList_t::iterator CH_it = CallHandlers.begin(); CH_it != CallHandlers.end(); ++CH_it) {
+        if ((*CH_it)->getFunctionName() == FunctionName) {
+            return *CH_it;
+        }
+    }
+    return nullptr;
+}
+
+
+void CallHandlerManager::addCallHandler(std::shared_ptr<CallHandlerBase> Handler) {
+    CallHandlers.push_back(Handler);
+}
diff --git a/lib/Analysis/Andersen/ObjectiveCBinary.cpp b/lib/Analysis/Andersen/ObjectiveCBinary.cpp
new file mode 100644
index 0000000..855dc15
--- /dev/null
+++ b/lib/Analysis/Andersen/ObjectiveCBinary.cpp
@@ -0,0 +1,725 @@
+#include <llvm/ADT/StringExtras.h>
+#include <llvm/Object/SymbolicFile.h>
+#include "llvm/Analysis/Andersen/ObjectiveCBinary.h"
+
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/LEB128.h"
+#include "llvm/Support/Debug.h"
+#include <sstream>
+
+
+using namespace llvm;
+
+#define DEBUG_TYPE "OBJC_BINARY"
+
+#define SEC_SELREFS "__objc_selrefs"
+#define SEC_CLASSREFS "__objc_classrefs"
+#define SEC_METHNAME "__objc_methname"
+#define SEC_OBJC_DATA "__objc_data"
+#define SEC_DATA "__data"
+#define SEC_CONST "__objc_const"
+#define SEC_CLASSNAME "__objc_classname"
+#define SEC_CLASSLIST "__objc_classlist"
+#define SEC_SUPERREF "__objc_superrefs"
+#define SEC_IVAR "__objc_ivar"
+#define SEC_TEXT "__text"
+#define SEC_CFSTRING "__cfstring"
+#define SEC_CSTRING "__cstring"
+#define SEC_GOT "__got"
+#define SEC_METHTYPE "__objc_methtype"
+
+#define ISA_OFFSET 0
+#define SUPER_OFFSET 8
+#define DATA_OFFSET 32
+
+#define NAME_OFFSET 24
+#define METHOD_OFFSET 32
+#define PROTOCOL_OFFSET 40
+#define IVAR_OFFSET 48
+#define PROP_OFFSET 64
+
+#define OBJC_CLASS_ID "_OBJC_CLASS_$_"
+#define OBJC_METACLASS_ID "_OBJC_METACLASS_$_"
+
+#define ADDSUBSUP(sub, sup) \
+  if (!Classes[sub])\
+    Classes[sub] = BaseClassPtr_t(new ObjectiveC::DummyClass(sub));\
+  Classes[sub]->setSuperclass(sup);\
+  if (!Metaclasses[sub])\
+    Metaclasses[sub] = BaseClassPtr_t(new ObjectiveC::DummyClass(sub));\
+  Metaclasses[sub]->setSuperclass(sup);
+
+
+ObjectiveCBinary::ObjectiveCBinary(llvm::StringRef Path) {
+    auto O = object::MachOObjectFile::createObjectFile(Path);
+    ObjectFile = std::move(O.get());
+    MachO = dyn_cast<object::MachOObjectFile>(ObjectFile.getBinary());
+
+    loadSections();
+    doBinding();
+    loadClasses();
+
+
+//    Classes["NSMutableData"]->setSuperclass("NSData");
+//    Metaclasses["NSMutableData"]->setSuperclass("NSData");
+    ADDSUBSUP("NSMutableData", "NSData")
+    ADDSUBSUP("NSData", "NSObject")
+    ADDSUBSUP("NSString", "NSObject")
+    ADDSUBSUP("NSMutableString", "NSString")
+    ADDSUBSUP("UIButton", "UIControl")
+    ADDSUBSUP("UIControl", "UIView")
+    ADDSUBSUP("NSMutableDictionary", "NSDictionary")
+}
+
+bool ObjectiveCBinary::isValidAddress(uint64_t Address) {
+    return false;
+}
+
+bool ObjectiveCBinary::isSelectorRef(uint64_t Address) {
+    return isAddressInSection(Address, getSectionIterator(SEC_SELREFS));
+}
+
+bool ObjectiveCBinary::isClassRef(uint64_t Address) {
+    return isAddressInSection(Address, getSectionIterator(SEC_CLASSREFS));
+}
+
+bool ObjectiveCBinary::isMethname(uint64_t Address){
+    return isAddressInSection(Address, getSectionIterator(SEC_METHNAME));
+}
+
+bool ObjectiveCBinary::isData(uint64_t Address) {
+    return isAddressInSection(Address, getSectionIterator(SEC_OBJC_DATA));
+}
+
+bool ObjectiveCBinary::isConst(uint64_t Address) {
+    return isAddressInSection(Address, getSectionIterator(SEC_CONST));
+}
+
+bool ObjectiveCBinary::isIVAR(uint64_t Address) {
+    return isAddressInSection(Address, getSectionIterator(SEC_IVAR));
+}
+
+bool ObjectiveCBinary::isAddressInSection(uint64_t Address, object::section_iterator Section) {
+    if (Section == MachO->section_end())
+        return false;
+    return Section->getAddress() <= Address &&
+           Address < (Section->getAddress() + Section->getSize());
+}
+
+void ObjectiveCBinary::loadSections() {
+    for (object::section_iterator S_it = MachO->section_begin(); S_it != MachO->section_end(); ++S_it) {
+        StringRef SectionName;
+        if (S_it->getName(SectionName)) {
+            continue;
+        }
+        if (SectionName == SEC_SELREFS) {
+            const object::SectionRef &S = *S_it;
+            SelRefsDataRef = S.getRawDataRefImpl();
+        } else if (SectionName == SEC_METHNAME) {
+            const object::SectionRef &S = *S_it;
+            MethnameDataRef = S.getRawDataRefImpl();
+        }
+    }
+}
+
+void ObjectiveCBinary::loadClasses() {
+    auto getInt8ArrayRef = [] (object::section_iterator Section) {
+        StringRef Content;
+        Section->getContents(Content);
+        return ArrayRef<uint8_t>((uint8_t*) Content.data(), Content.size());
+    };
+
+    object::section_iterator DataSection = getSectionIterator(SEC_OBJC_DATA);
+    ArrayRef<uint8_t> Data = getInt8ArrayRef(DataSection);
+
+    object::section_iterator ClassList = getSectionIterator(SEC_CLASSLIST);
+    ArrayRef<uint8_t> ClassListData = getInt8ArrayRef(ClassList);
+    //Iterate over the classes that are defined in this file
+    for (unsigned Idx = 0; Idx < ClassListData.size(); Idx += 8) {
+        uint64_t DataAddress = *(uint64_t*)ClassListData.slice(Idx).data();
+        if (!isAddressInSection(DataAddress, DataSection)) {
+            llvm_unreachable("Class does not point to objc_data");
+            continue;
+        }
+        parseClass(DataAddress);
+    }
+
+
+    StringRef Content;
+
+    object::section_iterator ClassRefsSection = getSectionIterator(SEC_CLASSREFS);
+    ClassRefsSection->getContents(Content);
+    ArrayRef<uint8_t> ClassRefs((uint8_t*) Content.data(), Content.size());
+
+    object::section_iterator ConstSection = getSectionIterator(SEC_CONST);
+    ConstSection->getContents(Content);
+    ArrayRef<uint8_t> Const((uint8_t*) Content.data(), Content.size());
+
+    object::section_iterator ClassnameSection = getSectionIterator(SEC_CLASSNAME);
+    ClassnameSection->getContents(Content);
+    ArrayRef<uint8_t> Classnames((uint8_t*) Content.data(), Content.size());
+
+    for (unsigned Idx = 0; Idx < ClassRefs.size(); Idx += 8) {
+        uint64_t ObjcDataAddress = *(uint64_t*)ClassRefs.slice(Idx).data();
+        uint64_t ClassRefAddress = ClassRefsSection->getAddress() + Idx;
+        if (!ObjcDataAddress) {
+            if (BindInfo[ClassRefAddress].size()) {
+                StringRef BindClassname = BindInfo[ClassRefAddress];
+                //TODO: do meta-classes have to be handled here?
+                this->ClassRefs[ClassRefAddress] = BindClassname.startswith_lower(OBJC_CLASS_ID) ? BindClassname.substr(strlen(OBJC_CLASS_ID)) : BindClassname.substr(strlen(OBJC_METACLASS_ID));
+            }
+            continue;
+        }
+        if (!isData(ObjcDataAddress))
+            continue;
+        uint64_t ConstAddress = *(uint64_t*)Data.slice(ObjcDataAddress - DataSection->getAddress() + 32).data();
+        if (!isConst(ConstAddress)) {
+            llvm_unreachable("this should not happen...");
+        }
+        uint64_t ClassNameAddress = *(uint64_t*)Const.slice(ConstAddress - ConstSection->getAddress() + 24).data();
+        if (!isAddressInSection(ClassNameAddress, getSectionIterator(SEC_CLASSNAME))) {
+            llvm_unreachable("no classname?");
+        }
+        StringRef Classname = (const char*)Classnames.slice(ClassNameAddress - ClassnameSection->getAddress()).data();
+        this->ClassRefs[ClassNameAddress] = Classname;
+        this->ClassRefs[ClassRefsSection->getAddress() + Idx] = Classname;
+    }
+}
+
+void ObjectiveCBinary::doBinding() {
+    ArrayRef<uint8_t> BindOpcodes = MachO->getDyldInfoBindOpcodes();
+
+    uint64_t SegmentNo = 0;
+    int64_t Offset = 0;
+    StringRef SymbolName;
+
+    for (unsigned Idx = 0; Idx < BindOpcodes.size();) {
+        unsigned Opcode = *BindOpcodes.slice(Idx).data();
+
+        if ((Opcode & ~0xF) == MachO::BIND_OPCODE_SET_DYLIB_ORDINAL_IMM) {
+            unsigned Imm = Opcode & 0xF;
+            Idx++;
+        } else if ((Opcode & ~0xF) == MachO::BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM) {
+            Idx++;
+            SymbolName = (const char*)BindOpcodes.slice(Idx).data();
+            Idx += SymbolName.size() + 1;
+        } else if (Opcode == (MachO::BIND_OPCODE_SET_TYPE_IMM | 0x1)) {
+            //Set type pointer
+            Idx++;
+        } else if ((Opcode & ~0xF) == MachO::BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB) {
+            SegmentNo = Opcode & 0xF;
+            Idx++;
+            unsigned n;
+            Offset = decodeULEB128(BindOpcodes.slice(Idx).data(), &n);
+            Idx += n;
+        } else if (Opcode == MachO::BIND_OPCODE_DO_BIND) {
+            MachO::segment_command_64 Segment = getSegment(SegmentNo);
+            addClass(SymbolName, Segment.vmaddr + Offset);
+            //FIXME: is this add correct???
+            Offset += 8;
+            Idx++;
+        } else if (Opcode == MachO::BIND_OPCODE_ADD_ADDR_ULEB) {
+            Idx++;
+            unsigned n;
+            Offset += decodeULEB128(BindOpcodes.slice(Idx).data(), &n);
+            Idx += n;
+        } else if ((Opcode & ~0xF) == MachO::BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED) {
+            unsigned Scaled = (Opcode & 0xF) * 8;
+            addClass(SymbolName, getSegment(SegmentNo).vmaddr + Offset);
+            //FIXME: again the add of 8
+            Offset += Scaled + 8;
+            Idx++;
+        } else if (Opcode == MachO::BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB) {
+            //TODO:
+            Idx++;
+            unsigned n;
+            uint64_t Count = decodeULEB128(BindOpcodes.slice(Idx).data(), &n);
+            Idx += n;
+            n = 0;
+            uint64_t Skip = decodeULEB128(BindOpcodes.slice(Idx).data(), &n);
+            for (unsigned i = 0; i < Count; ++i) {
+                addClass(SymbolName, getSegment(SegmentNo).vmaddr + Offset);
+                Offset += 8 + Skip;
+            }
+            Idx += n;
+        } else if (Opcode == MachO::BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB) {
+            addClass(SymbolName, getSegment(SegmentNo).vmaddr + Offset);
+            Idx++;
+            unsigned n;
+            Offset += decodeULEB128(BindOpcodes.slice(Idx).data(), &n) + 8;
+            Idx += n;
+        } else if (Opcode == MachO::BIND_OPCODE_DONE) {
+            break;
+        } else if (Opcode == MachO::BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB) {
+            Idx++;
+            unsigned n;
+            uint64_t dylib = decodeULEB128(BindOpcodes.slice(Idx).data(), &n) + 8;
+            Idx += n;
+        } else if (Opcode == MachO::BIND_OPCODE_SET_ADDEND_SLEB) {
+            Idx++;
+            unsigned n;
+            uint64_t addend = decodeSLEB128(BindOpcodes.slice(Idx).data(), &n);
+            Idx += n;
+        } else {
+            errs() << "0X" << utohexstr(Idx) << "\n";
+            errs() << "0x" << utohexstr(Opcode) << "\n";
+            assert(false);
+        }
+    }
+}
+
+void ObjectiveCBinary::parseClass(uint64_t DataAddress, bool MetaClass) {
+    object::section_iterator ConstSection = getSectionIterator(SEC_CONST);
+    object::section_iterator ObjcDataSection = getSectionIterator(SEC_OBJC_DATA);
+    object::section_iterator ClassnameSection = getSectionIterator(SEC_CLASSNAME);
+    object::section_iterator DataSection = getSectionIterator(SEC_DATA);
+
+    StringRef Content;
+
+    ObjcDataSection->getContents(Content);
+    ArrayRef<uint8_t> ObjcDataData((uint8_t*) Content.data(), Content.size());
+
+    ConstSection->getContents(Content);
+    ArrayRef<uint8_t> ConstData((uint8_t*) Content.data(), Content.size());
+
+    ClassnameSection->getContents(Content);
+    ArrayRef<uint8_t> ClassnameData((uint8_t*) Content.data(), Content.size());
+
+    DataSection->getContents(Content);
+    ArrayRef<uint8_t> DataData((uint8_t*) Content.data(), Content.size());
+
+    uint64_t ISA = *(uint64_t*) ObjcDataData.slice(DataAddress - ObjcDataSection->getAddress() + ISA_OFFSET).data();
+    uint64_t Super = *(uint64_t*) ObjcDataData.slice(DataAddress - ObjcDataSection->getAddress() + SUPER_OFFSET).data();
+    uint64_t Data = *(uint64_t*) ObjcDataData.slice(DataAddress - ObjcDataSection->getAddress() + DATA_OFFSET).data();
+
+    assert(isAddressInSection(Data, ConstSection));
+
+    uint64_t NamePtr = *(uint64_t*)ConstData.slice(Data - ConstSection->getAddress() + NAME_OFFSET).data();
+    assert(isAddressInSection(NamePtr, ClassnameSection));
+    uint64_t MethodsPtr = *(uint64_t*)ConstData.slice(Data - ConstSection->getAddress() + METHOD_OFFSET).data();
+    assert(!MethodsPtr || isAddressInSection(MethodsPtr, ConstSection));
+    uint64_t IVARsPtr = *(uint64_t*)ConstData.slice(Data - ConstSection->getAddress() + IVAR_OFFSET).data();
+    assert(!IVARsPtr || isAddressInSection(IVARsPtr, ConstSection));
+    uint64_t ProtocolsListPtr = *(uint64_t*)ConstData.slice(Data - ConstSection->getAddress() + PROTOCOL_OFFSET).data();
+    assert(!ProtocolsListPtr || isAddressInSection(ProtocolsListPtr, ConstSection));
+
+    StringRef Classname = (const char*)ClassnameData.slice(NamePtr - ClassnameSection->getAddress()).data();
+
+    ClassNames[DataAddress] = Classname;
+
+    BaseClassPtr_t BaseClassPtr = MetaClass ? Metaclasses[Classname] : Classes[Classname];
+    if (!BaseClassPtr) {
+        BaseClassPtr = BaseClassPtr_t(new ObjectiveC::Class(Classname));
+        BaseClassPtr->setAddress(DataAddress);
+        if (MetaClass)
+            Metaclasses[Classname] = BaseClassPtr;
+        else
+            Classes[Classname] = BaseClassPtr;
+    }
+    assert(BaseClassPtr->getType() != ObjectiveC::Dummy);
+    ClassPtr_t ClassPtr = std::static_pointer_cast<ObjectiveC::Class>(BaseClassPtr);
+
+
+    if (!Super) {
+        StringRef Name = BindInfo[DataAddress + SUPER_OFFSET];
+        if (Name.size()) {
+            assert(!(MetaClass ^ Name.startswith_lower(OBJC_METACLASS_ID)));
+            ClassPtr->setSuperclass(Name.substr(MetaClass ? strlen(OBJC_METACLASS_ID) : strlen(OBJC_CLASS_ID)));
+        } else {
+            assert(false);
+        }
+    } else {
+        uint64_t SuperData = *(uint64_t*) ObjcDataData.slice(Super - ObjcDataSection->getAddress() + DATA_OFFSET).data();
+        assert(isAddressInSection(SuperData, ConstSection));
+        uint64_t SuperNamePtr = *(uint64_t*)ConstData.slice(SuperData - ConstSection->getAddress() + NAME_OFFSET).data();
+        assert(isAddressInSection(NamePtr, ClassnameSection));
+        StringRef SuperClassname = (const char*)ClassnameData.slice(SuperNamePtr - ClassnameSection->getAddress()).data();
+        ClassPtr->setSuperclass(SuperClassname);
+    }
+
+    if (MethodsPtr) {
+        auto methods = parseMethods(MethodsPtr);
+        for (auto &M : methods) {
+            ClassPtr->addMethod(M);
+        }
+    }
+
+    if (Classname == "AddAccountViewController") {
+        assert(true);
+    }
+
+    if (IVARsPtr) {
+        uint32_t IVAREntrySize = *(uint32_t *) ConstData.slice(IVARsPtr - ConstSection->getAddress()).data();
+        uint32_t IVAREntryCount = *(uint32_t *) ConstData.slice(IVARsPtr - ConstSection->getAddress() + 4).data();
+
+        uint64_t CurrentIVAROffest = 8;
+        for (unsigned i = 0; i < IVAREntryCount; ++i) {
+            uint64_t OffsetPtr = *(uint64_t *) ConstData.slice(
+                    IVARsPtr - ConstSection->getAddress() + CurrentIVAROffest).data();
+            uint64_t IVARNamePtr = *(uint64_t *) ConstData.slice(
+                    IVARsPtr - ConstSection->getAddress() + CurrentIVAROffest + 8).data();
+            StringRef IVARName = getString(IVARNamePtr);
+
+            uint64_t IVARTypePtr = *(uint64_t *) ConstData.slice(
+                    IVARsPtr - ConstSection->getAddress() + CurrentIVAROffest + 16).data();
+            StringRef IVARType = getString(IVARTypePtr);
+            if (IVARType.find("@") == 0 && IVARType != "@?") {
+                if (IVARType == "@") {
+                    //FIXME: we can't obtain any more information!?
+                    IVARType = "NSObject";
+                } else {
+                    assert(IVARType.find("\"") != StringRef::npos);
+                    IVARType = IVARType.substr(IVARType.find("\"") + 1);
+                    assert(IVARType.find("\"") != StringRef::npos);
+                    IVARType = IVARType.substr(0, IVARType.find("\""));
+                }
+            } else {
+                IVARType = "";
+            }
+
+            ObjectiveC::IVAR ivar(IVARName, OffsetPtr, IVARType);
+            ClassPtr->addIVAR(ivar);
+            assert(IVARs.find(OffsetPtr) == IVARs.end());
+//            IVARs[OffsetPtr] = ivar;
+            IVARs.insert(std::pair<uint64_t, ObjectiveC::IVAR>(OffsetPtr, ivar));
+
+            CurrentIVAROffest += IVAREntrySize;
+        }
+    }
+
+    auto parseProtocol = [&](uint64_t ProtocolPtr) {
+        uint64_t ProtocolNamePtr = *(uint64_t *) DataData.slice(ProtocolPtr - DataSection->getAddress() + 8).data();
+        StringRef ProtocolName = getString(ProtocolNamePtr);
+
+
+        ObjectiveC::Protocol aProtocol(ProtocolName);
+        uint64_t ProtocolsListPtr = *(uint64_t *) DataData.slice(ProtocolPtr - DataSection->getAddress() + 16).data();
+        uint64_t InstanceMethodsPtr = *(uint64_t *) DataData.slice(ProtocolPtr - DataSection->getAddress() + 24).data();
+        uint64_t ClassMethodsPtr = *(uint64_t *) DataData.slice(ProtocolPtr - DataSection->getAddress() + 32).data();
+        uint64_t OptInstanceMethodsPtr = *(uint64_t *) DataData.slice(ProtocolPtr - DataSection->getAddress() + 40).data();
+        uint64_t OptClassMethodsPtr = *(uint64_t *) DataData.slice(ProtocolPtr - DataSection->getAddress() + 48).data();
+        uint64_t SignatureStartPtr = *(uint64_t *) DataData.slice(ProtocolPtr - DataSection->getAddress() + 72).data();
+        ClassPtr->addProtocol(ProtocolName.str());
+
+        uint64_t signaturesIdx = 0;
+
+
+        if (InstanceMethodsPtr) {
+            std::vector<ObjectiveC::Method> methods = parseMethods(InstanceMethodsPtr, SignatureStartPtr, &signaturesIdx);
+            for (unsigned i = 0; i < methods.size(); ++i) {
+                aProtocol.addInstanceMethod(methods[i]);
+            }
+        }
+        if (OptInstanceMethodsPtr) {
+            auto methods = parseMethods(OptInstanceMethodsPtr, SignatureStartPtr, &signaturesIdx);
+            for (auto m : methods) {
+                aProtocol.addInstanceMethod(m);
+            }
+        }
+        if (ClassMethodsPtr) {
+            auto methods = parseMethods(ClassMethodsPtr, SignatureStartPtr, &signaturesIdx);
+            for (auto m : methods) {
+                aProtocol.addClassMethod(m);
+            }
+        }
+        if (OptClassMethodsPtr) {
+            auto methods = parseMethods(OptClassMethodsPtr, SignatureStartPtr, &signaturesIdx);
+            for (auto m : methods) {
+                aProtocol.addClassMethod(m);
+            }
+        }
+        protocolMap[ProtocolName] = aProtocol;
+    };
+
+    if (ProtocolsListPtr) {
+        uint64_t ProtocolsCount = *(uint64_t *) ConstData.slice(ProtocolsListPtr - ConstSection->getAddress() ).data();
+        uint64_t index = 8;
+        for (unsigned i = 0; i < ProtocolsCount; ++i) {
+            uint64_t ProtocolPtr = *(uint64_t *) ConstData.slice(ProtocolsListPtr - ConstSection->getAddress() + index).data();
+            parseProtocol(ProtocolPtr);
+            index += 8;
+        }
+    }
+
+
+    assert((MetaClass ^ ISA) && "A metaclass can't have an ISA pointer!?");
+    if (ISA && isAddressInSection(ISA, ObjcDataSection)) {
+        parseClass(ISA, true);
+    }
+}
+
+std::vector<ObjectiveC::Method> ObjectiveCBinary::parseMethods(uint64_t MethodsPtr, uint64_t SignatureStartPtr, uint64_t *signaturesIdx) {
+    object::section_iterator ConstSection = getSectionIterator(SEC_CONST);
+    StringRef Content;
+
+    ConstSection->getContents(Content);
+    ArrayRef<uint8_t> ConstData((uint8_t*) Content.data(), Content.size());
+
+
+    std::vector<ObjectiveC::Method> methods;
+    uint32_t MethodEntrySize = *(uint32_t *) ConstData.slice(MethodsPtr - ConstSection->getAddress()).data();
+    uint32_t MethodEntryCount = *(uint32_t *) ConstData.slice(MethodsPtr - ConstSection->getAddress() + 4).data();
+
+    uint64_t CurrentMethodOffest = 8;
+    for (unsigned i = 0; i < MethodEntryCount; ++i) {
+        uint64_t MethodNamePtr = *(uint64_t *) ConstData.slice(
+                MethodsPtr - ConstSection->getAddress() + CurrentMethodOffest).data();
+        uint64_t IMPPtr = *(uint64_t *) ConstData.slice(
+                MethodsPtr - ConstSection->getAddress() + CurrentMethodOffest + 16).data();
+        uint64_t MethTypePtr = *(uint64_t *) ConstData.slice(
+                MethodsPtr - ConstSection->getAddress() + CurrentMethodOffest + 8).data();
+        StringRef MethodName = getString(MethodNamePtr);
+        StringRef MethodType = getString(MethTypePtr);
+        if (SignatureStartPtr && signaturesIdx) {
+            uint64_t MethType2Ptr = SignatureStartPtr + 8*(*signaturesIdx);
+            (*signaturesIdx)++;
+            MethType2Ptr = *(uint64_t *) ConstData.slice(
+                    MethType2Ptr - ConstSection->getAddress()).data();
+            MethodType = getString(MethType2Ptr);
+        }
+
+        methods.push_back(ObjectiveC::Method(MethodName, IMPPtr, MethodType));
+
+        CurrentMethodOffest += MethodEntrySize;
+    }
+    return methods;
+}
+
+bool ObjectiveCBinary::getValue(const uint64_t Address, uint64_t &Value) {
+    if (isSelectorRef(Address)) {
+        object::SectionRef Section(SelRefsDataRef, MachO);
+        StringRef Contents;
+        Section.getContents(Contents);
+        ArrayRef<uint8_t> D((uint8_t*) Contents.data(), Section.getSize());
+        Value = *((uint64_t*) D.slice(Address - Section.getAddress()).data());
+        return true;
+    } else if (isClassRef(Address)) {
+        object::section_iterator ClassRefSection = getSectionIterator(SEC_CLASSREFS);
+        StringRef Contents;
+        ClassRefSection->getContents(Contents);
+        ArrayRef<uint8_t> D((uint8_t*) Contents.data(), ClassRefSection->getSize());
+        Value = *((uint64_t*) D.slice(Address - ClassRefSection->getAddress()).data());
+        return true;
+    }
+    return false;
+}
+
+bool ObjectiveCBinary::getData(const uint64_t Address, StringRef &Content) {
+    if (isMethname(Address)) {
+        object::SectionRef Section(MethnameDataRef, MachO);
+        StringRef Contents;
+        Section.getContents(Contents);
+        ArrayRef<uint8_t> D((uint8_t*) Contents.data(), Section.getSize());
+        const char *Name = ((const char*) D.slice(Address - Section.getAddress()).data());
+        Content = StringRef(Name);
+        return true;
+    }
+    return false;
+}
+
+object::section_iterator ObjectiveCBinary::getSectionIterator(StringRef Name) {
+    for (object::section_iterator S_it = MachO->section_begin(); S_it != MachO->section_end(); ++S_it) {
+        StringRef SectionName;
+        if (S_it->getName(SectionName)) {
+            continue;
+        }
+        if (SectionName == Name) {
+            return S_it;
+        }
+    }
+    DEBUG(errs() << "Can't find section: " << Name << "\n");
+    return MachO->section_end();
+}
+
+std::string ObjectiveCBinary::getSectionName(uint64_t address) {
+    for (object::section_iterator S_it = MachO->section_begin(); S_it != MachO->section_end(); ++S_it) {
+        if (S_it->getAddress() <= address && address < (S_it->getAddress() + S_it->getSize()))
+        {
+            StringRef name;
+            S_it->getName(name);
+            return name.str();
+        }
+    }
+    return "";
+}
+
+MachO::segment_command_64 ObjectiveCBinary::getSegment(uint64_t SegmentNo) {
+    uint64_t Idx = 0;
+    for(object::MachOObjectFile::load_command_iterator L_it = MachO->begin_load_commands();
+        L_it != MachO->end_load_commands(); ++L_it) {
+        if (L_it->C.cmd == MachO::LC_SEGMENT_64) {
+            if (Idx == SegmentNo) {
+                return MachO->getSegment64LoadCommand(*L_it);
+            } else {
+                Idx++;
+            }
+        }
+    }
+    llvm_unreachable("Cant find segment");
+};
+
+void ObjectiveCBinary::addClass(StringRef ClassName, uint64_t Address) {
+    if (ClassName.startswith_lower(OBJC_CLASS_ID) || ClassName.startswith_lower(OBJC_METACLASS_ID)) {
+        size_t len = ClassName.startswith_lower(OBJC_CLASS_ID) ? strlen(OBJC_CLASS_ID) : strlen(OBJC_METACLASS_ID);
+        if (Classes[ClassName.substr(len)] == nullptr)
+            Classes[ClassName.substr(len)] = BaseClassPtr_t(new ObjectiveC::DummyClass(ClassName.substr(len)));
+        if (Metaclasses[ClassName.substr(len)] == nullptr)
+            Metaclasses[ClassName.substr(len)] = BaseClassPtr_t(new ObjectiveC::DummyClass(ClassName.substr(len)));
+    } else if (ClassName.startswith("_"))
+        //TODO: remove this when symbols are handled with a leading '_'
+        ClassName = ClassName.substr(1);
+    BindInfo[Address] = ClassName;
+}
+
+StringRef ObjectiveCBinary::getString(uint64_t Address) {
+    StringRef Contents;
+
+    object::section_iterator MethnameSection = getSectionIterator(SEC_METHNAME);
+    object::section_iterator ClassnameSection = getSectionIterator(SEC_CLASSNAME);
+    object::section_iterator DataSection = getSectionIterator(SEC_OBJC_DATA);
+    object::section_iterator SelRefSection = getSectionIterator(SEC_SELREFS);
+    object::section_iterator IVARSection = getSectionIterator(SEC_IVAR);
+    object::section_iterator SuperrefSection = getSectionIterator(SEC_SUPERREF);
+    object::section_iterator CFStringSection = getSectionIterator(SEC_CFSTRING);
+    object::section_iterator CStringSection = getSectionIterator(SEC_CSTRING);
+    object::section_iterator MethTypeSection = getSectionIterator(SEC_METHTYPE);
+
+    if (isAddressInSection(Address, CFStringSection)) {
+        StringRef Contents;
+        CFStringSection->getContents(Contents);
+        ArrayRef<uint8_t> Data((uint8_t*)Contents.data(), Contents.size());
+        uint64_t stringAddress = *(uint64_t*)Data.slice(Address + 16 - CFStringSection->getAddress()).data();
+        StringRef s = getString(stringAddress);
+        return s;
+    } else if (BindInfo[Address].size()) {
+        return BindInfo[Address].startswith_lower(OBJC_CLASS_ID) ? BindInfo[Address].substr(strlen(OBJC_CLASS_ID)) : BindInfo[Address];
+    } else if (isAddressInSection(Address, MethnameSection) &&
+            !MethnameSection->getContents(Contents)) {
+        return (Contents.data() + (Address - MethnameSection->getAddress()));
+    }  else  if (isAddressInSection(Address, ClassnameSection) &&
+               !ClassnameSection->getContents(Contents)) {
+        return (Contents.data() + (Address - ClassnameSection->getAddress()));
+    } else if (isAddressInSection(Address, DataSection)) {
+        return ClassNames[Address];
+    } else if (isAddressInSection(Address, SelRefSection)) {
+        StringRef Contents;
+        SelRefSection->getContents(Contents);
+        ArrayRef<uint8_t> Data((uint8_t*)Contents.data(), Contents.size());
+        return getString(*(uint64_t*)Data.slice(Address - SelRefSection->getAddress()).data());
+    } else if (isAddressInSection(Address, IVARSection)) {
+        std::map<uint64_t, ObjectiveC::IVAR>::iterator it = IVARs.find(Address);
+        assert(it != IVARs.end());
+        return it->second.getID();
+    } else if (isAddressInSection(Address, getSectionIterator(SEC_TEXT))) {
+        std::string FName = getFunctionName(Address);
+        if (FName.size())
+            return FName;
+        else {
+            //TODO: warn here?
+        }
+    } else if (isAddressInSection(Address, getSectionIterator(SEC_SUPERREF))) {
+        StringRef Contents;
+        SuperrefSection->getContents(Contents);
+        ArrayRef<uint8_t> Data((uint8_t*)Contents.data(), Contents.size());
+        uint64_t ClassAddress = *(uint64_t*)Data.slice(Address - SuperrefSection->getAddress()).data();
+        if (!ClassAddress) {
+            llvm_unreachable("Class Address is missing");
+        }
+        StringRef className = getString(ClassAddress);
+        if (className.startswith("_OBJC_METACLASS_$_"))
+            className = className.substr(strlen("_OBJC_METACLASS_$_"));
+
+        if (className == "NSObject")
+            return className;
+
+        ClassMap_t::iterator class_it = Classes.find(className);
+        if (class_it == Classes.end()) {
+            llvm_unreachable("class not found");
+        }
+        if (class_it->second->getAddress() != ClassAddress) {
+            class_it = Metaclasses.find(className);
+        }
+        assert(class_it->second->getAddress() == ClassAddress || class_it->second->getAddress() == 0);
+        return class_it->second->getSuperclass();
+    } else if (isAddressInSection(Address, CStringSection)) {
+        StringRef Contents;
+        CStringSection->getContents(Contents);
+        ArrayRef<uint8_t> Data((uint8_t*)Contents.data(), Contents.size());
+        const char *string = (const char*)Data.slice(Address - CStringSection->getAddress()).data();
+        return StringRef(string);
+    } else if (isAddressInSection(Address, MethTypeSection)) {
+        StringRef Contents;
+        MethTypeSection->getContents(Contents);
+        ArrayRef<uint8_t> Data((uint8_t*)Contents.data(), Contents.size());
+        const char *string = (const char*)Data.slice(Address - MethTypeSection->getAddress()).data();
+        return StringRef(string);
+    }
+    return "";
+}
+
+bool ObjectiveCBinary::getClass(const uint64_t Address, StringRef &Classname) {
+    Classname = ClassRefs[Address];
+    return Classname.size() > 0;
+}
+
+bool ObjectiveCBinary::getSelector(const uint64_t Address, StringRef &Selectorname) {
+    if (isSelectorRef(Address)) {
+        Selectorname = getString(Address);
+        return true;
+    }
+    return false;
+}
+
+std::deque<std::string> ObjectiveCBinary::getMethodCandidates(StringRef Type, StringRef Selector, bool Meta) {
+    BaseClassPtr_t Base = Meta ? Metaclasses[Type] : Classes[Type];
+    if (!Base) {
+//        for (ClassMap_t::iterator C_it = (Meta ? Metaclasses.begin() : Classes.begin()); C_it != (Meta ? Metaclasses.end(): Classes.end()); ++C_it) {
+//            errs() << C_it->first << " " << (uint64_t)C_it->second.get() << "\n";
+//        }
+//        errs() << "NOT FOUND:\n";
+//        errs() << Type << " " << Selector << "\n";
+        std::stringstream ss;
+        ss << (Meta ? "+[" : "-[") << Type.str() + " " + Selector.str() + "]";
+        std::deque<std::string> M;
+        M.push_front(ss.str());
+        return M;
+    }
+    assert(Base);
+    if (Base->getSuperclass().size()) {
+//        ClassPtr_t Class = std::static_pointer_cast<ObjectiveC::Class>(Base);
+        std::deque<std::string> M = getMethodCandidates(Base->getSuperclass(), Selector, Meta);
+        std::stringstream ss;
+        ss << (Meta ? "+[" : "-[") << Base->getClassName().str() + " " + Selector.str() + "]";
+        M.push_front(ss.str());
+        return M;
+    } else {
+        std::stringstream ss;
+        ss << (Meta ? "+[" : "-[") << Base->getClassName().str() + " " + Selector.str() + "]";
+        std::deque<std::string> M;
+        M.push_front(ss.str());
+        return M;
+    }
+    llvm_unreachable("");
+}
+
+std::string ObjectiveCBinary::getFunctionName(uint64_t Address) {
+    return "fn_" + utohexstr(Address);
+}
+
+bool ObjectiveCBinary::isCFString(const uint64_t Address) {
+    if (isAddressInSection(Address, getSectionIterator(SEC_CFSTRING)))
+        return true;
+    return false;
+}
+
+bool ObjectiveCBinary::isCString(const uint64_t Address) {
+    if (isAddressInSection(Address, getSectionIterator(SEC_CSTRING)))
+        return true;
+    return false;
+}
+
+bool ObjectiveCBinary::isConstValue(const uint64_t Address) {
+    if (isClassRef(Address) || isSelectorRef(Address) || isAddressInSection(Address, getSectionIterator(SEC_GOT)))
+        return true;
+    return false;
+}
diff --git a/lib/Analysis/Andersen/ObjectiveCClassInfo.cpp b/lib/Analysis/Andersen/ObjectiveCClassInfo.cpp
new file mode 100644
index 0000000..17a41c1
--- /dev/null
+++ b/lib/Analysis/Andersen/ObjectiveCClassInfo.cpp
@@ -0,0 +1,157 @@
+#include <llvm/Support/ErrorHandling.h>
+#include "llvm/Support/raw_ostream.h"
+#include <sstream>
+#include "llvm/Analysis/Andersen/ObjectiveCClassInfo.h"
+
+using namespace llvm;
+using namespace llvm::ObjectiveC;
+
+void Class::addMethod(Method M) {
+    assert(!M.Parent);
+    M.Parent = this;
+    Methods.push_back(M);
+}
+
+bool Class::getMethod(StringRef Methodname, Method &M) {
+    for (MethodList_t::iterator M_it = Methods.begin(); M_it != Methods.end(); ++M_it) {
+        if (M_it->Methodname == Methodname) {
+            M = *M_it;
+            return true;
+        }
+    }
+    return false;
+}
+
+void Class::addIVAR(IVAR ivar) {
+    assert(ivar.ParentClass.size() == 0);
+    IVARs.push_back(ivar);
+    ivar.ParentClass = Classname;
+}
+
+bool Class::getIVAR(StringRef IVARName, IVAR &ivar) {
+    for (IVARList_t::iterator it = IVARs.begin(); it != IVARs.end(); ++it) {
+        if (it->IVARName == IVARName) {
+            ivar = *it;
+            return true;
+        }
+    }
+    return false;
+}
+
+bool Class::getIVAR(uint64_t IVAROffset, IVAR &ivar) {
+    for (IVARList_t::iterator it = IVARs.begin(); it != IVARs.end(); ++it) {
+        if (it->OffsetPtr == IVAROffset) {
+            ivar = *it;
+            return true;
+        }
+    }
+    return false;
+}
+
+
+//Method
+
+void Method::parseType() {
+    if (!type.size())
+        return;
+
+    const char *type_it = type.data();
+    bool isReturnType = true;
+
+    unsigned currentGPR = 5;
+    unsigned currentFPR = -1U;
+
+    while (*type_it) {
+        switch (*type_it) {
+            default:
+                llvm_unreachable("");
+            case 'r':
+            case 'n':
+            case 'N':
+            case 'o':
+            case 'O':
+            case 'V': {
+                ++type_it;
+                break;
+            }
+            case 'v': {
+                
+                ++type_it;
+                break;
+            }
+            case 'i':
+            case 's':
+            case 'l':
+            case 'I':
+            case 'S':
+            case 'L':
+            case 'C':
+            case 'c':
+            case 'B':
+            case '*':
+            case ':':
+            case '#':
+            {
+                ++currentGPR;
+                ++type_it;
+                break;
+            }
+            case 'q':
+            case 'Q':
+            {
+                return;
+                ++type_it;
+                break;
+            }
+            case 'f': {
+                
+                ++type_it;
+                break;
+            }
+            case 'd': {
+                
+                ++type_it;
+                break;
+            }
+            case '@': {
+                unsigned reg = currentGPR++;
+                if (*(type_it + 1) == '\"') {
+                    type_it += 2;
+                    const char *end_it = strchr(type_it, '\"');
+                    unsigned length = end_it - type_it;
+                    std::string paramType(type_it);
+                    paramType = paramType.substr(0, length);
+                    type_it = end_it;
+                    regTypes.push_back(RegType_t(reg, paramType));
+                } else {
+
+                }
+                ++type_it;
+                break;
+            }
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+            case '8':
+            case '9':
+            {
+                ++type_it;
+                break;
+            }
+            case '[':
+            case '{':
+            case '(':
+            case 'b':
+            case '?':
+            case '^':
+            {
+                return;
+            }
+        }
+    }
+}
diff --git a/lib/Analysis/Andersen/SimpleCallGraph.cpp b/lib/Analysis/Andersen/SimpleCallGraph.cpp
new file mode 100644
index 0000000..aec5dbe
--- /dev/null
+++ b/lib/Analysis/Andersen/SimpleCallGraph.cpp
@@ -0,0 +1,167 @@
+#include <llvm/IR/Instruction.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/Module.h>
+#include <llvm/Support/raw_ostream.h>
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/IRBuilder.h>
+#include "llvm/Analysis/Andersen/SimpleCallGraph.h"
+#include "llvm/Support/Debug.h"
+
+using namespace llvm;
+using namespace std;
+
+#define DEBUG_TYPE "simple-callgraph"
+
+void SimpleCallGraph::addCallEdge(const Instruction *CallInst, std::string Target) {
+    std::unique_lock<std::mutex> lock(graphLock);
+    shared_ptr<FunctionSet_t> CalledFunctions = CallGraph[CallInst];
+    if (!CalledFunctions) {
+        CalledFunctions = shared_ptr<FunctionSet_t>(new FunctionSet_t());
+        CallGraph[CallInst] = CalledFunctions;
+    }
+
+    shared_ptr<InstructionSet_t> Callers = ReverseCallGraph[Target];
+    if (!Callers) {
+        Callers = shared_ptr<InstructionSet_t>(new InstructionSet_t());
+        ReverseCallGraph[Target] = Callers;
+    }
+
+    CalledFunctions->insert(Target);
+    Callers->insert(CallInst);
+}
+
+bool SimpleCallGraph::containtsEdge(const Instruction *Inst, std::string F) {
+    std::unique_lock<std::mutex> lock(graphLock);
+    FunctionSet_t &Called = getCalled(Inst);
+    return Called.find(F) != Called.end();
+}
+
+SimpleCallGraph::InstructionSet_t &SimpleCallGraph::getCallers(std::string F) {
+    shared_ptr<InstructionSet_t> Callers = ReverseCallGraph[F];
+    if (!Callers) {
+        Callers = shared_ptr<InstructionSet_t>(new InstructionSet_t());
+        ReverseCallGraph[F] = Callers;
+    }
+    return *Callers;
+}
+
+SimpleCallGraph::FunctionSet_t &SimpleCallGraph::getCalled(const Instruction *Inst) {
+    shared_ptr<FunctionSet_t> CalledFunctions = CallGraph[Inst];
+    if (!CalledFunctions) {
+        CalledFunctions = shared_ptr<FunctionSet_t>(new FunctionSet_t());
+        CallGraph[Inst] = CalledFunctions;
+    }
+    return *CalledFunctions;
+}
+
+void SimpleCallGraph::finalize() {
+    FunctionSet_t External;
+
+    for (Module::iterator F_it = M.begin(); F_it != M.end(); ++F_it) {
+        if (F_it->isDeclaration() || F_it->isIntrinsic())
+            continue;
+
+        if (getCallers(F_it->getName()).size() == 0) {
+            External.insert(F_it->getName());
+        }
+    }
+
+//    FIXME: necessary???
+    return;
+    assert(!M.getFunction("_EXTERNAL_"));
+
+    IRBuilder<> *Builder = new IRBuilder<>(getGlobalContext());
+
+    Function *ExternalFunc = dyn_cast<Function>(M.getOrInsertFunction("_EXTERNAL_", AttributeSet(), Type::getVoidTy(getGlobalContext()), nullptr));
+    assert(ExternalFunc);
+    BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "entry", ExternalFunc);
+    Builder->SetInsertPoint(BB);
+    Instruction *First = Builder->CreateCall(ExternalFunc, ArrayRef<Value*>());
+    Instruction *Second = Builder->CreateCall(ExternalFunc, ArrayRef<Value*>());
+    Builder->CreateRetVoid();
+    delete(Builder);
+
+
+    for (FunctionSet_t::iterator F_it = External.begin(); F_it != External.end(); ++F_it) {
+//        getCalled(First).insert(*F_it);
+//        getCallers(*F_it).insert(Second);
+        if (*F_it == "_EXTERNAL_")
+            continue;
+        addCallEdge(First, *F_it);
+//        addCallEdge(Second, *F_it);
+    }
+}
+
+void SimpleCallGraph::print(raw_ostream &ostream) {
+    std::set<std::string> Edges;
+
+    ostream << "strict digraph g {\n";
+    ostream << "overlap=false;\n";
+    for (CallGraph_t::iterator C_it = CallGraph.begin(); C_it != CallGraph.end(); ++C_it) {
+//        if (!(C_it->first->getParent()->getParent()->getName().startswith("-") || C_it->first->getParent()->getParent()->getName().startswith("+")))
+//            continue;
+        for (FunctionSet_t::iterator F_it = C_it->second->begin(); F_it != C_it->second->end(); ++F_it) {
+//            if (!((*F_it)[0] == '+' || (*F_it)[0] == '-'))
+//                continue;
+            if ((*F_it).find("objc") == 0) {
+                continue;
+            }
+//            ostream << "\"" << C_it->first->getParent()->getParent()->getName() << "\" -> \"" << *F_it << "\";\n";
+
+            Edges.insert("\"" + C_it->first->getParent()->getParent()->getName().str() + "\" -> \"" + *F_it + "\";\n");
+        }
+    }
+
+    for (std::set<std::string>::iterator E_it = Edges.begin(); E_it != Edges.end(); ++E_it) {
+        ostream << *E_it;
+    }
+
+    ostream << "}\n";
+
+    ostream.flush();
+}
+
+SimpleCallGraph::FunctionSet_t SimpleCallGraph::getCalled(const std::string &fun) {
+    FunctionSet_t called;
+    for (auto &call_it : CallGraph) {
+        if (call_it.first->getParent()->getParent()->getName() == fun) {
+            called.insert(call_it.second->begin(), call_it.second->end());
+        }
+    }
+    return called;
+}
+
+bool SimpleCallGraph::hasPath(std::string &from, std::string &to) {
+    std::unique_lock<std::mutex> lock(pathCacheLock);
+    if (pathCache.find(FromTo_t(from, to)) != pathCache.end()) {
+        return pathCache[FromTo_t(from, to)];
+    }
+    lock.unlock();
+    FunctionSet_t worklist(getCalled(from));
+    FunctionSet_t visited;
+    while (worklist.size()) {
+        FunctionSet_t tmp;
+        for (auto &w : worklist) {
+            if (visited.find(w) != visited.end())
+                continue;
+            visited.insert(w);
+            if (w == to) {
+                lock.lock();
+                pathCache[FromTo_t(from, to)] = true;
+                return true;
+            }
+            lock.lock();
+            pathCache[FromTo_t(from, w)] = true;
+            lock.unlock();
+            FunctionSet_t called = getCalled(w);
+            tmp.insert(called.begin(), called.end());
+        }
+
+        std::swap(tmp, worklist);
+    }
+    lock.lock();
+    DEBUG(errs() << "No path from " << from << "to " << to << "\n");
+    pathCache[FromTo_t(from, to)] = false;
+    return false;
+}
diff --git a/lib/Analysis/Andersen/StackAccessPass.cpp b/lib/Analysis/Andersen/StackAccessPass.cpp
new file mode 100644
index 0000000..3cb678d
--- /dev/null
+++ b/lib/Analysis/Andersen/StackAccessPass.cpp
@@ -0,0 +1,394 @@
+#include <llvm/IR/InstIterator.h>
+#include "llvm/Analysis/Andersen/StackAccessPass.h"
+
+#include "llvm/IR/Function.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Constants.h"
+#include <vector>
+#include <deque>
+#include <llvm/IR/CFG.h>
+#include <llvm/Support/raw_ostream.h>
+#include <llvm/Analysis/LoopInfo.h>
+#include <llvm/IR/PatternMatch.h>
+#include "llvm/IR/Module.h"
+#include <llvm/ProfileData/InstrProfReader.h>
+#include <llvm/IR/Dominators.h>
+#include "llvm/Support/Debug.h"
+
+using namespace llvm;
+
+#define DEBUG_TYPE "stack_access"
+
+char StackAccessPass::ID = 0;
+static RegisterPass<StackAccessPass> X("stack-access", "Scans for Stack variables",
+                                       true /* Only looks at CFG */,
+                                       true /* Analysis Pass */);
+
+void StackAccessPass::getAnalysisUsage(AnalysisUsage &AU) const {
+    AU.setPreservesAll();
+}
+
+bool StackAccessPass::runOnModule(Module &M) {
+    for (Module::iterator F = M.begin(), E = M.end(); F != E; ++F) {
+        F->hasName();
+    }
+    for (auto &F : M.functions()) {
+        if (F.isDeclaration() || F.isIntrinsic())
+            continue;
+        if (Offsets.find(&F) != Offsets.end() && ValuesForOffset.find(&F) != ValuesForOffset.end()) {
+            return true;
+        }
+        CurrentFunction = &F;
+
+        Offsets[&F] = std::shared_ptr<OffsetMap_t>(new OffsetMap_t());
+        OffsetMap_t &OffsetMap = *Offsets[&F];
+        ValuesForOffset[&F] = std::shared_ptr<OffsetValueListMap_t>(new OffsetValueListMap_t());
+        OffsetValueListMap_t &OffsetValueListMap = *ValuesForOffset[&F];
+
+        std::set<uint64_t> SPIdx;
+        SPIdx.insert(3);
+        SPIdx.insert(0);
+
+        runOnFunction(F, OffsetMap, OffsetValueListMap, SPIdx);
+    }
+
+    return true;
+}
+
+void StackAccessPass::runOnFunction(Function &F, OffsetMap_t &OffsetMap, OffsetValueListMap_t &OffsetValueListMap, std::set<uint64_t> SPIdx) {
+    DEBUG(errs() << "FUNCTION: " << F.getName() << "\n";);
+
+    std::deque<const Instruction*> IntToPtrInstructions;
+
+    for (inst_iterator I_it = inst_begin(F); I_it != inst_end(F); ++I_it) {
+        if (I_it->getOpcode() == Instruction::IntToPtr) {
+            IntToPtrInstructions.push_back(dyn_cast<const Instruction>(&*I_it->getOperand(0)));
+        } else if (I_it->getOpcode() == Instruction::Store &&
+                   PatternMatch::match((Value*)I_it->getOperand(0), PatternMatch::m_BinOp(PatternMatch::m_Value(), PatternMatch::m_ConstantInt()))) {
+            //If something gets passed as stack stored parameter there will be no 'inttoptr' instruction
+            IntToPtrInstructions.push_back(dyn_cast<const Instruction>(&*I_it->getOperand(0)));
+        }
+    }
+
+    DEBUG(errs() << "#IntToPtrInstructions: " << IntToPtrInstructions.size() << "\n");
+
+
+    std::set<const Instruction*> handled;
+
+    while (IntToPtrInstructions.size()) {
+        const Instruction *I = IntToPtrInstructions.front();
+        IntToPtrInstructions.pop_front();
+
+        if (handled.find(I) != handled.end())
+            continue;
+        handled.insert(I);
+
+        std::set<int64_t> Results = backtrackInstruction(I, IntToPtrInstructions, SPIdx);
+        if (!Results.size())
+            continue;
+        DEBUG(I->dump());
+
+        OffsetMap[I] = std::shared_ptr<Int64List_t>(new Int64List_t());
+        Int64List_t &O = *OffsetMap[I];
+
+
+        for (std::set<int64_t>::iterator it = Results.begin(); it != Results.end(); ++it) {
+            if (OffsetValueListMap.find(*it) == OffsetValueListMap.end())
+                OffsetValueListMap[*it] = std::shared_ptr<ValueList_t>(new ValueList_t());
+            OffsetValueListMap[*it]->insert(I);
+            O.insert(*it);
+            DEBUG(errs() << *it << "\t");
+        }
+        DEBUG(errs() << "\n");
+    }
+
+    DEBUG(
+            errs() << "Values for Offsets:\n";
+            for (OffsetValueListMap_t::iterator OV_it = OffsetValueListMap.begin(); OV_it != OffsetValueListMap.end(); ++OV_it) {
+                errs() << OV_it->first << "\n";
+                for (ValueList_t::iterator V_it = OV_it->second->begin(); V_it != OV_it->second->end(); ++V_it) {
+                    (*V_it)->dump();
+                }
+                errs() << "\n";
+            }
+    );
+}
+
+bool StackAccessPass::isStackPointer(Value *Ptr, std::set<uint64_t> SPIdx) {
+    assert(SPIdx.size());
+    if (Instruction *I = dyn_cast<Instruction>(Ptr)) {
+        if (I->getOpcode() == Instruction::GetElementPtr) {
+            if (ConstantInt *Idx = dyn_cast<ConstantInt>(I->getOperand(2))) {
+                if (SPIdx.find(Idx->getZExtValue()) != SPIdx.end()) {
+                    return true;
+                }
+            }
+        }
+    }
+    return false;
+}
+
+const Instruction *StackAccessPass::getStackPointer(const Function *F) {
+    for (BasicBlock::InstListType::const_iterator I_it = F->getEntryBlock().getInstList().begin();
+         I_it != F->getEntryBlock().getInstList().end();
+         ++I_it) {
+        if (I_it->getOpcode() == Instruction::GetElementPtr) {
+            if (ConstantInt *IdxValue = dyn_cast<ConstantInt>(I_it->getOperand(2))) {
+                if (IdxValue->getZExtValue() == 3) {
+                    return &*I_it;
+                }
+            }
+        }
+    }
+    return nullptr;
+}
+
+int64_t StackAccessPass::getStackPointerValue(const Instruction *Inst, bool findStackPointer) {
+
+    std::function<const Instruction* (const Instruction*, const Value*, bool)> getStore = [&](const Instruction *Inst, const Value *Ptr, bool searchPred){
+        const Instruction *Store = nullptr;
+        for (const Instruction *I = Inst; ; I = I->getPrevNode()) {
+            if (I->getOpcode() == Instruction::Store && I->getOperand(1) == Ptr) {
+                Store = &*I;
+                break;
+            }
+            if (I == &I->getParent()->front())
+                break;
+        }
+        if (!Store && searchPred) {
+            size_t num = 0;
+            const BasicBlock *pred = nullptr;
+            for (const_pred_iterator p_it = pred_begin(Inst->getParent()); p_it != pred_end(Inst->getParent()); ++p_it) {
+                pred = *p_it;
+                ++num;
+            }
+            if (num == 1) {
+                Store = getStore(pred->getTerminator(), Ptr, searchPred);
+            } else {
+                errs() << Inst->getParent()->getName() << "\n";
+                assert(false && "Multiple predecessors...");
+            }
+        }
+        return Store;
+    };
+
+    const Value *StackPtr = getStackPointer(Inst->getParent()->getParent());
+    if (!StackPtr)
+        return 0;
+    const Instruction *Store = getStore(Inst, StackPtr, true);
+
+    std::deque<std::pair<const Instruction *, int64_t>> Worklist;
+    if (findStackPointer)
+        Worklist.push_back(std::pair<const Instruction *, int64_t>(dyn_cast<Instruction>(Store->getOperand(0)), 0));
+    else
+        Worklist.push_back(std::pair<const Instruction *, int64_t>(Inst, 0));
+
+    std::set<int64_t> Results;
+
+    std::map<const Instruction*, int64_t> Visited;
+
+    std::set<uint64_t> SPIdx;
+    SPIdx.insert(3);
+    SPIdx.insert(0);
+
+    while (Worklist.size()) {
+        std::pair<const Instruction *, int64_t> P = Worklist.front();
+        Worklist.pop_front();
+
+        const Instruction *CurrentInst = P.first;
+        int64_t CurrentSize = P.second;
+
+        bool Run = true;
+        while (Run) {
+            if (!CurrentInst) {
+                llvm_unreachable("Should not happen...");
+            }
+
+            if (Visited.find(CurrentInst) != Visited.end()) {
+                break;
+            }
+            Visited[CurrentInst] = CurrentSize;
+            switch (CurrentInst->getOpcode()) {
+                default:
+                    CurrentInst->dump();
+                    llvm_unreachable("Not handled");
+                case Instruction::Load: {
+                    if (!isStackPointer(CurrentInst->getOperand(0), SPIdx)) {
+                        Run = false;
+                        break;
+                    }
+                    assert(isStackPointer(CurrentInst->getOperand(0), SPIdx));
+                    Store = getStore(CurrentInst, CurrentInst->getOperand(0), false);
+                    if (!Store) {
+                        Run = false;
+                        Results.insert(-CurrentSize);
+                    } else {
+                        CurrentInst = dyn_cast<Instruction>(Store->getOperand(0));
+                    }
+                    break;
+                }
+                case Instruction::Add: {
+                    Value *V = nullptr;
+                    uint64_t Const = 0;
+                    if (PatternMatch::match(CurrentInst, PatternMatch::m_Add(PatternMatch::m_Value(V), PatternMatch::m_ConstantInt(Const)))) {
+                        CurrentInst = dyn_cast<Instruction>(V);
+                        CurrentSize += (int64_t)Const;
+                    } else {
+                        Run = false;
+                        break;
+                        CurrentInst->dump();
+                        llvm_unreachable("Add with non-constant int");
+                    }
+                    break;
+                }
+                case Instruction::Sub: {
+                    Value *V = nullptr;
+                    uint64_t Const = 0;
+                    if (PatternMatch::match(CurrentInst, PatternMatch::m_Sub(PatternMatch::m_Value(V), PatternMatch::m_ConstantInt(Const)))) {
+                        CurrentInst = dyn_cast<Instruction>(V);
+                        CurrentSize -= (int64_t)Const;
+                    } else {
+                        Run = false;
+                        break;
+                        CurrentInst->dump();
+                        llvm_unreachable("Sub with non-constant int");
+                    }
+                    break;
+                }
+                case Instruction::PHI: {
+                    for (unsigned i = 1; i < CurrentInst->getNumOperands(); ++i) {
+                        Worklist.push_back(std::pair<Instruction*, int64_t>(dyn_cast<Instruction>(CurrentInst->getOperand(i)), CurrentSize));
+                    }
+                    CurrentInst = dyn_cast<Instruction>(CurrentInst->getOperand(0));
+                }
+            }
+        }
+    }
+    if (Results.size() != 1) {
+        errs() << Inst->getParent()->getParent()->getName() << "\n";
+        for (std::set<int64_t>::iterator i = Results.begin(); i != Results.end(); ++i) {
+            errs() << *i << "\n";
+        }
+        if (Results.size() == 0) {
+            errs() << "(Probably execption handling...)\n";
+            return -1U;
+        }
+        assert(false);
+    }
+    return *Results.begin();
+}
+
+std::set<int64_t> StackAccessPass::backtrackInstruction(const Instruction *Inst, std::deque<const Instruction*> &InstList, const std::set<uint64_t> SPIdx) {
+    std::function<const Instruction* (const Instruction*, const Value*)> getStore = [](const Instruction *Inst, const Value *Ptr){
+        const Instruction *Store = nullptr;
+        for (const Instruction *I = Inst; ; I = I->getPrevNode()) {
+            if (I->getOpcode() == Instruction::Store && I->getOperand(1) == Ptr) {
+                Store = &*I;
+                break;
+            }
+            if (I == &I->getParent()->front())
+                break;
+        }
+        return Store;
+    };
+
+    std::set<int64_t> Results;
+
+    std::deque<std::pair<const Instruction *, int64_t>> Worklist;
+    Worklist.push_back(std::pair<const Instruction *, int64_t>(Inst, 0));
+
+    std::map<const Instruction*, int64_t> Visited;
+
+    while (Worklist.size()) {
+        std::pair<const Instruction *, int64_t> P = Worklist.front();
+        Worklist.pop_front();
+
+        const Instruction *CurrentInst = P.first;
+        int64_t CurrentSize = P.second;
+
+        bool Run = true;
+        while (Run) {
+            if (!CurrentInst) {
+                break;
+            }
+
+            if (Visited.find(CurrentInst) != Visited.end()) {
+                break;
+            }
+            Visited[CurrentInst] = CurrentSize;
+
+            if (PatternMatch::match(CurrentInst, PatternMatch::m_BinOp(PatternMatch::m_Constant(), PatternMatch::m_Constant()))) {
+                Run = false;
+                continue;
+            }
+            switch (CurrentInst->getOpcode()) {
+                default:
+                    Run = false;
+                    break;
+                case Instruction::Load: {
+                    if (!isStackPointer(CurrentInst->getOperand(0), SPIdx)) {
+                        Run = false;
+                        break;
+                    }
+                    assert(isStackPointer(CurrentInst->getOperand(0), SPIdx));
+                    const Instruction *Store = getStore(CurrentInst, CurrentInst->getOperand(0));
+                    if (!Store) {
+                        Run = false;
+                        Results.insert(CurrentSize);
+                    } else {
+                        CurrentInst = dyn_cast<Instruction>(Store->getOperand(0));
+                    }
+                    break;
+                }
+                case Instruction::Add: {
+                    Value *V = nullptr;
+                    uint64_t Const = 0;
+                    if (PatternMatch::match(CurrentInst, PatternMatch::m_Add(PatternMatch::m_Value(V), PatternMatch::m_ConstantInt(Const)))) {
+                        CurrentInst = dyn_cast<Instruction>(V);
+                        CurrentSize += (int64_t)Const;
+                    } else if (PatternMatch::match(CurrentInst, PatternMatch::m_Add(PatternMatch::m_BinOp(), PatternMatch::m_Value()))) {
+                        InstList.push_back(dyn_cast<Instruction>(CurrentInst->getOperand(0)));
+                        Run = false;
+                        break;
+                    }
+                    break;
+                }
+                case Instruction::Sub: {
+                    Value *V = nullptr;
+                    uint64_t Const = 0;
+                    if (PatternMatch::match(CurrentInst, PatternMatch::m_Sub(PatternMatch::m_Value(V), PatternMatch::m_ConstantInt(Const)))) {
+                        CurrentInst = dyn_cast<Instruction>(V);
+                        CurrentSize -= (int64_t)Const;
+                    } else if (PatternMatch::match(CurrentInst, PatternMatch::m_Sub(PatternMatch::m_BinOp(), PatternMatch::m_Value()))) {
+                        InstList.push_back(dyn_cast<Instruction>(CurrentInst->getOperand(0)));
+                        Run = false;
+                        break;
+                    }
+                    break;
+                }
+                case Instruction::PHI: {
+                    for (unsigned i = 1; i < CurrentInst->getNumOperands(); ++i) {
+                        //Skip Constants
+                        if (Instruction *I = dyn_cast<Instruction>(CurrentInst->getOperand(i))) {
+                            Worklist.push_back(std::pair<Instruction*, int64_t>(I, CurrentSize));
+                        }
+                    }
+                    if (Instruction *I = dyn_cast<Instruction>(CurrentInst->getOperand(0))) {
+                        CurrentInst = I;
+                    } else {
+                        Run = false;
+                    }
+                    break;
+                }
+                case Instruction::IntToPtr: {
+                    CurrentInst = dyn_cast<Instruction>(CurrentInst->getOperand(0));
+                    break;
+                }
+            }
+        }
+    }
+
+
+    return Results;
+}
diff --git a/lib/Analysis/CMakeLists.txt b/lib/Analysis/CMakeLists.txt
index cb5cd07..b55104f 100644
--- a/lib/Analysis/CMakeLists.txt
+++ b/lib/Analysis/CMakeLists.txt
@@ -70,8 +70,26 @@ add_llvm_library(LLVMAnalysis
   ValueTracking.cpp
   VectorUtils.cpp
 
+  Andersen/Andersen.cpp
+  Andersen/AndersenAA.cpp
+  Andersen/ConstraintCollect.cpp
+  Andersen/ConstraintOptimize.cpp
+  Andersen/ConstraintSolving.cpp
+  Andersen/ExternalLibrary.cpp
+  Andersen/NodeFactory.cpp
+  Andersen/StackAccessPass.cpp
+  Andersen/DetectParametersPass.cpp
+  Andersen/ObjectiveCBinary.cpp
+  Andersen/ObjectiveCClassInfo.cpp
+  Andersen/ObjCCallHandler.cpp
+  Andersen/CallHandler/ObjCRuntimeCallHandler.cpp
+  Andersen/NonVolatileRegistersPass.cpp
+  Andersen/SimpleCallGraph.cpp
+
   ADDITIONAL_HEADER_DIRS
   ${LLVM_MAIN_INCLUDE_DIR}/llvm/Analysis
   )
 
-add_dependencies(LLVMAnalysis intrinsics_gen)
+add_subdirectory(Andersen)
+
+add_dependencies(LLVMAnalysis intrinsics_gen Object)
diff --git a/lib/Analysis/LLVMBuild.txt b/lib/Analysis/LLVMBuild.txt
index bddf1a3..9aba4dc 100644
--- a/lib/Analysis/LLVMBuild.txt
+++ b/lib/Analysis/LLVMBuild.txt
@@ -15,8 +15,12 @@
 ;
 ;===------------------------------------------------------------------------===;
 
+[common]
+subdirectories =
+ Andersen
+
 [component_0]
 type = Library
 name = Analysis
 parent = Libraries
-required_libraries = Core Support
+required_libraries = Core Support Object
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index d00c10f..e081df5 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -20,3 +20,4 @@ add_subdirectory(ProfileData)
 add_subdirectory(Fuzzer)
 add_subdirectory(Passes)
 add_subdirectory(LibDriver)
+add_subdirectory(LLVMSlicer)
diff --git a/lib/LLVMBuild.txt b/lib/LLVMBuild.txt
index 2edb66a..9f9092b 100644
--- a/lib/LLVMBuild.txt
+++ b/lib/LLVMBuild.txt
@@ -38,6 +38,7 @@ subdirectories =
  TableGen
  Target
  Transforms
+ LLVMSlicer
 
 [component_0]
 type = Group
diff --git a/lib/LLVMSlicer/Backtrack/Backtrack.cpp b/lib/LLVMSlicer/Backtrack/Backtrack.cpp
new file mode 100644
index 0000000..105d439
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/Backtrack.cpp
@@ -0,0 +1,266 @@
+#include "../Slicing/FunctionStaticSlicer.h"
+
+using namespace llvm;
+using namespace slicing;
+
+bool InsInfo::backtrack(InsInfoProvider *provider, PathElementBase *pathElement, std::vector<Path*> &paths, std::mutex &pathLock, Rule &rule) {
+
+    typedef std::pair<InsInfo *, const Value *> Pred_t;
+    typedef std::set<Pred_t> PredSet_t;
+
+    PathElementBase *prevElement = pathElement->getPrev();
+    const Value *prevRelevantVariable = prevElement ? prevElement->getRelevantVariable() : NULL;
+
+    if (rule.shouldStop(pathElement)) {
+        return true;
+    }
+
+    if (rule.dismissPath(pathElement)) {
+        return false;
+    }
+
+
+    PredSet_t predecessors;
+
+
+    if (prevElement && Up.find(prevElement->getElement()) != Up.end()) {
+        const Value *prevLoc = ptr::getAndersen()->getNodeFactory().getLocation(pathElement->getRelevantVariable());
+        if (prevLoc) {
+            if (const Instruction *prevLocInst = dyn_cast<const Instruction>(prevLoc)) {
+                if (prevLocInst->getName().find("init") != StringRef::npos) {
+                    if (const Instruction *prevInst = dyn_cast<const Instruction>(prevElement->getElement())) {
+                        if (prevInst->getParent()->getParent()   == prevLocInst->getParent()->getParent()) {
+                            return false;
+                        }
+                    }
+                }
+            }
+        }
+        for (auto &p : SlicedPredecessors[pathElement->getRelevantVariable()]) {
+            predecessors.insert(Pred_t(provider->getInsInfo(p), pathElement->getRelevantVariable()));
+        }
+        if (predecessors.size() == 0) {
+            return false;
+        }
+    }
+
+    if (predecessors.size() == 0 && ins->getOpcode() == Instruction::Call && (!prevElement || Up.find(prevElement->getElement()) == Up.end())) {
+
+        const Module *M = ins->getParent()->getParent()->getParent();
+
+        SimpleCallGraph::FunctionSet_t &called = ptr::getSimpleCallGraph().getCalled(ins);
+        for (auto &functionName : called) {
+            if (functionName == "CCKeyDerivationPBKDF") {
+                assert(true);
+            }
+            if (functionName == "-[NSString dataUsingEncoding:]") {
+                assert(true);
+            }
+            if (functionName == "+[RNEncryptor encryptData:withSettings:password:error:]") {
+                assert(true);
+            }
+            if (functionName == "fn_10006EE1C") {
+                assert(true);
+            }
+
+            const Function *function = M->getFunction(functionName);
+            if (!function || function->isDeclaration() || function->isIntrinsic())
+                continue;
+            const Instruction *ret = nullptr;
+            for (auto &BB_it : function->getBasicBlockList()) {
+                if (BB_it.getTerminator() && BB_it.getTerminator()->getOpcode() == Instruction::Ret) {
+                    ret = BB_it.getTerminator();
+                }
+            }
+            assert(ret);
+
+            InsInfo *retInfo = provider->getInsInfo(ret);
+            if (!retInfo) {
+                errs() << "Function " << functionName << " not sliced. Can not continue path!\n";
+                continue;
+            }
+            for (ValSet::const_iterator rc_it = DEF_begin(); rc_it != DEF_end(); ++rc_it) {
+
+                for (ValSet::const_iterator ret_rc_it = retInfo->RC_begin();
+                     ret_rc_it != retInfo->RC_end(); ++ret_rc_it) {
+                    IncType_t RC_inc = retInfo->getRCInc(*ret_rc_it);
+                    if (!(RC_inc < INC_MAX))
+                        continue;
+                    if (pathElement->getRelevantVariable() != ret_rc_it->first)
+                        continue;
+                    if (ret_rc_it->first == rc_it->first) {
+                        if (retInfo->SlicedPredecessors.find(rc_it->first) != retInfo->SlicedPredecessors.end()) {
+                            std::pair<const Instruction *, const Value *> v(ret, prevRelevantVariable);
+                            predecessors.insert(Pred_t(retInfo, pathElement->getRelevantVariable()));
+                            pathElement->getParent()->addCall(dyn_cast<CallInst>(ins));
+//                                visited.insert(v);
+
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    //FIXME: always skip this when a return was found???
+    if (predecessors.size() == 0) {
+        for (auto &RC_it : SlicedPredecessors) {
+
+            if (hasTranslation(pathElement->getRelevantVariable())) {
+                if (translations[pathElement->getRelevantVariable()].find((Value*) RC_it.first) ==
+                    translations[pathElement->getRelevantVariable()].end()) {
+                    continue;
+                } else {
+
+                }
+            }
+            IncType_t RC_inc = getRCInc(Pointee(RC_it.first, -1));
+            if (!(RC_inc < INC_MAX))
+                continue;
+            if (ins->getOpcode() == Instruction::Ret) {
+                if (RC_it.first != pathElement->getRelevantVariable())
+                    continue;
+            }
+            for (auto &I_it : RC_it.second) {
+                if (I_it == ins) {
+                    continue;
+                }
+                if (hasTranslation(pathElement->getRelevantVariable()) &&
+                    translations[pathElement->getRelevantVariable()].find(I_it) != translations[pathElement->getRelevantVariable()].end()) {
+
+                } else {
+                    InsInfo *pred = provider->getInsInfo(I_it);
+                    std::pair<const Instruction*, const Value*> v(I_it, RC_it.first);
+                    predecessors.insert(Pred_t(pred, RC_it.first));
+//                            if (pred->Up.find(ins) != pred->Up.end()) {
+//                                predecessors.insert(Pred_t(pred, RC_it.first));
+//                            } else {
+//                                if (RC_it.first == pathElement->getRelevantVariable()) {
+//                                    predecessors.insert(Pred_t(pred, RC_it.first));
+//                                }
+//                            }
+                }
+            }
+        }
+    }
+
+    if (ins->getOpcode() == Instruction::Call && prevElement && Up.find(prevElement->getElement()) != Up.end() && predecessors.size() == 0) {
+        return false;
+    }
+
+    if (predecessors.size() == 0) {
+        for (ValSet::const_iterator RC_it = RC_begin(); RC_it != RC_end(); ++RC_it) {
+            //This should be a parameter
+            if (RC_it->first == ins) {
+                for (auto &pred_it : SlicedPredecessors) {
+                    const Instruction *I = dyn_cast<const Instruction>(pred_it.first);
+                    if (!I) {
+                        continue;
+                    }
+                    std::pair<const Instruction*, const Value*> v(I, I);
+
+                    predecessors.insert(Pred_t(provider->getInsInfo(I), I));
+                }
+            }
+        }
+    }
+
+    if (predecessors.size() == 0) {
+
+        if (hasTranslation(pathElement->getRelevantVariable())) {
+            for (auto &t : translations[pathElement->getRelevantVariable()]) {
+                t->dump();
+                ConstPathElement *e = new ConstPathElement(t, pathElement->getRelevantVariable());
+                if (pathElement->setNext(e)) {
+                    return true;
+                } else {
+                    delete(e);
+                    return false;
+                }
+            }
+        }
+
+        for (auto ref : REF) {
+            IncType_t inc = getREFInc(ref);
+            if (!(inc < INC_MAX)) {
+                continue;
+            }
+            const Value *orig = ptr::getAndersen()->getNodeFactory().getLocation(ref.first);
+            if (!orig) {
+                continue;
+            }
+            if (dyn_cast<const ConstantInt>(orig)) {
+                ConstPathElement *e = new ConstPathElement(orig, pathElement->getRelevantVariable());
+                if (pathElement->setNext(e)) {
+                    return true;
+                } else {
+                    delete(e);
+                    return false;
+                }
+            }
+        }
+//            errs() <<"\n";
+//            errs()<< ins->getParent()->getParent()->getName() << ": ";ins->dump();
+
+        if (ins->getOpcode() == Instruction::Store) {
+            if (const ConstantInt *constantInt = dyn_cast<const ConstantInt>(ins->getOperand(0))) {
+                ConstPathElement *constPathElement = new ConstPathElement(constantInt, pathElement->getRelevantVariable());
+                pathElement->setNext(constPathElement);
+                constPathElement->setPrev(pathElement);
+            }
+        }
+        return true;
+    } else {
+        PredSet_t::iterator p_it = predecessors.begin();
+        PredSet_t::iterator p_first = p_it;
+
+
+
+        ++p_it;
+        for (; p_it != predecessors.end(); ++p_it) {
+//            for (int i = 0; i < 1 && p_it != predecessors.end(); ++i) {
+            if (pathElement->getParent()->contains(p_it->first->getIns(), p_it->second))
+                continue;
+            PathElement *element = new PathElement(p_it->first->getIns(), p_it->second);
+            element->setPrev(pathElement);
+            Path *newPath = new Path(*pathElement->getParent());
+            if (!newPath->getLast()->setNext(element)) {
+                delete(newPath);
+                continue;
+            };
+
+            InsInfo *ii = p_it->first;
+
+            if (ii->backtrack(provider, element, paths, pathLock, rule)) {
+                pathLock.lock();
+                if (//(std::find_if(paths->begin(), paths->end(), [e](const Path *p) { return e->getParent()->isSub(*p);}) == paths->end()) &&
+                        (std::find_if(paths.begin(), paths.end(), [element](const Path *p) { return *element->getParent() == *p;}) == paths.end())) {
+                    paths.push_back(element->getParent());
+                } else {
+                    delete(element->getParent());
+                }
+                pathLock.unlock();
+            } else {
+                delete(element->getParent());
+            }
+
+        }
+
+        bool result = true;
+        if (pathElement->getParent()->contains(p_first->first->getIns(), p_first->second)) {
+            result = false;
+        }
+        if (result) {
+            PathElement *element = new PathElement(p_first->first->getIns(), p_first->second);
+            if (!pathElement->setNext(element)) {
+                delete (element);
+                result = false;
+            } else {
+                element->setPrev(pathElement);
+                result = p_first->first->backtrack(provider, element, paths, pathLock, rule);
+            }
+        }
+
+        return result;
+    }
+}
diff --git a/lib/LLVMSlicer/Backtrack/Constraint.cpp b/lib/LLVMSlicer/Backtrack/Constraint.cpp
new file mode 100644
index 0000000..2320e0b
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/Constraint.cpp
@@ -0,0 +1,705 @@
+#include <PointsTo/PointsTo.h>
+#include <sstream>
+#include <llvm/ADT/StringExtras.h>
+#include "Constraint.h"
+#include "Rule.h"
+
+
+using namespace llvm;
+using namespace slicing;
+
+cl::opt<bool> PrintSameUseDef("print-same-usedef-only", cl::desc("Paths with same use-def are only printed once"), cl::init(false), cl::Hidden);
+
+Message::Message(Path *path, bool isPrecondition) : isPrecondition(isPrecondition), path(path) {
+
+}
+
+void Message::dump() {
+    if (isPrecondition) {
+        errs() << "Precondition not always fulfilled\n";
+    }
+    path->dump(false);
+}
+
+Parameter::Parameter(std::string functionName, uint64_t regNo, ParameterType parameterType) : functionName(functionName), regNo(regNo), parameterType(parameterType) {
+
+}
+
+std::string Parameter::getFunctionName() const {
+    return functionName;
+}
+
+uint64_t Parameter::getRegNo() const {
+    return regNo;
+}
+
+Parameter::ParameterType Parameter::getParameterType() const {
+    return parameterType;
+}
+
+
+//------------------------------------------
+//Constraint
+//------------------------------------------
+
+Constraint::Constraint(ConstraintType constraintType) : constraintType(constraintType) {
+
+}
+
+void Constraint::addConstraint(const Constraint *constraint) {
+    children.push_back(constraint);
+}
+
+Constraint::Type Constraint::getType() const {
+    return CONSTRAINT;
+}
+
+const Constraint::ConstraintList_t &Constraint::getChildren() const {
+    return children;
+}
+
+Constraint::ConstraintType Constraint::getConstraintType() const {
+    return constraintType;
+}
+
+//------------------------------------------
+//ChainedConstraint
+//------------------------------------------
+
+ChainConstraint::ChainConstraint(ConstraintType constraintType, ChainType chainType) : Constraint(constraintType), chainType(chainType) {
+
+}
+
+
+bool ChainConstraint::checkConstraint(PathElementBase *pathElement) const {
+    bool result = false;
+    switch (chainType) {
+        case AND: {
+            result = true;
+            for (auto &child : children) {
+                result &= child->checkConstraint(pathElement);
+            }
+            break;
+        }
+        case OR: {
+            for (auto &child : children) {
+                result |= child->checkConstraint(pathElement);
+            }
+            break;
+        }
+        case NOT_AND: {
+            result = true;
+            for (auto &child : children) {
+                result &= !child->checkConstraint(pathElement);
+            }
+            break;
+        }
+        default:
+            llvm_unreachable("");
+    }
+    return result;
+}
+
+bool ChainConstraint::shouldStop(PathElementBase *pathElement) const {
+    bool result = false;
+    switch (chainType) {
+        case OR: {
+            for (auto &child : children) {
+                result |= child->shouldStop(pathElement);
+            }
+            break;
+        }
+        case NOT_AND: {
+            //TODO: how to handle this, we can't stop always when we NOT find something...
+            result = false;
+            break;
+        }
+        default:
+            llvm_unreachable("");
+    }
+    return result;
+}
+
+//------------------------------------------
+//ConstConstraint
+//------------------------------------------
+
+ConstConstraint::ConstConstraint(Compare compare, uint64_t value, ConstraintType constraintType) : Constraint(constraintType), value(value), compare(compare) {
+
+}
+
+bool ConstConstraint::checkConstraint(PathElementBase *pathElement) const {
+    const Instruction *inst = dyn_cast<const Instruction>(pathElement->getElement());
+    if (inst) {
+        if (inst->getOpcode() == Instruction::Store) {
+            const ConstantInt *constInt = dyn_cast<const ConstantInt>(inst->getOperand(0));
+            switch (compare) {
+                case EQUAL: {
+                    if (constInt && constInt->getZExtValue() == value) {
+                        return true;
+                    } else {
+                        return false;
+                    }
+                    break;
+                }
+                case GREATER: {
+                    if (constInt && constInt->getZExtValue() > value) {
+                        return true;
+                    } else {
+                        return false;
+                    }
+                    break;
+                }
+                case LOREQ: {
+                    if (constInt && (constInt->getZExtValue() | value) == value) {
+                        return true;
+                    } else {
+                        return false;
+                    }
+                    break;
+                }
+                case LORNEQ: {
+                    if (constInt && (constInt->getZExtValue() & value) != value) {
+                        return true;
+                    } else {
+                        return false;
+                    }
+                    break;
+                }
+                case ANY: {
+                    if (constInt) {
+                        return true;
+                    }
+                }
+                default:
+                    llvm_unreachable("");
+            }
+
+        }
+    } else if (const ConstantInt *constAddress = dyn_cast<const ConstantInt>(pathElement->getElement())) {
+        uint64_t width = pathElement->getParent()->getShortestLoad();
+        uint64_t value = 0;
+        switch (width) {
+            case 32: {
+                value = ptr::getAndersen()->getMachO().getRAWData<uint32_t>(constAddress->getZExtValue());
+                break;
+            }
+            case 64: {
+                value = ptr::getAndersen()->getMachO().getRAWData<uint64_t>(constAddress->getZExtValue());
+                break;
+            }
+            default:
+                llvm_unreachable("");
+        }
+        if (compare == EQUAL) {
+            if (value == this->value) {
+                return true;
+            } else {
+                return false;
+            }
+        } else if (compare == GREATER) {
+            if (value > this->value) {
+                return true;
+            } else {
+                return false;
+            }
+            } else if (compare == LORNEQ) {
+            if ((value & this->value) != this->value) {
+                return true;
+            } else {
+                return false;
+            }
+        } else if (compare == ANY) {
+            return true;
+        } else {
+            llvm_unreachable("");
+        }
+    }
+    return false;
+}
+
+bool ConstConstraint::shouldStop(PathElementBase *pathElement) const {
+    if (const Instruction *inst = dyn_cast<const Instruction>(pathElement->getElement())) {
+        if (inst->getOpcode() == Instruction::Store) {
+            if (dyn_cast<const ConstantInt>(inst->getOperand(0))) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+//------------------------------------------
+//Rule
+//------------------------------------------
+
+Rule::Rule(std::string ruleTitle, ConstraintType constraintType, ChainType chainType):
+        ChainConstraint(constraintType, chainType), ruleTitle(ruleTitle) {
+
+}
+
+Rule::Rule(const Rule &base, const llvm::Value *criterion) : ChainConstraint(base.constraintType, base.chainType) , relevantLocation(criterion) {
+    std::stringstream ss;
+    ss << "Write to 0x";
+    ss << utohexstr(((ConstantInt*)criterion)->getZExtValue());
+    ruleTitle = ss.str();
+    for (auto user : criterion->users()) {
+        std::vector<const Value*> ptsToSet;
+        ptr::getAndersen()->getPointsToSet(user, ptsToSet);
+        for (auto &p : ptsToSet) {
+            relevantVariables.push_back(p);
+        }
+        //They point all to the same location, thus we can stop here
+        break;
+    }
+}
+
+void Rule::addInitialInstruction(const Instruction *callInst, const Instruction *paramInst, InstructionRuleList_t preconditionInstruction) {
+//    if (std::find(initialInstructions.begin(), initialInstructions.end(), inst) != initialInstructions.end())
+//        return;
+    initialInstructions.push_back(InitialInstructionPair_t(std::pair<const Instruction*, const Instruction*>(callInst, paramInst), preconditionInstruction));
+}
+
+const Rule::InitialInstructionList_t &Rule::getInitialInstruction() const {
+    return initialInstructions;
+}
+
+bool Rule::checkConstraint(PathElementBase *pathElement) const {
+    return ChainConstraint::checkConstraint(pathElement);
+}
+
+bool Rule::shouldStop(PathElementBase *pathElement) const {
+    if (children.size() == 0)
+        return false;
+
+    bool result = false;
+    if (chainType == ChainConstraint::AND)
+        result = true;
+    for (auto &c : children) {
+        bool c_r = c->shouldStop(pathElement);
+        switch (chainType) {
+            case ChainConstraint::AND: {
+                result &= c_r;
+                break;
+            }
+            case ChainConstraint::OR: {
+                result |= c_r;
+                break;
+            }
+            default:
+                llvm_unreachable("");
+        }
+    }
+    return result;
+}
+
+bool Rule::dismissPath(PathElementBase *pathElement) const {
+    bool dismiss = false;
+    if (const CallInst *callInst = dyn_cast<const CallInst>(pathElement->getElement())) {
+        for (auto &calledFunction : ptr::getSimpleCallGraph().getCalled(callInst)) {
+            if (calledFunction == "CC_SHA256_Init") {
+                dismiss = true;
+            } else {
+                return false;
+            }
+        }
+        return dismiss;
+    }
+    return false;
+}
+
+void Rule::addCriterion(Parameter parameter, std::vector<Rule*> preconditions) {
+    criterions.push_back(Criterion_t(parameter, preconditions));
+}
+
+Rule::RuleCriterionList_t Rule::getCriterions() const {
+    RuleCriterionList_t ruleCriterionList;
+
+
+    for (auto &c : criterions) {
+        ruleCriterionList.push_back(RuleCriterion_t(this, c));
+    }
+
+    for (auto &c : children) {
+        if (c->getType() == RULE) {
+            RuleCriterionList_t cl = ((const Rule*)c)->getCriterions();
+            ruleCriterionList.insert(ruleCriterionList.end(), cl.begin(), cl.end());
+        }
+    }
+
+    return ruleCriterionList;
+}
+
+void Rule::addConstraint(const Constraint *constraint) {
+    if (constraint->getConstraintType() == PRECONDITION) {
+        if (children.size() > 0) {
+            llvm_unreachable("only a single precondition may be added");
+        }
+        if (getConstraintType() != PRECONDITION && constraint->getType() != RULE) {
+            llvm_unreachable("The rule has to be a precondition if a constraint is one.");
+        }
+    }
+    Constraint::addConstraint(constraint);
+}
+
+
+bool Rule::useParentPath(Path *path) {
+    return false;
+}
+
+Constraint::Type Rule::getType() const {
+    return RULE;
+}
+
+bool Rule::preconditions() const {
+    bool cond = false;
+    if (getConstraintType() == PRECONDITION) {
+        for (auto &path : paths) {
+            cond |= checkConstraint(path->getLast());
+        }
+    } else {
+        cond = true;
+    }
+    return cond;
+}
+
+bool Rule::checkRule() {
+    if (initialInstructions.size() && paths.size() == 0) {
+        errs() << "ERROR: No paths found! " << ruleTitle << "\n";
+    }
+    checkedPaths = true;
+    for (auto &path : paths) {
+        if (!path->getEntry()->getNext())
+            continue;
+        const Instruction *first = dyn_cast<const Instruction>(path->getEntry()->getElement());
+        const Instruction *pathStart = first->getOpcode() == Instruction::Call ? dyn_cast<const Instruction>(path->getEntry()->getNext()->getElement()) : dyn_cast<const Instruction>(path->getEntry()->getElement());
+        if (!pathStart) {
+            continue;
+        }
+
+//        errs() << "PATHDUMP\n";
+//        path->dump();
+//        errs() << "--------\n";
+
+        InitialInstructionPair_t initIns;
+
+        if (parentRuleTitle.size()) {
+            for (auto &x : parentRule->initialInstructions) {
+                if (x.first.second == pathStart) {
+                    initIns = x;
+                }
+            }
+        } else {
+            for (auto &x : initialInstructions) {
+                if (x.first.second == pathStart) {
+                    initIns = x;
+                }
+            }
+        }
+
+//        for (auto &initIns : initialInstructions) {
+            if (initIns.first.second == pathStart || (parentRuleTitle.size() && path->contains(initIns.first.second))) {
+                Result result = VALID;
+                bool hasPrecond = false;
+                bool precond = false;
+                MessageList_t errorMessages;
+
+                PrecondResultList_t preConditionResults;
+                for (auto &preCond : initIns.second) {
+                    for (auto &p : preCond.second->getPaths(preCond.first)) {
+                        hasPrecond = true;
+                        bool result = preCond.second->checkRule(p);
+                        PrecondResult_t preResult;
+                        std::get<1>(preResult) = preCond.second;
+                        std::get<2>(preResult) = p;
+                        if (!result) {
+                            std::get<0>(preResult) = ERROR;
+                            errorMessages.push_back(Message(p, true));
+                            // preConditionResults.push_back(PathResult_t(ERROR, p));
+                        } else {
+                            // preConditionResults.push_back(PathResult_t(VALID, p));
+                            std::get<0>(preResult) = VALID;
+                        }
+                        preConditionResults.push_back(preResult);
+                        precond |= result;
+                    }
+                }
+
+                if (precond || !hasPrecond) {
+                    if (!checkRule(path)) {
+                        if (errorMessages.size()) {
+                            result = PRECOND_ERROR;
+                        } else {
+                            result = ERROR;
+                        }
+                        errorMessages.push_back(Message(path));
+                        CompletePathResult_t pathResult(PathResult_t(ERROR, path), preConditionResults);
+                        pathResults.push_back(pathResult);
+                    } else {
+                        CompletePathResult_t pathResult(PathResult_t(VALID, path), preConditionResults);
+                        pathResults.push_back(pathResult);
+//                        errs() << "VALID PATH:\n";
+//                        path->dump(true);
+//                        errs() << "------------------------\n";
+                    }
+                } else {
+                    //TODO: this is only for debug purposes to keep ALL paths
+                    if (!checkRule(path)) {
+                        if (errorMessages.size()) {
+                            result = PRECOND_ERROR;
+                        } else {
+                            result = ERROR;
+                        }
+                        errorMessages.push_back(Message(path));
+                        CompletePathResult_t pathResult(PathResult_t(ERROR, path), preConditionResults);
+                        pathResults.push_back(pathResult);
+                    } else {
+                        CompletePathResult_t pathResult(PathResult_t(VALID, path), preConditionResults);
+                        pathResults.push_back(pathResult);
+//                        errs() << "VALID PATH:\n";
+//                        path->dump(true);
+//                        errs() << "------------------------\n";
+                    }
+                }
+
+//                for (auto &m : errorMessages) {
+//                    m.dump();
+//                    errs() << "\n\n";
+//                }
+            }
+//        }
+    }
+//    if (preconditions()) {
+//
+//        for (auto &child : children) {
+//            if (child->getType() == RULE) {
+//                ((Rule*)child)->checkRule();
+//            } else {
+//                for (auto &path : paths) {
+//                    if (!checkConstraint(path->getLast())) {
+//                        path->dump();
+//                    }
+//                }
+//            }
+//        }
+//
+//    } else {
+//        return true;
+//    }
+    return false;
+}
+
+bool Rule::checkRule(Path *path) const {
+    return checkConstraint(path->getLast());
+}
+
+Rule::PathList_t Rule::getPaths(const Instruction *inst) const {
+    PathList_t foundPaths;
+    for (auto &path : paths) {
+        if (path->getEntry()->getNext() && path->getEntry()->getNext()->getElement() == inst) {
+            foundPaths.push_back(path);
+        }
+    }
+    return foundPaths;
+}
+
+void Rule::addPaths(PathList_t paths) {
+    this->paths.insert(this->paths.end(), paths.begin(), paths.end());
+}
+
+std::string Rule::getRuleTitle() const {
+    return ruleTitle;
+}
+
+bool Rule::operator == (const Rule &other) const  {
+    if (ruleTitle.size()) {
+        if (other.ruleTitle.size()) {
+            return ruleTitle == other.ruleTitle;
+        }
+        return false;
+    }
+    if (relevantLocation && relevantLocation == other.getRelevantLocation())
+        return true;
+    return false;
+}
+
+//------------------------------------------
+//CallConstraint
+//------------------------------------------
+
+CallConstraint::CallConstraint(ConstraintType constraintType, std::string functionName) : Constraint(constraintType), functionName(functionName) {
+
+}
+
+bool CallConstraint::checkConstraint(PathElementBase *pathElement) const {
+    const Instruction *inst = dyn_cast<const Instruction>(pathElement->getElement());
+    if (inst) {
+        SimpleCallGraph::FunctionSet_t calledFunctions = ptr::getSimpleCallGraph().getCalled(inst);
+        for (auto &calledFunction : calledFunctions) {
+            if (calledFunction == functionName) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+bool CallConstraint::shouldStop(PathElementBase *pathElement) const {
+    const Instruction *inst = dyn_cast<const Instruction>(pathElement->getElement());
+    if (!inst) {
+        return false;
+    }
+    if (inst->getOpcode() == Instruction::Call) {
+        SimpleCallGraph::FunctionSet_t calledFunctions = ptr::getSimpleCallGraph().getCalled(inst);
+        for (auto &calledFunction : calledFunctions) {
+            if (calledFunction == functionName) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+
+HTMLReportPrinter::HTMLReportPrinter(raw_ostream &file_out) : file_out(file_out) {
+    printHeader();
+}
+
+void HTMLReportPrinter::addResults(Rule *rule, const Rule::CompletePathResultList_t &results) {
+
+    static unsigned ruleCounter = 0;
+    static unsigned pathCounter = 0;
+    ruleCounter++;
+    file_out << "<div id=\"rule"<<ruleCounter<<"\">\n";
+    file_out << "<h1 data-toggle=\"collapse\" href=\"#rule"<< ruleCounter <<"body\">" << rule->getRuleTitle() << "</h1>\n";
+
+    file_out << "<div class=\"collapse in   \" id=\"rule"<<ruleCounter<<"body\">\n";
+
+    typedef std::pair<const Value*, const Value*> ValuePair_t;
+    typedef std::set<ValuePair_t> ValuePairSet_t;
+
+    ValuePairSet_t printed;
+
+    for (auto &r : results) {
+        if (PrintSameUseDef) {
+            ValuePair_t pair(r.first.second->getEntry()->getElement(), r.first.second->getLast()->getElement());
+            if (printed.find(pair) != printed.end())
+                continue;
+            printed.insert(pair);
+        }
+
+        bool preCond = r.second.size() ? false : true;
+        for (auto &pre : r.second) {
+            if (std::get<0>(pre) == Rule::VALID) {
+                preCond = true;
+            }
+        }
+
+        pathCounter++;
+        std::stringstream ruleHeaderClasses;
+        if (r.first.first == Rule::VALID) {
+            ruleHeaderClasses << "text-success ";
+        } else if (r.first.first == Rule::ERROR) {
+            ruleHeaderClasses << "text-danger ";
+        }
+        file_out << "<div class=\"tracebody " << (!preCond || r.first.first == Rule::VALID ? "dismiss" : "") << "\">\n";
+        file_out << "<div style=\"opacity:0.3; background-color:#000; height:10px\"></div>\n";
+        file_out << "<h2 data-toggle=\"collapse\" href=\"#pathBody"<< pathCounter <<"\" class=\""<< ruleHeaderClasses.str() <<"\">" << "PATH" << " #"<< pathCounter <<"</h2>\n";
+        file_out << "<div class=\"collapse in\" id=\"pathBody"<< pathCounter <<"\">\n";
+        for (auto &pre : r.second) {
+
+            std::stringstream preconditionHeaderClasses;
+
+            if (std::get<0>(pre) == Rule::VALID) {
+                preconditionHeaderClasses << "text-success ";
+            } else if (std::get<0>(pre) == Rule::ERROR) {
+                preconditionHeaderClasses << "text-danger ";
+            }
+            file_out << "<h4 class=\""<< preconditionHeaderClasses.str() <<"\">Precondition: " << std::get<1>(pre)->getRuleTitle() << "</h4>\n";
+            printPath(std::get<2>(pre), true);
+        }
+
+        file_out << "<h3>Trace</h3>\n";
+        printPath(r.first.second, false);
+        file_out << "</div>\n";
+        file_out << "</div>\n";
+    }
+
+    file_out << "</div>\n";
+    file_out << "</div>\n";
+}
+
+void HTMLReportPrinter::printHeader() {
+    file_out << "<!DOCTYPE html>\n"
+                        "<html>\n"
+                        "    <head>\n"
+                        "        <meta charset=\"utf-8\">\n"
+                        "        <title></title>\n"
+//                        "<link rel=\"stylesheet\" href=\"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\">\n"
+//                        "<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js\"></script>\n"
+//                        "<script src=\"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js\"></script>\n"
+                        "<link rel=\"stylesheet\" href=\"scripts/bootstrap.min.css\">\n"
+                        "<link rel=\"stylesheet\" href=\"scripts/report.css\">\n"
+                        "<script src=\"scripts/jquery.min.js\"></script>\n"
+                        "<script src=\"scripts/bootstrap.min.js\"></script>\n"
+                        "<script src=\"scripts/helper.js\"></script>\n"
+                        "    </head>\n"
+                        "    <body>\n";
+}
+
+void HTMLReportPrinter::printFooter() {
+    file_out << "    </body>\n"
+                        "</html>\n";
+}
+
+void HTMLReportPrinter::close() {
+    printFooter();
+    file_out.flush();
+}
+
+void HTMLReportPrinter::printPath(Path *path, bool collapsable) {
+    static unsigned pathID = 0;
+    std::stringstream ss;
+    ss << "path" << pathID++;
+    PathElementBase *current = path->getEntry();
+
+    if (collapsable) {
+        file_out << "<a data-toggle=\"collapse\" href=\"#"<< ss.str() <<"\">Show/Hide</a>\n";
+    }
+
+    std::stringstream classes;
+    classes << "collapse ";
+    if (!collapsable) {
+        classes << " in";
+    }
+
+    file_out << "<div id=\"" << ss.str() << "\" class=\"" << classes.str() << "\">\n";
+    while (current) {
+        file_out << "<div class=\"path-element\" data-instid=\"" << utohexstr((uint64_t) current->getElement()) <<"\">";
+//        current->print(file_out);
+        if (const Instruction *inst = dyn_cast<const Instruction>(current->getElement())) {
+            file_out << inst->getParent()->getParent()->getName();
+        }
+        file_out << current->getElement() << " ";
+        current->getElement()->print(file_out); file_out << "(" << *current->getRelevantVariable() << ")";
+        if (const CallInst *callInst = dyn_cast<const CallInst>(current->getElement())) {
+            const SimpleCallGraph::FunctionSet_t &calledFunctions = ptr::getSimpleCallGraph().getCalled(callInst);
+            if (calledFunctions.size()) {
+                file_out << "<div class=\"border-left-small\">\n"
+                                    "<div class=\"call-label\">Called:</div>\n";
+                for (auto &calledFunction : calledFunctions) {
+                    file_out << "<div class=\"call-entry\">" << calledFunction << "</div>\n";
+                }
+                file_out << "</div>\n";
+            }
+        } else if (dyn_cast<const ConstantInt>(current->getElement())) {
+
+            if (current->getType() == PathElementBase::ConstAddressElement) {
+                file_out << "<div>" << ((ConstPathElement*)current)->getValue() << "</div>\n";
+            }
+        }
+        file_out << "</div>\n";
+        current = current->getNext();
+    }
+    file_out << "</div>\n";
+}
diff --git a/lib/LLVMSlicer/Backtrack/Constraint.h b/lib/LLVMSlicer/Backtrack/Constraint.h
new file mode 100644
index 0000000..a69282b
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/Constraint.h
@@ -0,0 +1,254 @@
+#ifndef LLVM_CONSTRAINT_H
+#define LLVM_CONSTRAINT_H
+
+
+#include <string>
+#include <vector>
+#include "Path.h"
+
+namespace llvm {
+    namespace slicing {
+
+        class Rule;
+
+        class Parameter {
+        public:
+            enum ParameterType{
+                PRE,
+                POST
+            };
+            Parameter(std::string functionName, uint64_t regNo, ParameterType parameterType);
+
+            std::string getFunctionName() const;
+            uint64_t getRegNo() const;
+            ParameterType getParameterType() const;
+
+        private:
+            std::string functionName;
+            uint64_t regNo;
+            ParameterType parameterType;
+        };
+
+        class Message {
+        public:
+            Message(Path *path, bool isPrecondition = false);
+
+            void dump();
+        private:
+            bool isPrecondition;
+            Path *path;
+        };
+
+        class Constraint {
+        public:
+            typedef std::vector<const Constraint*> ConstraintList_t;
+            enum ConstraintType {
+                STRICT,
+                WARN,
+                PRECONDITION,
+                UNSPECIFIED
+            };
+
+            enum Type {
+                CONSTRAINT,
+                RULE
+            };
+
+            Constraint(ConstraintType constraintType);
+
+            virtual ~Constraint() {};
+
+            virtual void addConstraint(const Constraint *constraint);
+
+            virtual bool checkConstraint(PathElementBase *pathElement) const = 0;
+            virtual bool shouldStop(PathElementBase *pathElement) const = 0;
+
+            virtual Type getType() const;
+            ConstraintType getConstraintType() const;
+
+            const ConstraintList_t &getChildren() const;
+        protected:
+            ConstraintList_t children;
+            ConstraintType constraintType;
+        private:
+        };
+
+        class ChainConstraint : public Constraint {
+        public:
+            enum ChainType {
+                AND,
+                OR,
+                NOT_AND
+            };
+
+            ChainConstraint(ConstraintType constraintType, ChainType chainType);
+
+            virtual bool checkConstraint(PathElementBase *pathElement) const;
+            virtual bool shouldStop(PathElementBase *pathElement) const;
+
+        protected:
+            ChainType chainType;
+        };
+
+
+        class Rule : public ChainConstraint {
+        public:
+            typedef std::vector<const Instruction*> InstructionList_t;
+
+            typedef std::pair<Parameter, std::vector<Rule*>> Criterion_t;
+            typedef std::vector<Criterion_t> ParameterList_t;
+            typedef std::pair<const Rule*, Parameter> RuleParameter_t;
+            typedef std::vector<RuleParameter_t> RuleParameterList_t;
+            typedef std::pair<const Rule*, Criterion_t> RuleCriterion_t;
+            typedef std::vector<RuleCriterion_t> RuleCriterionList_t;
+            typedef std::vector<Path*> PathList_t;
+            typedef std::pair<const Instruction*, Rule*> InstructionRule_t;
+            typedef std::vector<InstructionRule_t> InstructionRuleList_t;
+            typedef std::pair<std::pair<const Instruction*, const Instruction*>, InstructionRuleList_t> InitialInstructionPair_t;
+            typedef std::vector<InitialInstructionPair_t> InitialInstructionList_t;
+
+            typedef std::vector<Message> MessageList_t;
+
+            enum Result {
+                ERROR,
+                PRECOND_ERROR,
+                VALID
+            };
+
+            typedef std::pair<Result, Path*> PathResult_t;
+            typedef std::tuple<Result, Rule*, Path*> PrecondResult_t;
+            typedef std::vector<PathResult_t> PathResultList_t;
+            typedef std::vector<PrecondResult_t> PrecondResultList_t;
+            typedef std::pair<PathResult_t, PrecondResultList_t> CompletePathResult_t;
+            typedef std::vector<CompletePathResult_t> CompletePathResultList_t;
+
+            Rule(std::string ruleTitle, ConstraintType constraintType, ChainType chainType);
+            Rule(const Rule &base, const llvm::Value *criterion);
+
+            void addInitialInstruction(const Instruction *callInst, const Instruction *paramInst, InstructionRuleList_t preconditionInstruction);
+            const InitialInstructionList_t &getInitialInstruction() const;
+
+            virtual bool checkConstraint(PathElementBase *pathElement) const;
+            virtual bool shouldStop(PathElementBase *pathElement) const;
+            virtual bool dismissPath(PathElementBase *pathElementBase) const;
+
+            void addCriterion(Parameter parameter, std::vector<Rule*> preconditions);
+            RuleCriterionList_t getCriterions() const;
+
+            virtual Type getType() const;
+
+            virtual void addConstraint(const Constraint *constraint);
+
+            bool preconditions() const;
+            bool checkRule();
+            bool checkRule(Path *path) const;
+
+            void addPaths(PathList_t paths);
+            std::string getRuleTitle() const;
+
+            const CompletePathResultList_t &getResults() const {
+                return pathResults;
+            };
+
+            const PathList_t &getPaths() const {
+                return paths;
+            }
+
+            std::vector<const llvm::Value*> getRelevantVariables() const {
+                return relevantVariables;
+            }
+
+            const llvm::Value *getRelevantLocation() const {
+                return relevantLocation;
+            }
+
+            bool operator == (const Rule &other) const ;
+
+            void setParentRuleTitle(std::string parent) {
+                parentRuleTitle = parent;
+            }
+
+            std::string getParentRuleTitle() const {
+                return parentRuleTitle;
+            }
+
+            void setParentRule(Rule *r) {
+                parentRule = r;
+            }
+
+            bool useParentPath(Path *path);
+
+            void setDismissable(Path *path) {
+                dismissablePaths.insert(path);
+            }
+
+            void removeDismissablePaths() {
+                for (auto &d : dismissablePaths) {
+                    while (std::find(paths.begin(), paths.end(), d) != paths.end()) {
+                        paths.erase(std::find(paths.begin(), paths.end(), d));
+                    }
+                }
+            }
+        private:
+            std::string ruleTitle;
+            InitialInstructionList_t initialInstructions;
+            ParameterList_t criterions;
+            PathList_t paths;
+
+            PathList_t getPaths(const Instruction *inst) const;
+
+            bool checkedPaths = false;
+            CompletePathResultList_t pathResults;
+
+            std::vector<const llvm::Value*> relevantVariables;
+            const llvm::Value *relevantLocation;
+            std::string parentRuleTitle;
+            Rule *parentRule;
+            std::set<Path*> dismissablePaths;
+        };
+
+
+        class ConstConstraint : public Constraint {
+        public:
+            enum Compare {
+                EQUAL,
+                GREATER,
+                LOREQ,
+                LORNEQ,
+                ANY
+            };
+            ConstConstraint(Compare compare, uint64_t value, ConstraintType constraintType);
+
+            virtual bool checkConstraint(PathElementBase *pathElement) const;
+            virtual bool shouldStop(PathElementBase *pathElement) const;
+
+        private:
+            uint64_t value;
+            Compare compare;
+        };
+
+        class CallConstraint : public Constraint {
+        public:
+            CallConstraint(ConstraintType constraintType, std::string functionName);
+
+            virtual bool checkConstraint(PathElementBase *pathElement) const;
+            virtual bool shouldStop(PathElementBase *pathElement) const;
+        private:
+            std::string functionName;
+        };
+
+        class HTMLReportPrinter {
+        public:
+            HTMLReportPrinter(raw_ostream &file_out);
+            void addResults(Rule *rule, const  Rule::CompletePathResultList_t &results);
+            void close();
+        private:
+            raw_ostream &file_out;
+            void printHeader();
+            void printFooter();
+            void printPath(Path *path, bool collapsable);
+        };
+    }
+}
+
+#endif //LLVM_CONSTRAINT_H
diff --git a/lib/LLVMSlicer/Backtrack/Path.cpp b/lib/LLVMSlicer/Backtrack/Path.cpp
new file mode 100644
index 0000000..e006bb1
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/Path.cpp
@@ -0,0 +1,334 @@
+#include <PointsTo/PointsTo.h>
+#include <llvm/IR/Dominators.h>
+#include <llvm/ADT/StringExtras.h>
+#include <sstream>
+#include "Path.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/Function.h"
+
+
+using namespace llvm;
+using namespace slicing;
+
+cl::opt<bool> SameUseDef("same-usedef-only", cl::desc("Paths with same origin and location of use are considered as equal."), cl::init(false), cl::Hidden);
+
+bool PathElement::setNext(PathElementBase *n) {
+
+//    return PathElementBase::setNext(n);
+
+    if (n->getType() != InstructionElement) {
+        return PathElementBase::setNext(n);
+    }
+
+    PathElement *nElem = (PathElement*)n;
+
+    if (inst->getParent()->getParent() != nElem->inst->getParent()->getParent() && nElem->inst->getOpcode() != Instruction::Ret) {
+        if (nElem->inst->getOpcode() == Instruction::Call) {
+            assert(true);
+        }
+
+//        if (inst->getName().find("init") != StringRef::npos) {
+//            if (nElem->getInstruction()->getOpcode() != Instruction::Store) {
+//                return false;
+//            }
+//        }
+
+
+        if (parent->hasCall()) {
+            const CallInst *c = parent->getLatestCall();
+            //TODO: check for a correct call...
+            parent->popCall();
+
+            if (n->getElement() == c) {
+                assert(true);
+            } else {
+                return false;
+            }
+
+            std::string from = nElem->inst->getParent()->getParent()->getName().str();
+            std::string to = c->getParent()->getParent()->getName().str();
+            if (from != to && !ptr::getSimpleCallGraph().hasPath(from, to)) {
+//                errs() << "No call from " << from << " to " << to << "\n";
+                assert(true);
+                return false;
+            }
+
+//            if (c->getParent()->getParent() != nElem->getInstruction()->getParent()->getParent()) {
+//                return false;
+//            }
+//
+//            if (const StoreInst *store = dyn_cast<const StoreInst>(nElem->getInstruction())) {
+//                if (const GetElementPtrInst *getElementPtrInst = dyn_cast<const GetElementPtrInst>(store->getOperand(1))) {
+//                    const Instruction *current = getSuccInBlock(c);
+//                    while (current) {
+//                        if (const StoreInst *cmp = dyn_cast<const StoreInst>(current)) {
+//                            if (cmp->getOperand(1) == getElementPtrInst) {
+//                                if (cmp == store) {
+//                                    break;
+//                                } else {
+//                                    return false;
+//                                }
+//                            }
+//                        }
+//                        current = current->getPrevNode();
+//                    }
+//                }
+//            }
+        }
+
+    }
+
+//    const Function *f = n->getInstruction()->getParent()->getParent();
+//    DominatorTree &domTree = ptr::getAndersen()->getAnalysis<DominatorTreeWrapperPass>(*((Function*)f)).getDomTree();
+//
+//    PathElement *current = this;
+//    while (current) {
+//        if (current->getInstruction()->getParent()->getParent() == f) {
+//            if (!domTree.dominates(n->getInstruction(), inst)) {
+//                return false;
+//            }
+//        }
+//        current = current->prev;
+//    }
+
+    return PathElementBase::setNext(n);
+}
+
+bool PathElementBase::setNext(PathElementBase *n) {
+    if (dyn_cast<const GlobalVariable>(n->getElement())) {
+        return false;
+    }
+    n->setParent(parent);
+    next = n;
+    return true;
+}
+
+void PathElement::dump() const {
+    print(errs());
+}
+
+void PathElement::print(raw_ostream &out) const {
+    int64_t address = (int64_t)inst;
+    out << utohexstr(address) << " " << inst->getParent()->getParent()->getName() << ": " << *inst << "\n";
+    out << "\tRelevant: " << *relevantVariable << "\n";
+
+    if (inst->getOpcode() == Instruction::Call) {
+        out << "\tCalled:";
+        if (getSuccInBlock(inst))
+            out << *getSuccInBlock(inst) << "\n";
+        else
+            out << "\n";
+        SimpleCallGraph::FunctionSet_t &called = ptr::getSimpleCallGraph().getCalled(inst);
+        for (auto &c : called) {
+            out << "\t\t" << c << "\n";
+        }
+    }
+}
+
+void PathElementBase::dump() const {
+    print(errs());
+}
+
+void PathElementBase::print(raw_ostream &out) const {
+    out << *element << "\n";
+    out << "\tRelevant: " << *relevantVariable << "\n";
+}
+
+void Path::dump(bool useDefOnly) const {
+    print(errs(), useDefOnly);
+}
+
+void Path::print(raw_ostream &out, bool useDefOnly) const {
+    if (useDefOnly) {
+        out << entry << "\n";
+        out << getLast() << "\n";
+    } else {
+        PathElementBase *current = entry;
+        while (current) {
+//        errs() << current->getInstruction()->getParent()->getParent()->getName() << ": ";
+//        current->getInstruction()->print(errs());
+//        errs() << "(";
+//        current->getRelevantVariable()->print(errs());
+//        errs() << ")\n";
+
+            current->print(out);
+            current = current->getNext();
+        }
+    }
+}
+
+bool Path::operator < (const Path &b) const
+{
+    PathElementBase *x = entry;
+    PathElementBase *y = b.entry;
+
+    bool same = true;
+    while (x && y) {
+
+        if (x->getElement() != y->getElement()) {
+            same = false;
+            break;
+        }
+
+        x = x->getNext();
+        y = y->getNext();
+    }
+
+    if (same && x == y)
+        return false;
+
+    return  x < y;
+}
+
+bool Path::operator == (const Path &b) const
+{
+    if (SameUseDef) {
+        return sameUseDef(b);
+    }
+
+    PathElementBase *x = entry;
+    PathElementBase *y = b.entry;
+
+    bool same = true;
+    while (x && y) {
+
+        if (x->getElement() != y->getElement()) {
+            same = false;
+            break;
+        }
+
+        x = x->getNext();
+        y = y->getNext();
+    }
+
+    if (same && x == y)
+        return true;
+
+    return false;
+
+
+//    if (entry == b.entry && getLast() == b.getLast()) {
+//        return true;
+//    }
+//    return false;
+}
+
+uint64_t Path::getShortestLoad(uint64_t currentMin) const {
+    PathElementBase *current = entry;
+    while (current) {
+        if (const LoadInst *inst = dyn_cast<const LoadInst>(current->getElement())) {
+            if (inst->getType()->getPrimitiveSizeInBits() < currentMin) {
+                currentMin = inst->getType()->getPrimitiveSizeInBits();
+            }
+        }
+        current = current->getNext();
+    }
+    return currentMin;
+}
+
+bool Path::sameUseDef(const Path &other) const {
+    if (*entry == *other.entry && *getLast() == *other.getLast()) {
+        return true;
+    }
+    return false;
+}
+
+
+bool Path::isSub(const Path &sub) const {
+    PathElementBase *x = entry;
+    PathElementBase *y = sub.entry;
+
+    bool same = true;
+    while (x && y) {
+
+        if (x->getElement() != y->getElement()) {
+            same = false;
+            break;
+        }
+
+        x = x->getNext();
+        y = y->getNext();
+    }
+
+    if (same) {
+        return true;
+    }
+
+    return false;
+}
+
+void ConstPathElement::dump() const {
+    print(errs());
+}
+
+void ConstPathElement::print(raw_ostream &out) const {
+    if (const ConstantInt *constant = dyn_cast<const ConstantInt>(element)) {
+        uint64_t address = constant->getZExtValue();
+        if (ptr::getAndersen()->getMachO().isCFString(address)) {
+            out << ptr::getAndersen()->getMachO().getString(address) << "\n";
+        } else if (ptr::getAndersen()->getMachO().isCString(address)) {
+            out << ptr::getAndersen()->getMachO().getString(address) << "\n";
+        } else {
+            uint64_t width = getParent()->getShortestLoad(64);
+            uint64_t data = 0;
+            switch (width) {
+                default:
+                    llvm_unreachable("");
+                case 32: {
+                    data = ptr::getAndersen()->getMachO().getRAWData<uint32_t>(address);
+                    break;
+                }
+                case 64: {
+                    data = ptr::getAndersen()->getMachO().getRAWData<uint64_t>(address);
+                    break;
+                }
+            }
+            out << "Load from: " << address << ": " << data << "\n";
+        }
+    } else {
+        llvm_unreachable("");
+    }
+}
+
+std::string ConstPathElement::getValue() const {
+    if (const ConstantInt *constant = dyn_cast<const ConstantInt>(element)) {
+        uint64_t address = constant->getZExtValue();
+        if (ptr::getAndersen()->getMachO().isCFString(address)) {
+            return "Constant string: \"" + ptr::getAndersen()->getMachO().getString(address).str() + "\"";
+        } else if (ptr::getAndersen()->getMachO().isCString(address)) {
+            return "Constant string: \"" + ptr::getAndersen()->getMachO().getString(address).str() + "\"";
+        } else {
+
+            uint64_t width = getParent()->getShortestLoad(64);
+            uint64_t data = 0;
+            switch (width) {
+                default:
+                    llvm_unreachable("");
+                case 32: {
+                    data = ptr::getAndersen()->getMachO().getRAWData<uint32_t>(address);
+                    break;
+                }
+                case 64: {
+                    data = ptr::getAndersen()->getMachO().getRAWData<uint64_t>(address);
+                    break;
+                }
+            }
+            std::stringstream ss;
+            ss << "Load from 0x" << utohexstr(address) << ": " << data;
+            return ss.str();
+        }
+    }
+    llvm_unreachable("");
+}
+
+bool ConstPathElement::shouldCreateNewCriterion() const {
+    if (const ConstantInt *constant = dyn_cast<const ConstantInt>(element)) {
+        uint64_t address = constant->getZExtValue();
+        if (ptr::getAndersen()->getMachO().getSectionName(address) == "__objc_ivar" ||
+                ptr::getAndersen()->getMachO().getSectionName(address) == "__data") {
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/lib/LLVMSlicer/Backtrack/Path.h b/lib/LLVMSlicer/Backtrack/Path.h
new file mode 100644
index 0000000..48e81eb
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/Path.h
@@ -0,0 +1,238 @@
+#ifndef LLVM_PATH_H
+#define LLVM_PATH_H
+
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+
+namespace llvm {
+    namespace slicing {
+
+        class Path;
+        class PathElement;
+
+        class PathElementBase {
+        public:
+            enum PathElementType {
+                InstructionElement,
+                ConstAddressElement
+            };
+
+            PathElementBase(const Value *e, const Value *r) : element(e), relevantVariable(r), next(nullptr), prev(
+                    nullptr), parent(nullptr) {
+
+            }
+
+            virtual ~PathElementBase() {};
+
+            virtual PathElementType getType() const = 0;
+
+            virtual bool operator < (const PathElementBase &b) const {
+                if (getType() != b.getType())
+                    return getType() < b.getType();
+                return true;
+            };
+            virtual bool operator == (const PathElementBase &b) const {
+                if (element == b.element)
+                    return true;
+                return false;
+            }
+
+            virtual PathElementBase *clone(PathElementBase *prev, Path *parent) = 0;
+
+            virtual bool setNext(PathElementBase *n);
+            void setPrev(PathElementBase *p) { prev = p; }
+
+            void removeNext() {
+                next = nullptr;
+            }
+
+            PathElementBase *getPrev() { return prev; }
+            PathElementBase *getNext() { return next; }
+
+            const Value *getElement() const { return element; }
+            const Value *getRelevantVariable() { return relevantVariable; }
+            Path *getParent() const { return parent; };
+            void setParent(Path *p) { parent = p; }
+
+            virtual void dump() const;
+            virtual void print(raw_ostream &out) const;
+
+        protected:
+            const Value *element;
+            const Value *relevantVariable;
+
+            PathElementBase *next;
+            PathElementBase *prev;
+            Path *parent;
+        };
+
+        class PathElement : public PathElementBase {
+        public:
+            PathElement(const Instruction *i, const Value *r) : PathElementBase(i, r), inst(i) {
+                assert(isa<const Instruction>(i));
+            }
+
+            const Instruction *getInstruction() {
+                assert(isa<const Instruction>(element));
+                return dyn_cast<const Instruction>(element);
+            }
+
+            virtual void dump() const;
+            virtual void print(raw_ostream &out) const;
+
+            virtual PathElementType getType() const {
+                return InstructionElement;
+            }
+
+            virtual bool setNext(PathElementBase *n);
+
+            virtual PathElementBase *clone(PathElementBase *prev, Path *parent) {
+                return new PathElement(*this, prev, parent);
+            }
+        private:
+
+            PathElement(const PathElement &p, PathElementBase *prev, Path *parent) : PathElementBase(p.element, p.relevantVariable) {
+                if (p.next)
+                    next = p.next->clone(this, parent);
+                else {
+                    next = NULL;
+                }
+                inst = p.inst;
+                relevantVariable = p.relevantVariable;
+
+                setPrev(prev);
+                setParent(parent);
+            }
+
+            const Instruction *inst;
+
+        };
+
+        class ConstPathElement : public PathElementBase {
+        public:
+            ConstPathElement(const Value *e, const Value *r) : PathElementBase(e, r) {
+
+            };
+            virtual PathElementType getType() const {
+                return ConstAddressElement;
+            };
+
+            virtual PathElementBase *clone(PathElementBase *prev, Path *parent) {
+                ConstPathElement *elem = new ConstPathElement(element, relevantVariable);
+                elem->setParent(parent);
+                elem->setPrev(prev);
+                return elem;
+            };
+
+            virtual void dump() const;
+            virtual void print(raw_ostream &out) const;
+            virtual std::string getValue() const;
+            virtual bool shouldCreateNewCriterion() const;
+        };
+
+        class Path {
+        public:
+            Path() {}
+            Path(const Path &p) {
+//                entry = new PathElement(*p.entry, NULL, this);
+                entry = p.entry->clone(NULL, this);
+                callStack = std::vector<const CallInst*>(p.callStack);
+            }
+
+            virtual ~Path() {
+                PathElementBase *current = entry;
+                PathElementBase *next = nullptr;
+
+                while (current) {
+                    next = current->getNext();
+                    delete(current);
+                    current = next;
+                }
+            }
+
+            void setEntry(PathElementBase *e) {
+                assert(!e->getParent());
+                entry = e;
+                entry->setParent(this);
+            }
+            PathElementBase *getLast() const {
+                assert(entry);
+                PathElementBase *current = entry;
+                while (current->getNext())
+                    current = current->getNext();
+                return current;
+            }
+
+            PathElementBase *getEntry() const {
+                return entry;
+            }
+
+            bool contains(const Instruction *inst, const Value *relevant = nullptr) {
+                if (inst->getOpcode() == Instruction::Ret)
+                {
+                    for (PathElementBase *current = entry; current; current = current->getNext()) {
+                        if (current->getElement() == inst) {
+                            return current->getRelevantVariable() == relevant;
+                        }
+                    }
+                    return false;
+                }
+                if (getLatestCall() == inst) {
+                    return false;
+                }
+                for (PathElementBase *current = entry; current; current = current->getNext()) {
+                    if (current->getElement() == inst) {
+                        return true;
+                    }
+                }
+                return false;
+            }
+
+            size_t getLength() const {
+                PathElementBase *current = entry;
+                size_t l = 0;
+                while (current) {
+                    l++;
+                    current = current->getNext();
+                }
+                return l;
+            }
+
+            void dump(bool useDefOnly = false) const;
+            void print(raw_ostream &out, bool useDefOnly = false) const;
+
+            virtual bool operator < (const Path &b) const;
+            virtual bool operator == (const Path &b) const;
+
+            void addCall(const CallInst* call) {
+                assert(call);
+                callStack.push_back(call);
+            }
+
+            bool hasCall() {
+                return callStack.size() > 0;
+            }
+
+            const CallInst *getLatestCall() {
+                if (!callStack.size())
+                    return nullptr;
+                return callStack.back();
+            }
+
+            void popCall() {
+                callStack.pop_back();
+            }
+
+            uint64_t getShortestLoad(uint64_t currentMin = 64) const;
+
+            bool sameUseDef(const Path &other) const;
+            bool isSub(const Path &sub) const;
+        private:
+            PathElementBase *entry;
+            std::vector<const CallInst*> callStack;
+        };
+
+    }
+}
+
+#endif //LLVM_PATH_H
diff --git a/lib/LLVMSlicer/Backtrack/PathGenerator.h b/lib/LLVMSlicer/Backtrack/PathGenerator.h
new file mode 100644
index 0000000..80cedd3
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/PathGenerator.h
@@ -0,0 +1,17 @@
+#ifndef LLVM_PATHGENERATOR_H
+#define LLVM_PATHGENERATOR_H
+
+namespace llvm {
+    namespace slicing {
+
+        class InsInfo;
+
+        class PathGenerator {
+        public:
+            static void generate(InsInfo *info);
+        };
+
+    }
+}
+
+#endif //LLVM_PATHGENERATOR_H
diff --git a/lib/LLVMSlicer/Backtrack/Rule.cpp b/lib/LLVMSlicer/Backtrack/Rule.cpp
new file mode 100644
index 0000000..e8a4fa1
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/Rule.cpp
@@ -0,0 +1,320 @@
+#include <llvm/Support/raw_ostream.h>
+#include "Rule.h"
+#include "json.hpp"
+#include "Constraint.h"
+
+#include <vector>
+#include <map>
+#include <llvm/Support/CommandLine.h>
+#include <fstream>
+
+using namespace llvm;
+using namespace llvm::slicing;
+
+using json = nlohmann::json;
+using std::string;
+using std::map;
+using std::vector;
+
+cl::opt<std::string> RulesFile("rules", cl::desc("r"), cl::init(""), cl::Hidden);
+
+uint64_t translateRegister(string reg) {
+    if (reg == "X0")
+        return 5;
+    if (reg == "X1")
+        return 6;
+    if (reg == "X2")
+        return 7;
+    if (reg == "X3")
+        return 8;
+    if (reg == "X4")
+        return 9;
+    if (reg == "X5")
+        return 10;
+    if (reg == "X6")
+        return 11;
+    if (reg == "X7")
+        return 12;
+    if (reg == "X8")
+        return 13;
+    return -1U;
+
+}
+
+typedef map<string, vector<Parameter>> CallMap_t;
+CallMap_t callMap;
+
+void dumpJSON(json &j) {
+    errs() << j.dump();
+}
+
+Constraint *parseCondition(json &cond);
+
+Rule *parseRule(json &rule, bool precondition) {
+
+    if (rule.find("name") == rule.end() ||
+        rule.find("conditions") == rule.end() ||
+        rule.find("criterion") == rule.end()) {
+        return nullptr;
+    }
+
+    if (!rule["conditions"].is_array()) {
+        llvm_unreachable("malformed");
+    }
+
+    Rule *r = new Rule(rule["name"].get<string>(), Constraint::STRICT, ChainConstraint::OR);
+    vector<Rule*> preConditions;
+
+    for (auto &cond : rule["conditions"]) {
+        string type = cond["type"];
+        if (type != "PRE")
+            continue;
+
+        Rule *p = parseRule(cond, true);
+
+        preConditions.push_back(p);
+    }
+    for (auto &cond : rule["conditions"]) {
+        string type = cond["type"];
+        if (type == "PRE") {
+            continue;
+        }
+        r->addConstraint(parseCondition(cond));
+    }
+
+    if (rule["criterion"].is_string()) {
+        if (callMap.find(rule["criterion"].get<string>()) == callMap.end()) {
+            errs() << rule["criterion"].dump() << "\n";
+            llvm_unreachable("");
+        }
+        for (auto &p : callMap[rule["criterion"]]) {
+            r->addCriterion(p, preConditions);
+        }
+    } else if (rule["criterion"].is_array()) {
+        for (auto &param : rule["criterion"]) {
+            Parameter::ParameterType type = Parameter::PRE;
+            if (param.find("type") != param.end()) {
+                llvm_unreachable("TODO");
+            }
+            r->addCriterion(
+                    Parameter(param["name"].get<string>(), translateRegister(param["parameter"].get<string>()), type),
+                    preConditions);
+        }
+    } else {
+        llvm_unreachable("");
+    }
+    if (rule.find("parent") != rule.end()) {
+        r->setParentRuleTitle(rule["parent"].get<string>());
+    }
+    return r;
+}
+
+Constraint *parseCondition(json &cond) {
+    Constraint::ConstraintType type = Constraint::STRICT;
+    if (cond["type"] == "PRE") {
+        type = Constraint::PRECONDITION;
+    }
+    if (cond.find("calls") != cond.end()) {
+        ChainConstraint *orConstraint = new ChainConstraint(Constraint::STRICT, ChainConstraint::OR);
+
+        if (callMap.find(cond["calls"].get<string>()) == callMap.end()) {
+            errs() << cond["calls"].dump() << "\n";
+            llvm_unreachable("");
+        }
+        for (auto &p : callMap[cond["calls"].get<string>()]) {
+            CallConstraint *constr = new CallConstraint(Constraint::STRICT, p.getFunctionName());
+            orConstraint->addConstraint(constr);
+        }
+        return orConstraint;
+    } else if (cond["conditionType"].get<string>() == "ConstInt") {
+        if (cond.find("equal") != cond.end()) {
+            return new llvm::slicing::ConstConstraint(ConstConstraint::EQUAL, cond["equal"].get<int>(), type);
+        } else if (cond.find("greater") != cond.end()) {
+            return new llvm::slicing::ConstConstraint(ConstConstraint::GREATER, cond["greater"].get<int>(), type);
+        } else if (cond.find("loreq") != cond.end()) {
+            return new llvm::slicing::ConstConstraint(ConstConstraint::LOREQ, cond["loreq"].get<int>(), type);
+        }else if (cond.find("lorneq") != cond.end()) {
+            return new llvm::slicing::ConstConstraint(ConstConstraint::LORNEQ, cond["lorneq"].get<int>(), type);
+        } else {
+            return new llvm::slicing::ConstConstraint(ConstConstraint::ANY, 0, type);
+        }
+    } else if (cond["conditionType"].get<string>() == "NOT") {
+        ChainConstraint *notChain = new llvm::slicing::ChainConstraint(Constraint::STRICT, ChainConstraint::NOT_AND);
+        for (auto &subCond : cond["conditions"]) {
+            notChain->addConstraint(parseCondition(subCond));
+        }
+        return notChain;
+    } else {
+        llvm_unreachable("");
+    }
+    return nullptr;
+}
+
+std::vector<Rule*> llvm::slicing::parseRules() {
+    if (RulesFile.size() == 0) {
+        errs() << "No rule specified\n";
+        llvm_unreachable("No rules specified");
+    }
+    std::ifstream inFile;
+    inFile.open(RulesFile);//open the input file
+
+    if (!inFile.is_open()) {
+        errs() << "Cant find rule file\n";
+        llvm_unreachable("");
+    }
+
+//    std::string content((std::istreambuf_iterator<char>(inFile)), std::istreambuf_iterator<char>());
+
+    json j = json::parse(inFile);
+    std::vector<Rule*> rules;
+
+    if (!j.is_array()) {
+//        errs() << content;
+        llvm_unreachable("malformed rules");
+    }
+    for (size_t i = 0; i < j.size(); ++i) {
+        if (j[i].find("calls") != j[i].end()) {
+            if (!j[i]["calls"].is_array()) {
+                llvm_unreachable("malformed rules");
+            }
+
+            string callsName = j[i]["name"];
+
+            for (auto &c : j[i]["calls"]) {
+                if (c.find("name") == c.end() || c.find("parameter") == c.end()) {
+                    errs() << c.dump() << "\n";
+                    llvm_unreachable("malformed rules");
+                }
+                string name = c["name"].get<string>();
+                string parameter = c["parameter"];
+
+                Parameter::ParameterType type = Parameter::PRE;
+                if (c.find("type") != c.end()) {
+                    llvm_unreachable("TODO");
+                }
+
+                uint64_t regNo = translateRegister(parameter);
+
+                llvm::slicing::Parameter p(name, regNo, type);
+
+                callMap[callsName].push_back(p);
+            }
+        }
+    }
+
+    for (auto &rule: j) {
+        Rule *r = parseRule(rule, false);
+        if (r) {
+            rules.push_back(r);
+        }
+//        if (rule.find("name") == rule.end() ||
+//                rule.find("conditions") == rule.end() ||
+//                rule.find("criterion") == rule.end()) {
+//            continue;
+//        }
+//
+//        if (!rule["conditions"].is_array()) {
+//            llvm_unreachable("malformed");
+//        }
+//
+//        vector<Rule*> preConditions;
+//
+//
+//
+//        for (auto &cond : rule["conditions"]) {
+//            string type = cond["type"];
+//            if (type != "PRE")
+//                continue;
+//            Rule *r = new Rule("", Constraint::PRECONDITION, ChainConstraint::AND);
+//
+//            if (cond["conditionType"].get<string>() == "ConstInt") {
+//                if (cond.find("equal") != cond.end()) {
+//                    r->addConstraint(new llvm::slicing::ConstConstraint(ConstConstraint::EQUAL, cond["equal"].get<int>(), Constraint::PRECONDITION));
+//                } else if (cond.find("greater") != cond.end()) {
+//                    r->addConstraint(new llvm::slicing::ConstConstraint(ConstConstraint::GREATER, cond["greater"].get<int>(), Constraint::PRECONDITION));
+//                } else {
+//                    errs() << cond.dump() << "\n";
+//                    llvm_unreachable("");
+//                }
+//            } else {
+//                llvm_unreachable("");
+//            }
+//
+//            if (cond["calls"].is_string()) {
+//                if (callMap.find(cond["calls"].get<string>()) == callMap.end()) {
+//                    errs() << cond["calls"].get<string>() << "\n";
+//                    llvm_unreachable("malformed");
+//                }
+//
+//                for (auto &p : callMap[cond["calls"].get<string>()]) {
+//                    r->addCriterion(p, {});
+//                }
+//
+//            }
+//
+//            preConditions.push_back(r);
+//        }
+//
+//        Rule *r = new Rule(rule["name"].get<string>(), Constraint::STRICT, ChainConstraint::OR);
+//
+//        if (rule["criterion"].is_string()) {
+//            if (callMap.find(rule["criterion"].get<string>()) == callMap.end()) {
+//                errs() << rule["criterion"].dump() << "\n";
+//                llvm_unreachable("");
+//            }
+//            for (auto &p : callMap[rule["criterion"]]) {
+//                r->addCriterion(p, preConditions);
+//            }
+//        } else if (rule["criterion"].is_array()) {
+//            for (auto &param : rule["criterion"]) {
+//                Parameter::ParameterType type = Parameter::PRE;
+//                if (param.find("type") != param.end()) {
+//                    llvm_unreachable("TODO");
+//                }
+//                r->addCriterion(Parameter(param["name"].get<string>(), translateRegister(param["parameter"].get<string>()), type), preConditions);
+//            }
+//        } else {
+//            llvm_unreachable("");
+//        }
+//
+//        for (auto &cond : rule["conditions"]) {
+//            string type = cond["type"];
+//            if (type == "PRE") {
+//                continue;
+//            }
+//
+//            if (cond.find("calls") != cond.end()) {
+//                ChainConstraint *orConstraint = new ChainConstraint(Constraint::STRICT, ChainConstraint::OR);
+//
+//                if (callMap.find(cond["calls"].get<string>()) == callMap.end()) {
+//                    errs() << cond["calls"].dump() << "\n";
+//                    llvm_unreachable("");
+//                }
+//                for (auto &p : callMap[cond["calls"].get<string>()]) {
+//                    CallConstraint *constr = new CallConstraint(Constraint::STRICT, p.getFunctionName());
+//                    orConstraint->addConstraint(constr);
+//                }
+//
+//                r->addConstraint(orConstraint);
+//            } else if (cond.find("conditionType") != cond.end()) {
+//                if (cond["conditionType"] == "ConstInt") {
+//                    if (cond.find("equal") != cond.end()) {
+//                        r->addConstraint(new llvm::slicing::ConstConstraint(ConstConstraint::EQUAL, cond["equal"].get<int>(), Constraint::STRICT));
+//                    } else if (cond.find("greater") != cond.end()) {
+//                        r->addConstraint(new llvm::slicing::ConstConstraint(ConstConstraint::GREATER, cond["greater"].get<int>(), Constraint::STRICT));
+//                    } else if (cond.find("loreq") != cond.end()) {
+//                        r->addConstraint(new llvm::slicing::ConstConstraint(ConstConstraint::LOREQ, cond["loreq"].get<int>(), Constraint::STRICT));
+//                    }else if (cond.find("lorneq") != cond.end()) {
+//                        r->addConstraint(new llvm::slicing::ConstConstraint(ConstConstraint::LORNEQ, cond["lorneq"].get<int>(), Constraint::STRICT));
+//                    } else {
+//                        errs() << cond.dump() << "\n";
+//                        llvm_unreachable("");
+//                    }
+//                }
+//            }
+//        }
+//
+//        rules.push_back(r);
+    }
+    return rules;
+}
diff --git a/lib/LLVMSlicer/Backtrack/Rule.h b/lib/LLVMSlicer/Backtrack/Rule.h
new file mode 100644
index 0000000..3dc70fe
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/Rule.h
@@ -0,0 +1,22 @@
+#ifndef LLVM_RULE_H
+#define LLVM_RULE_H
+
+#include <string>
+#include <set>
+#include <assert.h>
+
+#include "Path.h"
+
+namespace llvm {
+
+    class Instruction;
+
+    namespace slicing {
+
+        class Rule;
+
+        std::vector<Rule*> parseRules();
+    }
+}
+
+#endif //LLVM_RULE_H
diff --git a/lib/LLVMSlicer/Backtrack/json.hpp b/lib/LLVMSlicer/Backtrack/json.hpp
new file mode 100644
index 0000000..da10ca6
--- /dev/null
+++ b/lib/LLVMSlicer/Backtrack/json.hpp
@@ -0,0 +1,8638 @@
+/*
+    __ _____ _____ _____
+ __|  |   __|     |   | |  JSON for Modern C++
+|  |  |__   |  |  | | | |  version 2.0.0
+|_____|_____|_____|_|___|  https://github.com/nlohmann/json
+
+Copyright (c) 2013-2016 Niels Lohmann <http://nlohmann.me>.
+Licensed under the MIT License <http://opensource.org/licenses/MIT>.
+*/
+
+#ifndef NLOHMANN_JSON_HPP
+#define NLOHMANN_JSON_HPP
+
+#include <algorithm>
+#include <array>
+#include <cassert>
+#include <ciso646>
+#include <cmath>
+#include <cstddef>
+#include <cstdio>
+#include <cstdlib>
+#include <functional>
+#include <initializer_list>
+#include <iomanip>
+#include <iostream>
+#include <iterator>
+#include <limits>
+#include <map>
+#include <memory>
+#include <sstream>
+#include <stdexcept>
+#include <string>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+// enable ssize_t on MinGW
+#ifdef __GNUC__
+#ifdef __MINGW32__
+#include <sys/types.h>
+#endif
+#endif
+
+// disable float-equal warnings on GCC/clang
+#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wfloat-equal"
+#endif
+
+// enable ssize_t for MSVC
+#ifdef _MSC_VER
+#include <basetsd.h>
+    using ssize_t = SSIZE_T;
+#endif
+
+/*!
+@brief namespace for Niels Lohmann
+@see https://github.com/nlohmann
+@since version 1.0.0
+*/
+namespace nlohmann
+{
+
+
+/*!
+@brief unnamed namespace with internal helper functions
+@since version 1.0.0
+*/
+    namespace
+    {
+/*!
+@brief Helper to determine whether there's a key_type for T.
+@sa http://stackoverflow.com/a/7728728/266378
+*/
+        template<typename T>
+        struct has_mapped_type
+        {
+        private:
+            template<typename C> static char test(typename C::mapped_type*);
+            template<typename C> static char (&test(...))[2];
+        public:
+            static constexpr bool value = sizeof(test<T>(0)) == 1;
+        };
+
+    }
+
+/*!
+@brief a class to store JSON values
+
+@tparam ObjectType type for JSON objects (`std::map` by default; will be used
+in @ref object_t)
+@tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
+in @ref array_t)
+@tparam StringType type for JSON strings and object keys (`std::string` by
+default; will be used in @ref string_t)
+@tparam BooleanType type for JSON booleans (`bool` by default; will be used
+in @ref boolean_t)
+@tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
+default; will be used in @ref number_integer_t)
+@tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
+`uint64_t` by default; will be used in @ref number_unsigned_t)
+@tparam NumberFloatType type for JSON floating-point numbers (`double` by
+default; will be used in @ref number_float_t)
+@tparam AllocatorType type of the allocator to use (`std::allocator` by
+default)
+
+@requirement The class satisfies the following concept requirements:
+- Basic
+ - [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible):
+   JSON values can be default constructed. The result will be a JSON null value.
+ - [MoveConstructible](http://en.cppreference.com/w/cpp/concept/MoveConstructible):
+   A JSON value can be constructed from an rvalue argument.
+ - [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible):
+   A JSON value can be copy-constructed from an lvalue expression.
+ - [MoveAssignable](http://en.cppreference.com/w/cpp/concept/MoveAssignable):
+   A JSON value van be assigned from an rvalue argument.
+ - [CopyAssignable](http://en.cppreference.com/w/cpp/concept/CopyAssignable):
+   A JSON value can be copy-assigned from an lvalue expression.
+ - [Destructible](http://en.cppreference.com/w/cpp/concept/Destructible):
+   JSON values can be destructed.
+- Layout
+ - [StandardLayoutType](http://en.cppreference.com/w/cpp/concept/StandardLayoutType):
+   JSON values have
+   [standard layout](http://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
+   All non-static data members are private and standard layout types, the class
+   has no virtual functions or (virtual) base classes.
+- Library-wide
+ - [EqualityComparable](http://en.cppreference.com/w/cpp/concept/EqualityComparable):
+   JSON values can be compared with `==`, see @ref
+   operator==(const_reference,const_reference).
+ - [LessThanComparable](http://en.cppreference.com/w/cpp/concept/LessThanComparable):
+   JSON values can be compared with `<`, see @ref
+   operator<(const_reference,const_reference).
+ - [Swappable](http://en.cppreference.com/w/cpp/concept/Swappable):
+   Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
+   other compatible types, using unqualified function call @ref swap().
+ - [NullablePointer](http://en.cppreference.com/w/cpp/concept/NullablePointer):
+   JSON values can be compared against `std::nullptr_t` objects which are used
+   to model the `null` value.
+- Container
+ - [Container](http://en.cppreference.com/w/cpp/concept/Container):
+   JSON values can be used like STL containers and provide iterator access.
+ - [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer);
+   JSON values can be used like STL containers and provide reverse iterator
+   access.
+
+@internal
+@note ObjectType trick from http://stackoverflow.com/a/9860911
+@endinternal
+
+@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
+Format](http://rfc7159.net/rfc7159)
+
+@since version 1.0.0
+
+@nosubgrouping
+*/
+    template <
+            template<typename U, typename V, typename... Args> class ObjectType = std::map,
+            template<typename U, typename... Args> class ArrayType = std::vector,
+            class StringType = std::string,
+            class BooleanType = bool,
+            class NumberIntegerType = int64_t,
+            class NumberUnsignedType = uint64_t,
+            class NumberFloatType = double,
+            template<typename U> class AllocatorType = std::allocator
+    >
+    class basic_json
+    {
+    private:
+        /// workaround type for MSVC
+        using basic_json_t = basic_json<ObjectType,
+                ArrayType,
+                StringType,
+                BooleanType,
+                NumberIntegerType,
+                NumberUnsignedType,
+                NumberFloatType,
+                AllocatorType>;
+
+    public:
+
+        /////////////////////
+        // container types //
+        /////////////////////
+
+        /// @name container types
+        /// @{
+
+        /// the type of elements in a basic_json container
+        using value_type = basic_json;
+
+        /// the type of an element reference
+        using reference = value_type&;
+        /// the type of an element const reference
+        using const_reference = const value_type&;
+
+        /// a type to represent differences between iterators
+        using difference_type = std::ptrdiff_t;
+        /// a type to represent container sizes
+        using size_type = std::size_t;
+
+        /// the allocator type
+        using allocator_type = AllocatorType<basic_json>;
+
+        /// the type of an element pointer
+        using pointer = typename std::allocator_traits<allocator_type>::pointer;
+        /// the type of an element const pointer
+        using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;
+
+        // forward declaration
+        template<typename Base> class json_reverse_iterator;
+
+        /// an iterator for a basic_json container
+        class iterator;
+        /// a const iterator for a basic_json container
+        class const_iterator;
+        /// a reverse iterator for a basic_json container
+        using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
+        /// a const reverse iterator for a basic_json container
+        using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;
+
+        /// @}
+
+
+        /*!
+    @brief returns the allocator associated with the container
+    */
+        static allocator_type get_allocator()
+        {
+            return allocator_type();
+        }
+
+
+        ///////////////////////////
+        // JSON value data types //
+        ///////////////////////////
+
+        /// @name JSON value data types
+        /// @{
+
+        /*!
+    @brief a type for an object
+
+    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
+    > An object is an unordered collection of zero or more name/value pairs,
+    > where a name is a string and a value is a string, number, boolean, null,
+    > object, or array.
+
+    To store objects in C++, a type is defined by the template parameters
+    described below.
+
+    @tparam ObjectType  the container to store objects (e.g., `std::map` or
+    `std::unordered_map`)
+    @tparam StringType the type of the keys or names (e.g., `std::string`). The
+    comparison function `std::less<StringType>` is used to order elements
+    inside the container.
+    @tparam AllocatorType the allocator to use for objects (e.g.,
+    `std::allocator`)
+
+    #### Default type
+
+    With the default values for @a ObjectType (`std::map`), @a StringType
+    (`std::string`), and @a AllocatorType (`std::allocator`), the default value
+    for @a object_t is:
+
+    @code {.cpp}
+    std::map<
+      std::string, // key_type
+      basic_json, // value_type
+      std::less<std::string>, // key_compare
+      std::allocator<std::pair<const std::string, basic_json>> // allocator_type
+    >
+    @endcode
+
+    #### Behavior
+
+    The choice of @a object_t influences the behavior of the JSON class. With
+    the default type, objects have the following behavior:
+
+    - When all names are unique, objects will be interoperable in the sense
+      that all software implementations receiving that object will agree on the
+      name-value mappings.
+    - When the names within an object are not unique, later stored name/value
+      pairs overwrite previously stored name/value pairs, leaving the used
+      names unique. For instance, `{"key": 1}` and `{"key": 2, "key": 1}` will
+      be treated as equal and both stored as `{"key": 1}`.
+    - Internally, name/value pairs are stored in lexicographical order of the
+      names. Objects will also be serialized (see @ref dump) in this order. For
+      instance, `{"b": 1, "a": 2}` and `{"a": 2, "b": 1}` will be stored and
+      serialized as `{"a": 2, "b": 1}`.
+    - When comparing objects, the order of the name/value pairs is irrelevant.
+      This makes objects interoperable in the sense that they will not be
+      affected by these differences. For instance, `{"b": 1, "a": 2}` and
+      `{"a": 2, "b": 1}` will be treated as equal.
+
+    #### Limits
+
+    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
+    > An implementation may set limits on the maximum depth of nesting.
+
+    In this class, the object's limit of nesting is not constraint explicitly.
+    However, a maximum depth of nesting may be introduced by the compiler or
+    runtime environment. A theoretical limit can be queried by calling the @ref
+    max_size function of a JSON object.
+
+    #### Storage
+
+    Objects are stored as pointers in a @ref basic_json type. That is, for any
+    access to object values, a pointer of type `object_t*` must be dereferenced.
+
+    @sa @ref array_t -- type for an array value
+
+    @since version 1.0.0
+
+    @note The order name/value pairs are added to the object is *not* preserved
+    by the library. Therefore, iterating an object may return name/value pairs
+    in a different order than they were originally stored. In fact, keys will
+    be traversed in alphabetical order as `std::map` with `std::less` is used
+    by default. Please note this behavior conforms to [RFC
+    7159](http://rfc7159.net/rfc7159), because any order implements the
+    specified "unordered" nature of JSON objects.
+    */
+        using object_t = ObjectType<StringType,
+                basic_json,
+                std::less<StringType>,
+                AllocatorType<std::pair<const StringType,
+                        basic_json>>>;
+
+        /*!
+    @brief a type for an array
+
+    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
+    > An array is an ordered sequence of zero or more values.
+
+    To store objects in C++, a type is defined by the template parameters
+    explained below.
+
+    @tparam ArrayType  container type to store arrays (e.g., `std::vector` or
+    `std::list`)
+    @tparam AllocatorType  allocator to use for arrays (e.g., `std::allocator`)
+
+    #### Default type
+
+    With the default values for @a ArrayType (`std::vector`) and @a
+    AllocatorType (`std::allocator`), the default value for @a array_t is:
+
+    @code {.cpp}
+    std::vector<
+      basic_json, // value_type
+      std::allocator<basic_json> // allocator_type
+    >
+    @endcode
+
+    #### Limits
+
+    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
+    > An implementation may set limits on the maximum depth of nesting.
+
+    In this class, the array's limit of nesting is not constraint explicitly.
+    However, a maximum depth of nesting may be introduced by the compiler or
+    runtime environment. A theoretical limit can be queried by calling the @ref
+    max_size function of a JSON array.
+
+    #### Storage
+
+    Arrays are stored as pointers in a @ref basic_json type. That is, for any
+    access to array values, a pointer of type `array_t*` must be dereferenced.
+
+    @sa @ref object_t -- type for an object value
+
+    @since version 1.0.0
+    */
+        using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;
+
+        /*!
+    @brief a type for a string
+
+    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
+    > A string is a sequence of zero or more Unicode characters.
+
+    To store objects in C++, a type is defined by the template parameter
+    described below. Unicode values are split by the JSON class into byte-sized
+    characters during deserialization.
+
+    @tparam StringType  the container to store strings (e.g., `std::string`).
+    Note this container is used for keys/names in objects, see @ref object_t.
+
+    #### Default type
+
+    With the default values for @a StringType (`std::string`), the default
+    value for @a string_t is:
+
+    @code {.cpp}
+    std::string
+    @endcode
+
+    #### String comparison
+
+    [RFC 7159](http://rfc7159.net/rfc7159) states:
+    > Software implementations are typically required to test names of object
+    > members for equality. Implementations that transform the textual
+    > representation into sequences of Unicode code units and then perform the
+    > comparison numerically, code unit by code unit, are interoperable in the
+    > sense that implementations will agree in all cases on equality or
+    > inequality of two strings. For example, implementations that compare
+    > strings with escaped characters unconverted may incorrectly find that
+    > `"a\\b"` and `"a\u005Cb"` are not equal.
+
+    This implementation is interoperable as it does compare strings code unit
+    by code unit.
+
+    #### Storage
+
+    String values are stored as pointers in a @ref basic_json type. That is,
+    for any access to string values, a pointer of type `string_t*` must be
+    dereferenced.
+
+    @since version 1.0.0
+    */
+        using string_t = StringType;
+
+        /*!
+    @brief a type for a boolean
+
+    [RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
+    type which differentiates the two literals `true` and `false`.
+
+    To store objects in C++, a type is defined by the template parameter @a
+    BooleanType which chooses the type to use.
+
+    #### Default type
+
+    With the default values for @a BooleanType (`bool`), the default value for
+    @a boolean_t is:
+
+    @code {.cpp}
+    bool
+    @endcode
+
+    #### Storage
+
+    Boolean values are stored directly inside a @ref basic_json type.
+
+    @since version 1.0.0
+    */
+        using boolean_t = BooleanType;
+
+        /*!
+    @brief a type for a number (integer)
+
+    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
+    > The representation of numbers is similar to that used in most programming
+    > languages. A number is represented in base 10 using decimal digits. It
+    > contains an integer component that may be prefixed with an optional minus
+    > sign, which may be followed by a fraction part and/or an exponent part.
+    > Leading zeros are not allowed. (...) Numeric values that cannot be
+    > represented in the grammar below (such as Infinity and NaN) are not
+    > permitted.
+
+    This description includes both integer and floating-point numbers. However,
+    C++ allows more precise storage if it is known whether the number is a
+    signed integer, an unsigned integer or a floating-point number. Therefore,
+    three different types, @ref number_integer_t, @ref number_unsigned_t and
+    @ref number_float_t are used.
+
+    To store integer numbers in C++, a type is defined by the template
+    parameter @a NumberIntegerType which chooses the type to use.
+
+    #### Default type
+
+    With the default values for @a NumberIntegerType (`int64_t`), the default
+    value for @a number_integer_t is:
+
+    @code {.cpp}
+    int64_t
+    @endcode
+
+    #### Default behavior
+
+    - The restrictions about leading zeros is not enforced in C++. Instead,
+      leading zeros in integer literals lead to an interpretation as octal
+      number. Internally, the value will be stored as decimal number. For
+      instance, the C++ integer literal `010` will be serialized to `8`. During
+      deserialization, leading zeros yield an error.
+    - Not-a-number (NaN) values will be serialized to `null`.
+
+    #### Limits
+
+    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
+    > An implementation may set limits on the range and precision of numbers.
+
+    When the default type is used, the maximal integer number that can be
+    stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
+    that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
+    that are out of range will yield over/underflow when used in a constructor.
+    During deserialization, too large or small integer numbers will be
+    automatically be stored as @ref number_unsigned_t or @ref number_float_t.
+
+    [RFC 7159](http://rfc7159.net/rfc7159) further states:
+    > Note that when such software is used, numbers that are integers and are
+    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
+    > that implementations will agree exactly on their numeric values.
+
+    As this range is a subrange of the exactly supported range [INT64_MIN,
+    INT64_MAX], this class's integer type is interoperable.
+
+    #### Storage
+
+    Integer number values are stored directly inside a @ref basic_json type.
+
+    @sa @ref number_float_t -- type for number values (floating-point)
+
+    @sa @ref number_unsigned_t -- type for number values (unsigned integer)
+
+    @since version 1.0.0
+    */
+        using number_integer_t = NumberIntegerType;
+
+        /*!
+    @brief a type for a number (unsigned)
+
+    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
+    > The representation of numbers is similar to that used in most programming
+    > languages. A number is represented in base 10 using decimal digits. It
+    > contains an integer component that may be prefixed with an optional minus
+    > sign, which may be followed by a fraction part and/or an exponent part.
+    > Leading zeros are not allowed. (...) Numeric values that cannot be
+    > represented in the grammar below (such as Infinity and NaN) are not
+    > permitted.
+
+    This description includes both integer and floating-point numbers. However,
+    C++ allows more precise storage if it is known whether the number is a
+    signed integer, an unsigned integer or a floating-point number. Therefore,
+    three different types, @ref number_integer_t, @ref number_unsigned_t and
+    @ref number_float_t are used.
+
+    To store unsigned integer numbers in C++, a type is defined by the template
+    parameter @a NumberUnsignedType which chooses the type to use.
+
+    #### Default type
+
+    With the default values for @a NumberUnsignedType (`uint64_t`), the default
+    value for @a number_unsigned_t is:
+
+    @code {.cpp}
+    uint64_t
+    @endcode
+
+    #### Default behavior
+
+    - The restrictions about leading zeros is not enforced in C++. Instead,
+      leading zeros in integer literals lead to an interpretation as octal
+      number. Internally, the value will be stored as decimal number. For
+      instance, the C++ integer literal `010` will be serialized to `8`. During
+      deserialization, leading zeros yield an error.
+    - Not-a-number (NaN) values will be serialized to `null`.
+
+    #### Limits
+
+    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
+    > An implementation may set limits on the range and precision of numbers.
+
+    When the default type is used, the maximal integer number that can be
+    stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
+    number that can be stored is `0`. Integer numbers that are out of range
+    will yield over/underflow when used in a constructor. During
+    deserialization, too large or small integer numbers will be automatically
+    be stored as @ref number_integer_t or @ref number_float_t.
+
+    [RFC 7159](http://rfc7159.net/rfc7159) further states:
+    > Note that when such software is used, numbers that are integers and are
+    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
+    > that implementations will agree exactly on their numeric values.
+
+    As this range is a subrange (when considered in conjunction with the
+    number_integer_t type) of the exactly supported range [0, UINT64_MAX], this
+    class's integer type is interoperable.
+
+    #### Storage
+
+    Integer number values are stored directly inside a @ref basic_json type.
+
+    @sa @ref number_float_t -- type for number values (floating-point)
+
+    @sa @ref number_integer_t -- type for number values (integer)
+
+    @since version 2.0.0
+    */
+        using number_unsigned_t = NumberUnsignedType;
+
+        /*!
+    @brief a type for a number (floating-point)
+
+    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
+    > The representation of numbers is similar to that used in most programming
+    > languages. A number is represented in base 10 using decimal digits. It
+    > contains an integer component that may be prefixed with an optional minus
+    > sign, which may be followed by a fraction part and/or an exponent part.
+    > Leading zeros are not allowed. (...) Numeric values that cannot be
+    > represented in the grammar below (such as Infinity and NaN) are not
+    > permitted.
+
+    This description includes both integer and floating-point numbers. However,
+    C++ allows more precise storage if it is known whether the number is a
+    signed integer, an unsigned integer or a floating-point number. Therefore,
+    three different types, @ref number_integer_t, @ref number_unsigned_t and
+    @ref number_float_t are used.
+
+    To store floating-point numbers in C++, a type is defined by the template
+    parameter @a NumberFloatType which chooses the type to use.
+
+    #### Default type
+
+    With the default values for @a NumberFloatType (`double`), the default
+    value for @a number_float_t is:
+
+    @code {.cpp}
+    double
+    @endcode
+
+    #### Default behavior
+
+    - The restrictions about leading zeros is not enforced in C++. Instead,
+      leading zeros in floating-point literals will be ignored. Internally, the
+      value will be stored as decimal number. For instance, the C++
+      floating-point literal `01.2` will be serialized to `1.2`. During
+      deserialization, leading zeros yield an error.
+    - Not-a-number (NaN) values will be serialized to `null`.
+
+    #### Limits
+
+    [RFC 7159](http://rfc7159.net/rfc7159) states:
+    > This specification allows implementations to set limits on the range and
+    > precision of numbers accepted. Since software that implements IEEE
+    > 754-2008 binary64 (double precision) numbers is generally available and
+    > widely used, good interoperability can be achieved by implementations that
+    > expect no more precision or range than these provide, in the sense that
+    > implementations will approximate JSON numbers within the expected
+    > precision.
+
+    This implementation does exactly follow this approach, as it uses double
+    precision floating-point numbers. Note values smaller than
+    `-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
+    will be stored as NaN internally and be serialized to `null`.
+
+    #### Storage
+
+    Floating-point number values are stored directly inside a @ref basic_json
+    type.
+
+    @sa @ref number_integer_t -- type for number values (integer)
+
+    @sa @ref number_unsigned_t -- type for number values (unsigned integer)
+
+    @since version 1.0.0
+    */
+        using number_float_t = NumberFloatType;
+
+        /// @}
+
+
+        ///////////////////////////
+        // JSON type enumeration //
+        ///////////////////////////
+
+        /*!
+    @brief the JSON type enumeration
+
+    This enumeration collects the different JSON types. It is internally used
+    to distinguish the stored values, and the functions @ref is_null(), @ref
+    is_object(), @ref is_array(), @ref is_string(), @ref is_boolean(), @ref
+    is_number(), and @ref is_discarded() rely on it.
+
+    @since version 1.0.0
+    */
+        enum class value_t : uint8_t
+        {
+            null,            ///< null value
+            object,          ///< object (unordered set of name/value pairs)
+            array,           ///< array (ordered collection of values)
+            string,          ///< string value
+            boolean,         ///< boolean value
+            number_integer,  ///< number value (integer)
+            number_unsigned, ///< number value (unsigned integer)
+            number_float,    ///< number value (floating-point)
+            discarded        ///< discarded by the the parser callback function
+        };
+
+
+    private:
+        /// helper for exception-safe object creation
+        template<typename T, typename... Args>
+        static T* create(Args&& ... args)
+        {
+            AllocatorType<T> alloc;
+            auto deleter = [&](T * object)
+            {
+                alloc.deallocate(object, 1);
+            };
+            std::unique_ptr<T, decltype(deleter)> object(alloc.allocate(1), deleter);
+            alloc.construct(object.get(), std::forward<Args>(args)...);
+            return object.release();
+        }
+
+        ////////////////////////
+        // JSON value storage //
+        ////////////////////////
+
+        /*!
+    @brief a JSON value
+
+    The actual storage for a JSON value of the @ref basic_json class.
+
+    @since version 1.0.0
+    */
+        union json_value
+        {
+            /// object (stored with pointer to save storage)
+            object_t* object;
+            /// array (stored with pointer to save storage)
+            array_t* array;
+            /// string (stored with pointer to save storage)
+            string_t* string;
+            /// boolean
+            boolean_t boolean;
+            /// number (integer)
+            number_integer_t number_integer;
+            /// number (unsigned integer)
+            number_unsigned_t number_unsigned;
+            /// number (floating-point)
+            number_float_t number_float;
+
+            /// default constructor (for null values)
+            json_value() noexcept = default;
+            /// constructor for booleans
+            json_value(boolean_t v) noexcept : boolean(v) {}
+            /// constructor for numbers (integer)
+            json_value(number_integer_t v) noexcept : number_integer(v) {}
+            /// constructor for numbers (unsigned)
+            json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
+            /// constructor for numbers (floating-point)
+            json_value(number_float_t v) noexcept : number_float(v) {}
+            /// constructor for empty values of a given type
+            json_value(value_t t)
+            {
+                switch (t)
+                {
+                    case value_t::object:
+                    {
+                        object = create<object_t>();
+                        break;
+                    }
+
+                    case value_t::array:
+                    {
+                        array = create<array_t>();
+                        break;
+                    }
+
+                    case value_t::string:
+                    {
+                        string = create<string_t>("");
+                        break;
+                    }
+
+                    case value_t::boolean:
+                    {
+                        boolean = boolean_t(false);
+                        break;
+                    }
+
+                    case value_t::number_integer:
+                    {
+                        number_integer = number_integer_t(0);
+                        break;
+                    }
+
+                    case value_t::number_unsigned:
+                    {
+                        number_unsigned = number_unsigned_t(0);
+                        break;
+                    }
+
+                    case value_t::number_float:
+                    {
+                        number_float = number_float_t(0.0);
+                        break;
+                    }
+
+                    default:
+                    {
+                        break;
+                    }
+                }
+            }
+
+            /// constructor for strings
+            json_value(const string_t& value)
+            {
+                string = create<string_t>(value);
+            }
+
+            /// constructor for objects
+            json_value(const object_t& value)
+            {
+                object = create<object_t>(value);
+            }
+
+            /// constructor for arrays
+            json_value(const array_t& value)
+            {
+                array = create<array_t>(value);
+            }
+        };
+
+
+    public:
+        //////////////////////////
+        // JSON parser callback //
+        //////////////////////////
+
+        /*!
+    @brief JSON callback events
+
+    This enumeration lists the parser events that can trigger calling a
+    callback function of type @ref parser_callback_t during parsing.
+
+    @since version 1.0.0
+    */
+        enum class parse_event_t : uint8_t
+        {
+            /// the parser read `{` and started to process a JSON object
+                    object_start,
+            /// the parser read `}` and finished processing a JSON object
+                    object_end,
+            /// the parser read `[` and started to process a JSON array
+                    array_start,
+            /// the parser read `]` and finished processing a JSON array
+                    array_end,
+            /// the parser read a key of a value in an object
+                    key,
+            /// the parser finished reading a JSON value
+                    value
+        };
+
+        /*!
+    @brief per-element parser callback type
+
+    With a parser callback function, the result of parsing a JSON text can be
+    influenced. When passed to @ref parse(std::istream&, parser_callback_t) or
+    @ref parse(const string_t&, parser_callback_t), it is called on certain
+    events (passed as @ref parse_event_t via parameter @a event) with a set
+    recursion depth @a depth and context JSON value @a parsed. The return value
+    of the callback function is a boolean indicating whether the element that
+    emitted the callback shall be kept or not.
+
+    We distinguish six scenarios (determined by the event type) in which the
+    callback function can be called. The following table describes the values
+    of the parameters @a depth, @a event, and @a parsed.
+
+    parameter @a event | description | parameter @a depth | parameter @a parsed
+    ------------------ | ----------- | ------------------ | -------------------
+    parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
+    parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
+    parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
+    parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
+    parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
+    parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value
+
+    Discarding a value (i.e., returning `false`) has different effects
+    depending on the context in which function was called:
+
+    - Discarded values in structured types are skipped. That is, the parser
+      will behave as if the discarded value was never read.
+    - In case a value outside a structured type is skipped, it is replaced with
+      `null`. This case happens if the top-level element is skipped.
+
+    @param[in] depth  the depth of the recursion during parsing
+
+    @param[in] event  an event of type parse_event_t indicating the context in
+    the callback function has been called
+
+    @param[in,out] parsed  the current intermediate parse result; note that
+    writing to this value has no effect for parse_event_t::key events
+
+    @return Whether the JSON value which called the function during parsing
+    should be kept (`true`) or not (`false`). In the latter case, it is either
+    skipped completely or replaced by an empty discarded object.
+
+    @sa @ref parse(std::istream&, parser_callback_t) or
+    @ref parse(const string_t&, parser_callback_t) for examples
+
+    @since version 1.0.0
+    */
+        using parser_callback_t = std::function<bool(int depth, parse_event_t event, basic_json& parsed)>;
+
+
+        //////////////////
+        // constructors //
+        //////////////////
+
+        /// @name constructors and destructors
+        /// @{
+
+        /*!
+    @brief create an empty value with a given type
+
+    Create an empty JSON value with a given type. The value will be default
+    initialized with an empty value which depends on the type:
+
+    Value type  | initial value
+    ----------- | -------------
+    null        | `null`
+    boolean     | `false`
+    string      | `""`
+    number      | `0`
+    object      | `{}`
+    array       | `[]`
+
+    @param[in] value_type  the type of the value to create
+
+    @complexity Constant.
+
+    @throw std::bad_alloc if allocation for object, array, or string value
+    fails
+
+    @liveexample{The following code shows the constructor for different @ref
+    value_t values,basic_json__value_t}
+
+    @sa @ref basic_json(std::nullptr_t) -- create a `null` value
+    @sa @ref basic_json(boolean_t value) -- create a boolean value
+    @sa @ref basic_json(const string_t&) -- create a string value
+    @sa @ref basic_json(const object_t&) -- create a object value
+    @sa @ref basic_json(const array_t&) -- create a array value
+    @sa @ref basic_json(const number_float_t) -- create a number
+    (floating-point) value
+    @sa @ref basic_json(const number_integer_t) -- create a number (integer)
+    value
+    @sa @ref basic_json(const number_unsigned_t) -- create a number (unsigned)
+    value
+
+    @since version 1.0.0
+    */
+        basic_json(const value_t value_type)
+                : m_type(value_type), m_value(value_type)
+        {}
+
+        /*!
+    @brief create a null object (implicitly)
+
+    Create a `null` JSON value. This is the implicit version of the `null`
+    value constructor as it takes no parameters.
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is constant.
+    - As postcondition, it holds: `basic_json().empty() == true`.
+
+    @liveexample{The following code shows the constructor for a `null` JSON
+    value.,basic_json}
+
+    @sa @ref basic_json(std::nullptr_t) -- create a `null` value
+
+    @since version 1.0.0
+    */
+        basic_json() noexcept = default;
+
+        /*!
+    @brief create a null object (explicitly)
+
+    Create a `null` JSON value. This is the explicitly version of the `null`
+    value constructor as it takes a null pointer as parameter. It allows to
+    create `null` values by explicitly assigning a `nullptr` to a JSON value.
+    The passed null pointer itself is not read -- it is only used to choose the
+    right constructor.
+
+    @complexity Constant.
+
+    @liveexample{The following code shows the constructor with null pointer
+    parameter.,basic_json__nullptr_t}
+
+    @sa @ref basic_json() -- default constructor (implicitly creating a `null`
+    value)
+
+    @since version 1.0.0
+    */
+        basic_json(std::nullptr_t) noexcept
+                : basic_json(value_t::null)
+        {}
+
+        /*!
+    @brief create an object (explicit)
+
+    Create an object JSON value with a given content.
+
+    @param[in] val  a value for the object
+
+    @complexity Linear in the size of the passed @a val.
+
+    @throw std::bad_alloc if allocation for object value fails
+
+    @liveexample{The following code shows the constructor with an @ref object_t
+    parameter.,basic_json__object_t}
+
+    @sa @ref basic_json(const CompatibleObjectType&) -- create an object value
+    from a compatible STL container
+
+    @since version 1.0.0
+    */
+        basic_json(const object_t& val)
+                : m_type(value_t::object), m_value(val)
+        {}
+
+        /*!
+    @brief create an object (implicit)
+
+    Create an object JSON value with a given content. This constructor allows
+    any type that can be used to construct values of type @ref object_t.
+    Examples include the types `std::map` and `std::unordered_map`.
+
+    @tparam CompatibleObjectType an object type whose `key_type` and
+    `value_type` is compatible to @ref object_t
+
+    @param[in] val  a value for the object
+
+    @complexity Linear in the size of the passed @a val.
+
+    @throw std::bad_alloc if allocation for object value fails
+
+    @liveexample{The following code shows the constructor with several
+    compatible object type parameters.,basic_json__CompatibleObjectType}
+
+    @sa @ref basic_json(const object_t&) -- create an object value
+
+    @since version 1.0.0
+    */
+        template <class CompatibleObjectType, typename
+        std::enable_if<
+                std::is_constructible<typename object_t::key_type, typename CompatibleObjectType::key_type>::value and
+                std::is_constructible<basic_json, typename CompatibleObjectType::mapped_type>::value, int>::type
+        = 0>
+        basic_json(const CompatibleObjectType& val)
+                : m_type(value_t::object)
+        {
+            using std::begin;
+            using std::end;
+            m_value.object = create<object_t>(begin(val), end(val));
+        }
+
+        /*!
+    @brief create an array (explicit)
+
+    Create an array JSON value with a given content.
+
+    @param[in] val  a value for the array
+
+    @complexity Linear in the size of the passed @a val.
+
+    @throw std::bad_alloc if allocation for array value fails
+
+    @liveexample{The following code shows the constructor with an @ref array_t
+    parameter.,basic_json__array_t}
+
+    @sa @ref basic_json(const CompatibleArrayType&) -- create an array value
+    from a compatible STL containers
+
+    @since version 1.0.0
+    */
+        basic_json(const array_t& val)
+                : m_type(value_t::array), m_value(val)
+        {}
+
+        /*!
+    @brief create an array (implicit)
+
+    Create an array JSON value with a given content. This constructor allows
+    any type that can be used to construct values of type @ref array_t.
+    Examples include the types `std::vector`, `std::list`, and `std::set`.
+
+    @tparam CompatibleArrayType an object type whose `value_type` is compatible
+    to @ref array_t
+
+    @param[in] val  a value for the array
+
+    @complexity Linear in the size of the passed @a val.
+
+    @throw std::bad_alloc if allocation for array value fails
+
+    @liveexample{The following code shows the constructor with several
+    compatible array type parameters.,basic_json__CompatibleArrayType}
+
+    @sa @ref basic_json(const array_t&) -- create an array value
+
+    @since version 1.0.0
+    */
+        template <class CompatibleArrayType, typename
+        std::enable_if<
+                not std::is_same<CompatibleArrayType, typename basic_json_t::iterator>::value and
+                not std::is_same<CompatibleArrayType, typename basic_json_t::const_iterator>::value and
+                not std::is_same<CompatibleArrayType, typename basic_json_t::reverse_iterator>::value and
+                not std::is_same<CompatibleArrayType, typename basic_json_t::const_reverse_iterator>::value and
+                not std::is_same<CompatibleArrayType, typename array_t::iterator>::value and
+                not std::is_same<CompatibleArrayType, typename array_t::const_iterator>::value and
+                std::is_constructible<basic_json, typename CompatibleArrayType::value_type>::value, int>::type
+        = 0>
+        basic_json(const CompatibleArrayType& val)
+                : m_type(value_t::array)
+        {
+            using std::begin;
+            using std::end;
+            m_value.array = create<array_t>(begin(val), end(val));
+        }
+
+        /*!
+    @brief create a string (explicit)
+
+    Create an string JSON value with a given content.
+
+    @param[in] val  a value for the string
+
+    @complexity Linear in the size of the passed @a val.
+
+    @throw std::bad_alloc if allocation for string value fails
+
+    @liveexample{The following code shows the constructor with an @ref string_t
+    parameter.,basic_json__string_t}
+
+    @sa @ref basic_json(const typename string_t::value_type*) -- create a
+    string value from a character pointer
+    @sa @ref basic_json(const CompatibleStringType&) -- create a string value
+    from a compatible string container
+
+    @since version 1.0.0
+    */
+        basic_json(const string_t& val)
+                : m_type(value_t::string), m_value(val)
+        {}
+
+        /*!
+    @brief create a string (explicit)
+
+    Create a string JSON value with a given content.
+
+    @param[in] val  a literal value for the string
+
+    @complexity Linear in the size of the passed @a val.
+
+    @throw std::bad_alloc if allocation for string value fails
+
+    @liveexample{The following code shows the constructor with string literal
+    parameter.,basic_json__string_t_value_type}
+
+    @sa @ref basic_json(const string_t&) -- create a string value
+    @sa @ref basic_json(const CompatibleStringType&) -- create a string value
+    from a compatible string container
+
+    @since version 1.0.0
+    */
+        basic_json(const typename string_t::value_type* val)
+                : basic_json(string_t(val))
+        {}
+
+        /*!
+    @brief create a string (implicit)
+
+    Create a string JSON value with a given content.
+
+    @param[in] val  a value for the string
+
+    @tparam CompatibleStringType an string type which is compatible to @ref
+    string_t
+
+    @complexity Linear in the size of the passed @a val.
+
+    @throw std::bad_alloc if allocation for string value fails
+
+    @liveexample{The following code shows the construction of a string value
+    from a compatible type.,basic_json__CompatibleStringType}
+
+    @sa @ref basic_json(const string_t&) -- create a string value
+    @sa @ref basic_json(const typename string_t::value_type*) -- create a
+    string value from a character pointer
+
+    @since version 1.0.0
+    */
+        template <class CompatibleStringType, typename
+        std::enable_if<
+                std::is_constructible<string_t, CompatibleStringType>::value, int>::type
+        = 0>
+        basic_json(const CompatibleStringType& val)
+                : basic_json(string_t(val))
+        {}
+
+        /*!
+    @brief create a boolean (explicit)
+
+    Creates a JSON boolean type from a given value.
+
+    @param[in] val  a boolean value to store
+
+    @complexity Constant.
+
+    @liveexample{The example below demonstrates boolean
+    values.,basic_json__boolean_t}
+
+    @since version 1.0.0
+    */
+        basic_json(boolean_t val)
+                : m_type(value_t::boolean), m_value(val)
+        {}
+
+        /*!
+    @brief create an integer number (explicit)
+
+    Create an integer number JSON value with a given content.
+
+    @tparam T  helper type to compare number_integer_t and int (not visible in)
+    the interface.
+
+    @param[in] val  an integer to create a JSON number from
+
+    @note This constructor would have the same signature as @ref
+    basic_json(const int value), so we need to switch this one off in case
+    number_integer_t is the same as int. This is done via the helper type @a T.
+
+    @complexity Constant.
+
+    @liveexample{The example below shows the construction of an integer
+    number value.,basic_json__number_integer_t}
+
+    @sa @ref basic_json(const int) -- create a number value (integer)
+    @sa @ref basic_json(const CompatibleNumberIntegerType) -- create a number
+    value (integer) from a compatible number type
+
+    @since version 1.0.0
+    */
+        template<typename T,
+                typename std::enable_if<
+                        not (std::is_same<T, int>::value)
+                        and std::is_same<T, number_integer_t>::value
+                        , int>::type
+                = 0>
+        basic_json(const number_integer_t val)
+                : m_type(value_t::number_integer), m_value(val)
+        {}
+
+        /*!
+    @brief create an integer number from an enum type (explicit)
+
+    Create an integer number JSON value with a given content.
+
+    @param[in] val  an integer to create a JSON number from
+
+    @note This constructor allows to pass enums directly to a constructor. As
+    C++ has no way of specifying the type of an anonymous enum explicitly, we
+    can only rely on the fact that such values implicitly convert to int. As
+    int may already be the same type of number_integer_t, we may need to switch
+    off the constructor @ref basic_json(const number_integer_t).
+
+    @complexity Constant.
+
+    @liveexample{The example below shows the construction of an integer
+    number value from an anonymous enum.,basic_json__const_int}
+
+    @sa @ref basic_json(const number_integer_t) -- create a number value
+    (integer)
+    @sa @ref basic_json(const CompatibleNumberIntegerType) -- create a number
+    value (integer) from a compatible number type
+
+    @since version 1.0.0
+    */
+        basic_json(const int val)
+                : m_type(value_t::number_integer),
+                  m_value(static_cast<number_integer_t>(val))
+        {}
+
+        /*!
+    @brief create an integer number (implicit)
+
+    Create an integer number JSON value with a given content. This constructor
+    allows any type that can be used to construct values of type @ref
+    number_integer_t. Examples may include the types `int`, `int32_t`, or
+    `short`.
+
+    @tparam CompatibleNumberIntegerType an integer type which is compatible to
+    @ref number_integer_t.
+
+    @param[in] val  an integer to create a JSON number from
+
+    @complexity Constant.
+
+    @liveexample{The example below shows the construction of several integer
+    number values from compatible
+    types.,basic_json__CompatibleIntegerNumberType}
+
+    @sa @ref basic_json(const number_integer_t) -- create a number value
+    (integer)
+    @sa @ref basic_json(const int) -- create a number value (integer)
+
+    @since version 1.0.0
+    */
+        template<typename CompatibleNumberIntegerType, typename
+        std::enable_if<
+                std::is_constructible<number_integer_t, CompatibleNumberIntegerType>::value and
+                std::numeric_limits<CompatibleNumberIntegerType>::is_integer and
+                std::numeric_limits<CompatibleNumberIntegerType>::is_signed,
+                CompatibleNumberIntegerType>::type
+        = 0>
+        basic_json(const CompatibleNumberIntegerType val) noexcept
+                : m_type(value_t::number_integer),
+                  m_value(static_cast<number_integer_t>(val))
+        {}
+
+        /*!
+    @brief create an unsigned integer number (explicit)
+
+    Create an unsigned integer number JSON value with a given content.
+
+    @tparam T  helper type to compare number_unsigned_t and unsigned int
+    (not visible in) the interface.
+
+    @param[in] val  an integer to create a JSON number from
+
+    @complexity Constant.
+
+    @sa @ref basic_json(const CompatibleNumberUnsignedType) -- create a number
+    value (unsigned integer) from a compatible number type
+
+    @since version 2.0.0
+    */
+        template<typename T,
+                typename std::enable_if<
+                        not (std::is_same<T, int>::value)
+                        and std::is_same<T, number_unsigned_t>::value
+                        , int>::type
+                = 0>
+        basic_json(const number_unsigned_t val)
+                : m_type(value_t::number_unsigned), m_value(val)
+        {}
+
+        /*!
+    @brief create an unsigned number (implicit)
+
+    Create an unsigned number JSON value with a given content. This constructor
+    allows any type that can be used to construct values of type @ref
+    number_unsigned_t. Examples may include the types `unsigned int`,
+    `uint32_t`, or `unsigned short`.
+
+    @tparam CompatibleNumberUnsignedType an integer type which is compatible to
+    @ref number_unsigned_t.
+
+    @param[in] val  an unsigned integer to create a JSON number from
+
+    @complexity Constant.
+
+    @sa @ref basic_json(const number_unsigned_t) -- create a number value
+    (unsigned)
+
+    @since version 2.0.0
+    */
+        template < typename CompatibleNumberUnsignedType, typename
+        std::enable_if <
+                std::is_constructible<number_unsigned_t, CompatibleNumberUnsignedType>::value and
+                std::numeric_limits<CompatibleNumberUnsignedType>::is_integer and
+                !std::numeric_limits<CompatibleNumberUnsignedType>::is_signed,
+                CompatibleNumberUnsignedType >::type
+        = 0 >
+        basic_json(const CompatibleNumberUnsignedType val) noexcept
+                : m_type(value_t::number_unsigned),
+                  m_value(static_cast<number_unsigned_t>(val))
+        {}
+
+        /*!
+    @brief create a floating-point number (explicit)
+
+    Create a floating-point number JSON value with a given content.
+
+    @param[in] val  a floating-point value to create a JSON number from
+
+    @note [RFC 7159](http://www.rfc-editor.org/rfc/rfc7159.txt), section 6
+    disallows NaN values:
+    > Numeric values that cannot be represented in the grammar below (such
+    > as Infinity and NaN) are not permitted.
+    In case the parameter @a val is not a number, a JSON null value is
+    created instead.
+
+    @complexity Constant.
+
+    @liveexample{The following example creates several floating-point
+    values.,basic_json__number_float_t}
+
+    @sa @ref basic_json(const CompatibleNumberFloatType) -- create a number
+    value (floating-point) from a compatible number type
+
+    @since version 1.0.0
+    */
+        basic_json(const number_float_t val)
+                : m_type(value_t::number_float), m_value(val)
+        {
+            // replace infinity and NAN by null
+            if (not std::isfinite(val))
+            {
+                m_type = value_t::null;
+                m_value = json_value();
+            }
+        }
+
+        /*!
+    @brief create an floating-point number (implicit)
+
+    Create an floating-point number JSON value with a given content. This
+    constructor allows any type that can be used to construct values of type
+    @ref number_float_t. Examples may include the types `float`.
+
+    @tparam CompatibleNumberFloatType a floating-point type which is compatible
+    to @ref number_float_t.
+
+    @param[in] val  a floating-point to create a JSON number from
+
+    @note [RFC 7159](http://www.rfc-editor.org/rfc/rfc7159.txt), section 6
+    disallows NaN values:
+    > Numeric values that cannot be represented in the grammar below (such
+    > as Infinity and NaN) are not permitted.
+    In case the parameter @a val is not a number, a JSON null value is
+    created instead.
+
+    @complexity Constant.
+
+    @liveexample{The example below shows the construction of several
+    floating-point number values from compatible
+    types.,basic_json__CompatibleNumberFloatType}
+
+    @sa @ref basic_json(const number_float_t) -- create a number value
+    (floating-point)
+
+    @since version 1.0.0
+    */
+        template<typename CompatibleNumberFloatType, typename = typename
+        std::enable_if<
+                std::is_constructible<number_float_t, CompatibleNumberFloatType>::value and
+                std::is_floating_point<CompatibleNumberFloatType>::value>::type
+        >
+        basic_json(const CompatibleNumberFloatType val) noexcept
+                : basic_json(number_float_t(val))
+        {}
+
+        /*!
+    @brief create a container (array or object) from an initializer list
+
+    Creates a JSON value of type array or object from the passed initializer
+    list @a init. In case @a type_deduction is `true` (default), the type of
+    the JSON value to be created is deducted from the initializer list @a init
+    according to the following rules:
+
+    1. If the list is empty, an empty JSON object value `{}` is created.
+    2. If the list consists of pairs whose first element is a string, a JSON
+    object value is created where the first elements of the pairs are treated
+    as keys and the second elements are as values.
+    3. In all other cases, an array is created.
+
+    The rules aim to create the best fit between a C++ initializer list and
+    JSON values. The rationale is as follows:
+
+    1. The empty initializer list is written as `{}` which is exactly an empty
+    JSON object.
+    2. C++ has now way of describing mapped types other than to list a list of
+    pairs. As JSON requires that keys must be of type string, rule 2 is the
+    weakest constraint one can pose on initializer lists to interpret them as
+    an object.
+    3. In all other cases, the initializer list could not be interpreted as
+    JSON object type, so interpreting it as JSON array type is safe.
+
+    With the rules described above, the following JSON values cannot be
+    expressed by an initializer list:
+
+    - the empty array (`[]`): use @ref array(std::initializer_list<basic_json>)
+      with an empty initializer list in this case
+    - arrays whose elements satisfy rule 2: use @ref
+      array(std::initializer_list<basic_json>) with the same initializer list
+      in this case
+
+    @note When used without parentheses around an empty initializer list, @ref
+    basic_json() is called instead of this function, yielding the JSON null
+    value.
+
+    @param[in] init  initializer list with JSON values
+
+    @param[in] type_deduction internal parameter; when set to `true`, the type
+    of the JSON value is deducted from the initializer list @a init; when set
+    to `false`, the type provided via @a manual_type is forced. This mode is
+    used by the functions @ref array(std::initializer_list<basic_json>) and
+    @ref object(std::initializer_list<basic_json>).
+
+    @param[in] manual_type internal parameter; when @a type_deduction is set to
+    `false`, the created JSON value will use the provided type (only @ref
+    value_t::array and @ref value_t::object are valid); when @a type_deduction
+    is set to `true`, this parameter has no effect
+
+    @throw std::domain_error if @a type_deduction is `false`, @a manual_type is
+    `value_t::object`, but @a init contains an element which is not a pair
+    whose first element is a string; example: `"cannot create object from
+    initializer list"`
+
+    @complexity Linear in the size of the initializer list @a init.
+
+    @liveexample{The example below shows how JSON values are created from
+    initializer lists.,basic_json__list_init_t}
+
+    @sa @ref array(std::initializer_list<basic_json>) -- create a JSON array
+    value from an initializer list
+    @sa @ref object(std::initializer_list<basic_json>) -- create a JSON object
+    value from an initializer list
+
+    @since version 1.0.0
+    */
+        basic_json(std::initializer_list<basic_json> init,
+                   bool type_deduction = true,
+                   value_t manual_type = value_t::array)
+        {
+            // the initializer list could describe an object
+            bool is_an_object = true;
+
+            // check if each element is an array with two elements whose first
+            // element is a string
+            for (const auto& element : init)
+            {
+                if (not element.is_array() or element.size() != 2
+                    or not element[0].is_string())
+                {
+                    // we found an element that makes it impossible to use the
+                    // initializer list as object
+                    is_an_object = false;
+                    break;
+                }
+            }
+
+            // adjust type if type deduction is not wanted
+            if (not type_deduction)
+            {
+                // if array is wanted, do not create an object though possible
+                if (manual_type == value_t::array)
+                {
+                    is_an_object = false;
+                }
+
+                // if object is wanted but impossible, throw an exception
+                if (manual_type == value_t::object and not is_an_object)
+                {
+                    throw std::domain_error("cannot create object from initializer list");
+                }
+            }
+
+            if (is_an_object)
+            {
+                // the initializer list is a list of pairs -> create object
+                m_type = value_t::object;
+                m_value = value_t::object;
+
+                assert(m_value.object != nullptr);
+
+                for (auto& element : init)
+                {
+                    m_value.object->emplace(std::move(*(element[0].m_value.string)), std::move(element[1]));
+                }
+            }
+            else
+            {
+                // the initializer list describes an array -> create array
+                m_type = value_t::array;
+                m_value.array = create<array_t>(std::move(init));
+            }
+        }
+
+        /*!
+    @brief explicitly create an array from an initializer list
+
+    Creates a JSON array value from a given initializer list. That is, given a
+    list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
+    initializer list is empty, the empty array `[]` is created.
+
+    @note This function is only needed to express two edge cases that cannot be
+    realized with the initializer list constructor (@ref
+    basic_json(std::initializer_list<basic_json>, bool, value_t)). These cases
+    are:
+    1. creating an array whose elements are all pairs whose first element is a
+    string -- in this case, the initializer list constructor would create an
+    object, taking the first elements as keys
+    2. creating an empty array -- passing the empty initializer list to the
+    initializer list constructor yields an empty object
+
+    @param[in] init  initializer list with JSON values to create an array from
+    (optional)
+
+    @return JSON array value
+
+    @complexity Linear in the size of @a init.
+
+    @liveexample{The following code shows an example for the `array`
+    function.,array}
+
+    @sa @ref basic_json(std::initializer_list<basic_json>, bool, value_t) --
+    create a JSON value from an initializer list
+    @sa @ref object(std::initializer_list<basic_json>) -- create a JSON object
+    value from an initializer list
+
+    @since version 1.0.0
+    */
+        static basic_json array(std::initializer_list<basic_json> init =
+        std::initializer_list<basic_json>())
+        {
+            return basic_json(init, false, value_t::array);
+        }
+
+        /*!
+    @brief explicitly create an object from an initializer list
+
+    Creates a JSON object value from a given initializer list. The initializer
+    lists elements must be pairs, and their first elements must be strings. If
+    the initializer list is empty, the empty object `{}` is created.
+
+    @note This function is only added for symmetry reasons. In contrast to the
+    related function @ref array(std::initializer_list<basic_json>), there are
+    no cases which can only be expressed by this function. That is, any
+    initializer list @a init can also be passed to the initializer list
+    constructor
+    @ref basic_json(std::initializer_list<basic_json>, bool, value_t).
+
+    @param[in] init  initializer list to create an object from (optional)
+
+    @return JSON object value
+
+    @throw std::domain_error if @a init is not a pair whose first elements are
+    strings; thrown by
+    @ref basic_json(std::initializer_list<basic_json>, bool, value_t)
+
+    @complexity Linear in the size of @a init.
+
+    @liveexample{The following code shows an example for the `object`
+    function.,object}
+
+    @sa @ref basic_json(std::initializer_list<basic_json>, bool, value_t) --
+    create a JSON value from an initializer list
+    @sa @ref array(std::initializer_list<basic_json>) -- create a JSON array
+    value from an initializer list
+
+    @since version 1.0.0
+    */
+        static basic_json object(std::initializer_list<basic_json> init =
+        std::initializer_list<basic_json>())
+        {
+            return basic_json(init, false, value_t::object);
+        }
+
+        /*!
+    @brief construct an array with count copies of given value
+
+    Constructs a JSON array value by creating @a cnt copies of a passed
+    value. In case @a cnt is `0`, an empty array is created. As postcondition,
+    `std::distance(begin(),end()) == cnt` holds.
+
+    @param[in] cnt  the number of JSON copies of @a val to create
+    @param[in] val  the JSON value to copy
+
+    @complexity Linear in @a cnt.
+
+    @liveexample{The following code shows examples for the @ref
+    basic_json(size_type\, const basic_json&)
+    constructor.,basic_json__size_type_basic_json}
+
+    @since version 1.0.0
+    */
+        basic_json(size_type cnt, const basic_json& val)
+                : m_type(value_t::array)
+        {
+            m_value.array = create<array_t>(cnt, val);
+        }
+
+        /*!
+    @brief construct a JSON container given an iterator range
+
+    Constructs the JSON value with the contents of the range `[first, last)`.
+    The semantics depends on the different types a JSON value can have:
+    - In case of primitive types (number, boolean, or string), @a first must
+      be `begin()` and @a last must be `end()`. In this case, the value is
+      copied. Otherwise, std::out_of_range is thrown.
+    - In case of structured types (array, object), the constructor behaves
+      as similar versions for `std::vector`.
+    - In case of a null type, std::domain_error is thrown.
+
+    @tparam InputIT an input iterator type (@ref iterator or @ref
+    const_iterator)
+
+    @param[in] first begin of the range to copy from (included)
+    @param[in] last end of the range to copy from (excluded)
+
+    @throw std::domain_error if iterators are not compatible; that is, do not
+    belong to the same JSON value; example: `"iterators are not compatible"`
+    @throw std::out_of_range if iterators are for a primitive type (number,
+    boolean, or string) where an out of range error can be detected easily;
+    example: `"iterators out of range"`
+    @throw std::bad_alloc if allocation for object, array, or string fails
+    @throw std::domain_error if called with a null value; example: `"cannot use
+    construct with iterators from null"`
+
+    @complexity Linear in distance between @a first and @a last.
+
+    @liveexample{The example below shows several ways to create JSON values by
+    specifying a subrange with iterators.,basic_json__InputIt_InputIt}
+
+    @since version 1.0.0
+    */
+        template <class InputIT, typename
+        std::enable_if<
+                std::is_same<InputIT, typename basic_json_t::iterator>::value or
+                std::is_same<InputIT, typename basic_json_t::const_iterator>::value
+                , int>::type
+        = 0>
+        basic_json(InputIT first, InputIT last) : m_type(first.m_object->m_type)
+        {
+            // make sure iterator fits the current value
+            if (first.m_object != last.m_object)
+            {
+                throw std::domain_error("iterators are not compatible");
+            }
+
+            // check if iterator range is complete for primitive values
+            switch (m_type)
+            {
+                case value_t::boolean:
+                case value_t::number_float:
+                case value_t::number_integer:
+                case value_t::number_unsigned:
+                case value_t::string:
+                {
+                    if (not first.m_it.primitive_iterator.is_begin() or not last.m_it.primitive_iterator.is_end())
+                    {
+                        throw std::out_of_range("iterators out of range");
+                    }
+                    break;
+                }
+
+                default:
+                {
+                    break;
+                }
+            }
+
+            switch (m_type)
+            {
+                case value_t::number_integer:
+                {
+                    assert(first.m_object != nullptr);
+                    m_value.number_integer = first.m_object->m_value.number_integer;
+                    break;
+                }
+
+                case value_t::number_unsigned:
+                {
+                    assert(first.m_object != nullptr);
+                    m_value.number_unsigned = first.m_object->m_value.number_unsigned;
+                    break;
+                }
+
+                case value_t::number_float:
+                {
+                    assert(first.m_object != nullptr);
+                    m_value.number_float = first.m_object->m_value.number_float;
+                    break;
+                }
+
+                case value_t::boolean:
+                {
+                    assert(first.m_object != nullptr);
+                    m_value.boolean = first.m_object->m_value.boolean;
+                    break;
+                }
+
+                case value_t::string:
+                {
+                    assert(first.m_object != nullptr);
+                    m_value = *first.m_object->m_value.string;
+                    break;
+                }
+
+                case value_t::object:
+                {
+                    m_value.object = create<object_t>(first.m_it.object_iterator, last.m_it.object_iterator);
+                    break;
+                }
+
+                case value_t::array:
+                {
+                    m_value.array = create<array_t>(first.m_it.array_iterator, last.m_it.array_iterator);
+                    break;
+                }
+
+                default:
+                {
+                    assert(first.m_object != nullptr);
+                    throw std::domain_error("cannot use construct with iterators from " + first.m_object->type_name());
+                }
+            }
+        }
+
+        ///////////////////////////////////////
+        // other constructors and destructor //
+        ///////////////////////////////////////
+
+        /*!
+    @brief copy constructor
+
+    Creates a copy of a given JSON value.
+
+    @param[in] other  the JSON value to copy
+
+    @complexity Linear in the size of @a other.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is linear.
+    - As postcondition, it holds: `other == basic_json(other)`.
+
+    @throw std::bad_alloc if allocation for object, array, or string fails.
+
+    @liveexample{The following code shows an example for the copy
+    constructor.,basic_json__basic_json}
+
+    @since version 1.0.0
+    */
+        basic_json(const basic_json& other)
+                : m_type(other.m_type)
+        {
+            switch (m_type)
+            {
+                case value_t::object:
+                {
+                    assert(other.m_value.object != nullptr);
+                    m_value = *other.m_value.object;
+                    break;
+                }
+
+                case value_t::array:
+                {
+                    assert(other.m_value.array != nullptr);
+                    m_value = *other.m_value.array;
+                    break;
+                }
+
+                case value_t::string:
+                {
+                    assert(other.m_value.string != nullptr);
+                    m_value = *other.m_value.string;
+                    break;
+                }
+
+                case value_t::boolean:
+                {
+                    m_value = other.m_value.boolean;
+                    break;
+                }
+
+                case value_t::number_integer:
+                {
+                    m_value = other.m_value.number_integer;
+                    break;
+                }
+
+                case value_t::number_unsigned:
+                {
+                    m_value = other.m_value.number_unsigned;
+                    break;
+                }
+
+                case value_t::number_float:
+                {
+                    m_value = other.m_value.number_float;
+                    break;
+                }
+
+                default:
+                {
+                    break;
+                }
+            }
+        }
+
+        /*!
+    @brief move constructor
+
+    Move constructor. Constructs a JSON value with the contents of the given
+    value @a other using move semantics. It "steals" the resources from @a
+    other and leaves it as JSON null value.
+
+    @param[in,out] other  value to move to this object
+
+    @post @a other is a JSON null value
+
+    @complexity Constant.
+
+    @liveexample{The code below shows the move constructor explicitly called
+    via std::move.,basic_json__moveconstructor}
+
+    @since version 1.0.0
+    */
+        basic_json(basic_json&& other) noexcept
+                : m_type(std::move(other.m_type)),
+                  m_value(std::move(other.m_value))
+        {
+            // invalidate payload
+            other.m_type = value_t::null;
+            other.m_value = {};
+        }
+
+        /*!
+    @brief copy assignment
+
+    Copy assignment operator. Copies a JSON value via the "copy and swap"
+    strategy: It is expressed in terms of the copy constructor, destructor, and
+    the swap() member function.
+
+    @param[in] other  value to copy from
+
+    @complexity Linear.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is linear.
+
+    @liveexample{The code below shows and example for the copy assignment. It
+    creates a copy of value `a` which is then swapped with `b`. Finally\, the
+    copy of `a` (which is the null value after the swap) is
+    destroyed.,basic_json__copyassignment}
+
+    @since version 1.0.0
+    */
+        reference& operator=(basic_json other) noexcept (
+        std::is_nothrow_move_constructible<value_t>::value and
+        std::is_nothrow_move_assignable<value_t>::value and
+        std::is_nothrow_move_constructible<json_value>::value and
+        std::is_nothrow_move_assignable<json_value>::value
+        )
+        {
+            using std::swap;
+            swap(m_type, other.m_type);
+            swap(m_value, other.m_value);
+            return *this;
+        }
+
+        /*!
+    @brief destructor
+
+    Destroys the JSON value and frees all allocated memory.
+
+    @complexity Linear.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is linear.
+    - All stored elements are destroyed and all memory is freed.
+
+    @since version 1.0.0
+    */
+        ~basic_json()
+        {
+            switch (m_type)
+            {
+                case value_t::object:
+                {
+                    AllocatorType<object_t> alloc;
+                    alloc.destroy(m_value.object);
+                    alloc.deallocate(m_value.object, 1);
+                    break;
+                }
+
+                case value_t::array:
+                {
+                    AllocatorType<array_t> alloc;
+                    alloc.destroy(m_value.array);
+                    alloc.deallocate(m_value.array, 1);
+                    break;
+                }
+
+                case value_t::string:
+                {
+                    AllocatorType<string_t> alloc;
+                    alloc.destroy(m_value.string);
+                    alloc.deallocate(m_value.string, 1);
+                    break;
+                }
+
+                default:
+                {
+                    // all other types need no specific destructor
+                    break;
+                }
+            }
+        }
+
+        /// @}
+
+    public:
+        ///////////////////////
+        // object inspection //
+        ///////////////////////
+
+        /// @name object inspection
+        /// @{
+
+        /*!
+    @brief serialization
+
+    Serialization function for JSON values. The function tries to mimic
+    Python's @p json.dumps() function, and currently supports its @p indent
+    parameter.
+
+    @param[in] indent if indent is nonnegative, then array elements and object
+    members will be pretty-printed with that indent level. An indent level of 0
+    will only insert newlines. -1 (the default) selects the most compact
+    representation
+
+    @return string containing the serialization of the JSON value
+
+    @complexity Linear.
+
+    @liveexample{The following example shows the effect of different @a indent
+    parameters to the result of the serialization.,dump}
+
+    @see https://docs.python.org/2/library/json.html#json.dump
+
+    @since version 1.0.0
+    */
+        string_t dump(const int indent = -1) const
+        {
+            std::stringstream ss;
+
+            if (indent >= 0)
+            {
+                dump(ss, true, static_cast<unsigned int>(indent));
+            }
+            else
+            {
+                dump(ss, false, 0);
+            }
+
+            return ss.str();
+        }
+
+        /*!
+    @brief return the type of the JSON value (explicit)
+
+    Return the type of the JSON value as a value from the @ref value_t
+    enumeration.
+
+    @return the type of the JSON value
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `type()` for all JSON
+    types.,type}
+
+    @since version 1.0.0
+    */
+        value_t type() const noexcept
+        {
+            return m_type;
+        }
+
+        /*!
+    @brief return whether type is primitive
+
+    This function returns true iff the JSON type is primitive (string, number,
+    boolean, or null).
+
+    @return `true` if type is primitive (string, number, boolean, or null),
+    `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_primitive()` for all JSON
+    types.,is_primitive}
+
+    @sa @ref is_structured() -- returns whether JSON value is structured
+    @sa @ref is_null() -- returns whether JSON value is `null`
+    @sa @ref is_string() -- returns whether JSON value is a string
+    @sa @ref is_boolean() -- returns whether JSON value is a boolean
+    @sa @ref is_number() -- returns whether JSON value is a number
+
+    @since version 1.0.0
+    */
+        bool is_primitive() const noexcept
+        {
+            return is_null() or is_string() or is_boolean() or is_number();
+        }
+
+        /*!
+    @brief return whether type is structured
+
+    This function returns true iff the JSON type is structured (array or
+    object).
+
+    @return `true` if type is structured (array or object), `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_structured()` for all JSON
+    types.,is_structured}
+
+    @sa @ref is_primitive() -- returns whether value is primitive
+    @sa @ref is_array() -- returns whether value is an array
+    @sa @ref is_object() -- returns whether value is an object
+
+    @since version 1.0.0
+    */
+        bool is_structured() const noexcept
+        {
+            return is_array() or is_object();
+        }
+
+        /*!
+    @brief return whether value is null
+
+    This function returns true iff the JSON value is null.
+
+    @return `true` if type is null, `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_null()` for all JSON
+    types.,is_null}
+
+    @since version 1.0.0
+    */
+        bool is_null() const noexcept
+        {
+            return m_type == value_t::null;
+        }
+
+        /*!
+    @brief return whether value is a boolean
+
+    This function returns true iff the JSON value is a boolean.
+
+    @return `true` if type is boolean, `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_boolean()` for all JSON
+    types.,is_boolean}
+
+    @since version 1.0.0
+    */
+        bool is_boolean() const noexcept
+        {
+            return m_type == value_t::boolean;
+        }
+
+        /*!
+    @brief return whether value is a number
+
+    This function returns true iff the JSON value is a number. This includes
+    both integer and floating-point values.
+
+    @return `true` if type is number (regardless whether integer, unsigned
+    integer or floating-type), `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_number()` for all JSON
+    types.,is_number}
+
+    @sa @ref is_number_integer() -- check if value is an integer or unsigned
+    integer number
+    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
+    number
+    @sa @ref is_number_float() -- check if value is a floating-point number
+
+    @since version 1.0.0
+    */
+        bool is_number() const noexcept
+        {
+            return is_number_integer() or is_number_float();
+        }
+
+        /*!
+    @brief return whether value is an integer number
+
+    This function returns true iff the JSON value is an integer or unsigned
+    integer number. This excludes floating-point values.
+
+    @return `true` if type is an integer or unsigned integer number, `false`
+    otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_number_integer()` for all
+    JSON types.,is_number_integer}
+
+    @sa @ref is_number() -- check if value is a number
+    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
+    number
+    @sa @ref is_number_float() -- check if value is a floating-point number
+
+    @since version 1.0.0
+    */
+        bool is_number_integer() const noexcept
+        {
+            return m_type == value_t::number_integer or m_type == value_t::number_unsigned;
+        }
+
+        /*!
+    @brief return whether value is an unsigned integer number
+
+    This function returns true iff the JSON value is an unsigned integer
+    number. This excludes floating-point and (signed) integer values.
+
+    @return `true` if type is an unsigned integer number, `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_number_unsigned()` for all
+    JSON types.,is_number_unsigned}
+
+    @sa @ref is_number() -- check if value is a number
+    @sa @ref is_number_integer() -- check if value is an integer or unsigned
+    integer number
+    @sa @ref is_number_float() -- check if value is a floating-point number
+
+    @since version 2.0.0
+    */
+        bool is_number_unsigned() const noexcept
+        {
+            return m_type == value_t::number_unsigned;
+        }
+
+        /*!
+    @brief return whether value is a floating-point number
+
+    This function returns true iff the JSON value is a floating-point number.
+    This excludes integer and unsigned integer values.
+
+    @return `true` if type is a floating-point number, `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_number_float()` for all
+    JSON types.,is_number_float}
+
+    @sa @ref is_number() -- check if value is number
+    @sa @ref is_number_integer() -- check if value is an integer number
+    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
+    number
+
+    @since version 1.0.0
+    */
+        bool is_number_float() const noexcept
+        {
+            return m_type == value_t::number_float;
+        }
+
+        /*!
+    @brief return whether value is an object
+
+    This function returns true iff the JSON value is an object.
+
+    @return `true` if type is object, `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_object()` for all JSON
+    types.,is_object}
+
+    @since version 1.0.0
+    */
+        bool is_object() const noexcept
+        {
+            return m_type == value_t::object;
+        }
+
+        /*!
+    @brief return whether value is an array
+
+    This function returns true iff the JSON value is an array.
+
+    @return `true` if type is array, `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_array()` for all JSON
+    types.,is_array}
+
+    @since version 1.0.0
+    */
+        bool is_array() const noexcept
+        {
+            return m_type == value_t::array;
+        }
+
+        /*!
+    @brief return whether value is a string
+
+    This function returns true iff the JSON value is a string.
+
+    @return `true` if type is string, `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_string()` for all JSON
+    types.,is_string}
+
+    @since version 1.0.0
+    */
+        bool is_string() const noexcept
+        {
+            return m_type == value_t::string;
+        }
+
+        /*!
+    @brief return whether value is discarded
+
+    This function returns true iff the JSON value was discarded during parsing
+    with a callback function (see @ref parser_callback_t).
+
+    @note This function will always be `false` for JSON values after parsing.
+    That is, discarded values can only occur during parsing, but will be
+    removed when inside a structured value or replaced by null in other cases.
+
+    @return `true` if type is discarded, `false` otherwise.
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies `is_discarded()` for all JSON
+    types.,is_discarded}
+
+    @since version 1.0.0
+    */
+        bool is_discarded() const noexcept
+        {
+            return m_type == value_t::discarded;
+        }
+
+        /*!
+    @brief return the type of the JSON value (implicit)
+
+    Implicitly return the type of the JSON value as a value from the @ref
+    value_t enumeration.
+
+    @return the type of the JSON value
+
+    @complexity Constant.
+
+    @liveexample{The following code exemplifies the @ref value_t operator for
+    all JSON types.,operator__value_t}
+
+    @since version 1.0.0
+    */
+        operator value_t() const noexcept
+        {
+            return m_type;
+        }
+
+        /// @}
+
+    private:
+        //////////////////
+        // value access //
+        //////////////////
+
+        /// get an object (explicit)
+        template <class T, typename
+        std::enable_if<
+                std::is_convertible<typename object_t::key_type, typename T::key_type>::value and
+                std::is_convertible<basic_json_t, typename T::mapped_type>::value
+                , int>::type = 0>
+        T get_impl(T*) const
+        {
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                return T(m_value.object->begin(), m_value.object->end());
+            }
+            else
+            {
+                throw std::domain_error("type must be object, but is " + type_name());
+            }
+        }
+
+        /// get an object (explicit)
+        object_t get_impl(object_t*) const
+        {
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                return *(m_value.object);
+            }
+            else
+            {
+                throw std::domain_error("type must be object, but is " + type_name());
+            }
+        }
+
+        /// get an array (explicit)
+        template <class T, typename
+        std::enable_if<
+                std::is_convertible<basic_json_t, typename T::value_type>::value and
+                not std::is_same<basic_json_t, typename T::value_type>::value and
+                not std::is_arithmetic<T>::value and
+                not std::is_convertible<std::string, T>::value and
+                not has_mapped_type<T>::value
+                , int>::type = 0>
+        T get_impl(T*) const
+        {
+            if (is_array())
+            {
+                T to_vector;
+                assert(m_value.array != nullptr);
+                std::transform(m_value.array->begin(), m_value.array->end(),
+                               std::inserter(to_vector, to_vector.end()), [](basic_json i)
+                               {
+                                   return i.get<typename T::value_type>();
+                               });
+                return to_vector;
+            }
+            else
+            {
+                throw std::domain_error("type must be array, but is " + type_name());
+            }
+        }
+
+        /// get an array (explicit)
+        template <class T, typename
+        std::enable_if<
+                std::is_convertible<basic_json_t, T>::value and
+                not std::is_same<basic_json_t, T>::value
+                , int>::type = 0>
+        std::vector<T> get_impl(std::vector<T>*) const
+        {
+            if (is_array())
+            {
+                std::vector<T> to_vector;
+                assert(m_value.array != nullptr);
+                to_vector.reserve(m_value.array->size());
+                std::transform(m_value.array->begin(), m_value.array->end(),
+                               std::inserter(to_vector, to_vector.end()), [](basic_json i)
+                               {
+                                   return i.get<T>();
+                               });
+                return to_vector;
+            }
+            else
+            {
+                throw std::domain_error("type must be array, but is " + type_name());
+            }
+        }
+
+        /// get an array (explicit)
+        template <class T, typename
+        std::enable_if<
+                std::is_same<basic_json, typename T::value_type>::value and
+                not has_mapped_type<T>::value
+                , int>::type = 0>
+        T get_impl(T*) const
+        {
+            if (is_array())
+            {
+                assert(m_value.array != nullptr);
+                return T(m_value.array->begin(), m_value.array->end());
+            }
+            else
+            {
+                throw std::domain_error("type must be array, but is " + type_name());
+            }
+        }
+
+        /// get an array (explicit)
+        array_t get_impl(array_t*) const
+        {
+            if (is_array())
+            {
+                assert(m_value.array != nullptr);
+                return *(m_value.array);
+            }
+            else
+            {
+                throw std::domain_error("type must be array, but is " + type_name());
+            }
+        }
+
+        /// get a string (explicit)
+        template <typename T, typename
+        std::enable_if<
+                std::is_convertible<string_t, T>::value
+                , int>::type = 0>
+        T get_impl(T*) const
+        {
+            if (is_string())
+            {
+                assert(m_value.string != nullptr);
+                return *m_value.string;
+            }
+            else
+            {
+                throw std::domain_error("type must be string, but is " + type_name());
+            }
+        }
+
+        /// get a number (explicit)
+        template<typename T, typename
+        std::enable_if<
+                std::is_arithmetic<T>::value
+                , int>::type = 0>
+        T get_impl(T*) const
+        {
+            switch (m_type)
+            {
+                case value_t::number_integer:
+                {
+                    return static_cast<T>(m_value.number_integer);
+                }
+
+                case value_t::number_unsigned:
+                {
+                    return static_cast<T>(m_value.number_unsigned);
+                }
+
+                case value_t::number_float:
+                {
+                    return static_cast<T>(m_value.number_float);
+                }
+
+                default:
+                {
+                    throw std::domain_error("type must be number, but is " + type_name());
+                }
+            }
+        }
+
+        /// get a boolean (explicit)
+        boolean_t get_impl(boolean_t*) const
+        {
+            if (is_boolean())
+            {
+                return m_value.boolean;
+            }
+            else
+            {
+                throw std::domain_error("type must be boolean, but is " + type_name());
+            }
+        }
+
+        /// get a pointer to the value (object)
+        object_t* get_impl_ptr(object_t*) noexcept
+        {
+            return is_object() ? m_value.object : nullptr;
+        }
+
+        /// get a pointer to the value (object)
+        const object_t* get_impl_ptr(const object_t*) const noexcept
+        {
+            return is_object() ? m_value.object : nullptr;
+        }
+
+        /// get a pointer to the value (array)
+        array_t* get_impl_ptr(array_t*) noexcept
+        {
+            return is_array() ? m_value.array : nullptr;
+        }
+
+        /// get a pointer to the value (array)
+        const array_t* get_impl_ptr(const array_t*) const noexcept
+        {
+            return is_array() ? m_value.array : nullptr;
+        }
+
+        /// get a pointer to the value (string)
+        string_t* get_impl_ptr(string_t*) noexcept
+        {
+            return is_string() ? m_value.string : nullptr;
+        }
+
+        /// get a pointer to the value (string)
+        const string_t* get_impl_ptr(const string_t*) const noexcept
+        {
+            return is_string() ? m_value.string : nullptr;
+        }
+
+        /// get a pointer to the value (boolean)
+        boolean_t* get_impl_ptr(boolean_t*) noexcept
+        {
+            return is_boolean() ? &m_value.boolean : nullptr;
+        }
+
+        /// get a pointer to the value (boolean)
+        const boolean_t* get_impl_ptr(const boolean_t*) const noexcept
+        {
+            return is_boolean() ? &m_value.boolean : nullptr;
+        }
+
+        /// get a pointer to the value (integer number)
+        number_integer_t* get_impl_ptr(number_integer_t*) noexcept
+        {
+            return is_number_integer() ? &m_value.number_integer : nullptr;
+        }
+
+        /// get a pointer to the value (integer number)
+        const number_integer_t* get_impl_ptr(const number_integer_t*) const noexcept
+        {
+            return is_number_integer() ? &m_value.number_integer : nullptr;
+        }
+
+        /// get a pointer to the value (unsigned number)
+        number_unsigned_t* get_impl_ptr(number_unsigned_t*) noexcept
+        {
+            return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
+        }
+
+        /// get a pointer to the value (unsigned number)
+        const number_unsigned_t* get_impl_ptr(const number_unsigned_t*) const noexcept
+        {
+            return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
+        }
+
+        /// get a pointer to the value (floating-point number)
+        number_float_t* get_impl_ptr(number_float_t*) noexcept
+        {
+            return is_number_float() ? &m_value.number_float : nullptr;
+        }
+
+        /// get a pointer to the value (floating-point number)
+        const number_float_t* get_impl_ptr(const number_float_t*) const noexcept
+        {
+            return is_number_float() ? &m_value.number_float : nullptr;
+        }
+
+        /*!
+    @brief helper function to implement get_ref()
+
+    This funcion helps to implement get_ref() without code duplication for
+    const and non-const overloads
+
+    @tparam ThisType will be deduced as `basic_json` or `const basic_json`
+
+    @throw std::domain_error if ReferenceType does not match underlying value
+    type of the current JSON
+    */
+        template<typename ReferenceType, typename ThisType>
+        static ReferenceType get_ref_impl(ThisType& obj)
+        {
+            // delegate the call to get_ptr<>()
+            using PointerType = typename std::add_pointer<ReferenceType>::type;
+            auto ptr = obj.template get_ptr<PointerType>();
+
+            if (ptr != nullptr)
+            {
+                return *ptr;
+            }
+            else
+            {
+                throw std::domain_error("incompatible ReferenceType for get_ref, actual type is " +
+                                        obj.type_name());
+            }
+        }
+
+    public:
+
+        /// @name value access
+        /// @{
+
+        /*!
+    @brief get a value (explicit)
+
+    Explicit type conversion between the JSON value and a compatible value.
+
+    @tparam ValueType non-pointer type compatible to the JSON value, for
+    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
+    `std::vector` types for JSON arrays
+
+    @return copy of the JSON value, converted to type @a ValueType
+
+    @throw std::domain_error in case passed type @a ValueType is incompatible
+    to JSON; example: `"type must be object, but is null"`
+
+    @complexity Linear in the size of the JSON value.
+
+    @liveexample{The example below shows several conversions from JSON values
+    to other types. There a few things to note: (1) Floating-point numbers can
+    be converted to integers\, (2) A JSON array can be converted to a standard
+    `std::vector<short>`\, (3) A JSON object can be converted to C++
+    associative containers such as `std::unordered_map<std::string\,
+    json>`.,get__ValueType_const}
+
+    @internal
+    The idea of using a casted null pointer to choose the correct
+    implementation is from <http://stackoverflow.com/a/8315197/266378>.
+    @endinternal
+
+    @sa @ref operator ValueType() const for implicit conversion
+    @sa @ref get() for pointer-member access
+
+    @since version 1.0.0
+    */
+        template<typename ValueType, typename
+        std::enable_if<
+                not std::is_pointer<ValueType>::value
+                , int>::type = 0>
+        ValueType get() const
+        {
+            return get_impl(static_cast<ValueType*>(nullptr));
+        }
+
+        /*!
+    @brief get a pointer value (explicit)
+
+    Explicit pointer access to the internally stored JSON value. No copies are
+    made.
+
+    @warning The pointer becomes invalid if the underlying JSON object changes.
+
+    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
+    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
+    @ref number_unsigned_t, or @ref number_float_t.
+
+    @return pointer to the internally stored JSON value if the requested
+    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how pointers to internal values of a
+    JSON value can be requested. Note that no type conversions are made and a
+    `nullptr` is returned if the value and the requested pointer type does not
+    match.,get__PointerType}
+
+    @sa @ref get_ptr() for explicit pointer-member access
+
+    @since version 1.0.0
+    */
+        template<typename PointerType, typename
+        std::enable_if<
+                std::is_pointer<PointerType>::value
+                , int>::type = 0>
+        PointerType get() noexcept
+        {
+            // delegate the call to get_ptr
+            return get_ptr<PointerType>();
+        }
+
+        /*!
+    @brief get a pointer value (explicit)
+    @copydoc get()
+    */
+        template<typename PointerType, typename
+        std::enable_if<
+                std::is_pointer<PointerType>::value
+                , int>::type = 0>
+        const PointerType get() const noexcept
+        {
+            // delegate the call to get_ptr
+            return get_ptr<PointerType>();
+        }
+
+        /*!
+    @brief get a pointer value (implicit)
+
+    Implicit pointer access to the internally stored JSON value. No copies are
+    made.
+
+    @warning Writing data to the pointee of the result yields an undefined
+    state.
+
+    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
+    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
+    @ref number_unsigned_t, or @ref number_float_t.
+
+    @return pointer to the internally stored JSON value if the requested
+    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how pointers to internal values of a
+    JSON value can be requested. Note that no type conversions are made and a
+    `nullptr` is returned if the value and the requested pointer type does not
+    match.,get_ptr}
+
+    @since version 1.0.0
+    */
+        template<typename PointerType, typename
+        std::enable_if<
+                std::is_pointer<PointerType>::value
+                , int>::type = 0>
+        PointerType get_ptr() noexcept
+        {
+            // delegate the call to get_impl_ptr<>()
+            return get_impl_ptr(static_cast<PointerType>(nullptr));
+        }
+
+        /*!
+    @brief get a pointer value (implicit)
+    @copydoc get_ptr()
+    */
+        template<typename PointerType, typename
+        std::enable_if<
+                std::is_pointer<PointerType>::value
+                and std::is_const<typename std::remove_pointer<PointerType>::type>::value
+                , int>::type = 0>
+        const PointerType get_ptr() const noexcept
+        {
+            // delegate the call to get_impl_ptr<>() const
+            return get_impl_ptr(static_cast<const PointerType>(nullptr));
+        }
+
+        /*!
+    @brief get a reference value (implicit)
+
+    Implict reference access to the internally stored JSON value. No copies are
+    made.
+
+    @warning Writing data to the referee of the result yields an undefined
+    state.
+
+    @tparam ReferenceType reference type; must be a reference to @ref array_t,
+    @ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
+    @ref number_float_t.
+
+    @return reference to the internally stored JSON value if the requested
+    reference type @a ReferenceType fits to the JSON value; throws
+    std::domain_error otherwise
+
+    @throw std::domain_error in case passed type @a ReferenceType is
+    incompatible with the stored JSON value
+
+    @complexity Constant.
+
+    @liveexample{The example shows several calls to `get_ref()`.,get_ref}
+
+    @since version 1.1.0
+    */
+        template<typename ReferenceType, typename
+        std::enable_if<
+                std::is_reference<ReferenceType>::value
+                , int>::type = 0>
+        ReferenceType get_ref()
+        {
+            // delegate call to get_ref_impl
+            return get_ref_impl<ReferenceType>(*this);
+        }
+
+        /*!
+    @brief get a reference value (implicit)
+    @copydoc get_ref()
+    */
+        template<typename ReferenceType, typename
+        std::enable_if<
+                std::is_reference<ReferenceType>::value
+                and std::is_const<typename std::remove_reference<ReferenceType>::type>::value
+                , int>::type = 0>
+        ReferenceType get_ref() const
+        {
+            // delegate call to get_ref_impl
+            return get_ref_impl<ReferenceType>(*this);
+        }
+
+        /*!
+    @brief get a value (implicit)
+
+    Implicit type conversion between the JSON value and a compatible value. The
+    call is realized by calling @ref get() const.
+
+    @tparam ValueType non-pointer type compatible to the JSON value, for
+    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
+    `std::vector` types for JSON arrays. The character type of @ref string_t as
+    well as an initializer list of this type is excluded to avoid ambiguities
+    as these types implicitly convert to `std::string`.
+
+    @return copy of the JSON value, converted to type @a ValueType
+
+    @throw std::domain_error in case passed type @a ValueType is incompatible
+    to JSON, thrown by @ref get() const
+
+    @complexity Linear in the size of the JSON value.
+
+    @liveexample{The example below shows several conversions from JSON values
+    to other types. There a few things to note: (1) Floating-point numbers can
+    be converted to integers\, (2) A JSON array can be converted to a standard
+    `std::vector<short>`\, (3) A JSON object can be converted to C++
+    associative containers such as `std::unordered_map<std::string\,
+    json>`.,operator__ValueType}
+
+    @since version 1.0.0
+    */
+        template < typename ValueType, typename
+        std::enable_if <
+                not std::is_pointer<ValueType>::value
+                and not std::is_same<ValueType, typename string_t::value_type>::value
+                #ifndef _MSC_VER  // Fix for issue #167 operator<< abiguity under VS2015
+                and not std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>::value
+#endif
+                , int >::type = 0 >
+        operator ValueType() const
+        {
+            // delegate the call to get<>() const
+            return get<ValueType>();
+        }
+
+        /// @}
+
+
+        ////////////////////
+        // element access //
+        ////////////////////
+
+        /// @name element access
+        /// @{
+
+        /*!
+    @brief access specified array element with bounds checking
+
+    Returns a reference to the element at specified location @a idx, with
+    bounds checking.
+
+    @param[in] idx  index of the element to access
+
+    @return reference to the element at index @a idx
+
+    @throw std::domain_error if the JSON value is not an array; example:
+    `"cannot use at() with string"`
+    @throw std::out_of_range if the index @a idx is out of range of the array;
+    that is, `idx >= size()`; example: `"array index 7 is out of range"`
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how array elements can be read and
+    written using `at()`.,at__size_type}
+
+    @since version 1.0.0
+    */
+        reference at(size_type idx)
+        {
+            // at only works for arrays
+            if (is_array())
+            {
+                try
+                {
+                    assert(m_value.array != nullptr);
+                    return m_value.array->at(idx);
+                }
+                catch (std::out_of_range&)
+                {
+                    // create better exception explanation
+                    throw std::out_of_range("array index " + std::to_string(idx) + " is out of range");
+                }
+            }
+            else
+            {
+                throw std::domain_error("cannot use at() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief access specified array element with bounds checking
+
+    Returns a const reference to the element at specified location @a idx, with
+    bounds checking.
+
+    @param[in] idx  index of the element to access
+
+    @return const reference to the element at index @a idx
+
+    @throw std::domain_error if the JSON value is not an array; example:
+    `"cannot use at() with string"`
+    @throw std::out_of_range if the index @a idx is out of range of the array;
+    that is, `idx >= size()`; example: `"array index 7 is out of range"`
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how array elements can be read using
+    `at()`.,at__size_type_const}
+
+    @since version 1.0.0
+    */
+        const_reference at(size_type idx) const
+        {
+            // at only works for arrays
+            if (is_array())
+            {
+                try
+                {
+                    assert(m_value.array != nullptr);
+                    return m_value.array->at(idx);
+                }
+                catch (std::out_of_range&)
+                {
+                    // create better exception explanation
+                    throw std::out_of_range("array index " + std::to_string(idx) + " is out of range");
+                }
+            }
+            else
+            {
+                throw std::domain_error("cannot use at() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief access specified object element with bounds checking
+
+    Returns a reference to the element at with specified key @a key, with
+    bounds checking.
+
+    @param[in] key  key of the element to access
+
+    @return reference to the element at key @a key
+
+    @throw std::domain_error if the JSON value is not an object; example:
+    `"cannot use at() with boolean"`
+    @throw std::out_of_range if the key @a key is is not stored in the object;
+    that is, `find(key) == end()`; example: `"key "the fast" not found"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be read and
+    written using `at()`.,at__object_t_key_type}
+
+    @sa @ref operator[](const typename object_t::key_type&) for unchecked
+    access by reference
+    @sa @ref value() for access by value with a default value
+
+    @since version 1.0.0
+    */
+        reference at(const typename object_t::key_type& key)
+        {
+            // at only works for objects
+            if (is_object())
+            {
+                try
+                {
+                    assert(m_value.object != nullptr);
+                    return m_value.object->at(key);
+                }
+                catch (std::out_of_range&)
+                {
+                    // create better exception explanation
+                    throw std::out_of_range("key '" + key + "' not found");
+                }
+            }
+            else
+            {
+                throw std::domain_error("cannot use at() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief access specified object element with bounds checking
+
+    Returns a const reference to the element at with specified key @a key, with
+    bounds checking.
+
+    @param[in] key  key of the element to access
+
+    @return const reference to the element at key @a key
+
+    @throw std::domain_error if the JSON value is not an object; example:
+    `"cannot use at() with boolean"`
+    @throw std::out_of_range if the key @a key is is not stored in the object;
+    that is, `find(key) == end()`; example: `"key "the fast" not found"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be read using
+    `at()`.,at__object_t_key_type_const}
+
+    @sa @ref operator[](const typename object_t::key_type&) for unchecked
+    access by reference
+    @sa @ref value() for access by value with a default value
+
+    @since version 1.0.0
+    */
+        const_reference at(const typename object_t::key_type& key) const
+        {
+            // at only works for objects
+            if (is_object())
+            {
+                try
+                {
+                    assert(m_value.object != nullptr);
+                    return m_value.object->at(key);
+                }
+                catch (std::out_of_range&)
+                {
+                    // create better exception explanation
+                    throw std::out_of_range("key '" + key + "' not found");
+                }
+            }
+            else
+            {
+                throw std::domain_error("cannot use at() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief access specified array element
+
+    Returns a reference to the element at specified location @a idx.
+
+    @note If @a idx is beyond the range of the array (i.e., `idx >= size()`),
+    then the array is silently filled up with `null` values to make `idx` a
+    valid reference to the last stored element.
+
+    @param[in] idx  index of the element to access
+
+    @return reference to the element at index @a idx
+
+    @throw std::domain_error if JSON is not an array or null; example: `"cannot
+    use operator[] with null"`
+
+    @complexity Constant if @a idx is in the range of the array. Otherwise
+    linear in `idx - size()`.
+
+    @liveexample{The example below shows how array elements can be read and
+    written using `[]` operator. Note the addition of `null`
+    values.,operatorarray__size_type}
+
+    @since version 1.0.0
+    */
+        reference operator[](size_type idx)
+        {
+            // implicitly convert null to object
+            if (is_null())
+            {
+                m_type = value_t::array;
+                m_value.array = create<array_t>();
+            }
+
+            // [] only works for arrays
+            if (is_array())
+            {
+                assert(m_value.array != nullptr);
+                for (size_t i = m_value.array->size(); i <= idx; ++i)
+                {
+                    m_value.array->push_back(basic_json());
+                }
+
+                return m_value.array->operator[](idx);
+            }
+            else
+            {
+                throw std::domain_error("cannot use operator[] with " + type_name());
+            }
+        }
+
+        /*!
+    @brief access specified array element
+
+    Returns a const reference to the element at specified location @a idx.
+
+    @param[in] idx  index of the element to access
+
+    @return const reference to the element at index @a idx
+
+    @throw std::domain_error if JSON is not an array; example: `"cannot use
+    operator[] with null"`
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how array elements can be read using
+    the `[]` operator.,operatorarray__size_type_const}
+
+    @since version 1.0.0
+    */
+        const_reference operator[](size_type idx) const
+        {
+            // at only works for arrays
+            if (is_array())
+            {
+                assert(m_value.array != nullptr);
+                return m_value.array->operator[](idx);
+            }
+            else
+            {
+                throw std::domain_error("cannot use operator[] with " + type_name());
+            }
+        }
+
+        /*!
+    @brief access specified object element
+
+    Returns a reference to the element at with specified key @a key.
+
+    @note If @a key is not found in the object, then it is silently added to
+    the object and filled with a `null` value to make `key` a valid reference.
+    In case the value was `null` before, it is converted to an object.
+
+    @param[in] key  key of the element to access
+
+    @return reference to the element at key @a key
+
+    @throw std::domain_error if JSON is not an object or null; example:
+    `"cannot use operator[] with null"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be read and
+    written using the `[]` operator.,operatorarray__key_type}
+
+    @sa @ref at(const typename object_t::key_type&) for access by reference
+    with range checking
+    @sa @ref value() for access by value with a default value
+
+    @since version 1.0.0
+    */
+        reference operator[](const typename object_t::key_type& key)
+        {
+            // implicitly convert null to object
+            if (is_null())
+            {
+                m_type = value_t::object;
+                m_value.object = create<object_t>();
+            }
+
+            // [] only works for objects
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                return m_value.object->operator[](key);
+            }
+            else
+            {
+                throw std::domain_error("cannot use operator[] with " + type_name());
+            }
+        }
+
+        /*!
+    @brief read-only access specified object element
+
+    Returns a const reference to the element at with specified key @a key. No
+    bounds checking is performed.
+
+    @warning If the element with key @a key does not exist, the behavior is
+    undefined.
+
+    @param[in] key  key of the element to access
+
+    @return const reference to the element at key @a key
+
+    @throw std::domain_error if JSON is not an object; example: `"cannot use
+    operator[] with null"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be read using
+    the `[]` operator.,operatorarray__key_type_const}
+
+    @sa @ref at(const typename object_t::key_type&) for access by reference
+    with range checking
+    @sa @ref value() for access by value with a default value
+
+    @since version 1.0.0
+    */
+        const_reference operator[](const typename object_t::key_type& key) const
+        {
+            // [] only works for objects
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                assert(m_value.object->find(key) != m_value.object->end());
+                return m_value.object->find(key)->second;
+            }
+            else
+            {
+                throw std::domain_error("cannot use operator[] with " + type_name());
+            }
+        }
+
+        /*!
+    @brief access specified object element
+
+    Returns a reference to the element at with specified key @a key.
+
+    @note If @a key is not found in the object, then it is silently added to
+    the object and filled with a `null` value to make `key` a valid reference.
+    In case the value was `null` before, it is converted to an object.
+
+    @param[in] key  key of the element to access
+
+    @return reference to the element at key @a key
+
+    @throw std::domain_error if JSON is not an object or null; example:
+    `"cannot use operator[] with null"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be read and
+    written using the `[]` operator.,operatorarray__key_type}
+
+    @sa @ref at(const typename object_t::key_type&) for access by reference
+    with range checking
+    @sa @ref value() for access by value with a default value
+
+    @since version 1.0.0
+    */
+        template<typename T, std::size_t n>
+        reference operator[](T * (&key)[n])
+        {
+            return operator[](static_cast<const T>(key));
+        }
+
+        /*!
+    @brief read-only access specified object element
+
+    Returns a const reference to the element at with specified key @a key. No
+    bounds checking is performed.
+
+    @warning If the element with key @a key does not exist, the behavior is
+    undefined.
+
+    @note This function is required for compatibility reasons with Clang.
+
+    @param[in] key  key of the element to access
+
+    @return const reference to the element at key @a key
+
+    @throw std::domain_error if JSON is not an object; example: `"cannot use
+    operator[] with null"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be read using
+    the `[]` operator.,operatorarray__key_type_const}
+
+    @sa @ref at(const typename object_t::key_type&) for access by reference
+    with range checking
+    @sa @ref value() for access by value with a default value
+
+    @since version 1.0.0
+    */
+        template<typename T, std::size_t n>
+        const_reference operator[](T * (&key)[n]) const
+        {
+            return operator[](static_cast<const T>(key));
+        }
+
+        /*!
+    @brief access specified object element
+
+    Returns a reference to the element at with specified key @a key.
+
+    @note If @a key is not found in the object, then it is silently added to
+    the object and filled with a `null` value to make `key` a valid reference.
+    In case the value was `null` before, it is converted to an object.
+
+    @param[in] key  key of the element to access
+
+    @return reference to the element at key @a key
+
+    @throw std::domain_error if JSON is not an object or null; example:
+    `"cannot use operator[] with null"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be read and
+    written using the `[]` operator.,operatorarray__key_type}
+
+    @sa @ref at(const typename object_t::key_type&) for access by reference
+    with range checking
+    @sa @ref value() for access by value with a default value
+
+    @since version 1.1.0
+    */
+        template<typename T>
+        reference operator[](T* key)
+        {
+            // implicitly convert null to object
+            if (is_null())
+            {
+                m_type = value_t::object;
+                m_value = value_t::object;
+            }
+
+            // at only works for objects
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                return m_value.object->operator[](key);
+            }
+            else
+            {
+                throw std::domain_error("cannot use operator[] with " + type_name());
+            }
+        }
+
+        /*!
+    @brief read-only access specified object element
+
+    Returns a const reference to the element at with specified key @a key. No
+    bounds checking is performed.
+
+    @warning If the element with key @a key does not exist, the behavior is
+    undefined.
+
+    @param[in] key  key of the element to access
+
+    @return const reference to the element at key @a key
+
+    @throw std::domain_error if JSON is not an object; example: `"cannot use
+    operator[] with null"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be read using
+    the `[]` operator.,operatorarray__key_type_const}
+
+    @sa @ref at(const typename object_t::key_type&) for access by reference
+    with range checking
+    @sa @ref value() for access by value with a default value
+
+    @since version 1.1.0
+    */
+        template<typename T>
+        const_reference operator[](T* key) const
+        {
+            // at only works for objects
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                assert(m_value.object->find(key) != m_value.object->end());
+                return m_value.object->find(key)->second;
+            }
+            else
+            {
+                throw std::domain_error("cannot use operator[] with " + type_name());
+            }
+        }
+
+        /*!
+    @brief access specified object element with default value
+
+    Returns either a copy of an object's element at the specified key @a key or
+    a given default value if no element with key @a key exists.
+
+    The function is basically equivalent to executing
+    @code {.cpp}
+    try {
+        return at(key);
+    } catch(std::out_of_range) {
+        return default_value;
+    }
+    @endcode
+
+    @note Unlike @ref at(const typename object_t::key_type&), this function
+    does not throw if the given key @a key was not found.
+
+    @note Unlike @ref operator[](const typename object_t::key_type& key), this
+    function does not implicitly add an element to the position defined by @a
+    key. This function is furthermore also applicable to const objects.
+
+    @param[in] key  key of the element to access
+    @param[in] default_value  the value to return if @a key is not found
+
+    @tparam ValueType type compatible to JSON values, for instance `int` for
+    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
+    JSON arrays. Note the type of the expected value at @a key and the default
+    value @a default_value must be compatible.
+
+    @return copy of the element at key @a key or @a default_value if @a key
+    is not found
+
+    @throw std::domain_error if JSON is not an object; example: `"cannot use
+    value() with null"`
+
+    @complexity Logarithmic in the size of the container.
+
+    @liveexample{The example below shows how object elements can be queried
+    with a default value.,basic_json__value}
+
+    @sa @ref at(const typename object_t::key_type&) for access by reference
+    with range checking
+    @sa @ref operator[](const typename object_t::key_type&) for unchecked
+    access by reference
+
+    @since version 1.0.0
+    */
+        template <class ValueType, typename
+        std::enable_if<
+                std::is_convertible<basic_json_t, ValueType>::value
+                , int>::type = 0>
+        ValueType value(const typename object_t::key_type& key, ValueType default_value) const
+        {
+            // at only works for objects
+            if (is_object())
+            {
+                // if key is found, return value and given default value otherwise
+                const auto it = find(key);
+                if (it != end())
+                {
+                    return *it;
+                }
+                else
+                {
+                    return default_value;
+                }
+            }
+            else
+            {
+                throw std::domain_error("cannot use value() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief overload for a default value of type const char*
+    @copydoc basic_json::value()
+    */
+        string_t value(const typename object_t::key_type& key, const char* default_value) const
+        {
+            return value(key, string_t(default_value));
+        }
+
+        /*!
+    @brief access the first element
+
+    Returns a reference to the first element in the container. For a JSON
+    container `c`, the expression `c.front()` is equivalent to `*c.begin()`.
+
+    @return In case of a structured type (array or object), a reference to the
+    first element is returned. In cast of number, string, or boolean values, a
+    reference to the value is returned.
+
+    @complexity Constant.
+
+    @pre The JSON value must not be `null` (would throw `std::out_of_range`) or
+    an empty array or object (undefined behavior, guarded by assertions).
+    @post The JSON value remains unchanged.
+
+    @throw std::out_of_range when called on `null` value
+
+    @liveexample{The following code shows an example for `front()`.,front}
+
+    @sa @ref back() -- access the last element
+
+    @since version 1.0.0
+    */
+        reference front()
+        {
+            return *begin();
+        }
+
+        /*!
+    @copydoc basic_json::front()
+    */
+        const_reference front() const
+        {
+            return *cbegin();
+        }
+
+        /*!
+    @brief access the last element
+
+    Returns a reference to the last element in the container. For a JSON
+    container `c`, the expression `c.back()` is equivalent to `{ auto tmp =
+    c.end(); --tmp; return *tmp; }`.
+
+    @return In case of a structured type (array or object), a reference to the
+    last element is returned. In cast of number, string, or boolean values, a
+    reference to the value is returned.
+
+    @complexity Constant.
+
+    @pre The JSON value must not be `null` (would throw `std::out_of_range`) or
+    an empty array or object (undefined behavior, guarded by assertions).
+    @post The JSON value remains unchanged.
+
+    @throw std::out_of_range when called on null value.
+
+    @liveexample{The following code shows an example for `back()`.,back}
+
+    @sa @ref front() -- access the first element
+
+    @since version 1.0.0
+    */
+        reference back()
+        {
+            auto tmp = end();
+            --tmp;
+            return *tmp;
+        }
+
+        /*!
+    @copydoc basic_json::back()
+    */
+        const_reference back() const
+        {
+            auto tmp = cend();
+            --tmp;
+            return *tmp;
+        }
+
+        /*!
+    @brief remove element given an iterator
+
+    Removes the element specified by iterator @a pos. Invalidates iterators and
+    references at or after the point of the erase, including the end()
+    iterator. The iterator @a pos must be valid and dereferenceable. Thus the
+    end() iterator (which is valid, but is not dereferenceable) cannot be used
+    as a value for @a pos.
+
+    If called on a primitive type other than null, the resulting JSON value
+    will be `null`.
+
+    @param[in] pos iterator to the element to remove
+    @return Iterator following the last removed element. If the iterator @a pos
+    refers to the last element, the end() iterator is returned.
+
+    @tparam InteratorType an @ref iterator or @ref const_iterator
+
+    @throw std::domain_error if called on a `null` value; example: `"cannot use
+    erase() with null"`
+    @throw std::domain_error if called on an iterator which does not belong to
+    the current JSON value; example: `"iterator does not fit current value"`
+    @throw std::out_of_range if called on a primitive type with invalid
+    iterator (i.e., any iterator which is not end()); example: `"iterator out
+    of range"`
+
+    @complexity The complexity depends on the type:
+    - objects: amortized constant
+    - arrays: linear in distance between pos and the end of the container
+    - strings: linear in the length of the string
+    - other types: constant
+
+    @liveexample{The example shows the result of `erase()` for different JSON
+    types.,erase__IteratorType}
+
+    @sa @ref erase(InteratorType, InteratorType) -- removes the elements in the
+    given range
+    @sa @ref erase(const typename object_t::key_type&) -- removes the element
+    from an object at the given key
+    @sa @ref erase(const size_type) -- removes the element from an array at the
+    given index
+
+    @since version 1.0.0
+    */
+        template <class InteratorType, typename
+        std::enable_if<
+                std::is_same<InteratorType, typename basic_json_t::iterator>::value or
+                std::is_same<InteratorType, typename basic_json_t::const_iterator>::value
+                , int>::type
+        = 0>
+        InteratorType erase(InteratorType pos)
+        {
+            // make sure iterator fits the current value
+            if (this != pos.m_object)
+            {
+                throw std::domain_error("iterator does not fit current value");
+            }
+
+            InteratorType result = end();
+
+            switch (m_type)
+            {
+                case value_t::boolean:
+                case value_t::number_float:
+                case value_t::number_integer:
+                case value_t::number_unsigned:
+                case value_t::string:
+                {
+                    if (not pos.m_it.primitive_iterator.is_begin())
+                    {
+                        throw std::out_of_range("iterator out of range");
+                    }
+
+                    if (is_string())
+                    {
+                        delete m_value.string;
+                        m_value.string = nullptr;
+                    }
+
+                    m_type = value_t::null;
+                    break;
+                }
+
+                case value_t::object:
+                {
+                    assert(m_value.object != nullptr);
+                    result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
+                    break;
+                }
+
+                case value_t::array:
+                {
+                    assert(m_value.array != nullptr);
+                    result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
+                    break;
+                }
+
+                default:
+                {
+                    throw std::domain_error("cannot use erase() with " + type_name());
+                }
+            }
+
+            return result;
+        }
+
+        /*!
+    @brief remove elements given an iterator range
+
+    Removes the element specified by the range `[first; last)`. Invalidates
+    iterators and references at or after the point of the erase, including the
+    end() iterator. The iterator @a first does not need to be dereferenceable
+    if `first == last`: erasing an empty range is a no-op.
+
+    If called on a primitive type other than null, the resulting JSON value
+    will be `null`.
+
+    @param[in] first iterator to the beginning of the range to remove
+    @param[in] last iterator past the end of the range to remove
+    @return Iterator following the last removed element. If the iterator @a
+    second refers to the last element, the end() iterator is returned.
+
+    @tparam InteratorType an @ref iterator or @ref const_iterator
+
+    @throw std::domain_error if called on a `null` value; example: `"cannot use
+    erase() with null"`
+    @throw std::domain_error if called on iterators which does not belong to
+    the current JSON value; example: `"iterators do not fit current value"`
+    @throw std::out_of_range if called on a primitive type with invalid
+    iterators (i.e., if `first != begin()` and `last != end()`); example:
+    `"iterators out of range"`
+
+    @complexity The complexity depends on the type:
+    - objects: `log(size()) + std::distance(first, last)`
+    - arrays: linear in the distance between @a first and @a last, plus linear
+      in the distance between @a last and end of the container
+    - strings: linear in the length of the string
+    - other types: constant
+
+    @liveexample{The example shows the result of `erase()` for different JSON
+    types.,erase__IteratorType_IteratorType}
+
+    @sa @ref erase(InteratorType) -- removes the element at a given position
+    @sa @ref erase(const typename object_t::key_type&) -- removes the element
+    from an object at the given key
+    @sa @ref erase(const size_type) -- removes the element from an array at the
+    given index
+
+    @since version 1.0.0
+    */
+        template <class InteratorType, typename
+        std::enable_if<
+                std::is_same<InteratorType, typename basic_json_t::iterator>::value or
+                std::is_same<InteratorType, typename basic_json_t::const_iterator>::value
+                , int>::type
+        = 0>
+        InteratorType erase(InteratorType first, InteratorType last)
+        {
+            // make sure iterator fits the current value
+            if (this != first.m_object or this != last.m_object)
+            {
+                throw std::domain_error("iterators do not fit current value");
+            }
+
+            InteratorType result = end();
+
+            switch (m_type)
+            {
+                case value_t::boolean:
+                case value_t::number_float:
+                case value_t::number_integer:
+                case value_t::number_unsigned:
+                case value_t::string:
+                {
+                    if (not first.m_it.primitive_iterator.is_begin() or not last.m_it.primitive_iterator.is_end())
+                    {
+                        throw std::out_of_range("iterators out of range");
+                    }
+
+                    if (is_string())
+                    {
+                        delete m_value.string;
+                        m_value.string = nullptr;
+                    }
+
+                    m_type = value_t::null;
+                    break;
+                }
+
+                case value_t::object:
+                {
+                    assert(m_value.object != nullptr);
+                    result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
+                                                                        last.m_it.object_iterator);
+                    break;
+                }
+
+                case value_t::array:
+                {
+                    assert(m_value.array != nullptr);
+                    result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
+                                                                      last.m_it.array_iterator);
+                    break;
+                }
+
+                default:
+                {
+                    throw std::domain_error("cannot use erase() with " + type_name());
+                }
+            }
+
+            return result;
+        }
+
+        /*!
+    @brief remove element from a JSON object given a key
+
+    Removes elements from a JSON object with the key value @a key.
+
+    @param[in] key value of the elements to remove
+
+    @return Number of elements removed. If ObjectType is the default `std::map`
+    type, the return value will always be `0` (@a key was not found) or `1` (@a
+    key was found).
+
+    @throw std::domain_error when called on a type other than JSON object;
+    example: `"cannot use erase() with null"`
+
+    @complexity `log(size()) + count(key)`
+
+    @liveexample{The example shows the effect of `erase()`.,erase__key_type}
+
+    @sa @ref erase(InteratorType) -- removes the element at a given position
+    @sa @ref erase(InteratorType, InteratorType) -- removes the elements in the
+    given range
+    @sa @ref erase(const size_type) -- removes the element from an array at the
+    given index
+
+    @since version 1.0.0
+    */
+        size_type erase(const typename object_t::key_type& key)
+        {
+            // this erase only works for objects
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                return m_value.object->erase(key);
+            }
+            else
+            {
+                throw std::domain_error("cannot use erase() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief remove element from a JSON array given an index
+
+    Removes element from a JSON array at the index @a idx.
+
+    @param[in] idx index of the element to remove
+
+    @throw std::domain_error when called on a type other than JSON array;
+    example: `"cannot use erase() with null"`
+    @throw std::out_of_range when `idx >= size()`; example: `"index out of
+    range"`
+
+    @complexity Linear in distance between @a idx and the end of the container.
+
+    @liveexample{The example shows the effect of `erase()`.,erase__size_type}
+
+    @sa @ref erase(InteratorType) -- removes the element at a given position
+    @sa @ref erase(InteratorType, InteratorType) -- removes the elements in the
+    given range
+    @sa @ref erase(const typename object_t::key_type&) -- removes the element
+    from an object at the given key
+
+    @since version 1.0.0
+    */
+        void erase(const size_type idx)
+        {
+            // this erase only works for arrays
+            if (is_array())
+            {
+                if (idx >= size())
+                {
+                    throw std::out_of_range("index out of range");
+                }
+
+                assert(m_value.array != nullptr);
+                m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
+            }
+            else
+            {
+                throw std::domain_error("cannot use erase() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief find an element in a JSON object
+
+    Finds an element in a JSON object with key equivalent to @a key. If the
+    element is not found or the JSON value is not an object, end() is returned.
+
+    @param[in] key key value of the element to search for
+
+    @return Iterator to an element with key equivalent to @a key. If no such
+    element is found, past-the-end (see end()) iterator is returned.
+
+    @complexity Logarithmic in the size of the JSON object.
+
+    @liveexample{The example shows how `find()` is used.,find__key_type}
+
+    @since version 1.0.0
+    */
+        iterator find(typename object_t::key_type key)
+        {
+            auto result = end();
+
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                result.m_it.object_iterator = m_value.object->find(key);
+            }
+
+            return result;
+        }
+
+        /*!
+    @brief find an element in a JSON object
+    @copydoc find(typename object_t::key_type)
+    */
+        const_iterator find(typename object_t::key_type key) const
+        {
+            auto result = cend();
+
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                result.m_it.object_iterator = m_value.object->find(key);
+            }
+
+            return result;
+        }
+
+        /*!
+    @brief returns the number of occurrences of a key in a JSON object
+
+    Returns the number of elements with key @a key. If ObjectType is the
+    default `std::map` type, the return value will always be `0` (@a key was
+    not found) or `1` (@a key was found).
+
+    @param[in] key key value of the element to count
+
+    @return Number of elements with key @a key. If the JSON value is not an
+    object, the return value will be `0`.
+
+    @complexity Logarithmic in the size of the JSON object.
+
+    @liveexample{The example shows how `count()` is used.,count}
+
+    @since version 1.0.0
+    */
+        size_type count(typename object_t::key_type key) const
+        {
+            // return 0 for all nonobject types
+            assert(not is_object() or m_value.object != nullptr);
+            return is_object() ? m_value.object->count(key) : 0;
+        }
+
+        /// @}
+
+
+        ///////////////
+        // iterators //
+        ///////////////
+
+        /// @name iterators
+        /// @{
+
+        /*!
+    @brief returns an iterator to the first element
+
+    Returns an iterator to the first element.
+
+    @image html range-begin-end.svg "Illustration from cppreference.com"
+
+    @return iterator to the first element
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is constant.
+
+    @liveexample{The following code shows an example for `begin()`.,begin}
+
+    @sa @ref cbegin() -- returns a const iterator to the beginning
+    @sa @ref end() -- returns an iterator to the end
+    @sa @ref cend() -- returns a const iterator to the end
+
+    @since version 1.0.0
+    */
+        iterator begin()
+        {
+            iterator result(this);
+            result.set_begin();
+            return result;
+        }
+
+        /*!
+    @copydoc basic_json::cbegin()
+    */
+        const_iterator begin() const
+        {
+            return cbegin();
+        }
+
+        /*!
+    @brief returns a const iterator to the first element
+
+    Returns a const iterator to the first element.
+
+    @image html range-begin-end.svg "Illustration from cppreference.com"
+
+    @return const iterator to the first element
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of `const_cast<const basic_json&>(*this).begin()`.
+
+    @liveexample{The following code shows an example for `cbegin()`.,cbegin}
+
+    @sa @ref begin() -- returns an iterator to the beginning
+    @sa @ref end() -- returns an iterator to the end
+    @sa @ref cend() -- returns a const iterator to the end
+
+    @since version 1.0.0
+    */
+        const_iterator cbegin() const
+        {
+            const_iterator result(this);
+            result.set_begin();
+            return result;
+        }
+
+        /*!
+    @brief returns an iterator to one past the last element
+
+    Returns an iterator to one past the last element.
+
+    @image html range-begin-end.svg "Illustration from cppreference.com"
+
+    @return iterator one past the last element
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is constant.
+
+    @liveexample{The following code shows an example for `end()`.,end}
+
+    @sa @ref cend() -- returns a const iterator to the end
+    @sa @ref begin() -- returns an iterator to the beginning
+    @sa @ref cbegin() -- returns a const iterator to the beginning
+
+    @since version 1.0.0
+    */
+        iterator end()
+        {
+            iterator result(this);
+            result.set_end();
+            return result;
+        }
+
+        /*!
+    @copydoc basic_json::cend()
+    */
+        const_iterator end() const
+        {
+            return cend();
+        }
+
+        /*!
+    @brief returns a const iterator to one past the last element
+
+    Returns a const iterator to one past the last element.
+
+    @image html range-begin-end.svg "Illustration from cppreference.com"
+
+    @return const iterator one past the last element
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of `const_cast<const basic_json&>(*this).end()`.
+
+    @liveexample{The following code shows an example for `cend()`.,cend}
+
+    @sa @ref end() -- returns an iterator to the end
+    @sa @ref begin() -- returns an iterator to the beginning
+    @sa @ref cbegin() -- returns a const iterator to the beginning
+
+    @since version 1.0.0
+    */
+        const_iterator cend() const
+        {
+            const_iterator result(this);
+            result.set_end();
+            return result;
+        }
+
+        /*!
+    @brief returns an iterator to the reverse-beginning
+
+    Returns an iterator to the reverse-beginning; that is, the last element.
+
+    @image html range-rbegin-rend.svg "Illustration from cppreference.com"
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of `reverse_iterator(end())`.
+
+    @liveexample{The following code shows an example for `rbegin()`.,rbegin}
+
+    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
+    @sa @ref rend() -- returns a reverse iterator to the end
+    @sa @ref crend() -- returns a const reverse iterator to the end
+
+    @since version 1.0.0
+    */
+        reverse_iterator rbegin()
+        {
+            return reverse_iterator(end());
+        }
+
+        /*!
+    @copydoc basic_json::crbegin()
+    */
+        const_reverse_iterator rbegin() const
+        {
+            return crbegin();
+        }
+
+        /*!
+    @brief returns an iterator to the reverse-end
+
+    Returns an iterator to the reverse-end; that is, one before the first
+    element.
+
+    @image html range-rbegin-rend.svg "Illustration from cppreference.com"
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of `reverse_iterator(begin())`.
+
+    @liveexample{The following code shows an example for `rend()`.,rend}
+
+    @sa @ref crend() -- returns a const reverse iterator to the end
+    @sa @ref rbegin() -- returns a reverse iterator to the beginning
+    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
+
+    @since version 1.0.0
+    */
+        reverse_iterator rend()
+        {
+            return reverse_iterator(begin());
+        }
+
+        /*!
+    @copydoc basic_json::crend()
+    */
+        const_reverse_iterator rend() const
+        {
+            return crend();
+        }
+
+        /*!
+    @brief returns a const reverse iterator to the last element
+
+    Returns a const iterator to the reverse-beginning; that is, the last
+    element.
+
+    @image html range-rbegin-rend.svg "Illustration from cppreference.com"
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.
+
+    @liveexample{The following code shows an example for `crbegin()`.,crbegin}
+
+    @sa @ref rbegin() -- returns a reverse iterator to the beginning
+    @sa @ref rend() -- returns a reverse iterator to the end
+    @sa @ref crend() -- returns a const reverse iterator to the end
+
+    @since version 1.0.0
+    */
+        const_reverse_iterator crbegin() const
+        {
+            return const_reverse_iterator(cend());
+        }
+
+        /*!
+    @brief returns a const reverse iterator to one before the first
+
+    Returns a const reverse iterator to the reverse-end; that is, one before
+    the first element.
+
+    @image html range-rbegin-rend.svg "Illustration from cppreference.com"
+
+    @complexity Constant.
+
+    @requirement This function helps `basic_json` satisfying the
+    [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of `const_cast<const basic_json&>(*this).rend()`.
+
+    @liveexample{The following code shows an example for `crend()`.,crend}
+
+    @sa @ref rend() -- returns a reverse iterator to the end
+    @sa @ref rbegin() -- returns a reverse iterator to the beginning
+    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
+
+    @since version 1.0.0
+    */
+        const_reverse_iterator crend() const
+        {
+            return const_reverse_iterator(cbegin());
+        }
+
+    private:
+        // forward declaration
+        template<typename IteratorType> class iteration_proxy;
+
+    public:
+        /*!
+    @brief wrapper to access iterator member functions in range-based for
+
+    This function allows to access @ref iterator::key() and @ref
+    iterator::value() during range-based for loops. In these loops, a reference
+    to the JSON values is returned, so there is no access to the underlying
+    iterator.
+
+    @note The name of this function is not yet final and may change in the
+    future.
+    */
+        static iteration_proxy<iterator> iterator_wrapper(reference cont)
+        {
+            return iteration_proxy<iterator>(cont);
+        }
+
+        /*!
+    @copydoc iterator_wrapper(reference)
+    */
+        static iteration_proxy<const_iterator> iterator_wrapper(const_reference cont)
+        {
+            return iteration_proxy<const_iterator>(cont);
+        }
+
+        /// @}
+
+
+        //////////////
+        // capacity //
+        //////////////
+
+        /// @name capacity
+        /// @{
+
+        /*!
+    @brief checks whether the container is empty
+
+    Checks if a JSON value has no elements.
+
+    @return The return value depends on the different types and is
+            defined as follows:
+            Value type  | return value
+            ----------- | -------------
+            null        | `true`
+            boolean     | `false`
+            string      | `false`
+            number      | `false`
+            object      | result of function `object_t::empty()`
+            array       | result of function `array_t::empty()`
+
+    @complexity Constant, as long as @ref array_t and @ref object_t satisfy the
+    Container concept; that is, their `empty()` functions have constant
+    complexity.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of `begin() == end()`.
+
+    @liveexample{The following code uses `empty()` to check if a JSON
+    object contains any elements.,empty}
+
+    @sa @ref size() -- returns the number of elements
+
+    @since version 1.0.0
+    */
+        bool empty() const noexcept
+        {
+            switch (m_type)
+            {
+                case value_t::null:
+                {
+                    // null values are empty
+                    return true;
+                }
+
+                case value_t::array:
+                {
+                    assert(m_value.array != nullptr);
+                    return m_value.array->empty();
+                }
+
+                case value_t::object:
+                {
+                    assert(m_value.object != nullptr);
+                    return m_value.object->empty();
+                }
+
+                default:
+                {
+                    // all other types are nonempty
+                    return false;
+                }
+            }
+        }
+
+        /*!
+    @brief returns the number of elements
+
+    Returns the number of elements in a JSON value.
+
+    @return The return value depends on the different types and is
+            defined as follows:
+            Value type  | return value
+            ----------- | -------------
+            null        | `0`
+            boolean     | `1`
+            string      | `1`
+            number      | `1`
+            object      | result of function object_t::size()
+            array       | result of function array_t::size()
+
+    @complexity Constant, as long as @ref array_t and @ref object_t satisfy the
+    Container concept; that is, their size() functions have constant complexity.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of `std::distance(begin(), end())`.
+
+    @liveexample{The following code calls `size()` on the different value
+    types.,size}
+
+    @sa @ref empty() -- checks whether the container is empty
+    @sa @ref max_size() -- returns the maximal number of elements
+
+    @since version 1.0.0
+    */
+        size_type size() const noexcept
+        {
+            switch (m_type)
+            {
+                case value_t::null:
+                {
+                    // null values are empty
+                    return 0;
+                }
+
+                case value_t::array:
+                {
+                    assert(m_value.array != nullptr);
+                    return m_value.array->size();
+                }
+
+                case value_t::object:
+                {
+                    assert(m_value.object != nullptr);
+                    return m_value.object->size();
+                }
+
+                default:
+                {
+                    // all other types have size 1
+                    return 1;
+                }
+            }
+        }
+
+        /*!
+    @brief returns the maximum possible number of elements
+
+    Returns the maximum number of elements a JSON value is able to hold due to
+    system or library implementation limitations, i.e. `std::distance(begin(),
+    end())` for the JSON value.
+
+    @return The return value depends on the different types and is
+            defined as follows:
+            Value type  | return value
+            ----------- | -------------
+            null        | `0` (same as `size()`)
+            boolean     | `1` (same as `size()`)
+            string      | `1` (same as `size()`)
+            number      | `1` (same as `size()`)
+            object      | result of function `object_t::max_size()`
+            array       | result of function `array_t::max_size()`
+
+    @complexity Constant, as long as @ref array_t and @ref object_t satisfy the
+    Container concept; that is, their `max_size()` functions have constant
+    complexity.
+
+    @requirement This function helps `basic_json` satisfying the
+    [Container](http://en.cppreference.com/w/cpp/concept/Container)
+    requirements:
+    - The complexity is constant.
+    - Has the semantics of returning `b.size()` where `b` is the largest
+      possible JSON value.
+
+    @liveexample{The following code calls `max_size()` on the different value
+    types. Note the output is implementation specific.,max_size}
+
+    @sa @ref size() -- returns the number of elements
+
+    @since version 1.0.0
+    */
+        size_type max_size() const noexcept
+        {
+            switch (m_type)
+            {
+                case value_t::array:
+                {
+                    assert(m_value.array != nullptr);
+                    return m_value.array->max_size();
+                }
+
+                case value_t::object:
+                {
+                    assert(m_value.object != nullptr);
+                    return m_value.object->max_size();
+                }
+
+                default:
+                {
+                    // all other types have max_size() == size()
+                    return size();
+                }
+            }
+        }
+
+        /// @}
+
+
+        ///////////////
+        // modifiers //
+        ///////////////
+
+        /// @name modifiers
+        /// @{
+
+        /*!
+    @brief clears the contents
+
+    Clears the content of a JSON value and resets it to the default value as
+    if @ref basic_json(value_t) would have been called:
+
+    Value type  | initial value
+    ----------- | -------------
+    null        | `null`
+    boolean     | `false`
+    string      | `""`
+    number      | `0`
+    object      | `{}`
+    array       | `[]`
+
+    @note Floating-point numbers are set to `0.0` which will be serialized to
+    `0`. The vale type remains @ref number_float_t.
+
+    @complexity Linear in the size of the JSON value.
+
+    @liveexample{The example below shows the effect of `clear()` to different
+    JSON types.,clear}
+
+    @since version 1.0.0
+    */
+        void clear() noexcept
+        {
+            switch (m_type)
+            {
+                case value_t::number_integer:
+                {
+                    m_value.number_integer = 0;
+                    break;
+                }
+
+                case value_t::number_unsigned:
+                {
+                    m_value.number_unsigned = 0;
+                    break;
+                }
+
+                case value_t::number_float:
+                {
+                    m_value.number_float = 0.0;
+                    break;
+                }
+
+                case value_t::boolean:
+                {
+                    m_value.boolean = false;
+                    break;
+                }
+
+                case value_t::string:
+                {
+                    assert(m_value.string != nullptr);
+                    m_value.string->clear();
+                    break;
+                }
+
+                case value_t::array:
+                {
+                    assert(m_value.array != nullptr);
+                    m_value.array->clear();
+                    break;
+                }
+
+                case value_t::object:
+                {
+                    assert(m_value.object != nullptr);
+                    m_value.object->clear();
+                    break;
+                }
+
+                default:
+                {
+                    break;
+                }
+            }
+        }
+
+        /*!
+    @brief add an object to an array
+
+    Appends the given element @a val to the end of the JSON value. If the
+    function is called on a JSON null value, an empty array is created before
+    appending @a val.
+
+    @param[in] val the value to add to the JSON array
+
+    @throw std::domain_error when called on a type other than JSON array or
+    null; example: `"cannot use push_back() with number"`
+
+    @complexity Amortized constant.
+
+    @liveexample{The example shows how `push_back()` and `+=` can be used to
+    add elements to a JSON array. Note how the `null` value was silently
+    converted to a JSON array.,push_back}
+
+    @since version 1.0.0
+    */
+        void push_back(basic_json&& val)
+        {
+            // push_back only works for null objects or arrays
+            if (not(is_null() or is_array()))
+            {
+                throw std::domain_error("cannot use push_back() with " + type_name());
+            }
+
+            // transform null object into an array
+            if (is_null())
+            {
+                m_type = value_t::array;
+                m_value = value_t::array;
+            }
+
+            // add element to array (move semantics)
+            assert(m_value.array != nullptr);
+            m_value.array->push_back(std::move(val));
+            // invalidate object
+            val.m_type = value_t::null;
+        }
+
+        /*!
+    @brief add an object to an array
+    @copydoc push_back(basic_json&&)
+    */
+        reference operator+=(basic_json&& val)
+        {
+            push_back(std::move(val));
+            return *this;
+        }
+
+        /*!
+    @brief add an object to an array
+    @copydoc push_back(basic_json&&)
+    */
+        void push_back(const basic_json& val)
+        {
+            // push_back only works for null objects or arrays
+            if (not(is_null() or is_array()))
+            {
+                throw std::domain_error("cannot use push_back() with " + type_name());
+            }
+
+            // transform null object into an array
+            if (is_null())
+            {
+                m_type = value_t::array;
+                m_value = value_t::array;
+            }
+
+            // add element to array
+            assert(m_value.array != nullptr);
+            m_value.array->push_back(val);
+        }
+
+        /*!
+    @brief add an object to an array
+    @copydoc push_back(basic_json&&)
+    */
+        reference operator+=(const basic_json& val)
+        {
+            push_back(val);
+            return *this;
+        }
+
+        /*!
+    @brief add an object to an object
+
+    Inserts the given element @a val to the JSON object. If the function is
+    called on a JSON null value, an empty object is created before inserting @a
+    val.
+
+    @param[in] val the value to add to the JSON object
+
+    @throw std::domain_error when called on a type other than JSON object or
+    null; example: `"cannot use push_back() with number"`
+
+    @complexity Logarithmic in the size of the container, O(log(`size()`)).
+
+    @liveexample{The example shows how `push_back()` and `+=` can be used to
+    add elements to a JSON object. Note how the `null` value was silently
+    converted to a JSON object.,push_back__object_t__value}
+
+    @since version 1.0.0
+    */
+        void push_back(const typename object_t::value_type& val)
+        {
+            // push_back only works for null objects or objects
+            if (not(is_null() or is_object()))
+            {
+                throw std::domain_error("cannot use push_back() with " + type_name());
+            }
+
+            // transform null object into an object
+            if (is_null())
+            {
+                m_type = value_t::object;
+                m_value = value_t::object;
+            }
+
+            // add element to array
+            assert(m_value.object != nullptr);
+            m_value.object->insert(val);
+        }
+
+        /*!
+    @brief add an object to an object
+    @copydoc push_back(const typename object_t::value_type&)
+    */
+        reference operator+=(const typename object_t::value_type& val)
+        {
+            push_back(val);
+            return operator[](val.first);
+        }
+
+        /*!
+    @brief inserts element
+
+    Inserts element @a val before iterator @a pos.
+
+    @param[in] pos iterator before which the content will be inserted; may be
+    the end() iterator
+    @param[in] val element to insert
+    @return iterator pointing to the inserted @a val.
+
+    @throw std::domain_error if called on JSON values other than arrays;
+    example: `"cannot use insert() with string"`
+    @throw std::domain_error if @a pos is not an iterator of *this; example:
+    `"iterator does not fit current value"`
+
+    @complexity Constant plus linear in the distance between pos and end of the
+    container.
+
+    @liveexample{The example shows how `insert()` is used.,insert}
+
+    @since version 1.0.0
+    */
+        iterator insert(const_iterator pos, const basic_json& val)
+        {
+            // insert only works for arrays
+            if (is_array())
+            {
+                // check if iterator pos fits to this JSON value
+                if (pos.m_object != this)
+                {
+                    throw std::domain_error("iterator does not fit current value");
+                }
+
+                // insert to array and return iterator
+                iterator result(this);
+                assert(m_value.array != nullptr);
+                result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, val);
+                return result;
+            }
+            else
+            {
+                throw std::domain_error("cannot use insert() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief inserts element
+    @copydoc insert(const_iterator, const basic_json&)
+    */
+        iterator insert(const_iterator pos, basic_json&& val)
+        {
+            return insert(pos, val);
+        }
+
+        /*!
+    @brief inserts elements
+
+    Inserts @a cnt copies of @a val before iterator @a pos.
+
+    @param[in] pos iterator before which the content will be inserted; may be
+    the end() iterator
+    @param[in] cnt number of copies of @a val to insert
+    @param[in] val element to insert
+    @return iterator pointing to the first element inserted, or @a pos if
+    `cnt==0`
+
+    @throw std::domain_error if called on JSON values other than arrays;
+    example: `"cannot use insert() with string"`
+    @throw std::domain_error if @a pos is not an iterator of *this; example:
+    `"iterator does not fit current value"`
+
+    @complexity Linear in @a cnt plus linear in the distance between @a pos
+    and end of the container.
+
+    @liveexample{The example shows how `insert()` is used.,insert__count}
+
+    @since version 1.0.0
+    */
+        iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
+        {
+            // insert only works for arrays
+            if (is_array())
+            {
+                // check if iterator pos fits to this JSON value
+                if (pos.m_object != this)
+                {
+                    throw std::domain_error("iterator does not fit current value");
+                }
+
+                // insert to array and return iterator
+                iterator result(this);
+                assert(m_value.array != nullptr);
+                result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);
+                return result;
+            }
+            else
+            {
+                throw std::domain_error("cannot use insert() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief inserts elements
+
+    Inserts elements from range `[first, last)` before iterator @a pos.
+
+    @param[in] pos iterator before which the content will be inserted; may be
+    the end() iterator
+    @param[in] first begin of the range of elements to insert
+    @param[in] last end of the range of elements to insert
+
+    @throw std::domain_error if called on JSON values other than arrays;
+    example: `"cannot use insert() with string"`
+    @throw std::domain_error if @a pos is not an iterator of *this; example:
+    `"iterator does not fit current value"`
+    @throw std::domain_error if @a first and @a last do not belong to the same
+    JSON value; example: `"iterators do not fit"`
+    @throw std::domain_error if @a first or @a last are iterators into
+    container for which insert is called; example: `"passed iterators may not
+    belong to container"`
+
+    @return iterator pointing to the first element inserted, or @a pos if
+    `first==last`
+
+    @complexity Linear in `std::distance(first, last)` plus linear in the
+    distance between @a pos and end of the container.
+
+    @liveexample{The example shows how `insert()` is used.,insert__range}
+
+    @since version 1.0.0
+    */
+        iterator insert(const_iterator pos, const_iterator first, const_iterator last)
+        {
+            // insert only works for arrays
+            if (not is_array())
+            {
+                throw std::domain_error("cannot use insert() with " + type_name());
+            }
+
+            // check if iterator pos fits to this JSON value
+            if (pos.m_object != this)
+            {
+                throw std::domain_error("iterator does not fit current value");
+            }
+
+            if (first.m_object != last.m_object)
+            {
+                throw std::domain_error("iterators do not fit");
+            }
+
+            if (first.m_object == this or last.m_object == this)
+            {
+                throw std::domain_error("passed iterators may not belong to container");
+            }
+
+            // insert to array and return iterator
+            iterator result(this);
+            assert(m_value.array != nullptr);
+            result.m_it.array_iterator = m_value.array->insert(
+                    pos.m_it.array_iterator,
+                    first.m_it.array_iterator,
+                    last.m_it.array_iterator);
+            return result;
+        }
+
+        /*!
+    @brief inserts elements
+
+    Inserts elements from initializer list @a ilist before iterator @a pos.
+
+    @param[in] pos iterator before which the content will be inserted; may be
+    the end() iterator
+    @param[in] ilist initializer list to insert the values from
+
+    @throw std::domain_error if called on JSON values other than arrays;
+    example: `"cannot use insert() with string"`
+    @throw std::domain_error if @a pos is not an iterator of *this; example:
+    `"iterator does not fit current value"`
+
+    @return iterator pointing to the first element inserted, or @a pos if
+    `ilist` is empty
+
+    @complexity Linear in `ilist.size()` plus linear in the distance between @a
+    pos and end of the container.
+
+    @liveexample{The example shows how `insert()` is used.,insert__ilist}
+
+    @since version 1.0.0
+    */
+        iterator insert(const_iterator pos, std::initializer_list<basic_json> ilist)
+        {
+            // insert only works for arrays
+            if (not is_array())
+            {
+                throw std::domain_error("cannot use insert() with " + type_name());
+            }
+
+            // check if iterator pos fits to this JSON value
+            if (pos.m_object != this)
+            {
+                throw std::domain_error("iterator does not fit current value");
+            }
+
+            // insert to array and return iterator
+            iterator result(this);
+            assert(m_value.array != nullptr);
+            result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, ilist);
+            return result;
+        }
+
+        /*!
+    @brief exchanges the values
+
+    Exchanges the contents of the JSON value with those of @a other. Does not
+    invoke any move, copy, or swap operations on individual elements. All
+    iterators and references remain valid. The past-the-end iterator is
+    invalidated.
+
+    @param[in,out] other JSON value to exchange the contents with
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how JSON values can be swapped with
+    `swap()`.,swap__reference}
+
+    @since version 1.0.0
+    */
+        void swap(reference other) noexcept (
+        std::is_nothrow_move_constructible<value_t>::value and
+        std::is_nothrow_move_assignable<value_t>::value and
+        std::is_nothrow_move_constructible<json_value>::value and
+        std::is_nothrow_move_assignable<json_value>::value
+        )
+        {
+            std::swap(m_type, other.m_type);
+            std::swap(m_value, other.m_value);
+        }
+
+        /*!
+    @brief exchanges the values
+
+    Exchanges the contents of a JSON array with those of @a other. Does not
+    invoke any move, copy, or swap operations on individual elements. All
+    iterators and references remain valid. The past-the-end iterator is
+    invalidated.
+
+    @param[in,out] other array to exchange the contents with
+
+    @throw std::domain_error when JSON value is not an array; example: `"cannot
+    use swap() with string"`
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how arrays can be swapped with
+    `swap()`.,swap__array_t}
+
+    @since version 1.0.0
+    */
+        void swap(array_t& other)
+        {
+            // swap only works for arrays
+            if (is_array())
+            {
+                assert(m_value.array != nullptr);
+                std::swap(*(m_value.array), other);
+            }
+            else
+            {
+                throw std::domain_error("cannot use swap() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief exchanges the values
+
+    Exchanges the contents of a JSON object with those of @a other. Does not
+    invoke any move, copy, or swap operations on individual elements. All
+    iterators and references remain valid. The past-the-end iterator is
+    invalidated.
+
+    @param[in,out] other object to exchange the contents with
+
+    @throw std::domain_error when JSON value is not an object; example:
+    `"cannot use swap() with string"`
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how objects can be swapped with
+    `swap()`.,swap__object_t}
+
+    @since version 1.0.0
+    */
+        void swap(object_t& other)
+        {
+            // swap only works for objects
+            if (is_object())
+            {
+                assert(m_value.object != nullptr);
+                std::swap(*(m_value.object), other);
+            }
+            else
+            {
+                throw std::domain_error("cannot use swap() with " + type_name());
+            }
+        }
+
+        /*!
+    @brief exchanges the values
+
+    Exchanges the contents of a JSON string with those of @a other. Does not
+    invoke any move, copy, or swap operations on individual elements. All
+    iterators and references remain valid. The past-the-end iterator is
+    invalidated.
+
+    @param[in,out] other string to exchange the contents with
+
+    @throw std::domain_error when JSON value is not a string; example: `"cannot
+    use swap() with boolean"`
+
+    @complexity Constant.
+
+    @liveexample{The example below shows how strings can be swapped with
+    `swap()`.,swap__string_t}
+
+    @since version 1.0.0
+    */
+        void swap(string_t& other)
+        {
+            // swap only works for strings
+            if (is_string())
+            {
+                assert(m_value.string != nullptr);
+                std::swap(*(m_value.string), other);
+            }
+            else
+            {
+                throw std::domain_error("cannot use swap() with " + type_name());
+            }
+        }
+
+        /// @}
+
+
+        //////////////////////////////////////////
+        // lexicographical comparison operators //
+        //////////////////////////////////////////
+
+        /// @name lexicographical comparison operators
+        /// @{
+
+    private:
+        /*!
+    @brief comparison operator for JSON types
+
+    Returns an ordering that is similar to Python:
+    - order: null < boolean < number < object < array < string
+    - furthermore, each type is not smaller than itself
+
+    @since version 1.0.0
+    */
+        friend bool operator<(const value_t lhs, const value_t rhs)
+        {
+            static constexpr std::array<uint8_t, 8> order = {{
+                                                                     0, // null
+                                                                     3, // object
+                                                                     4, // array
+                                                                     5, // string
+                                                                     1, // boolean
+                                                                     2, // integer
+                                                                     2, // unsigned
+                                                                     2, // float
+                                                             }
+            };
+
+            // discarded values are not comparable
+            if (lhs == value_t::discarded or rhs == value_t::discarded)
+            {
+                return false;
+            }
+
+            return order[static_cast<std::size_t>(lhs)] < order[static_cast<std::size_t>(rhs)];
+        }
+
+    public:
+        /*!
+    @brief comparison: equal
+
+    Compares two JSON values for equality according to the following rules:
+    - Two JSON values are equal if (1) they are from the same type and (2)
+      their stored values are the same.
+    - Integer and floating-point numbers are automatically converted before
+      comparison. Floating-point numbers are compared indirectly: two
+      floating-point numbers `f1` and `f2` are considered equal if neither
+      `f1 > f2` nor `f2 > f1` holds.
+    - Two JSON null values are equal.
+
+    @param[in] lhs  first JSON value to consider
+    @param[in] rhs  second JSON value to consider
+    @return whether the values @a lhs and @a rhs are equal
+
+    @complexity Linear.
+
+    @liveexample{The example demonstrates comparing several JSON
+    types.,operator__equal}
+
+    @since version 1.0.0
+    */
+        friend bool operator==(const_reference lhs, const_reference rhs) noexcept
+        {
+            const auto lhs_type = lhs.type();
+            const auto rhs_type = rhs.type();
+
+            if (lhs_type == rhs_type)
+            {
+                switch (lhs_type)
+                {
+                    case value_t::array:
+                    {
+                        assert(lhs.m_value.array != nullptr);
+                        assert(rhs.m_value.array != nullptr);
+                        return *lhs.m_value.array == *rhs.m_value.array;
+                    }
+                    case value_t::object:
+                    {
+                        assert(lhs.m_value.object != nullptr);
+                        assert(rhs.m_value.object != nullptr);
+                        return *lhs.m_value.object == *rhs.m_value.object;
+                    }
+                    case value_t::null:
+                    {
+                        return true;
+                    }
+                    case value_t::string:
+                    {
+                        assert(lhs.m_value.string != nullptr);
+                        assert(rhs.m_value.string != nullptr);
+                        return *lhs.m_value.string == *rhs.m_value.string;
+                    }
+                    case value_t::boolean:
+                    {
+                        return lhs.m_value.boolean == rhs.m_value.boolean;
+                    }
+                    case value_t::number_integer:
+                    {
+                        return lhs.m_value.number_integer == rhs.m_value.number_integer;
+                    }
+                    case value_t::number_unsigned:
+                    {
+                        return lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;
+                    }
+                    case value_t::number_float:
+                    {
+                        return lhs.m_value.number_float == rhs.m_value.number_float;
+                    }
+                    default:
+                    {
+                        return false;
+                    }
+                }
+            }
+            else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
+            {
+                return static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float;
+            }
+            else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
+            {
+                return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer);
+            }
+            else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
+            {
+                return static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float;
+            }
+            else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
+            {
+                return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned);
+            }
+            else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
+            {
+                return static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;
+            }
+            else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
+            {
+                return lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned);
+            }
+
+            return false;
+        }
+
+        /*!
+    @brief comparison: equal
+
+    The functions compares the given JSON value against a null pointer. As the
+    null pointer can be used to initialize a JSON value to null, a comparison
+    of JSON value @a v with a null pointer should be equivalent to call
+    `v.is_null()`.
+
+    @param[in] v  JSON value to consider
+    @return whether @a v is null
+
+    @complexity Constant.
+
+    @liveexample{The example compares several JSON types to the null pointer.
+    ,operator__equal__nullptr_t}
+
+    @since version 1.0.0
+    */
+        friend bool operator==(const_reference v, std::nullptr_t) noexcept
+        {
+            return v.is_null();
+        }
+
+        /*!
+    @brief comparison: equal
+    @copydoc operator==(const_reference, std::nullptr_t)
+    */
+        friend bool operator==(std::nullptr_t, const_reference v) noexcept
+        {
+            return v.is_null();
+        }
+
+        /*!
+    @brief comparison: not equal
+
+    Compares two JSON values for inequality by calculating `not (lhs == rhs)`.
+
+    @param[in] lhs  first JSON value to consider
+    @param[in] rhs  second JSON value to consider
+    @return whether the values @a lhs and @a rhs are not equal
+
+    @complexity Linear.
+
+    @liveexample{The example demonstrates comparing several JSON
+    types.,operator__notequal}
+
+    @since version 1.0.0
+    */
+        friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
+        {
+            return not (lhs == rhs);
+        }
+
+        /*!
+    @brief comparison: not equal
+
+    The functions compares the given JSON value against a null pointer. As the
+    null pointer can be used to initialize a JSON value to null, a comparison
+    of JSON value @a v with a null pointer should be equivalent to call
+    `not v.is_null()`.
+
+    @param[in] v  JSON value to consider
+    @return whether @a v is not null
+
+    @complexity Constant.
+
+    @liveexample{The example compares several JSON types to the null pointer.
+    ,operator__notequal__nullptr_t}
+
+    @since version 1.0.0
+    */
+        friend bool operator!=(const_reference v, std::nullptr_t) noexcept
+        {
+            return not v.is_null();
+        }
+
+        /*!
+    @brief comparison: not equal
+    @copydoc operator!=(const_reference, std::nullptr_t)
+    */
+        friend bool operator!=(std::nullptr_t, const_reference v) noexcept
+        {
+            return not v.is_null();
+        }
+
+        /*!
+    @brief comparison: less than
+
+    Compares whether one JSON value @a lhs is less than another JSON value @a
+    rhs according to the following rules:
+    - If @a lhs and @a rhs have the same type, the values are compared using
+      the default `<` operator.
+    - Integer and floating-point numbers are automatically converted before
+      comparison
+    - In case @a lhs and @a rhs have different types, the values are ignored
+      and the order of the types is considered, see
+      @ref operator<(const value_t, const value_t).
+
+    @param[in] lhs  first JSON value to consider
+    @param[in] rhs  second JSON value to consider
+    @return whether @a lhs is less than @a rhs
+
+    @complexity Linear.
+
+    @liveexample{The example demonstrates comparing several JSON
+    types.,operator__less}
+
+    @since version 1.0.0
+    */
+        friend bool operator<(const_reference lhs, const_reference rhs) noexcept
+        {
+            const auto lhs_type = lhs.type();
+            const auto rhs_type = rhs.type();
+
+            if (lhs_type == rhs_type)
+            {
+                switch (lhs_type)
+                {
+                    case value_t::array:
+                    {
+                        assert(lhs.m_value.array != nullptr);
+                        assert(rhs.m_value.array != nullptr);
+                        return *lhs.m_value.array < *rhs.m_value.array;
+                    }
+                    case value_t::object:
+                    {
+                        assert(lhs.m_value.object != nullptr);
+                        assert(rhs.m_value.object != nullptr);
+                        return *lhs.m_value.object < *rhs.m_value.object;
+                    }
+                    case value_t::null:
+                    {
+                        return false;
+                    }
+                    case value_t::string:
+                    {
+                        assert(lhs.m_value.string != nullptr);
+                        assert(rhs.m_value.string != nullptr);
+                        return *lhs.m_value.string < *rhs.m_value.string;
+                    }
+                    case value_t::boolean:
+                    {
+                        return lhs.m_value.boolean < rhs.m_value.boolean;
+                    }
+                    case value_t::number_integer:
+                    {
+                        return lhs.m_value.number_integer < rhs.m_value.number_integer;
+                    }
+                    case value_t::number_unsigned:
+                    {
+                        return lhs.m_value.number_unsigned < rhs.m_value.number_unsigned;
+                    }
+                    case value_t::number_float:
+                    {
+                        return lhs.m_value.number_float < rhs.m_value.number_float;
+                    }
+                    default:
+                    {
+                        return false;
+                    }
+                }
+            }
+            else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
+            {
+                return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
+            }
+            else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
+            {
+                return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
+            }
+            else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
+            {
+                return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
+            }
+            else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
+            {
+                return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
+            }
+            else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
+            {
+                return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
+            }
+            else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
+            {
+                return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
+            }
+
+            // We only reach this line if we cannot compare values. In that case,
+            // we compare types. Note we have to call the operator explicitly,
+            // because MSVC has problems otherwise.
+            return operator<(lhs_type, rhs_type);
+        }
+
+        /*!
+    @brief comparison: less than or equal
+
+    Compares whether one JSON value @a lhs is less than or equal to another
+    JSON value by calculating `not (rhs < lhs)`.
+
+    @param[in] lhs  first JSON value to consider
+    @param[in] rhs  second JSON value to consider
+    @return whether @a lhs is less than or equal to @a rhs
+
+    @complexity Linear.
+
+    @liveexample{The example demonstrates comparing several JSON
+    types.,operator__greater}
+
+    @since version 1.0.0
+    */
+        friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
+        {
+            return not (rhs < lhs);
+        }
+
+        /*!
+    @brief comparison: greater than
+
+    Compares whether one JSON value @a lhs is greater than another
+    JSON value by calculating `not (lhs <= rhs)`.
+
+    @param[in] lhs  first JSON value to consider
+    @param[in] rhs  second JSON value to consider
+    @return whether @a lhs is greater than to @a rhs
+
+    @complexity Linear.
+
+    @liveexample{The example demonstrates comparing several JSON
+    types.,operator__lessequal}
+
+    @since version 1.0.0
+    */
+        friend bool operator>(const_reference lhs, const_reference rhs) noexcept
+        {
+            return not (lhs <= rhs);
+        }
+
+        /*!
+    @brief comparison: greater than or equal
+
+    Compares whether one JSON value @a lhs is greater than or equal to another
+    JSON value by calculating `not (lhs < rhs)`.
+
+    @param[in] lhs  first JSON value to consider
+    @param[in] rhs  second JSON value to consider
+    @return whether @a lhs is greater than or equal to @a rhs
+
+    @complexity Linear.
+
+    @liveexample{The example demonstrates comparing several JSON
+    types.,operator__greaterequal}
+
+    @since version 1.0.0
+    */
+        friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
+        {
+            return not (lhs < rhs);
+        }
+
+        /// @}
+
+
+        ///////////////////
+        // serialization //
+        ///////////////////
+
+        /// @name serialization
+        /// @{
+
+        /*!
+    @brief serialize to stream
+
+    Serialize the given JSON value @a j to the output stream @a o. The JSON
+    value will be serialized using the @ref dump member function. The
+    indentation of the output can be controlled with the member variable
+    `width` of the output stream @a o. For instance, using the manipulator
+    `std::setw(4)` on @a o sets the indentation level to `4` and the
+    serialization result is the same as calling `dump(4)`.
+
+    @param[in,out] o  stream to serialize to
+    @param[in] j  JSON value to serialize
+
+    @return the stream @a o
+
+    @complexity Linear.
+
+    @liveexample{The example below shows the serialization with different
+    parameters to `width` to adjust the indentation level.,operator_serialize}
+
+    @since version 1.0.0
+    */
+        friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
+        {
+            // read width member and use it as indentation parameter if nonzero
+            const bool pretty_print = (o.width() > 0);
+            const auto indentation = (pretty_print ? o.width() : 0);
+
+            // reset width to 0 for subsequent calls to this stream
+            o.width(0);
+
+            // do the actual serialization
+            j.dump(o, pretty_print, static_cast<unsigned int>(indentation));
+            return o;
+        }
+
+        /*!
+    @brief serialize to stream
+    @copydoc operator<<(std::ostream&, const basic_json&)
+    */
+        friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
+        {
+            return o << j;
+        }
+
+        /// @}
+
+
+        /////////////////////
+        // deserialization //
+        /////////////////////
+
+        /// @name deserialization
+        /// @{
+
+        /*!
+    @brief deserialize from string
+
+    @param[in] s  string to read a serialized JSON value from
+    @param[in] cb a parser callback function of type @ref parser_callback_t
+    which is used to control the deserialization by filtering unwanted values
+    (optional)
+
+    @return result of the deserialization
+
+    @complexity Linear in the length of the input. The parser is a predictive
+    LL(1) parser. The complexity can be higher if the parser callback function
+    @a cb has a super-linear complexity.
+
+    @note A UTF-8 byte order mark is silently ignored.
+
+    @liveexample{The example below demonstrates the `parse()` function with and
+    without callback function.,parse__string__parser_callback_t}
+
+    @sa @ref parse(std::istream&, parser_callback_t) for a version that reads
+    from an input stream
+
+    @since version 1.0.0
+    */
+        static basic_json parse(const string_t& s, parser_callback_t cb = nullptr)
+        {
+            return parser(s, cb).parse();
+        }
+
+        /*!
+    @brief deserialize from stream
+
+    @param[in,out] i  stream to read a serialized JSON value from
+    @param[in] cb a parser callback function of type @ref parser_callback_t
+    which is used to control the deserialization by filtering unwanted values
+    (optional)
+
+    @return result of the deserialization
+
+    @complexity Linear in the length of the input. The parser is a predictive
+    LL(1) parser. The complexity can be higher if the parser callback function
+    @a cb has a super-linear complexity.
+
+    @note A UTF-8 byte order mark is silently ignored.
+
+    @liveexample{The example below demonstrates the `parse()` function with and
+    without callback function.,parse__istream__parser_callback_t}
+
+    @sa @ref parse(const string_t&, parser_callback_t) for a version that reads
+    from a string
+
+    @since version 1.0.0
+    */
+        static basic_json parse(std::istream& i, parser_callback_t cb = nullptr)
+        {
+            return parser(i, cb).parse();
+        }
+
+        /*!
+    @copydoc parse(std::istream&, parser_callback_t)
+    */
+        static basic_json parse(std::istream&& i, parser_callback_t cb = nullptr)
+        {
+            return parser(i, cb).parse();
+        }
+
+        /*!
+    @brief deserialize from stream
+
+    Deserializes an input stream to a JSON value.
+
+    @param[in,out] i  input stream to read a serialized JSON value from
+    @param[in,out] j  JSON value to write the deserialized input to
+
+    @throw std::invalid_argument in case of parse errors
+
+    @complexity Linear in the length of the input. The parser is a predictive
+    LL(1) parser.
+
+    @note A UTF-8 byte order mark is silently ignored.
+
+    @liveexample{The example below shows how a JSON value is constructed by
+    reading a serialization from a stream.,operator_deserialize}
+
+    @sa parse(std::istream&, parser_callback_t) for a variant with a parser
+    callback function to filter values while parsing
+
+    @since version 1.0.0
+    */
+        friend std::istream& operator<<(basic_json& j, std::istream& i)
+        {
+            j = parser(i).parse();
+            return i;
+        }
+
+        /*!
+    @brief deserialize from stream
+    @copydoc operator<<(basic_json&, std::istream&)
+    */
+        friend std::istream& operator>>(std::istream& i, basic_json& j)
+        {
+            j = parser(i).parse();
+            return i;
+        }
+
+        /// @}
+
+
+    private:
+        ///////////////////////////
+        // convenience functions //
+        ///////////////////////////
+
+        /// return the type as string
+        string_t type_name() const
+        {
+            switch (m_type)
+            {
+                case value_t::null:
+                    return "null";
+                case value_t::object:
+                    return "object";
+                case value_t::array:
+                    return "array";
+                case value_t::string:
+                    return "string";
+                case value_t::boolean:
+                    return "boolean";
+                case value_t::discarded:
+                    return "discarded";
+                default:
+                    return "number";
+            }
+        }
+
+        /*!
+    @brief calculates the extra space to escape a JSON string
+
+    @param[in] s  the string to escape
+    @return the number of characters required to escape string @a s
+
+    @complexity Linear in the length of string @a s.
+    */
+        static std::size_t extra_space(const string_t& s) noexcept
+        {
+            std::size_t result = 0;
+
+            for (const auto& c : s)
+            {
+                switch (c)
+                {
+                    case '"':
+                    case '\\':
+                    case '\b':
+                    case '\f':
+                    case '\n':
+                    case '\r':
+                    case '\t':
+                    {
+                        // from c (1 byte) to \x (2 bytes)
+                        result += 1;
+                        break;
+                    }
+
+                    default:
+                    {
+                        if (c >= 0x00 and c <= 0x1f)
+                        {
+                            // from c (1 byte) to \uxxxx (6 bytes)
+                            result += 5;
+                        }
+                        break;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        /*!
+    @brief escape a string
+
+    Escape a string by replacing certain special characters by a sequence of an
+    escape character (backslash) and another character and other control
+    characters by a sequence of "\u" followed by a four-digit hex
+    representation.
+
+    @param[in] s  the string to escape
+    @return  the escaped string
+
+    @complexity Linear in the length of string @a s.
+    */
+        static string_t escape_string(const string_t& s) noexcept
+        {
+            const auto space = extra_space(s);
+            if (space == 0)
+            {
+                return s;
+            }
+
+            // create a result string of necessary size
+            string_t result(s.size() + space, '\\');
+            std::size_t pos = 0;
+
+            for (const auto& c : s)
+            {
+                switch (c)
+                {
+                    // quotation mark (0x22)
+                    case '"':
+                    {
+                        result[pos + 1] = '"';
+                        pos += 2;
+                        break;
+                    }
+
+                        // reverse solidus (0x5c)
+                    case '\\':
+                    {
+                        // nothing to change
+                        pos += 2;
+                        break;
+                    }
+
+                        // backspace (0x08)
+                    case '\b':
+                    {
+                        result[pos + 1] = 'b';
+                        pos += 2;
+                        break;
+                    }
+
+                        // formfeed (0x0c)
+                    case '\f':
+                    {
+                        result[pos + 1] = 'f';
+                        pos += 2;
+                        break;
+                    }
+
+                        // newline (0x0a)
+                    case '\n':
+                    {
+                        result[pos + 1] = 'n';
+                        pos += 2;
+                        break;
+                    }
+
+                        // carriage return (0x0d)
+                    case '\r':
+                    {
+                        result[pos + 1] = 'r';
+                        pos += 2;
+                        break;
+                    }
+
+                        // horizontal tab (0x09)
+                    case '\t':
+                    {
+                        result[pos + 1] = 't';
+                        pos += 2;
+                        break;
+                    }
+
+                    default:
+                    {
+                        if (c >= 0x00 and c <= 0x1f)
+                        {
+                            // convert a number 0..15 to its hex representation
+                            // (0..f)
+                            auto hexify = [](const char v) -> char
+                            {
+                                return (v < 10) ? ('0' + v) : ('a' + v - 10);
+                            };
+
+                            // print character c as \uxxxx
+                            for (const char m :
+                                    { 'u', '0', '0', hexify(c >> 4), hexify(c & 0x0f)
+                                    })
+                            {
+                                result[++pos] = m;
+                            }
+
+                            ++pos;
+                        }
+                        else
+                        {
+                            // all other characters are added as-is
+                            result[pos++] = c;
+                        }
+                        break;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        /*!
+    @brief internal implementation of the serialization function
+
+    This function is called by the public member function dump and organizes
+    the serialization internally. The indentation level is propagated as
+    additional parameter. In case of arrays and objects, the function is called
+    recursively. Note that
+
+    - strings and object keys are escaped using `escape_string()`
+    - integer numbers are converted implicitly via `operator<<`
+    - floating-point numbers are converted to a string using `"%g"` format
+
+    @param[out] o              stream to write to
+    @param[in] pretty_print    whether the output shall be pretty-printed
+    @param[in] indent_step     the indent level
+    @param[in] current_indent  the current indent level (only used internally)
+    */
+        void dump(std::ostream& o,
+                  const bool pretty_print,
+                  const unsigned int indent_step,
+                  const unsigned int current_indent = 0) const
+        {
+            // variable to hold indentation for recursive calls
+            unsigned int new_indent = current_indent;
+
+            switch (m_type)
+            {
+                case value_t::object:
+                {
+                    assert(m_value.object != nullptr);
+
+                    if (m_value.object->empty())
+                    {
+                        o << "{}";
+                        return;
+                    }
+
+                    o << "{";
+
+                    // increase indentation
+                    if (pretty_print)
+                    {
+                        new_indent += indent_step;
+                        o << "\n";
+                    }
+
+                    for (auto i = m_value.object->cbegin(); i != m_value.object->cend(); ++i)
+                    {
+                        if (i != m_value.object->cbegin())
+                        {
+                            o << (pretty_print ? ",\n" : ",");
+                        }
+                        o << string_t(new_indent, ' ') << "\""
+                        << escape_string(i->first) << "\":"
+                        << (pretty_print ? " " : "");
+                        i->second.dump(o, pretty_print, indent_step, new_indent);
+                    }
+
+                    // decrease indentation
+                    if (pretty_print)
+                    {
+                        new_indent -= indent_step;
+                        o << "\n";
+                    }
+
+                    o << string_t(new_indent, ' ') + "}";
+                    return;
+                }
+
+                case value_t::array:
+                {
+                    assert(m_value.array != nullptr);
+
+                    if (m_value.array->empty())
+                    {
+                        o << "[]";
+                        return;
+                    }
+
+                    o << "[";
+
+                    // increase indentation
+                    if (pretty_print)
+                    {
+                        new_indent += indent_step;
+                        o << "\n";
+                    }
+
+                    for (auto i = m_value.array->cbegin(); i != m_value.array->cend(); ++i)
+                    {
+                        if (i != m_value.array->cbegin())
+                        {
+                            o << (pretty_print ? ",\n" : ",");
+                        }
+                        o << string_t(new_indent, ' ');
+                        i->dump(o, pretty_print, indent_step, new_indent);
+                    }
+
+                    // decrease indentation
+                    if (pretty_print)
+                    {
+                        new_indent -= indent_step;
+                        o << "\n";
+                    }
+
+                    o << string_t(new_indent, ' ') << "]";
+                    return;
+                }
+
+                case value_t::string:
+                {
+                    assert(m_value.string != nullptr);
+                    o << string_t("\"") << escape_string(*m_value.string) << "\"";
+                    return;
+                }
+
+                case value_t::boolean:
+                {
+                    o << (m_value.boolean ? "true" : "false");
+                    return;
+                }
+
+                case value_t::number_integer:
+                {
+                    o << m_value.number_integer;
+                    return;
+                }
+
+                case value_t::number_unsigned:
+                {
+                    o << m_value.number_unsigned;
+                    return;
+                }
+
+                case value_t::number_float:
+                {
+                    // If the number is an integer then output as a fixed with with
+                    // precision 1 to output "0.0", "1.0" etc as expected for some
+                    // round trip tests otherwise  15 digits of precision allows
+                    // round-trip IEEE 754 string->double->string; to be safe, we
+                    // read this value from
+                    // std::numeric_limits<number_float_t>::digits10
+                    if (std::fmod(m_value.number_float, 1) == 0)
+                    {
+                        o << std::fixed << std::setprecision(1);
+                    }
+                    else
+                    {
+                        // std::defaultfloat not supported in gcc version < 5
+                        o.unsetf(std::ios_base::floatfield);
+                        o << std::setprecision(std::numeric_limits<double>::digits10);
+                    }
+                    o << m_value.number_float;
+                    return;
+                }
+
+                case value_t::discarded:
+                {
+                    o << "<discarded>";
+                    return;
+                }
+
+                case value_t::null:
+                {
+                    o << "null";
+                    return;
+                }
+            }
+        }
+
+    private:
+        //////////////////////
+        // member variables //
+        //////////////////////
+
+        /// the type of the current element
+        value_t m_type = value_t::null;
+
+        /// the value of the current element
+        json_value m_value = {};
+
+
+    private:
+        ///////////////
+        // iterators //
+        ///////////////
+
+        /*!
+    @brief an iterator for primitive JSON types
+
+    This class models an iterator for primitive JSON types (boolean, number,
+    string). It's only purpose is to allow the iterator/const_iterator classes
+    to "iterate" over primitive values. Internally, the iterator is modeled by
+    a `difference_type` variable. Value begin_value (`0`) models the begin,
+    end_value (`1`) models past the end.
+    */
+        class primitive_iterator_t
+        {
+        public:
+            /// set iterator to a defined beginning
+            void set_begin()
+            {
+                m_it = begin_value;
+            }
+
+            /// set iterator to a defined past the end
+            void set_end()
+            {
+                m_it = end_value;
+            }
+
+            /// return whether the iterator can be dereferenced
+            bool is_begin() const
+            {
+                return (m_it == begin_value);
+            }
+
+            /// return whether the iterator is at end
+            bool is_end() const
+            {
+                return (m_it == end_value);
+            }
+
+            /// return reference to the value to change and compare
+            operator difference_type& ()
+            {
+                return m_it;
+            }
+
+            /// return value to compare
+            operator difference_type () const
+            {
+                return m_it;
+            }
+
+        private:
+            static constexpr difference_type begin_value = 0;
+            static constexpr difference_type end_value = begin_value + 1;
+
+            /// iterator as signed integer type
+            difference_type m_it = std::numeric_limits<std::ptrdiff_t>::denorm_min();
+        };
+
+        /*!
+    @brief an iterator value
+
+    @note This structure could easily be a union, but MSVC currently does not
+    allow unions members with complex constructors, see
+    https://github.com/nlohmann/json/pull/105.
+    */
+        struct internal_iterator
+        {
+            /// iterator for JSON objects
+            typename object_t::iterator object_iterator;
+            /// iterator for JSON arrays
+            typename array_t::iterator array_iterator;
+            /// generic iterator for all other types
+            primitive_iterator_t primitive_iterator;
+
+            /// create an uninitialized internal_iterator
+            internal_iterator()
+                    : object_iterator(), array_iterator(), primitive_iterator()
+            {}
+        };
+
+        /// proxy class for the iterator_wrapper functions
+        template<typename IteratorType>
+        class iteration_proxy
+        {
+        private:
+            /// helper class for iteration
+            class iteration_proxy_internal
+            {
+            private:
+                /// the iterator
+                IteratorType anchor;
+                /// an index for arrays (used to create key names)
+                size_t array_index = 0;
+
+            public:
+                iteration_proxy_internal(IteratorType it)
+                        : anchor(it)
+                {}
+
+                /// dereference operator (needed for range-based for)
+                iteration_proxy_internal& operator*()
+                {
+                    return *this;
+                }
+
+                /// increment operator (needed for range-based for)
+                iteration_proxy_internal& operator++()
+                {
+                    ++anchor;
+                    ++array_index;
+
+                    return *this;
+                }
+
+                /// inequality operator (needed for range-based for)
+                bool operator!= (const iteration_proxy_internal& o) const
+                {
+                    return anchor != o.anchor;
+                }
+
+                /// return key of the iterator
+                typename basic_json::string_t key() const
+                {
+                    assert(anchor.m_object != nullptr);
+
+                    switch (anchor.m_object->type())
+                    {
+                        // use integer array index as key
+                        case value_t::array:
+                        {
+                            return std::to_string(array_index);
+                        }
+
+                            // use key from the object
+                        case value_t::object:
+                        {
+                            return anchor.key();
+                        }
+
+                            // use an empty key for all primitive types
+                        default:
+                        {
+                            return "";
+                        }
+                    }
+                }
+
+                /// return value of the iterator
+                typename IteratorType::reference value() const
+                {
+                    return anchor.value();
+                }
+            };
+
+            /// the container to iterate
+            typename IteratorType::reference container;
+
+        public:
+            /// construct iteration proxy from a container
+            iteration_proxy(typename IteratorType::reference cont)
+                    : container(cont)
+            {}
+
+            /// return iterator begin (needed for range-based for)
+            iteration_proxy_internal begin()
+            {
+                return iteration_proxy_internal(container.begin());
+            }
+
+            /// return iterator end (needed for range-based for)
+            iteration_proxy_internal end()
+            {
+                return iteration_proxy_internal(container.end());
+            }
+        };
+
+    public:
+        /*!
+    @brief a const random access iterator for the @ref basic_json class
+
+    This class implements a const iterator for the @ref basic_json class. From
+    this class, the @ref iterator class is derived.
+
+    @requirement The class satisfies the following concept requirements:
+    - [RandomAccessIterator](http://en.cppreference.com/w/cpp/concept/RandomAccessIterator):
+      The iterator that can be moved to point (forward and backward) to any
+      element in constant time.
+
+    @since version 1.0.0
+    */
+        class const_iterator : public std::iterator<std::random_access_iterator_tag, const basic_json>
+        {
+            /// allow basic_json to access private members
+            friend class basic_json;
+
+        public:
+            /// the type of the values when the iterator is dereferenced
+            using value_type = typename basic_json::value_type;
+            /// a type to represent differences between iterators
+            using difference_type = typename basic_json::difference_type;
+            /// defines a pointer to the type iterated over (value_type)
+            using pointer = typename basic_json::const_pointer;
+            /// defines a reference to the type iterated over (value_type)
+            using reference = typename basic_json::const_reference;
+            /// the category of the iterator
+            using iterator_category = std::bidirectional_iterator_tag;
+
+            /// default constructor
+            const_iterator() = default;
+
+            /// constructor for a given JSON instance
+            const_iterator(pointer object) : m_object(object)
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        m_it.object_iterator = typename object_t::iterator();
+                        break;
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        m_it.array_iterator = typename array_t::iterator();
+                        break;
+                    }
+
+                    default:
+                    {
+                        m_it.primitive_iterator = primitive_iterator_t();
+                        break;
+                    }
+                }
+            }
+
+            /// copy constructor given a nonconst iterator
+            const_iterator(const iterator& other) : m_object(other.m_object)
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        m_it.object_iterator = other.m_it.object_iterator;
+                        break;
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        m_it.array_iterator = other.m_it.array_iterator;
+                        break;
+                    }
+
+                    default:
+                    {
+                        m_it.primitive_iterator = other.m_it.primitive_iterator;
+                        break;
+                    }
+                }
+            }
+
+            /// copy constructor
+            const_iterator(const const_iterator& other) noexcept
+                    : m_object(other.m_object), m_it(other.m_it)
+            {}
+
+            /// copy assignment
+            const_iterator& operator=(const_iterator other) noexcept(
+            std::is_nothrow_move_constructible<pointer>::value and
+            std::is_nothrow_move_assignable<pointer>::value and
+            std::is_nothrow_move_constructible<internal_iterator>::value and
+            std::is_nothrow_move_assignable<internal_iterator>::value
+            )
+            {
+                std::swap(m_object, other.m_object);
+                std::swap(m_it, other.m_it);
+                return *this;
+            }
+
+        private:
+            /// set the iterator to the first value
+            void set_begin()
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        assert(m_object->m_value.object != nullptr);
+                        m_it.object_iterator = m_object->m_value.object->begin();
+                        break;
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        assert(m_object->m_value.array != nullptr);
+                        m_it.array_iterator = m_object->m_value.array->begin();
+                        break;
+                    }
+
+                    case basic_json::value_t::null:
+                    {
+                        // set to end so begin()==end() is true: null is empty
+                        m_it.primitive_iterator.set_end();
+                        break;
+                    }
+
+                    default:
+                    {
+                        m_it.primitive_iterator.set_begin();
+                        break;
+                    }
+                }
+            }
+
+            /// set the iterator past the last value
+            void set_end()
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        assert(m_object->m_value.object != nullptr);
+                        m_it.object_iterator = m_object->m_value.object->end();
+                        break;
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        assert(m_object->m_value.array != nullptr);
+                        m_it.array_iterator = m_object->m_value.array->end();
+                        break;
+                    }
+
+                    default:
+                    {
+                        m_it.primitive_iterator.set_end();
+                        break;
+                    }
+                }
+            }
+
+        public:
+            /// return a reference to the value pointed to by the iterator
+            reference operator*() const
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        assert(m_object->m_value.object);
+                        assert(m_it.object_iterator != m_object->m_value.object->end());
+                        return m_it.object_iterator->second;
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        assert(m_object->m_value.array);
+                        assert(m_it.array_iterator != m_object->m_value.array->end());
+                        return *m_it.array_iterator;
+                    }
+
+                    case basic_json::value_t::null:
+                    {
+                        throw std::out_of_range("cannot get value");
+                    }
+
+                    default:
+                    {
+                        if (m_it.primitive_iterator.is_begin())
+                        {
+                            return *m_object;
+                        }
+                        else
+                        {
+                            throw std::out_of_range("cannot get value");
+                        }
+                    }
+                }
+            }
+
+            /// dereference the iterator
+            pointer operator->() const
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        assert(m_object->m_value.object);
+                        assert(m_it.object_iterator != m_object->m_value.object->end());
+                        return &(m_it.object_iterator->second);
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        assert(m_object->m_value.array);
+                        assert(m_it.array_iterator != m_object->m_value.array->end());
+                        return &*m_it.array_iterator;
+                    }
+
+                    default:
+                    {
+                        if (m_it.primitive_iterator.is_begin())
+                        {
+                            return m_object;
+                        }
+                        else
+                        {
+                            throw std::out_of_range("cannot get value");
+                        }
+                    }
+                }
+            }
+
+            /// post-increment (it++)
+            const_iterator operator++(int)
+            {
+                auto result = *this;
+                ++(*this);
+                return result;
+            }
+
+            /// pre-increment (++it)
+            const_iterator& operator++()
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        ++m_it.object_iterator;
+                        break;
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        ++m_it.array_iterator;
+                        break;
+                    }
+
+                    default:
+                    {
+                        ++m_it.primitive_iterator;
+                        break;
+                    }
+                }
+
+                return *this;
+            }
+
+            /// post-decrement (it--)
+            const_iterator operator--(int)
+            {
+                auto result = *this;
+                --(*this);
+                return result;
+            }
+
+            /// pre-decrement (--it)
+            const_iterator& operator--()
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        --m_it.object_iterator;
+                        break;
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        --m_it.array_iterator;
+                        break;
+                    }
+
+                    default:
+                    {
+                        --m_it.primitive_iterator;
+                        break;
+                    }
+                }
+
+                return *this;
+            }
+
+            /// comparison: equal
+            bool operator==(const const_iterator& other) const
+            {
+                // if objects are not the same, the comparison is undefined
+                if (m_object != other.m_object)
+                {
+                    throw std::domain_error("cannot compare iterators of different containers");
+                }
+
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        return (m_it.object_iterator == other.m_it.object_iterator);
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        return (m_it.array_iterator == other.m_it.array_iterator);
+                    }
+
+                    default:
+                    {
+                        return (m_it.primitive_iterator == other.m_it.primitive_iterator);
+                    }
+                }
+            }
+
+            /// comparison: not equal
+            bool operator!=(const const_iterator& other) const
+            {
+                return not operator==(other);
+            }
+
+            /// comparison: smaller
+            bool operator<(const const_iterator& other) const
+            {
+                // if objects are not the same, the comparison is undefined
+                if (m_object != other.m_object)
+                {
+                    throw std::domain_error("cannot compare iterators of different containers");
+                }
+
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        throw std::domain_error("cannot compare order of object iterators");
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        return (m_it.array_iterator < other.m_it.array_iterator);
+                    }
+
+                    default:
+                    {
+                        return (m_it.primitive_iterator < other.m_it.primitive_iterator);
+                    }
+                }
+            }
+
+            /// comparison: less than or equal
+            bool operator<=(const const_iterator& other) const
+            {
+                return not other.operator < (*this);
+            }
+
+            /// comparison: greater than
+            bool operator>(const const_iterator& other) const
+            {
+                return not operator<=(other);
+            }
+
+            /// comparison: greater than or equal
+            bool operator>=(const const_iterator& other) const
+            {
+                return not operator<(other);
+            }
+
+            /// add to iterator
+            const_iterator& operator+=(difference_type i)
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        throw std::domain_error("cannot use offsets with object iterators");
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        m_it.array_iterator += i;
+                        break;
+                    }
+
+                    default:
+                    {
+                        m_it.primitive_iterator += i;
+                        break;
+                    }
+                }
+
+                return *this;
+            }
+
+            /// subtract from iterator
+            const_iterator& operator-=(difference_type i)
+            {
+                return operator+=(-i);
+            }
+
+            /// add to iterator
+            const_iterator operator+(difference_type i)
+            {
+                auto result = *this;
+                result += i;
+                return result;
+            }
+
+            /// subtract from iterator
+            const_iterator operator-(difference_type i)
+            {
+                auto result = *this;
+                result -= i;
+                return result;
+            }
+
+            /// return difference
+            difference_type operator-(const const_iterator& other) const
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        throw std::domain_error("cannot use offsets with object iterators");
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        return m_it.array_iterator - other.m_it.array_iterator;
+                    }
+
+                    default:
+                    {
+                        return m_it.primitive_iterator - other.m_it.primitive_iterator;
+                    }
+                }
+            }
+
+            /// access to successor
+            reference operator[](difference_type n) const
+            {
+                assert(m_object != nullptr);
+
+                switch (m_object->m_type)
+                {
+                    case basic_json::value_t::object:
+                    {
+                        throw std::domain_error("cannot use operator[] for object iterators");
+                    }
+
+                    case basic_json::value_t::array:
+                    {
+                        return *(m_it.array_iterator + n);
+                    }
+
+                    case basic_json::value_t::null:
+                    {
+                        throw std::out_of_range("cannot get value");
+                    }
+
+                    default:
+                    {
+                        if (m_it.primitive_iterator == -n)
+                        {
+                            return *m_object;
+                        }
+                        else
+                        {
+                            throw std::out_of_range("cannot get value");
+                        }
+                    }
+                }
+            }
+
+            /// return the key of an object iterator
+            typename object_t::key_type key() const
+            {
+                assert(m_object != nullptr);
+
+                if (m_object->is_object())
+                {
+                    return m_it.object_iterator->first;
+                }
+                else
+                {
+                    throw std::domain_error("cannot use key() for non-object iterators");
+                }
+            }
+
+            /// return the value of an iterator
+            reference value() const
+            {
+                return operator*();
+            }
+
+        private:
+            /// associated JSON instance
+            pointer m_object = nullptr;
+            /// the actual iterator of the associated instance
+            internal_iterator m_it = internal_iterator();
+        };
+
+        /*!
+    @brief a mutable random access iterator for the @ref basic_json class
+
+    @requirement The class satisfies the following concept requirements:
+    - [RandomAccessIterator](http://en.cppreference.com/w/cpp/concept/RandomAccessIterator):
+      The iterator that can be moved to point (forward and backward) to any
+      element in constant time.
+    - [OutputIterator](http://en.cppreference.com/w/cpp/concept/OutputIterator):
+      It is possible to write to the pointed-to element.
+
+    @since version 1.0.0
+    */
+        class iterator : public const_iterator
+        {
+        public:
+            using base_iterator = const_iterator;
+            using pointer = typename basic_json::pointer;
+            using reference = typename basic_json::reference;
+
+            /// default constructor
+            iterator() = default;
+
+            /// constructor for a given JSON instance
+            iterator(pointer object) noexcept
+                    : base_iterator(object)
+            {}
+
+            /// copy constructor
+            iterator(const iterator& other) noexcept
+                    : base_iterator(other)
+            {}
+
+            /// copy assignment
+            iterator& operator=(iterator other) noexcept(
+            std::is_nothrow_move_constructible<pointer>::value and
+            std::is_nothrow_move_assignable<pointer>::value and
+            std::is_nothrow_move_constructible<internal_iterator>::value and
+            std::is_nothrow_move_assignable<internal_iterator>::value
+            )
+            {
+                base_iterator::operator=(other);
+                return *this;
+            }
+
+            /// return a reference to the value pointed to by the iterator
+            reference operator*()
+            {
+                return const_cast<reference>(base_iterator::operator*());
+            }
+
+            /// dereference the iterator
+            pointer operator->()
+            {
+                return const_cast<pointer>(base_iterator::operator->());
+            }
+
+            /// post-increment (it++)
+            iterator operator++(int)
+            {
+                iterator result = *this;
+                base_iterator::operator++();
+                return result;
+            }
+
+            /// pre-increment (++it)
+            iterator& operator++()
+            {
+                base_iterator::operator++();
+                return *this;
+            }
+
+            /// post-decrement (it--)
+            iterator operator--(int)
+            {
+                iterator result = *this;
+                base_iterator::operator--();
+                return result;
+            }
+
+            /// pre-decrement (--it)
+            iterator& operator--()
+            {
+                base_iterator::operator--();
+                return *this;
+            }
+
+            /// add to iterator
+            iterator& operator+=(difference_type i)
+            {
+                base_iterator::operator+=(i);
+                return *this;
+            }
+
+            /// subtract from iterator
+            iterator& operator-=(difference_type i)
+            {
+                base_iterator::operator-=(i);
+                return *this;
+            }
+
+            /// add to iterator
+            iterator operator+(difference_type i)
+            {
+                auto result = *this;
+                result += i;
+                return result;
+            }
+
+            /// subtract from iterator
+            iterator operator-(difference_type i)
+            {
+                auto result = *this;
+                result -= i;
+                return result;
+            }
+
+            /// return difference
+            difference_type operator-(const iterator& other) const
+            {
+                return base_iterator::operator-(other);
+            }
+
+            /// access to successor
+            reference operator[](difference_type n) const
+            {
+                return const_cast<reference>(base_iterator::operator[](n));
+            }
+
+            /// return the value of an iterator
+            reference value() const
+            {
+                return const_cast<reference>(base_iterator::value());
+            }
+        };
+
+        /*!
+    @brief a template for a reverse iterator class
+
+    @tparam Base the base iterator type to reverse. Valid types are @ref
+    iterator (to create @ref reverse_iterator) and @ref const_iterator (to
+    create @ref const_reverse_iterator).
+
+    @requirement The class satisfies the following concept requirements:
+    - [RandomAccessIterator](http://en.cppreference.com/w/cpp/concept/RandomAccessIterator):
+      The iterator that can be moved to point (forward and backward) to any
+      element in constant time.
+    - [OutputIterator](http://en.cppreference.com/w/cpp/concept/OutputIterator):
+      It is possible to write to the pointed-to element (only if @a Base is
+      @ref iterator).
+
+    @since version 1.0.0
+    */
+        template<typename Base>
+        class json_reverse_iterator : public std::reverse_iterator<Base>
+        {
+        public:
+            /// shortcut to the reverse iterator adaptor
+            using base_iterator = std::reverse_iterator<Base>;
+            /// the reference type for the pointed-to element
+            using reference = typename Base::reference;
+
+            /// create reverse iterator from iterator
+            json_reverse_iterator(const typename base_iterator::iterator_type& it)
+                    : base_iterator(it)
+            {}
+
+            /// create reverse iterator from base class
+            json_reverse_iterator(const base_iterator& it)
+                    : base_iterator(it)
+            {}
+
+            /// post-increment (it++)
+            json_reverse_iterator operator++(int)
+            {
+                return base_iterator::operator++(1);
+            }
+
+            /// pre-increment (++it)
+            json_reverse_iterator& operator++()
+            {
+                base_iterator::operator++();
+                return *this;
+            }
+
+            /// post-decrement (it--)
+            json_reverse_iterator operator--(int)
+            {
+                return base_iterator::operator--(1);
+            }
+
+            /// pre-decrement (--it)
+            json_reverse_iterator& operator--()
+            {
+                base_iterator::operator--();
+                return *this;
+            }
+
+            /// add to iterator
+            json_reverse_iterator& operator+=(difference_type i)
+            {
+                base_iterator::operator+=(i);
+                return *this;
+            }
+
+            /// add to iterator
+            json_reverse_iterator operator+(difference_type i) const
+            {
+                auto result = *this;
+                result += i;
+                return result;
+            }
+
+            /// subtract from iterator
+            json_reverse_iterator operator-(difference_type i) const
+            {
+                auto result = *this;
+                result -= i;
+                return result;
+            }
+
+            /// return difference
+            difference_type operator-(const json_reverse_iterator& other) const
+            {
+                return this->base() - other.base();
+            }
+
+            /// access to successor
+            reference operator[](difference_type n) const
+            {
+                return *(this->operator+(n));
+            }
+
+            /// return the key of an object iterator
+            typename object_t::key_type key() const
+            {
+                auto it = --this->base();
+                return it.key();
+            }
+
+            /// return the value of an iterator
+            reference value() const
+            {
+                auto it = --this->base();
+                return it.operator * ();
+            }
+        };
+
+
+    private:
+        //////////////////////
+        // lexer and parser //
+        //////////////////////
+
+        /*!
+    @brief lexical analysis
+
+    This class organizes the lexical analysis during JSON deserialization. The
+    core of it is a scanner generated by [re2c](http://re2c.org) that processes
+    a buffer and recognizes tokens according to RFC 7159.
+    */
+        class lexer
+        {
+        public:
+            /// token types for the parser
+            enum class token_type
+            {
+                uninitialized,   ///< indicating the scanner is uninitialized
+                literal_true,    ///< the "true" literal
+                literal_false,   ///< the "false" literal
+                literal_null,    ///< the "null" literal
+                value_string,    ///< a string -- use get_string() for actual value
+                value_number,    ///< a number -- use get_number() for actual value
+                begin_array,     ///< the character for array begin "["
+                begin_object,    ///< the character for object begin "{"
+                end_array,       ///< the character for array end "]"
+                end_object,      ///< the character for object end "}"
+                name_separator,  ///< the name separator ":"
+                value_separator, ///< the value separator ","
+                parse_error,     ///< indicating a parse error
+                end_of_input     ///< indicating the end of the input buffer
+            };
+
+            /// the char type to use in the lexer
+            using lexer_char_t = unsigned char;
+
+            /// constructor with a given buffer
+            explicit lexer(const string_t& s) noexcept
+                    : m_stream(nullptr), m_buffer(s)
+            {
+                m_content = reinterpret_cast<const lexer_char_t*>(s.c_str());
+                assert(m_content != nullptr);
+                m_start = m_cursor = m_content;
+                m_limit = m_content + s.size();
+            }
+
+            /// constructor with a given stream
+            explicit lexer(std::istream* s) noexcept
+                    : m_stream(s), m_buffer()
+            {
+                assert(m_stream != nullptr);
+                getline(*m_stream, m_buffer);
+                m_content = reinterpret_cast<const lexer_char_t*>(m_buffer.c_str());
+                assert(m_content != nullptr);
+                m_start = m_cursor = m_content;
+                m_limit = m_content + m_buffer.size();
+            }
+
+            /// default constructor
+            lexer() = default;
+
+            // switch off unwanted functions
+            lexer(const lexer&) = delete;
+            lexer operator=(const lexer&) = delete;
+
+            /*!
+        @brief create a string from a Unicode code point
+
+        @param[in] codepoint1  the code point (can be high surrogate)
+        @param[in] codepoint2  the code point (can be low surrogate or 0)
+
+        @return string representation of the code point
+
+        @throw std::out_of_range if code point is >0x10ffff; example: `"code
+        points above 0x10FFFF are invalid"`
+        @throw std::invalid_argument if the low surrogate is invalid; example:
+        `""missing or wrong low surrogate""`
+
+        @see <http://en.wikipedia.org/wiki/UTF-8#Sample_code>
+        */
+            static string_t to_unicode(const std::size_t codepoint1,
+                                       const std::size_t codepoint2 = 0)
+            {
+                // calculate the codepoint from the given code points
+                std::size_t codepoint = codepoint1;
+
+                // check if codepoint1 is a high surrogate
+                if (codepoint1 >= 0xD800 and codepoint1 <= 0xDBFF)
+                {
+                    // check if codepoint2 is a low surrogate
+                    if (codepoint2 >= 0xDC00 and codepoint2 <= 0xDFFF)
+                    {
+                        codepoint =
+                                // high surrogate occupies the most significant 22 bits
+                                (codepoint1 << 10)
+                                // low surrogate occupies the least significant 15 bits
+                                + codepoint2
+                                // there is still the 0xD800, 0xDC00 and 0x10000 noise
+                                // in the result so we have to subtract with:
+                                // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
+                                - 0x35FDC00;
+                    }
+                    else
+                    {
+                        throw std::invalid_argument("missing or wrong low surrogate");
+                    }
+                }
+
+                string_t result;
+
+                if (codepoint < 0x80)
+                {
+                    // 1-byte characters: 0xxxxxxx (ASCII)
+                    result.append(1, static_cast<typename string_t::value_type>(codepoint));
+                }
+                else if (codepoint <= 0x7ff)
+                {
+                    // 2-byte characters: 110xxxxx 10xxxxxx
+                    result.append(1, static_cast<typename string_t::value_type>(0xC0 | ((codepoint >> 6) & 0x1F)));
+                    result.append(1, static_cast<typename string_t::value_type>(0x80 | (codepoint & 0x3F)));
+                }
+                else if (codepoint <= 0xffff)
+                {
+                    // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
+                    result.append(1, static_cast<typename string_t::value_type>(0xE0 | ((codepoint >> 12) & 0x0F)));
+                    result.append(1, static_cast<typename string_t::value_type>(0x80 | ((codepoint >> 6) & 0x3F)));
+                    result.append(1, static_cast<typename string_t::value_type>(0x80 | (codepoint & 0x3F)));
+                }
+                else if (codepoint <= 0x10ffff)
+                {
+                    // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+                    result.append(1, static_cast<typename string_t::value_type>(0xF0 | ((codepoint >> 18) & 0x07)));
+                    result.append(1, static_cast<typename string_t::value_type>(0x80 | ((codepoint >> 12) & 0x3F)));
+                    result.append(1, static_cast<typename string_t::value_type>(0x80 | ((codepoint >> 6) & 0x3F)));
+                    result.append(1, static_cast<typename string_t::value_type>(0x80 | (codepoint & 0x3F)));
+                }
+                else
+                {
+                    throw std::out_of_range("code points above 0x10FFFF are invalid");
+                }
+
+                return result;
+            }
+
+            /// return name of values of type token_type (only used for errors)
+            static std::string token_type_name(token_type t)
+            {
+                switch (t)
+                {
+                    case token_type::uninitialized:
+                        return "<uninitialized>";
+                    case token_type::literal_true:
+                        return "true literal";
+                    case token_type::literal_false:
+                        return "false literal";
+                    case token_type::literal_null:
+                        return "null literal";
+                    case token_type::value_string:
+                        return "string literal";
+                    case token_type::value_number:
+                        return "number literal";
+                    case token_type::begin_array:
+                        return "'['";
+                    case token_type::begin_object:
+                        return "'{'";
+                    case token_type::end_array:
+                        return "']'";
+                    case token_type::end_object:
+                        return "'}'";
+                    case token_type::name_separator:
+                        return "':'";
+                    case token_type::value_separator:
+                        return "','";
+                    case token_type::parse_error:
+                        return "<parse error>";
+                    case token_type::end_of_input:
+                        return "end of input";
+                    default:
+                    {
+                        // catch non-enum values
+                        return "unknown token"; // LCOV_EXCL_LINE
+                    }
+                }
+            }
+
+            /*!
+        This function implements a scanner for JSON. It is specified using
+        regular expressions that try to follow RFC 7159 as close as possible.
+        These regular expressions are then translated into a minimized
+        deterministic finite automaton (DFA) by the tool
+        [re2c](http://re2c.org). As a result, the translated code for this
+        function consists of a large block of code with `goto` jumps.
+
+        @return the class of the next token read from the buffer
+        */
+            token_type scan() noexcept
+            {
+                // pointer for backtracking information
+                m_marker = nullptr;
+
+                // remember the begin of the token
+                m_start = m_cursor;
+                assert(m_start != nullptr);
+
+
+                {
+                    lexer_char_t yych;
+                    unsigned int yyaccept = 0;
+                    static const unsigned char yybm[] =
+                            {
+                                    0,   0,   0,   0,   0,   0,   0,   0,
+                                    0,  32,  32,   0,   0,  32,   0,   0,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    160, 128,   0, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    192, 192, 192, 192, 192, 192, 192, 192,
+                                    192, 192, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128,   0, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                                    128, 128, 128, 128, 128, 128, 128, 128,
+                            };
+                    if ((m_limit - m_cursor) < 5)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yybm[0 + yych] & 32)
+                    {
+                        goto basic_json_parser_6;
+                    }
+                    if (yych <= '\\')
+                    {
+                        if (yych <= '-')
+                        {
+                            if (yych <= '"')
+                            {
+                                if (yych <= 0x00)
+                                {
+                                    goto basic_json_parser_2;
+                                }
+                                if (yych <= '!')
+                                {
+                                    goto basic_json_parser_4;
+                                }
+                                goto basic_json_parser_9;
+                            }
+                            else
+                            {
+                                if (yych <= '+')
+                                {
+                                    goto basic_json_parser_4;
+                                }
+                                if (yych <= ',')
+                                {
+                                    goto basic_json_parser_10;
+                                }
+                                goto basic_json_parser_12;
+                            }
+                        }
+                        else
+                        {
+                            if (yych <= '9')
+                            {
+                                if (yych <= '/')
+                                {
+                                    goto basic_json_parser_4;
+                                }
+                                if (yych <= '0')
+                                {
+                                    goto basic_json_parser_13;
+                                }
+                                goto basic_json_parser_15;
+                            }
+                            else
+                            {
+                                if (yych <= ':')
+                                {
+                                    goto basic_json_parser_17;
+                                }
+                                if (yych == '[')
+                                {
+                                    goto basic_json_parser_19;
+                                }
+                                goto basic_json_parser_4;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (yych <= 't')
+                        {
+                            if (yych <= 'f')
+                            {
+                                if (yych <= ']')
+                                {
+                                    goto basic_json_parser_21;
+                                }
+                                if (yych <= 'e')
+                                {
+                                    goto basic_json_parser_4;
+                                }
+                                goto basic_json_parser_23;
+                            }
+                            else
+                            {
+                                if (yych == 'n')
+                                {
+                                    goto basic_json_parser_24;
+                                }
+                                if (yych <= 's')
+                                {
+                                    goto basic_json_parser_4;
+                                }
+                                goto basic_json_parser_25;
+                            }
+                        }
+                        else
+                        {
+                            if (yych <= '|')
+                            {
+                                if (yych == '{')
+                                {
+                                    goto basic_json_parser_26;
+                                }
+                                goto basic_json_parser_4;
+                            }
+                            else
+                            {
+                                if (yych <= '}')
+                                {
+                                    goto basic_json_parser_28;
+                                }
+                                if (yych == 0xEF)
+                                {
+                                    goto basic_json_parser_30;
+                                }
+                                goto basic_json_parser_4;
+                            }
+                        }
+                    }
+                    basic_json_parser_2:
+                    ++m_cursor;
+                    {
+                        return token_type::end_of_input;
+                    }
+                    basic_json_parser_4:
+                    ++m_cursor;
+                    basic_json_parser_5:
+                    {
+                        return token_type::parse_error;
+                    }
+                    basic_json_parser_6:
+                    ++m_cursor;
+                    if (m_limit <= m_cursor)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yybm[0 + yych] & 32)
+                    {
+                        goto basic_json_parser_6;
+                    }
+                    {
+                        return scan();
+                    }
+                    basic_json_parser_9:
+                    yyaccept = 0;
+                    yych = *(m_marker = ++m_cursor);
+                    if (yych <= 0x0F)
+                    {
+                        goto basic_json_parser_5;
+                    }
+                    goto basic_json_parser_32;
+                    basic_json_parser_10:
+                    ++m_cursor;
+                    {
+                        return token_type::value_separator;
+                    }
+                    basic_json_parser_12:
+                    yych = *++m_cursor;
+                    if (yych <= '/')
+                    {
+                        goto basic_json_parser_5;
+                    }
+                    if (yych <= '0')
+                    {
+                        goto basic_json_parser_13;
+                    }
+                    if (yych <= '9')
+                    {
+                        goto basic_json_parser_15;
+                    }
+                    goto basic_json_parser_5;
+                    basic_json_parser_13:
+                    yyaccept = 1;
+                    yych = *(m_marker = ++m_cursor);
+                    if (yych <= 'D')
+                    {
+                        if (yych == '.')
+                        {
+                            goto basic_json_parser_37;
+                        }
+                    }
+                    else
+                    {
+                        if (yych <= 'E')
+                        {
+                            goto basic_json_parser_38;
+                        }
+                        if (yych == 'e')
+                        {
+                            goto basic_json_parser_38;
+                        }
+                    }
+                    basic_json_parser_14:
+                    {
+                        return token_type::value_number;
+                    }
+                    basic_json_parser_15:
+                    yyaccept = 1;
+                    m_marker = ++m_cursor;
+                    if ((m_limit - m_cursor) < 3)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yybm[0 + yych] & 64)
+                    {
+                        goto basic_json_parser_15;
+                    }
+                    if (yych <= 'D')
+                    {
+                        if (yych == '.')
+                        {
+                            goto basic_json_parser_37;
+                        }
+                        goto basic_json_parser_14;
+                    }
+                    else
+                    {
+                        if (yych <= 'E')
+                        {
+                            goto basic_json_parser_38;
+                        }
+                        if (yych == 'e')
+                        {
+                            goto basic_json_parser_38;
+                        }
+                        goto basic_json_parser_14;
+                    }
+                    basic_json_parser_17:
+                    ++m_cursor;
+                    {
+                        return token_type::name_separator;
+                    }
+                    basic_json_parser_19:
+                    ++m_cursor;
+                    {
+                        return token_type::begin_array;
+                    }
+                    basic_json_parser_21:
+                    ++m_cursor;
+                    {
+                        return token_type::end_array;
+                    }
+                    basic_json_parser_23:
+                    yyaccept = 0;
+                    yych = *(m_marker = ++m_cursor);
+                    if (yych == 'a')
+                    {
+                        goto basic_json_parser_39;
+                    }
+                    goto basic_json_parser_5;
+                    basic_json_parser_24:
+                    yyaccept = 0;
+                    yych = *(m_marker = ++m_cursor);
+                    if (yych == 'u')
+                    {
+                        goto basic_json_parser_40;
+                    }
+                    goto basic_json_parser_5;
+                    basic_json_parser_25:
+                    yyaccept = 0;
+                    yych = *(m_marker = ++m_cursor);
+                    if (yych == 'r')
+                    {
+                        goto basic_json_parser_41;
+                    }
+                    goto basic_json_parser_5;
+                    basic_json_parser_26:
+                    ++m_cursor;
+                    {
+                        return token_type::begin_object;
+                    }
+                    basic_json_parser_28:
+                    ++m_cursor;
+                    {
+                        return token_type::end_object;
+                    }
+                    basic_json_parser_30:
+                    yyaccept = 0;
+                    yych = *(m_marker = ++m_cursor);
+                    if (yych == 0xBB)
+                    {
+                        goto basic_json_parser_42;
+                    }
+                    goto basic_json_parser_5;
+                    basic_json_parser_31:
+                    ++m_cursor;
+                    if (m_limit <= m_cursor)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    basic_json_parser_32:
+                    if (yybm[0 + yych] & 128)
+                    {
+                        goto basic_json_parser_31;
+                    }
+                    if (yych <= 0x0F)
+                    {
+                        goto basic_json_parser_33;
+                    }
+                    if (yych <= '"')
+                    {
+                        goto basic_json_parser_34;
+                    }
+                    goto basic_json_parser_36;
+                    basic_json_parser_33:
+                    m_cursor = m_marker;
+                    if (yyaccept == 0)
+                    {
+                        goto basic_json_parser_5;
+                    }
+                    else
+                    {
+                        goto basic_json_parser_14;
+                    }
+                    basic_json_parser_34:
+                    ++m_cursor;
+                    {
+                        return token_type::value_string;
+                    }
+                    basic_json_parser_36:
+                    ++m_cursor;
+                    if (m_limit <= m_cursor)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yych <= 'e')
+                    {
+                        if (yych <= '/')
+                        {
+                            if (yych == '"')
+                            {
+                                goto basic_json_parser_31;
+                            }
+                            if (yych <= '.')
+                            {
+                                goto basic_json_parser_33;
+                            }
+                            goto basic_json_parser_31;
+                        }
+                        else
+                        {
+                            if (yych <= '\\')
+                            {
+                                if (yych <= '[')
+                                {
+                                    goto basic_json_parser_33;
+                                }
+                                goto basic_json_parser_31;
+                            }
+                            else
+                            {
+                                if (yych == 'b')
+                                {
+                                    goto basic_json_parser_31;
+                                }
+                                goto basic_json_parser_33;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (yych <= 'q')
+                        {
+                            if (yych <= 'f')
+                            {
+                                goto basic_json_parser_31;
+                            }
+                            if (yych == 'n')
+                            {
+                                goto basic_json_parser_31;
+                            }
+                            goto basic_json_parser_33;
+                        }
+                        else
+                        {
+                            if (yych <= 's')
+                            {
+                                if (yych <= 'r')
+                                {
+                                    goto basic_json_parser_31;
+                                }
+                                goto basic_json_parser_33;
+                            }
+                            else
+                            {
+                                if (yych <= 't')
+                                {
+                                    goto basic_json_parser_31;
+                                }
+                                if (yych <= 'u')
+                                {
+                                    goto basic_json_parser_43;
+                                }
+                                goto basic_json_parser_33;
+                            }
+                        }
+                    }
+                    basic_json_parser_37:
+                    yych = *++m_cursor;
+                    if (yych <= '/')
+                    {
+                        goto basic_json_parser_33;
+                    }
+                    if (yych <= '9')
+                    {
+                        goto basic_json_parser_44;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_38:
+                    yych = *++m_cursor;
+                    if (yych <= ',')
+                    {
+                        if (yych == '+')
+                        {
+                            goto basic_json_parser_46;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    else
+                    {
+                        if (yych <= '-')
+                        {
+                            goto basic_json_parser_46;
+                        }
+                        if (yych <= '/')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= '9')
+                        {
+                            goto basic_json_parser_47;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    basic_json_parser_39:
+                    yych = *++m_cursor;
+                    if (yych == 'l')
+                    {
+                        goto basic_json_parser_49;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_40:
+                    yych = *++m_cursor;
+                    if (yych == 'l')
+                    {
+                        goto basic_json_parser_50;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_41:
+                    yych = *++m_cursor;
+                    if (yych == 'u')
+                    {
+                        goto basic_json_parser_51;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_42:
+                    yych = *++m_cursor;
+                    if (yych == 0xBF)
+                    {
+                        goto basic_json_parser_52;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_43:
+                    ++m_cursor;
+                    if (m_limit <= m_cursor)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yych <= '@')
+                    {
+                        if (yych <= '/')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= '9')
+                        {
+                            goto basic_json_parser_54;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    else
+                    {
+                        if (yych <= 'F')
+                        {
+                            goto basic_json_parser_54;
+                        }
+                        if (yych <= '`')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= 'f')
+                        {
+                            goto basic_json_parser_54;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    basic_json_parser_44:
+                    yyaccept = 1;
+                    m_marker = ++m_cursor;
+                    if ((m_limit - m_cursor) < 3)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yych <= 'D')
+                    {
+                        if (yych <= '/')
+                        {
+                            goto basic_json_parser_14;
+                        }
+                        if (yych <= '9')
+                        {
+                            goto basic_json_parser_44;
+                        }
+                        goto basic_json_parser_14;
+                    }
+                    else
+                    {
+                        if (yych <= 'E')
+                        {
+                            goto basic_json_parser_38;
+                        }
+                        if (yych == 'e')
+                        {
+                            goto basic_json_parser_38;
+                        }
+                        goto basic_json_parser_14;
+                    }
+                    basic_json_parser_46:
+                    yych = *++m_cursor;
+                    if (yych <= '/')
+                    {
+                        goto basic_json_parser_33;
+                    }
+                    if (yych >= ':')
+                    {
+                        goto basic_json_parser_33;
+                    }
+                    basic_json_parser_47:
+                    ++m_cursor;
+                    if (m_limit <= m_cursor)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yych <= '/')
+                    {
+                        goto basic_json_parser_14;
+                    }
+                    if (yych <= '9')
+                    {
+                        goto basic_json_parser_47;
+                    }
+                    goto basic_json_parser_14;
+                    basic_json_parser_49:
+                    yych = *++m_cursor;
+                    if (yych == 's')
+                    {
+                        goto basic_json_parser_55;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_50:
+                    yych = *++m_cursor;
+                    if (yych == 'l')
+                    {
+                        goto basic_json_parser_56;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_51:
+                    yych = *++m_cursor;
+                    if (yych == 'e')
+                    {
+                        goto basic_json_parser_58;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_52:
+                    ++m_cursor;
+                    {
+                        return scan();
+                    }
+                    basic_json_parser_54:
+                    ++m_cursor;
+                    if (m_limit <= m_cursor)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yych <= '@')
+                    {
+                        if (yych <= '/')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= '9')
+                        {
+                            goto basic_json_parser_60;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    else
+                    {
+                        if (yych <= 'F')
+                        {
+                            goto basic_json_parser_60;
+                        }
+                        if (yych <= '`')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= 'f')
+                        {
+                            goto basic_json_parser_60;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    basic_json_parser_55:
+                    yych = *++m_cursor;
+                    if (yych == 'e')
+                    {
+                        goto basic_json_parser_61;
+                    }
+                    goto basic_json_parser_33;
+                    basic_json_parser_56:
+                    ++m_cursor;
+                    {
+                        return token_type::literal_null;
+                    }
+                    basic_json_parser_58:
+                    ++m_cursor;
+                    {
+                        return token_type::literal_true;
+                    }
+                    basic_json_parser_60:
+                    ++m_cursor;
+                    if (m_limit <= m_cursor)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yych <= '@')
+                    {
+                        if (yych <= '/')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= '9')
+                        {
+                            goto basic_json_parser_63;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    else
+                    {
+                        if (yych <= 'F')
+                        {
+                            goto basic_json_parser_63;
+                        }
+                        if (yych <= '`')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= 'f')
+                        {
+                            goto basic_json_parser_63;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    basic_json_parser_61:
+                    ++m_cursor;
+                    {
+                        return token_type::literal_false;
+                    }
+                    basic_json_parser_63:
+                    ++m_cursor;
+                    if (m_limit <= m_cursor)
+                    {
+                        yyfill();    // LCOV_EXCL_LINE;
+                    }
+                    yych = *m_cursor;
+                    if (yych <= '@')
+                    {
+                        if (yych <= '/')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= '9')
+                        {
+                            goto basic_json_parser_31;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                    else
+                    {
+                        if (yych <= 'F')
+                        {
+                            goto basic_json_parser_31;
+                        }
+                        if (yych <= '`')
+                        {
+                            goto basic_json_parser_33;
+                        }
+                        if (yych <= 'f')
+                        {
+                            goto basic_json_parser_31;
+                        }
+                        goto basic_json_parser_33;
+                    }
+                }
+
+
+            }
+
+            /// append data from the stream to the internal buffer
+            void yyfill() noexcept
+            {
+                if (m_stream == nullptr or not * m_stream)
+                {
+                    return;
+                }
+
+                const ssize_t offset_start = m_start - m_content;
+                const ssize_t offset_marker = m_marker - m_start;
+                const ssize_t offset_cursor = m_cursor - m_start;
+
+                m_buffer.erase(0, static_cast<size_t>(offset_start));
+                std::string line;
+                assert(m_stream != nullptr);
+                std::getline(*m_stream, line);
+                m_buffer += "\n" + line; // add line with newline symbol
+
+                m_content = reinterpret_cast<const lexer_char_t*>(m_buffer.c_str());
+                assert(m_content != nullptr);
+                m_start  = m_content;
+                m_marker = m_start + offset_marker;
+                m_cursor = m_start + offset_cursor;
+                m_limit  = m_start + m_buffer.size() - 1;
+            }
+
+            /// return string representation of last read token
+            string_t get_token() const noexcept
+            {
+                assert(m_start != nullptr);
+                return string_t(reinterpret_cast<typename string_t::const_pointer>(m_start),
+                                static_cast<size_t>(m_cursor - m_start));
+            }
+
+            /*!
+        @brief return string value for string tokens
+
+        The function iterates the characters between the opening and closing
+        quotes of the string value. The complete string is the range
+        [m_start,m_cursor). Consequently, we iterate from m_start+1 to
+        m_cursor-1.
+
+        We differentiate two cases:
+
+        1. Escaped characters. In this case, a new character is constructed
+           according to the nature of the escape. Some escapes create new
+           characters (e.g., `"\\n"` is replaced by `"\n"`), some are copied as
+           is (e.g., `"\\\\"`). Furthermore, Unicode escapes of the shape
+           `"\\uxxxx"` need special care. In this case, to_unicode takes care
+           of the construction of the values.
+        2. Unescaped characters are copied as is.
+
+        @return string value of current token without opening and closing quotes
+        @throw std::out_of_range if to_unicode fails
+        */
+            string_t get_string() const
+            {
+                string_t result;
+                result.reserve(static_cast<size_t>(m_cursor - m_start - 2));
+
+                // iterate the result between the quotes
+                for (const lexer_char_t* i = m_start + 1; i < m_cursor - 1; ++i)
+                {
+                    // process escaped characters
+                    if (*i == '\\')
+                    {
+                        // read next character
+                        ++i;
+
+                        switch (*i)
+                        {
+                            // the default escapes
+                            case 't':
+                            {
+                                result += "\t";
+                                break;
+                            }
+                            case 'b':
+                            {
+                                result += "\b";
+                                break;
+                            }
+                            case 'f':
+                            {
+                                result += "\f";
+                                break;
+                            }
+                            case 'n':
+                            {
+                                result += "\n";
+                                break;
+                            }
+                            case 'r':
+                            {
+                                result += "\r";
+                                break;
+                            }
+                            case '\\':
+                            {
+                                result += "\\";
+                                break;
+                            }
+                            case '/':
+                            {
+                                result += "/";
+                                break;
+                            }
+                            case '"':
+                            {
+                                result += "\"";
+                                break;
+                            }
+
+                                // unicode
+                            case 'u':
+                            {
+                                // get code xxxx from uxxxx
+                                auto codepoint = std::strtoul(std::string(reinterpret_cast<typename string_t::const_pointer>(i + 1),
+                                                                          4).c_str(), nullptr, 16);
+
+                                // check if codepoint is a high surrogate
+                                if (codepoint >= 0xD800 and codepoint <= 0xDBFF)
+                                {
+                                    // make sure there is a subsequent unicode
+                                    if ((i + 6 >= m_limit) or * (i + 5) != '\\' or * (i + 6) != 'u')
+                                    {
+                                        throw std::invalid_argument("missing low surrogate");
+                                    }
+
+                                    // get code yyyy from uxxxx\uyyyy
+                                    auto codepoint2 = std::strtoul(std::string(reinterpret_cast<typename string_t::const_pointer>
+                                                                               (i + 7), 4).c_str(), nullptr, 16);
+                                    result += to_unicode(codepoint, codepoint2);
+                                    // skip the next 10 characters (xxxx\uyyyy)
+                                    i += 10;
+                                }
+                                else
+                                {
+                                    // add unicode character(s)
+                                    result += to_unicode(codepoint);
+                                    // skip the next four characters (xxxx)
+                                    i += 4;
+                                }
+                                break;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        // all other characters are just copied to the end of the
+                        // string
+                        result.append(1, static_cast<typename string_t::value_type>(*i));
+                    }
+                }
+
+                return result;
+            }
+
+            /*!
+        @brief parse floating point number
+
+        This function (and its overloads) serves to select the most approprate
+        standard floating point number parsing function based on the type
+        supplied via the first parameter.  Set this to
+        @a static_cast<number_float_t*>(nullptr).
+
+        @param[in] type  the @ref number_float_t in use
+
+        @param[in,out] endptr recieves a pointer to the first character after
+        the number
+
+        @return the floating point number
+
+        @bug This function uses `std::strtof`, `std::strtod`, or `std::strtold`
+        which use the current C locale to determine which character is used as
+        decimal point character. This may yield to parse errors if the locale
+        does not used `.`.
+        */
+            long double str_to_float_t(long double* /* type */, char** endptr) const
+            {
+                return std::strtold(reinterpret_cast<typename string_t::const_pointer>(m_start), endptr);
+            }
+
+            /*!
+        @brief parse floating point number
+
+        This function (and its overloads) serves to select the most approprate
+        standard floating point number parsing function based on the type
+        supplied via the first parameter.  Set this to
+        @a static_cast<number_float_t*>(nullptr).
+
+        @param[in] type  the @ref number_float_t in use
+
+        @param[in,out] endptr  recieves a pointer to the first character after
+        the number
+
+        @return the floating point number
+        */
+            double str_to_float_t(double* /* type */, char** endptr) const
+            {
+                return std::strtod(reinterpret_cast<typename string_t::const_pointer>(m_start), endptr);
+            }
+
+            /*!
+        @brief parse floating point number
+
+        This function (and its overloads) serves to select the most approprate
+        standard floating point number parsing function based on the type
+        supplied via the first parameter.  Set this to
+        @a static_cast<number_float_t*>(nullptr).
+
+        @param[in] type  the @ref number_float_t in use
+
+        @param[in,out] endptr  recieves a pointer to the first character after
+        the number
+
+        @return the floating point number
+        */
+            float str_to_float_t(float* /* type */, char** endptr) const
+            {
+                return std::strtof(reinterpret_cast<typename string_t::const_pointer>(m_start), endptr);
+            }
+
+            /*!
+        @brief static_cast between two types and indicate if it results in error
+
+        This function performs a static_cast between @a source and @a dest.  It
+        then checks if a static_cast back to @a dest produces an error.
+
+        @param[in] source  the value to cast from
+
+        @param[out] dest  the value to cast to
+
+        @return @a true if the cast was performed without error, @a false otherwise
+        */
+            template <typename T_A, typename T_B>
+            bool attempt_cast(T_A source, T_B& dest) const
+            {
+                dest = static_cast<T_B>(source);
+                return (source == static_cast<T_A>(dest));
+            }
+
+            /*!
+        @brief return number value for number tokens
+
+        This function translates the last token into the most appropriate
+        number type (either integer, unsigned integer or floating point), which
+        is passed back to the caller via the result parameter. The pointer @a
+        m_start points to the beginning of the parsed number. We first examine
+        the first character to determine the sign of the number and then pass
+        this pointer to either @a std::strtoull (if positive) or @a
+        std::strtoll (if negative), both of which set @a endptr to the first
+        character past the converted number. If this pointer is not the same as
+        @a m_cursor, then either more or less characters have been used during
+        the comparison.
+
+        This can happen for inputs like "01" which will be treated like number
+        0 followed by number 1. This will also occur for valid floating point
+        inputs like "12e3" will be incorrectly read as 12. Numbers that are too
+        large or too small for a signed/unsigned long long will cause a range
+        error (@a errno set to ERANGE). The parsed number is cast to a @ref
+        number_integer_t/@ref number_unsigned_t using the helper function @ref
+        attempt_cast, which returns @a false if the cast could not be peformed
+        without error.
+
+        In any of these cases (more/less characters read, range error or a cast
+        error) the pointer is passed to @a std:strtod, which also sets @a
+        endptr to the first character past the converted number. The resulting
+        @ref number_float_t is then cast to a @ref number_integer_t/@ref
+        number_unsigned_t using @ref attempt_cast and if no error occurs is
+        stored in that form, otherwise it is stored as a @ref number_float_t.
+
+        A final comparison is made of @a endptr and if still not the same as
+        @ref m_cursor a bad input is assumed and @a result parameter is set to
+        NAN.
+
+        @param[out] result @ref basic_json object to receive the number, or NAN
+        if the conversion read past the current token. The latter case needs to
+        be treated by the caller function.
+        */
+            void get_number(basic_json& result) const
+            {
+                typename string_t::value_type* endptr;
+                assert(m_start != nullptr);
+                errno = 0;
+
+                // attempt to parse it as an integer - first checking for a
+                // negative number
+                if (*reinterpret_cast<typename string_t::const_pointer>(m_start) != '-')
+                {
+                    // positive, parse with strtoull and attempt cast to
+                    // number_unsigned_t
+                    if (attempt_cast(std::strtoull(reinterpret_cast<typename string_t::const_pointer>(m_start), &endptr,
+                                                   10), result.m_value.number_unsigned))
+                    {
+                        result.m_type = value_t::number_unsigned;
+                    }
+                    else
+                    {
+                        // cast failed due to overflow - store as float
+                        result.m_type = value_t::number_float;
+                    }
+                }
+                else
+                {
+                    // Negative, parse with strtoll and attempt cast to
+                    // number_integer_t
+                    if (attempt_cast(std::strtoll(reinterpret_cast<typename string_t::const_pointer>(m_start), &endptr,
+                                                  10), result.m_value.number_integer))
+                    {
+                        result.m_type = value_t::number_integer;
+                    }
+                    else
+                    {
+                        // cast failed due to overflow - store as float
+                        result.m_type = value_t::number_float;
+                    }
+                }
+
+                // check the end of the number was reached and no range error
+                // occurred
+                if (reinterpret_cast<lexer_char_t*>(endptr) != m_cursor || errno == ERANGE)
+                {
+                    result.m_type = value_t::number_float;
+                }
+
+                if (result.m_type  == value_t::number_float)
+                {
+                    // either the number won't fit in an integer (range error from
+                    // strtoull/strtoll or overflow on cast) or there was something
+                    // else after the number, which could be an exponent
+
+                    // parse with strtod
+                    result.m_value.number_float = str_to_float_t(static_cast<number_float_t*>(nullptr), &endptr);
+
+                    // anything after the number is an error
+                    if (reinterpret_cast<lexer_char_t*>(endptr) != m_cursor)
+                    {
+                        throw std::invalid_argument(std::string("parse error - ") + get_token() + " is not a number");
+                    }
+                }
+            }
+
+        private:
+            /// optional input stream
+            std::istream* m_stream = nullptr;
+            /// the buffer
+            string_t m_buffer;
+            /// the buffer pointer
+            const lexer_char_t* m_content = nullptr;
+            /// pointer to the beginning of the current symbol
+            const lexer_char_t* m_start = nullptr;
+            /// pointer for backtracking information
+            const lexer_char_t* m_marker = nullptr;
+            /// pointer to the current symbol
+            const lexer_char_t* m_cursor = nullptr;
+            /// pointer to the end of the buffer
+            const lexer_char_t* m_limit = nullptr;
+        };
+
+        /*!
+    @brief syntax analysis
+
+    This class implements a recursive decent parser.
+    */
+        class parser
+        {
+        public:
+            /// constructor for strings
+            parser(const string_t& s, parser_callback_t cb = nullptr)
+                    : callback(cb), m_lexer(s)
+            {
+                // read first token
+                get_token();
+            }
+
+            /// a parser reading from an input stream
+            parser(std::istream& _is, parser_callback_t cb = nullptr)
+                    : callback(cb), m_lexer(&_is)
+            {
+                // read first token
+                get_token();
+            }
+
+            /// public parser interface
+            basic_json parse()
+            {
+                basic_json result = parse_internal(true);
+
+                expect(lexer::token_type::end_of_input);
+
+                // return parser result and replace it with null in case the
+                // top-level value was discarded by the callback function
+                return result.is_discarded() ? basic_json() : result;
+            }
+
+        private:
+            /// the actual parser
+            basic_json parse_internal(bool keep)
+            {
+                auto result = basic_json(value_t::discarded);
+
+                switch (last_token)
+                {
+                    case lexer::token_type::begin_object:
+                    {
+                        if (keep and (not callback or (keep = callback(depth++, parse_event_t::object_start, result))))
+                        {
+                            // explicitly set result to object to cope with {}
+                            result.m_type = value_t::object;
+                            result.m_value = json_value(value_t::object);
+                        }
+
+                        // read next token
+                        get_token();
+
+                        // closing } -> we are done
+                        if (last_token == lexer::token_type::end_object)
+                        {
+                            get_token();
+                            if (keep and callback and not callback(--depth, parse_event_t::object_end, result))
+                            {
+                                result = basic_json(value_t::discarded);
+                            }
+                            return result;
+                        }
+
+                        // no comma is expected here
+                        unexpect(lexer::token_type::value_separator);
+
+                        // otherwise: parse key-value pairs
+                        do
+                        {
+                            // ugly, but could be fixed with loop reorganization
+                            if (last_token == lexer::token_type::value_separator)
+                            {
+                                get_token();
+                            }
+
+                            // store key
+                            expect(lexer::token_type::value_string);
+                            const auto key = m_lexer.get_string();
+
+                            bool keep_tag = false;
+                            if (keep)
+                            {
+                                if (callback)
+                                {
+                                    basic_json k(key);
+                                    keep_tag = callback(depth, parse_event_t::key, k);
+                                }
+                                else
+                                {
+                                    keep_tag = true;
+                                }
+                            }
+
+                            // parse separator (:)
+                            get_token();
+                            expect(lexer::token_type::name_separator);
+
+                            // parse and add value
+                            get_token();
+                            auto value = parse_internal(keep);
+                            if (keep and keep_tag and not value.is_discarded())
+                            {
+                                result[key] = std::move(value);
+                            }
+                        }
+                        while (last_token == lexer::token_type::value_separator);
+
+                        // closing }
+                        expect(lexer::token_type::end_object);
+                        get_token();
+                        if (keep and callback and not callback(--depth, parse_event_t::object_end, result))
+                        {
+                            result = basic_json(value_t::discarded);
+                        }
+
+                        return result;
+                    }
+
+                    case lexer::token_type::begin_array:
+                    {
+                        if (keep and (not callback or (keep = callback(depth++, parse_event_t::array_start, result))))
+                        {
+                            // explicitly set result to object to cope with []
+                            result.m_type = value_t::array;
+                            result.m_value = json_value(value_t::array);
+                        }
+
+                        // read next token
+                        get_token();
+
+                        // closing ] -> we are done
+                        if (last_token == lexer::token_type::end_array)
+                        {
+                            get_token();
+                            if (callback and not callback(--depth, parse_event_t::array_end, result))
+                            {
+                                result = basic_json(value_t::discarded);
+                            }
+                            return result;
+                        }
+
+                        // no comma is expected here
+                        unexpect(lexer::token_type::value_separator);
+
+                        // otherwise: parse values
+                        do
+                        {
+                            // ugly, but could be fixed with loop reorganization
+                            if (last_token == lexer::token_type::value_separator)
+                            {
+                                get_token();
+                            }
+
+                            // parse value
+                            auto value = parse_internal(keep);
+                            if (keep and not value.is_discarded())
+                            {
+                                result.push_back(std::move(value));
+                            }
+                        }
+                        while (last_token == lexer::token_type::value_separator);
+
+                        // closing ]
+                        expect(lexer::token_type::end_array);
+                        get_token();
+                        if (keep and callback and not callback(--depth, parse_event_t::array_end, result))
+                        {
+                            result = basic_json(value_t::discarded);
+                        }
+
+                        return result;
+                    }
+
+                    case lexer::token_type::literal_null:
+                    {
+                        get_token();
+                        result.m_type = value_t::null;
+                        break;
+                    }
+
+                    case lexer::token_type::value_string:
+                    {
+                        const auto s = m_lexer.get_string();
+                        get_token();
+                        result = basic_json(s);
+                        break;
+                    }
+
+                    case lexer::token_type::literal_true:
+                    {
+                        get_token();
+                        result.m_type = value_t::boolean;
+                        result.m_value = true;
+                        break;
+                    }
+
+                    case lexer::token_type::literal_false:
+                    {
+                        get_token();
+                        result.m_type = value_t::boolean;
+                        result.m_value = false;
+                        break;
+                    }
+
+                    case lexer::token_type::value_number:
+                    {
+                        m_lexer.get_number(result);
+                        get_token();
+                        break;
+                    }
+
+                    default:
+                    {
+                        // the last token was unexpected
+                        unexpect(last_token);
+                    }
+                }
+
+                if (keep and callback and not callback(depth, parse_event_t::value, result))
+                {
+                    result = basic_json(value_t::discarded);
+                }
+                return result;
+            }
+
+            /// get next token from lexer
+            typename lexer::token_type get_token()
+            {
+                last_token = m_lexer.scan();
+                return last_token;
+            }
+
+            void expect(typename lexer::token_type t) const
+            {
+                if (t != last_token)
+                {
+                    std::string error_msg = "parse error - unexpected ";
+                    error_msg += (last_token == lexer::token_type::parse_error ? ("'" +  m_lexer.get_token() + "'") :
+                                  lexer::token_type_name(last_token));
+                    error_msg += "; expected " + lexer::token_type_name(t);
+                    throw std::invalid_argument(error_msg);
+                }
+            }
+
+            void unexpect(typename lexer::token_type t) const
+            {
+                if (t == last_token)
+                {
+                    std::string error_msg = "parse error - unexpected ";
+                    error_msg += (last_token == lexer::token_type::parse_error ? ("'" +  m_lexer.get_token() + "'") :
+                                  lexer::token_type_name(last_token));
+                    throw std::invalid_argument(error_msg);
+                }
+            }
+
+        private:
+            /// current level of recursion
+            int depth = 0;
+            /// callback function
+            parser_callback_t callback;
+            /// the type of the last read token
+            typename lexer::token_type last_token = lexer::token_type::uninitialized;
+            /// the lexer
+            lexer m_lexer;
+        };
+    };
+
+
+/////////////
+// presets //
+/////////////
+
+/*!
+@brief default JSON class
+
+This type is the default specialization of the @ref basic_json class which uses
+the standard template types.
+
+@since version 1.0.0
+*/
+    using json = basic_json<>;
+}
+
+
+/////////////////////////
+// nonmember functions //
+/////////////////////////
+
+// specialization of std::swap, and std::hash
+namespace std
+{
+/*!
+@brief exchanges the values of two JSON objects
+
+@since version 1.0.0
+*/
+    template <>
+    inline void swap(nlohmann::json& j1,
+                     nlohmann::json& j2) noexcept(
+    is_nothrow_move_constructible<nlohmann::json>::value and
+    is_nothrow_move_assignable<nlohmann::json>::value
+    )
+    {
+        j1.swap(j2);
+    }
+
+/// hash value for JSON objects
+    template <>
+    struct hash<nlohmann::json>
+    {
+        /*!
+    @brief return a hash value for a JSON object
+
+    @since version 1.0.0
+    */
+        std::size_t operator()(const nlohmann::json& j) const
+        {
+            // a naive hashing via the string representation
+            const auto& h = hash<nlohmann::json::string_t>();
+            return h(j.dump());
+        }
+    };
+}
+
+/*!
+@brief user-defined string literal for JSON values
+
+This operator implements a user-defined string literal for JSON objects. It can
+be used by adding \p "_json" to a string literal and returns a JSON object if
+no parse error occurred.
+
+@param[in] s  a string representation of a JSON object
+@return a JSON object
+
+@since version 1.0.0
+*/
+inline nlohmann::json operator "" _json(const char* s, std::size_t)
+{
+    return nlohmann::json::parse(reinterpret_cast<const nlohmann::json::string_t::value_type*>(s));
+}
+
+// restore GCC/clang diagnostic settings
+#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
+#pragma GCC diagnostic pop
+#endif
+
+#endif
\ No newline at end of file
diff --git a/lib/LLVMSlicer/CMakeLists.txt b/lib/LLVMSlicer/CMakeLists.txt
new file mode 100644
index 0000000..d0c7e6c
--- /dev/null
+++ b/lib/LLVMSlicer/CMakeLists.txt
@@ -0,0 +1,16 @@
+add_llvm_library(LLVMSlicer
+Kleerer.cpp
+ModStats.cpp
+Slicing/FunctionStaticSlicer.cpp
+Slicing/PostDominanceFrontier.cpp
+Slicing/Prepare.cpp
+Slicing/StaticSlicer.cpp
+Callgraph/Callgraph.cpp
+Languages/LLVM.cpp
+Modifies/Modifies.cpp
+PointsTo/PointsTo.cpp
+Backtrack/Path.cpp
+Backtrack/Rule.cpp
+Backtrack/Constraint.cpp
+Backtrack/Backtrack.cpp
+)
diff --git a/lib/LLVMSlicer/Callgraph/Callgraph.cpp b/lib/LLVMSlicer/Callgraph/Callgraph.cpp
new file mode 100644
index 0000000..907d8be
--- /dev/null
+++ b/lib/LLVMSlicer/Callgraph/Callgraph.cpp
@@ -0,0 +1,42 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#include "../PointsTo/PointsTo.h"
+#include "Callgraph.h"
+
+using namespace llvm;
+using namespace callgraph;
+
+Callgraph::Callgraph(Module &M, ptr::PointsToSets const& PS) {
+  typedef Module::iterator FunctionsIter;
+  for (FunctionsIter f = M.begin(); f != M.end(); ++f)
+    if (!f->isDeclaration() && !memoryManStuff(&*f))
+      for (inst_iterator i = inst_begin(*f); i != inst_end(*f); i++)
+	if (const CallInst *CI = dyn_cast<CallInst const>(&*i))
+	  handleCall(&*f, CI, PS);
+
+  detail::computeTransitiveClosure(directCallsMap, callsMap);
+  for (const_iterator it = begin(); it != end(); ++it)
+    directCalleesMap.insert(value_type(it->second,it->first));
+  for (const_iterator it = callsMap.begin(); it != callsMap.end(); ++it)
+    calleesMap.insert(value_type(it->second,it->first));
+}
+
+void Callgraph::handleCall(const Function *parent,
+			   const CallInst *CI,
+			   const ptr::PointsToSets &PS) {
+  if (isInlineAssembly(CI))
+    return;
+
+  typedef SmallVector<const Value *, 10> CalledFunctions;
+  CalledFunctions G;
+  getCalledFunctions(CI, PS, std::back_inserter(G));
+
+  for (CalledFunctions::const_iterator I = G.begin(), E = G.end();
+       I != E; ++I) {
+    const Function *called = dyn_cast<Function>(*I);
+    if (!memoryManStuff(called) && !called->isDeclaration() &&
+	!contains(parent, called))
+      insertDirectCall(value_type(parent, called));
+  }
+}
diff --git a/lib/LLVMSlicer/Callgraph/Callgraph.h b/lib/LLVMSlicer/Callgraph/Callgraph.h
new file mode 100644
index 0000000..2102046
--- /dev/null
+++ b/lib/LLVMSlicer/Callgraph/Callgraph.h
@@ -0,0 +1,135 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef CALLGRAPH_CALLGRAPH_H
+#define CALLGRAPH_CALLGRAPH_H
+
+#include <map>
+#include <algorithm>
+#include <iterator>
+#include <utility>
+
+#include "llvm/IR/Function.h"
+#include "llvm/ADT/STLExtras.h" /* tie */
+
+#include "../Languages/LLVM.h"
+#include "../Languages/LLVMSupport.h"
+#include "../PointsTo/PointsTo.h"
+
+namespace llvm { namespace callgraph {
+
+    struct Callgraph {
+        typedef std::multimap<const llvm::Function *, const llvm::Function *>
+		Container;
+        typedef Container::key_type key_type;
+        typedef Container::mapped_type mapped_type;
+        typedef Container::value_type value_type;
+        typedef Container::iterator iterator;
+        typedef Container::const_iterator const_iterator;
+        typedef std::pair<const_iterator,const_iterator> range_iterator;
+
+        Callgraph(Module &M, const llvm::ptr::PointsToSets &PS);
+
+        range_iterator directCalls(key_type const& key) const
+        { return directCallsMap.equal_range(key); }
+
+        range_iterator directCallees(key_type const& key) const
+        { return directCalleesMap.equal_range(key); }
+
+        range_iterator calls(key_type const& key) const
+        { return callsMap.equal_range(key); }
+
+        range_iterator callees(key_type const& key) const
+        { return calleesMap.equal_range(key); }
+
+        bool contains(key_type const key, mapped_type const value) const {
+          range_iterator rng = directCalls(key);
+          for (const_iterator it = rng.first; it != rng.second; ++it)
+            if (it->second == value)
+              return true;
+          return false;
+        }
+
+        const_iterator begin() const { return directCallsMap.begin(); }
+        iterator begin() { return directCallsMap.begin(); }
+        const_iterator end() const { return directCallsMap.end(); }
+        iterator end() { return directCallsMap.end(); }
+        const_iterator begin_closure() const { return callsMap.begin(); }
+        const_iterator end_closure() const { return callsMap.end(); }
+        Container const& getContainer() const { return directCallsMap; }
+        Container& getContainer() { return directCallsMap; }
+
+    protected:
+        iterator insertDirectCall(value_type const& val)
+        { return directCallsMap.insert(val); }
+
+    private:
+        Container directCallsMap;
+        Container directCalleesMap;
+        Container callsMap;
+        Container calleesMap;
+
+        void handleCall(const llvm::Function *parent, const llvm::CallInst *CI,
+                        const llvm::ptr::PointsToSets &PS);
+    };
+}}
+
+namespace llvm { namespace callgraph { namespace detail {
+
+  template<typename Relation>
+  void computeTransitiveClosure(Relation const& R, Relation& TCR) {
+    typedef std::set<typename Relation::value_type> Set;
+    typedef std::multimap<typename Relation::value_type::first_type,
+                          typename Relation::value_type::second_type> Dict;
+
+    Set S;
+    std::copy(R.begin(),R.end(),std::inserter(S,S.end()));
+
+    Dict D;
+    std::copy(R.begin(),R.end(),std::inserter(D,D.end()));
+
+    while (true)
+    {
+      std::size_t const old_size = S.size();
+
+      for (typename Set::const_iterator it = S.begin(); it != S.end(); ++it) {
+        typename Dict::const_iterator b,e;
+        std::tie(b,e) = D.equal_range(it->second);
+        for ( ; b != e; ++b)
+          S.insert(typename Set::value_type(it->first,b->second));
+      }
+
+      if (old_size == S.size())
+          break;
+    }
+
+    std::copy(S.begin(),S.end(),std::inserter(TCR,TCR.end()));
+  }
+
+}}}
+
+namespace llvm { namespace callgraph {
+
+    static inline Callgraph::range_iterator
+    getDirectCalls(Callgraph::key_type const& key, Callgraph const& CG) {
+        return CG.directCalls(key);
+    }
+
+    static inline Callgraph::range_iterator
+    getDirectCallees(Callgraph::key_type const& key, Callgraph const& CG) {
+        return CG.directCallees(key);
+    }
+
+    static inline Callgraph::range_iterator
+    getCalls(Callgraph::key_type const& key, Callgraph const& CG) {
+        return CG.calls(key);
+    }
+
+    static inline Callgraph::range_iterator
+    getCallees(Callgraph::key_type const& key, Callgraph const& CG) {
+        return CG.callees(key);
+    }
+
+}}
+
+#endif
diff --git a/lib/LLVMSlicer/Kleerer.cpp b/lib/LLVMSlicer/Kleerer.cpp
new file mode 100644
index 0000000..915b96f
--- /dev/null
+++ b/lib/LLVMSlicer/Kleerer.cpp
@@ -0,0 +1,462 @@
+#include <llvm/Support/FileSystem.h>
+#include "llvm/IR/Attributes.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/Pass.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/TypeBuilder.h"
+#include "llvm/IR/Verifier.h"
+#include "llvm/Bitcode/ReaderWriter.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include "Callgraph/Callgraph.h"
+#include "PointsTo/PointsTo.h"
+#include "Slicing/Prepare.h"
+
+using namespace llvm;
+
+namespace {
+  class KleererPass : public ModulePass {
+  public:
+    static char ID;
+
+    KleererPass() : ModulePass(ID) { }
+
+    virtual bool runOnModule(Module &M);
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();
+//      AU.addRequired<DataLayout>();
+    }
+  };
+}
+
+class Kleerer {
+public:
+  Kleerer(ModulePass &modPass, Module &M, DataLayout &TD,
+          callgraph::Callgraph &CG) : modPass(modPass),
+      M(M), TD(TD), CG(CG), C(M.getContext()), intPtrTy(TD.getIntPtrType(C)),
+      done(false) {
+    voidPtrType = TypeBuilder<void *, false>::get(C);
+    size_tType = TypeBuilder<size_t, false>::get(C);
+    intType = TypeBuilder<int, false>::get(C);
+    uintType = TypeBuilder<unsigned, false>::get(C);
+  }
+
+  bool run();
+
+private:
+  ModulePass &modPass;
+  Module &M;
+  DataLayout &TD;
+  callgraph::Callgraph &CG;
+  LLVMContext &C;
+  IntegerType *intPtrTy;
+  bool done;
+  Function *klee_make_symbolic;
+
+  /* types */
+  Type *voidPtrType;
+  Type *size_tType;
+  Type *intType;
+  Type *uintType;
+
+  Value *handlePtrArg(BasicBlock *mainBB, Constant *name, PointerType *PT);
+  void prepareArguments(Function &F, BasicBlock *mainBB,
+                        std::vector<Value *> &params);
+  void writeMain(Function &F);
+
+  Constant *get_assert_fail();
+
+  Instruction *createMalloc(BasicBlock *BB, Type *type, unsigned typeSize,
+                            Value *arraySize);
+  Instruction *call_klee_make_symbolic(Constant *name, BasicBlock *BB,
+                                       Type *type, Value *addr,
+                                       Value *arraySize = 0);
+  Instruction *mallocSymbolic(BasicBlock *BB, Constant *name, Type *elemTy,
+                              unsigned typeSize, Value *arrSize);
+  void makeGlobalsSymbolic(Module &M, BasicBlock *BB);
+  BasicBlock *checkAiState(Function *mainFun, BasicBlock *BB,
+                           const DebugLoc &debugLoc);
+  void addGlobals(Module &M);
+};
+
+static RegisterPass<KleererPass> X("kleerer", "Prepares a module for Klee");
+char KleererPass::ID;
+
+static void check(Value *Func, ArrayRef<Value *> Args) {
+  FunctionType *FTy =
+    cast<FunctionType>(cast<PointerType>(Func->getType())->getElementType());
+
+  assert((Args.size() == FTy->getNumParams() ||
+          (FTy->isVarArg() && Args.size() > FTy->getNumParams())) &&
+         "XXCalling a function with bad signature!");
+
+  for (unsigned i = 0; i != Args.size(); ++i) {
+    if (!(FTy->getParamType(i) == Args[i]->getType())) {
+      errs() << "types:\n  ";
+      FTy->getParamType(i)->dump();
+      errs() << "\n  ";
+      Args[i]->getType()->dump();
+      errs() << "\n";
+    }
+    assert((i >= FTy->getNumParams() ||
+            FTy->getParamType(i) == Args[i]->getType()) &&
+           "YYCalling a function with a bad signature!");
+  }
+}
+
+static unsigned getTypeSize(DataLayout &TD, Type *type) {
+  if (type->isFunctionTy()) /* it is not sized, weird */
+    return TD.getPointerSize();
+
+  if (!type->isSized())
+    return 100; /* FIXME */
+
+  if (StructType *ST = dyn_cast<StructType>(type))
+    return TD.getStructLayout(ST)->getSizeInBytes();
+
+  return TD.getTypeAllocSize(type);
+}
+
+Instruction *Kleerer::createMalloc(BasicBlock *BB, Type *type,
+                                   unsigned typeSize, Value *arraySize) {
+  return CallInst::CreateMalloc(BB, intPtrTy, type,
+                                ConstantInt::get(intPtrTy, typeSize),
+                                arraySize);
+}
+
+static Constant *getGlobalString(LLVMContext &C, Module &M,
+                                 const StringRef &str) {
+  Constant *strArray = ConstantDataArray::getString(C, str);
+  GlobalVariable *strVar =
+        new GlobalVariable(M, strArray->getType(), true,
+                           GlobalValue::PrivateLinkage, strArray, "");
+  strVar->setUnnamedAddr(true);
+  strVar->setAlignment(1);
+
+  std::vector<Value *> params;
+  params.push_back(ConstantInt::get(TypeBuilder<types::i<32>, true>::get(C), 0));
+  params.push_back(ConstantInt::get(TypeBuilder<types::i<32>, true>::get(C), 0));
+
+  return ConstantExpr::getInBoundsGetElementPtr(strVar->getType(), strVar, params);
+}
+
+Instruction *Kleerer::call_klee_make_symbolic(Constant *name, BasicBlock *BB,
+                                              Type *type, Value *addr,
+                                              Value *arraySize) {
+  std::vector<Value *> p;
+
+  if (addr->getType() != voidPtrType)
+    addr = new BitCastInst(addr, voidPtrType, "", BB);
+  p.push_back(addr);
+
+  unsigned typeSize = getTypeSize(TD, type);
+  Value *size;
+
+  if (arraySize && typeSize == 1)
+    size = arraySize;
+  else {
+    size = ConstantInt::get(size_tType, typeSize);
+    if (arraySize)
+      size = BinaryOperator::CreateMul(arraySize, size,
+                                     "make_symbolic_size", BB);
+  }
+
+  p.push_back(size);
+  p.push_back(name);
+
+  check(klee_make_symbolic, p);
+
+  return CallInst::Create(klee_make_symbolic, p);
+}
+
+/*
+ * it also initializes __ai_state_*
+ */
+void Kleerer::makeGlobalsSymbolic(Module &M, BasicBlock *BB) {
+  Constant *zero = ConstantInt::get(intType, 0);
+  for (Module::global_iterator I = M.global_begin(), E = M.global_end();
+      I != E; ++I) {
+    GlobalVariable &GV = *I;
+    if (GV.isConstant() || !GV.hasName())
+	continue;
+    StringRef GVName = GV.getName();
+    if (GVName.startswith("llvm."))
+	    continue;
+    if (GVName.startswith("__ai_") && !GVName.startswith("__ai_state_"))
+	    continue;
+/*    errs() << "TU " << GVName << " ";
+    GV.getType()->getElementType()->dump();
+    errs() << "\n\t" << GVName << "\n";*/
+    Constant *glob_str = getGlobalString(C, M, GVName);
+    BB->getInstList().push_back(call_klee_make_symbolic(glob_str, BB,
+		GV.getType()->getElementType(), &GV));
+    if (GVName.startswith("__ai_state_"))
+	new StoreInst(zero, &GV, "", true, BB);
+  }
+}
+
+Constant *Kleerer::get_assert_fail()
+{
+  Type *constCharPtrTy = TypeBuilder<const char *, false>::get(C);
+  AttributeSet attrs = AttributeSet().addAttribute(C,
+		  AttributeSet::FunctionIndex, Attribute::NoReturn);
+  return M.getOrInsertFunction("__assert_fail", attrs, Type::getVoidTy(C),
+                               constCharPtrTy, constCharPtrTy, uintType,
+                               constCharPtrTy, NULL);
+}
+
+BasicBlock *Kleerer::checkAiState(Function *mainFun, BasicBlock *BB,
+                                  const DebugLoc &debugLoc) {
+  Module *M = mainFun->getParent();
+  Constant *zero = ConstantInt::get(intType, 0);
+
+  BasicBlock *finalBB = BasicBlock::Create(C, "final", mainFun);
+  BasicBlock *assBB = BasicBlock::Create(C, "assertBB", mainFun);
+  std::vector<Value *> params;
+  params.push_back(getGlobalString(C, *M, "leaving function with lock held"));
+  params.push_back(getGlobalString(C, *M, "n/a"));
+  params.push_back(zero);
+  params.push_back(getGlobalString(C, *M, "main"));
+  CallInst::Create(get_assert_fail(), params, "", assBB)->setDebugLoc(debugLoc);
+  new UnreachableInst(C, assBB);
+  Value *sum = zero;
+
+  for (Module::global_iterator I = M->global_begin(), E = M->global_end();
+      I != E; ++I) {
+    GlobalVariable &ai_state = *I;
+    if (!ai_state.hasName() || !ai_state.getName().startswith("__ai_state_"))
+      continue;
+    Value *ai_stateVal = new LoadInst(&ai_state, "", true, BB);
+    sum = BinaryOperator::Create(BinaryOperator::Add, ai_stateVal, sum, "", BB);
+  }
+
+  Value *ai_stateIsZero = new ICmpInst(*BB, CmpInst::ICMP_EQ, sum, zero);
+  BranchInst::Create(finalBB, assBB, ai_stateIsZero, BB);
+
+  return finalBB;
+}
+
+void Kleerer::addGlobals(Module &mainMod) {
+  for (Module::global_iterator I = M.global_begin(), E = M.global_end();
+       I != E; ++I) {
+    GlobalVariable &G = *I;
+    if (!G.isDeclaration() || G.hasInitializer())
+      continue;
+    Constant *xxx = Constant::getNullValue(G.getType()->getElementType());
+    G.setInitializer(xxx);
+  }
+}
+
+struct st_desc {
+  unsigned long flag;
+#define STF_ONE  1
+};
+
+static const struct st_desc *getStDesc(const Type *elemTy) {
+  typedef std::map<std::string, struct st_desc> StructMap;
+
+  static const StructMap::value_type structMapData[] = {
+    StructMap::value_type("pci_dev", (struct st_desc){ STF_ONE }),
+  };
+
+  #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+  static const StructMap structMap(structMapData,
+                                   structMapData + ARRAY_SIZE(structMapData));
+
+  if (const StructType *ST = dyn_cast<StructType>(elemTy))
+    if (!ST->isLiteral() && ST->hasName()) {
+
+      /* each struct name has "struct." prepended */
+      StructMap::const_iterator I = structMap.find(ST->getName().substr(7));
+      if (I != structMap.end())
+        return &I->second;
+    }
+
+  return NULL;
+}
+
+Instruction *Kleerer::mallocSymbolic(BasicBlock *BB, Constant *name,
+                                     Type *elemTy, unsigned typeSize,
+                                     Value *arrSize) {
+  BasicBlock::InstListType &insList = BB->getInstList();
+  Instruction *ins = createMalloc(BB, elemTy, typeSize, arrSize);
+  insList.push_back(ins);
+  insList.push_back(call_klee_make_symbolic(name, BB, elemTy, ins, arrSize));
+  return ins;
+}
+
+Value *Kleerer::handlePtrArg(BasicBlock *mainBB, Constant *name,
+                             PointerType *PT) {
+  BasicBlock::InstListType &insList = mainBB->getInstList();
+  Instruction *ins;
+  Type *elemTy = PT->getElementType();
+  const struct st_desc *st_desc = getStDesc(elemTy);
+  unsigned typeSize = getTypeSize(TD, elemTy);
+  Value *arrSize = NULL;
+  if (!st_desc || !(st_desc->flag & STF_ONE)) {
+    unsigned count = (1 << 20) / typeSize;
+    if (count > 4096)
+      count = 4096;
+
+    arrSize = ConstantInt::get(size_tType, count);
+  }
+
+  ins = mallocSymbolic(mainBB, name, elemTy, typeSize, arrSize);
+  if (arrSize) {
+    bool cast = ins->getType() != voidPtrType;
+    if (cast)
+      insList.push_back(ins = new BitCastInst(ins, voidPtrType));
+    ins = GetElementPtrInst::CreateInBounds(ins,
+           ConstantInt::get(TypeBuilder<types::i<64>, true>::get(C), 2048));
+    insList.push_back(ins);
+    if (cast)
+      insList.push_back(ins = new BitCastInst(ins, PT));
+  }
+
+  return ins;
+}
+
+void Kleerer::prepareArguments(Function &F, BasicBlock *mainBB,
+                               std::vector<Value *> &params) {
+  BasicBlock::InstListType &insList = mainBB->getInstList();
+
+  for (Function::const_arg_iterator I = F.arg_begin(), E = F.arg_end(); I != E;
+       ++I) {
+    const Value &param = *I;
+    Type *type = param.getType();
+#ifdef DEBUG_WRITE_MAIN
+    errs() << "param\n  ";
+    param.print(errs());
+    errs() << "\n  type=";
+    type->print(errs());
+    errs() << "\n";
+#endif
+    Value *val = NULL;
+    Constant *name = getGlobalString(C, M, param.hasName() ? param.getName() :
+                                     "noname");
+    if (PointerType *PT = dyn_cast<PointerType>(type)) {
+      val = handlePtrArg(mainBB, name, PT);
+    } else if (IntegerType *IT = dyn_cast<IntegerType>(type)) {
+      Instruction *ins;
+      insList.push_front(ins = new AllocaInst(IT));
+      insList.push_back(call_klee_make_symbolic(name, mainBB, type, ins));
+      insList.push_back(ins = new LoadInst(ins));
+      val = ins;
+    }
+    if (val)
+      params.push_back(val);
+  }
+}
+
+void Kleerer::writeMain(Function &F) {
+  std::string name = M.getModuleIdentifier() + ".main." + F.getName().str() + ".o";
+  Function *mainFun = Function::Create(TypeBuilder<int(), false>::get(C),
+                    GlobalValue::ExternalLinkage, "main", &M);
+  BasicBlock *mainBB = BasicBlock::Create(C, "entry", mainFun);
+
+  FunctionType *klee_make_symbolicTy =
+      TypeBuilder<void(void *, size_t, const char *), false>::get(C);
+  klee_make_symbolic = dyn_cast<Function>(
+      M.getOrInsertFunction("klee_make_symbolic", klee_make_symbolicTy));
+  /* if there was one, it should have the same type, i.e. we got Function */
+  assert(klee_make_symbolic);
+/*  Function *klee_int = Function::Create(
+              TypeBuilder<int(const char *), false>::get(C),
+              GlobalValue::ExternalLinkage, "klee_int", &M);*/
+
+//  F.dump();
+
+  std::vector<Value *> params;
+  prepareArguments(F, mainBB, params);
+//  mainFun->viewCFG();
+
+  makeGlobalsSymbolic(M, mainBB);
+  addGlobals(M);
+#ifdef DEBUG_WRITE_MAIN
+  errs() << "==============\n";
+  errs() << mainMod;
+  errs() << "==============\n";
+#endif
+  check(&F, params);
+
+  CallInst::Create(&F, params, "", mainBB);
+  BasicBlock *final = checkAiState(mainFun, mainBB, F.back().back().getDebugLoc());
+  ReturnInst::Create(C, ConstantInt::get(mainFun->getReturnType(), 0),
+                     final);
+
+#ifdef DEBUG_WRITE_MAIN
+  mainFun->viewCFG();
+#endif
+
+  std::string ErrorInfo;
+    std::error_code EC;
+  raw_fd_ostream out(name.c_str(), EC, sys::fs::F_None);
+  if (!ErrorInfo.empty()) {
+    errs() << __func__ << ": cannot write '" << name << "'!\n";
+    return;
+  }
+
+//  errs() << mainMod;
+
+    legacy::PassManager Passes;
+  Passes.add(createVerifierPass());
+  Passes.run(M);
+
+  WriteBitcodeToFile(&M, out);
+  errs() << __func__ << ": written: '" << name << "'\n";
+  mainFun->eraseFromParent();
+//  done = true;
+}
+
+bool Kleerer::run() {
+  Function *F__assert_fail = M.getFunction("__assert_fail");
+  if (!F__assert_fail) /* nothing to find here bro */
+    return false;
+
+  callgraph::Callgraph::range_iterator RI = CG.callees(F__assert_fail);
+  if (std::distance(RI.first, RI.second) == 0)
+    return false;
+
+  const ConstantArray *initFuns = getInitFuns(M);
+  assert(initFuns && "No initial functions found. Did you run -prepare?");
+
+  for (ConstantArray::const_op_iterator I = initFuns->op_begin(),
+       E = initFuns->op_end(); I != E; ++I) {
+    const ConstantExpr *CE = cast<ConstantExpr>(&*I);
+    assert(CE->getOpcode() == Instruction::BitCast);
+    Function &F = *cast<Function>(CE->getOperand(0));
+
+    callgraph::Callgraph::const_iterator II, EE;
+    std::tie(II, EE) = CG.calls(&F);
+    for (; II != EE; ++II) {
+      const Function *callee = (*II).second;
+      if (callee == F__assert_fail) {
+        writeMain(F);
+        break;
+      }
+    }
+    if (done)
+      break;
+  }
+  return false;
+}
+
+bool KleererPass::runOnModule(Module &M) {
+  const DataLayout &TD = M.getDataLayout();
+  ptr::PointsToSets PS;
+  {
+    ptr::ProgramStructure P(M);
+    computePointsToSets(P, PS);
+  }
+
+  callgraph::Callgraph CG(M, PS);
+
+  Kleerer K(*this, M, (DataLayout&)TD, CG);
+  return K.run();
+}
diff --git a/lib/LLVMSlicer/LLVMBuild.txt b/lib/LLVMSlicer/LLVMBuild.txt
new file mode 100644
index 0000000..661b89e
--- /dev/null
+++ b/lib/LLVMSlicer/LLVMBuild.txt
@@ -0,0 +1,26 @@
+;===- ./lib/MC/LLVMBuild.txt -----------------------------------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[common]
+;subdirectories = Callgraph Languages Modifies PointsTo Slicing
+
+[component_0]
+;LOADABLE_MODULE = 1
+type = Library
+name = Slicer
+parent = Libraries
+required_libraries = Object Support Analysis Core TransformUtils
diff --git a/lib/LLVMSlicer/Languages/LLVM.cpp b/lib/LLVMSlicer/Languages/LLVM.cpp
new file mode 100644
index 0000000..95a64f0
--- /dev/null
+++ b/lib/LLVMSlicer/Languages/LLVM.cpp
@@ -0,0 +1,248 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#include "llvm/IR/Constant.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/InlineAsm.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Value.h"
+
+#include "LLVM.h"
+
+namespace llvm {
+
+    bool hasExtraReference(llvm::Value const* const V)
+    {
+        if (llvm::isa<llvm::AllocaInst const>(V))
+            return true;
+        if (llvm::isa<llvm::GlobalVariable const>(V))
+            return true;
+        if (llvm::isa<llvm::Function const>(V))
+            return true;
+        //if (llvm::isa<llvm::Argument const>(V))
+        //    return true;
+        return false;
+        //return V->isDereferenceablePointer();
+    }
+
+    bool isConstantValue(llvm::Value const* const V) {
+      return isa<ConstantPointerNull>(V) ||
+        (isa<Constant const>(V) &&
+         !isa<GlobalValue>(V) &&
+         !isa<UndefValue>(V));
+    }
+
+    bool isPointerValue(llvm::Value const* const V)
+    {
+        if (!V->getType()->isPointerTy())
+            return false;
+        if (!hasExtraReference(V))
+            return true;
+        return llvm::dyn_cast<llvm::PointerType const>(V->getType())
+                    ->getElementType()->isPointerTy();
+    }
+
+    bool isPointerToPointerValue(llvm::Value const* const V)
+    {
+        return isPointerValue(V) && getPointedType(V)->isPointerTy();
+    }
+
+    bool isPointerManipulation(llvm::Instruction const* const I) {
+        if (isa<AllocaInst>(I)) {
+          return false;
+        } else if (I->getOpcode() == llvm::Instruction::Load)
+        {
+            if (llvm::dyn_cast<llvm::PointerType const>(
+                        I->getOperand(0)->getType())->
+                    getElementType()->isPointerTy())
+                return true;
+        }
+        else if (I->getOpcode() == llvm::Instruction::Store)
+        {
+            if (I->getOperand(0)->getType()->isPointerTy())
+                return true;
+        }
+        else if (I->getOpcode() == llvm::Instruction::BitCast)
+        {
+            if (I->getType()->isPointerTy() &&
+                    I->getOperand(0)->getType()->isPointerTy())
+                return true;
+        }
+        else if (I->getOpcode() == llvm::Instruction::GetElementPtr)
+        //else if (llvm::GetElementPtrInst const* const gep =
+        //            llvm::dyn_cast<llvm::GetElementPtrInst>(I))
+        {
+            return true;
+        } else if (const llvm::CallInst *C =
+                        llvm::dyn_cast<llvm::CallInst>(I)) {
+          if (isInlineAssembly(C))
+            return false;
+          return memoryManStuff(C->getCalledValue());
+        } else if (const PHINode *PHI = dyn_cast<PHINode>(I)) {
+          return isPointerValue(PHI);
+        } else if (const ExtractValueInst *EV =
+                   dyn_cast<const ExtractValueInst>(I)) {
+          return isPointerValue(EV);
+        } else if (const InsertValueInst *IV =
+                   dyn_cast<const InsertValueInst>(I)) {
+          return isPointerValue(IV->getInsertedValueOperand());
+        } else if (isa<IntToPtrInst>(I)) {
+          return true;
+        } else if (const SelectInst *SEL = dyn_cast<SelectInst>(I)) {
+          if (isPointerValue(SEL))
+            return true;
+        }
+
+        assert(!isPointerValue(I) &&
+               "Instruction cannot be a of pointer type here!");
+
+        return false;
+    }
+
+    llvm::Type const* getPointedType(llvm::Value const* const V)
+    {
+        const Type *t = getPointedType(V->getType());
+        if (hasExtraReference(V))
+            t = getPointedType(t);
+        return t;
+    }
+
+    Type *getPointedType(Type *T) {
+      return dyn_cast<PointerType>(T)->getElementType();
+    }
+
+    const Type *getPointedType(const Type *T) {
+      return dyn_cast<PointerType>(T)->getElementType();
+    }
+
+    bool isGlobalPointerInitialization(llvm::GlobalVariable const* const G)
+    {
+        if (G->isDeclaration())
+            return false;
+        llvm::Value const* const op = G->getOperand(0);
+        return op->getType()->isPointerTy() && (
+                    hasExtraReference(op) ||
+                    llvm::dyn_cast<llvm::PointerType const>(op->getType())
+                            ->getElementType()->isFunctionTy()
+                    );
+    }
+
+    const FunctionType *getCalleePrototype(const CallInst *C) {
+	assert(!isInlineAssembly(C) && "Inline assembly is not supported!");
+
+	const Value *callie = C->getCalledValue();
+
+        if (const Function *fn = dyn_cast<Function>(callie))
+            return fn->getFunctionType();
+        else if (const PointerType *ptrType =
+		dyn_cast<PointerType>(callie->getType()))
+            return dyn_cast<FunctionType>(ptrType->getElementType());
+
+	assert(0 && "Invalid callie type");
+    }
+
+    bool isMemoryAllocation(llvm::Value const* const V)
+    {
+        if (llvm::Function const* const F =
+                llvm::dyn_cast<llvm::Function const>(V))
+            return F->isDeclaration() && F->hasName() &&
+                   F->getName().equals("malloc");
+        return false;
+    }
+
+    bool isMemoryDeallocation(llvm::Value const* const V)
+    {
+        if (llvm::Function const* const F =
+                llvm::dyn_cast<llvm::Function const>(V))
+            return F->isDeclaration() && F->hasName() &&
+                   F->getName().equals("free");
+        return false;
+    }
+
+    bool isMemoryCopy(llvm::Value const* const V)
+    {
+        if (llvm::Function const* const F =
+                llvm::dyn_cast<llvm::Function const>(V))
+                return F->getIntrinsicID() == llvm::Intrinsic::memcpy;
+        return false;
+    }
+
+    bool isMemoryMove(llvm::Value const* const V)
+    {
+        if (llvm::Function const* const F =
+                llvm::dyn_cast<llvm::Function const>(V))
+                return F->getIntrinsicID() == llvm::Intrinsic::memmove;
+        return false;
+    }
+
+    bool isMemorySet(llvm::Value const* const V)
+    {
+        if (llvm::Function const* const F =
+                llvm::dyn_cast<llvm::Function const>(V))
+                return F->getIntrinsicID() == llvm::Intrinsic::memset;
+        return false;
+    }
+
+    bool memoryManStuff(llvm::Value const* const V)
+    {
+        return isMemoryAllocation(V) || isMemoryDeallocation(V) ||
+               isMemoryCopy(V) || isMemoryMove(V) || isMemorySet(V);
+    }
+
+    bool isInlineAssembly(const Value *V) {
+	if (const CallInst *c = dyn_cast<const CallInst>(V))
+	    return c->isInlineAsm();
+	return false;
+    }
+
+    bool isInlineAssemblyWithSideEffect(const Value *V) {
+	if (const CallInst *c = dyn_cast<const CallInst>(V))
+	    if (const InlineAsm *a = dyn_cast<const InlineAsm>(c->getCalledValue()))
+		return a->hasSideEffects();
+	return false;
+    }
+
+    bool callToMemoryManStuff(llvm::CallInst const* const C)
+    {
+        return memoryManStuff(C->getCalledValue());
+    }
+
+    llvm::Instruction const* getFunctionEntry(llvm::Function const* const F)
+    {
+        return &F->getEntryBlock().front();
+    }
+
+    bool isLocalToFunction(llvm::Value const* const V,
+                           llvm::Function const* const F)
+    {
+        if (llvm::Instruction const* I =
+                llvm::dyn_cast<llvm::Instruction const>(V))
+            return I->getParent()->getParent() == F;
+        return false;
+    }
+
+    bool callToVoidFunction(llvm::CallInst const* const C)
+    {
+      if (isInlineAssembly(C))
+        return false;
+      return C->getType()->getTypeID() == llvm::Type::VoidTyID;
+    }
+
+    llvm::Instruction const* getSuccInBlock(llvm::Instruction const* const I)
+    {
+        llvm::BasicBlock::const_iterator it(I);
+        return ++it == I->getParent()->end() ? 0 : &*it;
+    }
+
+    const Value *elimConstExpr(const Value *V) {
+      if (const ConstantExpr *CE = dyn_cast<ConstantExpr>(V)) {
+        if (Instruction::isBinaryOp(CE->getOpcode()))
+          return V;
+        assert((CE->getOpcode() == llvm::Instruction::GetElementPtr ||
+                CE->isCast()) &&
+          "Only GEP or CAST const expressions are supported for now.");
+        return elimConstExpr(CE->getOperand(0));
+      }
+      return V;
+    }
+}
diff --git a/lib/LLVMSlicer/Languages/LLVM.h b/lib/LLVMSlicer/Languages/LLVM.h
new file mode 100644
index 0000000..04d9529
--- /dev/null
+++ b/lib/LLVMSlicer/Languages/LLVM.h
@@ -0,0 +1,72 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef LANGUAGES_LLVM_H
+#define LANGUAGES_LLVM_H
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/BasicBlock.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/Value.h>
+#include <llvm/IR/GlobalValue.h>
+#include <llvm/IR/Type.h>
+#include <llvm/IR/DerivedTypes.h>
+#include <llvm/IR/Intrinsics.h>
+#include <llvm/ADT/SetVector.h>
+#include <llvm/IR/InstIterator.h>
+#include <llvm/Support/raw_os_ostream.h>
+
+namespace llvm {
+
+    bool hasExtraReference(llvm::Value const* const V);
+    bool isConstantValue(llvm::Value const* const V);
+    bool isPointerValue(llvm::Value const* const V);
+    bool isPointerToPointerValue(llvm::Value const* const V);
+    bool isPointerManipulation(llvm::Instruction const* const I);
+    llvm::Type const* getPointedType(llvm::Value const* const V);
+    llvm::Type *getPointedType(llvm::Type *T);
+    const llvm::Type *getPointedType(const llvm::Type *T);
+    bool isGlobalPointerInitialization(llvm::GlobalVariable const* const G);
+    llvm::FunctionType const* getCalleePrototype(llvm::CallInst const* const C);
+    bool isMemoryAllocation(llvm::Value const* const V);
+    bool isMemoryDeallocation(llvm::Value const* const V);
+    bool isMemoryCopy(llvm::Value const* const V);
+    bool isMemoryMove(llvm::Value const* const V);
+    bool isMemorySet(llvm::Value const* const V);
+    bool memoryManStuff(llvm::Value const* const V);
+    bool isInlineAssembly(const llvm::Value *V);
+    bool isInlineAssemblyWithSideEffect(const llvm::Value *V);
+    bool callToMemoryManStuff(llvm::CallInst const* const C);
+    llvm::Instruction const *getFunctionEntry(const llvm::Function *F);
+    bool isLocalToFunction(llvm::Value const* const V,
+                           llvm::Function const* const F);
+    bool callToVoidFunction(llvm::CallInst const* const C);
+    llvm::Instruction const* getSuccInBlock(llvm::Instruction const* const);
+    const llvm::Value *elimConstExpr(const llvm::Value *V);
+
+    template<typename OutIterator>
+    void getFunctionCalls(const llvm::Function *F, OutIterator out)
+    {
+        for (llvm::const_inst_iterator i = llvm::inst_begin(F);
+                i != llvm::inst_end(F); i++)
+            if (const llvm::CallInst *c =
+                    llvm::dyn_cast<llvm::CallInst>(&*i))
+		if (!isInlineAssembly(c))
+		    *out++ = c;
+    }
+
+    template<typename OutIterator>
+    void getFunctionExits(const llvm::Function *F, OutIterator out)
+    {
+        for (llvm::const_inst_iterator i = llvm::inst_begin(F);
+                i != llvm::inst_end(F); i++)
+            if (const llvm::ReturnInst *r =
+                    llvm::dyn_cast<llvm::ReturnInst>(&*i))
+                *out++ = r;
+    }
+
+}
+
+#endif
diff --git a/lib/LLVMSlicer/Languages/LLVMSupport.h b/lib/LLVMSlicer/Languages/LLVMSupport.h
new file mode 100644
index 0000000..0411e46
--- /dev/null
+++ b/lib/LLVMSlicer/Languages/LLVMSupport.h
@@ -0,0 +1,40 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef LANGUAGES_LLVMSUPPORT_H
+#define LANGUAGES_LLVMSUPPORT_H
+
+#include <llvm/IR/Function.h>
+#include <llvm/IR/Instructions.h>
+
+#include "../PointsTo/PointsTo.h"
+
+namespace llvm {
+
+  template<typename OutIterator>
+  void getCalledFunctions(const CallInst *CI, const ptr::PointsToSets &PS,
+		  OutIterator out) {
+    const Value *stripped = CI->getCalledValue()->stripPointerCasts();
+
+    if (const Function *F = dyn_cast<Function>(stripped)) {
+      *out++ = F;
+        SimpleCallGraph &SG = ptr::getSimpleCallGraph();
+        SimpleCallGraph::FunctionSet_t Called = SG.getCalled(CI);
+        for (SimpleCallGraph::FunctionSet_t::iterator Called_it = Called.begin(); Called_it != Called.end(); ++ Called_it) {
+            Function *Called_F = CI->getParent()->getParent()->getParent()->getFunction(*Called_it);
+            if (Called_F && Called_F != F) {
+                *out++ = Called_F;
+            }
+        }
+    } else {
+      typedef ptr::PointsToSets::PointsToSet PTSet;
+      const PTSet &S = getPointsToSet(stripped, PS);
+      for (PTSet::const_iterator I = S.begin(), E = S.end(); I != E; ++I)
+        if (const Function *F = dyn_cast<Function>(I->first))
+	  *out++ = F;
+    }
+  }
+
+}
+
+#endif
diff --git a/lib/LLVMSlicer/ModStats.cpp b/lib/LLVMSlicer/ModStats.cpp
new file mode 100644
index 0000000..f42edfc
--- /dev/null
+++ b/lib/LLVMSlicer/ModStats.cpp
@@ -0,0 +1,352 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#include "llvm/IR/Instructions.h"
+#include "llvm/Pass.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include "Callgraph/Callgraph.h"
+#include "PointsTo/PointsTo.h"
+#include "Slicing/Prepare.h"
+
+using namespace llvm;
+
+namespace {
+  class ModStats : public ModulePass {
+  public:
+    static char ID;
+
+    ModStats() : ModulePass(ID) { }
+
+    virtual bool runOnModule(Module &M);
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();
+      AU.addRequired<LoopInfoWrapperPass>();
+    }
+  };
+}
+
+class FunInfo {
+public:
+  FunInfo(const Function &F) : F(F), ins(0), _hasAsm(false), _hasCall(false),
+          _hasExternalCall(false), _hasLock(false), _hasLoop(false),
+          _hasNestedAsm(false), _hasNestedExtCall(false), _hasNestedLock(false),
+          _hasNestedLoop(false) {}
+
+  const Function &getFun() const { return F; }
+
+  void inline incIns() { ins++; }
+  void inline setHasAsm() { _hasAsm = true; }
+  void inline setHasCall() { _hasCall = true; }
+  void inline setHasExternalCall() { _hasExternalCall = true; }
+  void inline setHasLock() { _hasLock = true; }
+  void inline setHasLoop() { _hasLoop = true; }
+  void inline setHasNestedAsm() { _hasNestedAsm = true; }
+  void inline setHasNestedExtCall() { _hasNestedExtCall = true; }
+  void inline setHasNestedLock() { _hasNestedLock = true; }
+  void inline setHasNestedLoop() { _hasNestedLoop = true; }
+
+  unsigned getIns() const { return ins; }
+  bool hasAsm() const { return _hasAsm; }
+  bool hasCall() const { return _hasCall; }
+  bool hasExternalCall() const { return _hasExternalCall; }
+  bool hasLock() const { return _hasLock; }
+  bool hasLoop() const { return _hasLoop; }
+  bool hasNestedAsm() const { return _hasAsm || _hasNestedAsm; }
+  bool hasNestedExtCall() const { return _hasExternalCall || _hasNestedExtCall; }
+  bool hasNestedLock() const { return _hasLock || _hasNestedLock; }
+  bool hasNestedLoop() const { return _hasLoop || _hasNestedLoop; }
+
+private:
+  const Function &F;
+
+  unsigned ins;
+  bool _hasAsm;
+  bool _hasCall;
+  bool _hasExternalCall;
+  bool _hasLock;
+  bool _hasLoop;
+  bool _hasNestedAsm;
+  bool _hasNestedExtCall;
+  bool _hasNestedLock;
+  bool _hasNestedLoop;
+};
+
+class ModInfo {
+public:
+  typedef std::map<const Function *, FunInfo *> FunMap;
+
+  ModInfo(const Module &M) : M(M), ins(0), fun(0), funWithAsm(0),
+          funWithCall(0), funWithExtCall(0), funWithLock(0), funWithLoop(0),
+          funWithNestedAsm(0), funWithNestedExtCall(0), funWithNestedLock(0),
+          funWithNestedLoop(0), funSafe(0), funSafeWOLoop(0) {}
+
+  void inline addIns(unsigned ins) { this->ins += ins; }
+  void inline incFun() { fun++; }
+  void inline incFunWithAsm() { funWithAsm++; }
+  void inline incFunWithCall() { funWithCall++; }
+  void inline incFunWithExtCall() { funWithExtCall++; }
+  void inline incFunWithLock() { funWithLock++; }
+  void inline incFunWithLoop() { funWithLoop++; }
+  void inline incFunWithNestedAsm() { funWithNestedAsm++; }
+  void inline incFunWithNestedExtCall() { funWithNestedExtCall++; }
+  void inline incFunWithNestedLock() { funWithNestedLock++; }
+  void inline incFunWithNestedLoop() { funWithNestedLoop++; }
+  void inline incFunSafe() { funSafe++; }
+  void inline incFunSafeWOLoop() { funSafeWOLoop++; }
+
+  void addFunInfo(FunInfo *funInfo) {
+    funMap.insert(FunMap::value_type(&funInfo->getFun(), funInfo));
+  }
+  FunInfo *getFunInfo(const Function *fun) { return funMap[fun]; }
+
+  void dump() const;
+
+private:
+  const Module &M;
+
+  unsigned ins;
+  unsigned fun;
+  unsigned funWithAsm;
+  unsigned funWithCall;
+  unsigned funWithExtCall;
+  unsigned funWithLock;
+  unsigned funWithLoop;
+  unsigned funWithNestedAsm;
+  unsigned funWithNestedExtCall;
+  unsigned funWithNestedLock;
+  unsigned funWithNestedLoop;
+  unsigned funSafe;
+  unsigned funSafeWOLoop;
+  FunMap funMap;
+};
+
+class StatsComputer {
+public:
+  StatsComputer(ModulePass &modPass, Module &M) : modPass(modPass), M(M) {}
+
+  void run();
+
+private:
+  ModulePass &modPass;
+  Module &M;
+
+  void handleFun(ModInfo &modInfo, const Function &F, const LoopInfo &LI);
+  void handleBB(FunInfo &funInfo, const LoopInfo &LI, const BasicBlock &BB);
+  void handleIns(FunInfo &funInfo, const Instruction &ins);
+};
+
+static RegisterPass<ModStats> X("modstats", "Prints out some stats about module");
+char ModStats::ID;
+
+void ModInfo::dump() const {
+  errs() << "Module " << M.getModuleIdentifier() << " dump\n";
+  errs() << "  machine code: " << M.getModuleIdentifier() << " " << ins <<
+    " " << fun << " " <<
+    funWithAsm << " " << funWithNestedAsm << " " <<
+    funWithExtCall << " " << funWithNestedExtCall << " " <<
+    funWithLock << " " << funWithNestedLock << " " <<
+    funWithLoop << " " << funWithNestedLoop << " " <<
+    funSafe << " " << funSafeWOLoop << "\n";
+  errs() << "  instructions: " << ins << "\n";
+  errs() << "  functions: " << fun << "\n";
+  errs() << "    with asm: " << funWithAsm << "\n";
+  errs() << "      incl nested: " << funWithNestedAsm << "\n";
+  errs() << "    with ext call: " << funWithExtCall << "\n";
+  errs() << "      incl nested: " << funWithNestedExtCall << "\n";
+  errs() << "    with lock: " << funWithLock << "\n";
+  errs() << "      incl nested: " << funWithNestedLock << "\n";
+  errs() << "    with loop: " << funWithLoop << "\n";
+  errs() << "      incl nested: " << funWithNestedLoop << "\n";
+  errs() << "    safe: " << funSafe << "\n";
+  errs() << "    safe w/o loop: " << funSafeWOLoop << "\n";
+}
+
+static bool isLockingFun(StringRef name) {
+  return name.startswith("_spin_lock") || name.startswith("_spin_unlock") ||
+    name.startswith("_spin_trylock") ||
+    name.startswith("_read_lock") || name.startswith("_read_unlock") ||
+    name.startswith("_read_trylock") ||
+    name.startswith("_write_lock") || name.startswith("_write_unlock") ||
+    name.startswith("_write_trylock") ||
+    name.equals("mutex_lock") || name.equals("mutex_unlock") ||
+    name.equals("mutex_lock_interruptible") || name.equals("mutex_trylock");
+}
+
+void StatsComputer::handleIns(FunInfo &funInfo, const Instruction &ins) {
+  if (const CallInst *CI = dyn_cast<const CallInst>(&ins)) {
+    if (CI->isInlineAsm()) {
+#ifdef DEBUG_ASM
+      errs() << "ASM: in " << ins.getParent()->getParent()->getName() << " ";
+      CI->print(errs());
+      CI->getParent()->print(errs());
+      errs() << "\n";
+#endif
+      funInfo.setHasAsm();
+    } else {
+      Function *called = CI->getCalledFunction();
+      if (called) {
+        StringRef calledName = called->getName();
+        if (calledName.startswith("llvm.") ||
+            calledName.equals("__assert_fail") ||
+            calledName.equals("__kmalloc") || calledName.equals("kfree") ||
+            isLockingFun(calledName))
+          return;
+        if (called->isDeclaration()) {
+#ifdef DEBUG_EXT
+          errs() << "EXT1 " << ins.getParent()->getParent()->getName() <<
+            " to " << called->getName() << "\n";
+#endif
+          funInfo.setHasExternalCall();
+        }
+      } else {
+#ifdef DEBUG_EXT
+        errs() << "EXT2 " << ins.getParent()->getParent()->getName() << " to ";
+        ins.print(errs());
+        errs() << '\n';
+#endif
+        funInfo.setHasExternalCall();
+      }
+      funInfo.setHasCall();
+    }
+  } else if (const StoreInst *SI = dyn_cast<const StoreInst>(&ins)) {
+    const Value *LHS = SI->getPointerOperand();
+    if (LHS->hasName() && LHS->getName().startswith("__ai_state"))
+      funInfo.setHasLock();
+  }
+}
+
+void StatsComputer::handleBB(FunInfo &funInfo, const LoopInfo &LI,
+                             const BasicBlock &BB) {
+  for (BasicBlock::const_iterator I = BB.begin(), E = BB.end(); I != E; ++I) {
+    funInfo.incIns();
+    if (LI.getLoopFor(&BB))
+      funInfo.setHasLoop();
+    handleIns(funInfo, *I);
+  }
+}
+
+void StatsComputer::handleFun(ModInfo &modInfo, const Function &F,
+                              const LoopInfo &LI) {
+  FunInfo *funInfo = new FunInfo(F);
+  modInfo.addFunInfo(funInfo);
+
+  for (Function::const_iterator I = F.begin(), E = F.end(); I != E; ++I)
+    handleBB(*funInfo, LI, *I);
+}
+
+static std::string __attribute__((unused))
+getFlags(const FunInfo *funInfo, bool nested = false) {
+  std::string flags;
+  if (funInfo->hasAsm() || (nested && funInfo->hasNestedAsm()))
+    flags += "A";
+  if (funInfo->hasExternalCall() || (nested && funInfo->hasNestedExtCall()))
+    flags += "E";
+  if (funInfo->hasLock() || (nested && funInfo->hasNestedLock()))
+    flags += "L";
+  if (funInfo->hasLoop() || (nested && funInfo->hasNestedLoop()))
+    flags += "O";
+  return flags;
+}
+
+void StatsComputer::run() {
+  ptr::PointsToSets PS;
+  {
+    ptr::ProgramStructure P(M);
+    computePointsToSets(P, PS);
+  }
+
+  callgraph::Callgraph CG(M, PS);
+  ModInfo modInfo(M);
+
+#ifdef DEBUG_DUMP_CALLREL
+  for (callgraph::Callgraph::const_iterator I = CG.begin_closure(),
+		  E = CG.end_closure(); I != E; ++I) {
+	  const Function *from = I->first;
+	  const Function *to = I->second;
+	  errs() << "CALLREL " << from->getName() << " => " << to->getName() << "\n";
+  }
+#endif
+
+  for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I) {
+    Function &F = *I;
+    if (F.isDeclaration())
+      continue;
+    handleFun(modInfo, F, modPass.getAnalysis<LoopInfoWrapperPass>(F).getLoopInfo());
+  }
+
+  const ConstantArray *initFuns = getInitFuns(M);
+  assert(initFuns && "No initial functions found. Did you run -prepare?");
+
+  for (ConstantArray::const_op_iterator I = initFuns->op_begin(),
+       E = initFuns->op_end(); I != E; ++I) {
+    const ConstantExpr *CE = cast<ConstantExpr>(&*I);
+    assert(CE->getOpcode() == Instruction::BitCast);
+    const Function &F = *cast<Function>(CE->getOperand(0));
+    FunInfo *funInfo = modInfo.getFunInfo(&F);
+    callgraph::Callgraph::const_iterator II, EE;
+    std::tie(II, EE) = CG.calls(&F);
+#ifdef DEBUG_NESTED
+    errs() << "at " << F.getName() << " flags [" << getFlags(funInfo) << "]\n";
+#endif
+    for (; II != EE; ++II) {
+      const Function *called = II->second;
+      const FunInfo *calledFunInfo = modInfo.getFunInfo(called);
+#ifdef DEBUG_NESTED
+      errs() << "  " << called->getName() << " [" << getFlags(calledFunInfo) <<
+          "]\n";
+#endif
+      if (calledFunInfo->hasAsm())
+        funInfo->setHasNestedAsm();
+      if (calledFunInfo->hasExternalCall())
+        funInfo->setHasNestedExtCall();
+      if (calledFunInfo->hasLock())
+        funInfo->setHasNestedLock();
+      if (calledFunInfo->hasLoop())
+        funInfo->setHasNestedLoop();
+    }
+#ifdef DEBUG_NESTED
+    errs() << "RET flags [" << getFlags(funInfo, true) << "]\n";
+#endif
+
+    if (funInfo->hasNestedLock()) {
+      modInfo.incFun();
+      modInfo.addIns(funInfo->getIns());
+      if (funInfo->hasAsm())
+        modInfo.incFunWithAsm();
+      if (funInfo->hasCall())
+        modInfo.incFunWithCall();
+      if (funInfo->hasExternalCall())
+        modInfo.incFunWithExtCall();
+      if (funInfo->hasLock())
+        modInfo.incFunWithLock();
+      if (funInfo->hasLoop())
+        modInfo.incFunWithLoop();
+      if (funInfo->hasNestedAsm())
+        modInfo.incFunWithNestedAsm();
+      if (funInfo->hasNestedExtCall())
+        modInfo.incFunWithNestedExtCall();
+      if (funInfo->hasNestedLock())
+        modInfo.incFunWithNestedLock();
+      if (funInfo->hasNestedLoop())
+        modInfo.incFunWithNestedLoop();
+      if (!funInfo->hasNestedExtCall() && !funInfo->hasNestedAsm()) {
+        modInfo.incFunSafe();
+        if (!funInfo->hasNestedLoop())
+          modInfo.incFunSafeWOLoop();
+      }
+    }
+  }
+
+  modInfo.dump();
+}
+
+bool ModStats::runOnModule(Module &M) {
+  StatsComputer sc(*this, M);
+  sc.run();
+	return false;
+}
diff --git a/lib/LLVMSlicer/Modifies/ExternalHandler.gen b/lib/LLVMSlicer/Modifies/ExternalHandler.gen
new file mode 100644
index 0000000..c0adf1b
--- /dev/null
+++ b/lib/LLVMSlicer/Modifies/ExternalHandler.gen
@@ -0,0 +1,3570 @@
+#ifndef LLVM_EXTERNALMODHANDLER_H
+#define LLVM_EXTERNALMODHANDLER_H
+
+#include "llvm/Analysis/Andersen/DetectParametersPass.h"
+
+namespace llvm {
+
+namespace {
+int translateRegister(std::string RegName) {
+  if (RegName == "X0") 
+    return 5;
+  if (RegName == "X1") 
+    return 6;
+  if (RegName == "X2") 
+    return 7;
+  if (RegName == "X3") 
+    return 8;
+  if (RegName == "X4") 
+    return 9;
+  if (RegName == "X5") 
+    return 10;
+  if (RegName == "X6") 
+    return 11;
+  if (RegName == "X7") 
+    return 12;
+  llvm_unreachable("Unknown Register");
+}
+}
+void anonymous_1005(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "malloc"
+}
+
+void anonymous_1008(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSFileHandle fileHandleForReadingAtPath:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1019(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSFileHandle readDataOfLength:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1030(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[UITextField text]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1036(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[UITextView text]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1042(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[UILabel text]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1048(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString stringByTrimmingCharactersInSet:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1057(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString stringByAppendingString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_106(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSData dataWithContentsOfURL:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1069(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString componentsSeparatedByString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1081(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[UIView initWithFrame:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1088(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[UIViewController initWithNibName:bundle:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1095(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSNull null]"
+}
+
+void anonymous_1098(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[UIApplication sharedApplication]"
+}
+
+void anonymous_1101(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSUserDefaults objectForKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1108(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSUserDefaults setObject:forKey:]"
+}
+
+void anonymous_1115(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSKeyedArchiver archivedDataWithRootObject:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1121(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[UIAlertView textFieldAtIndex:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_1127(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSDictionary objectForKey:]"
+}
+
+void anonymous_1131(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSDictionary setObject:forKey:]"
+}
+
+void anonymous_1138(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSDictionary valueForKey:]"
+}
+
+void anonymous_1142(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSDictionary setValue:forKey:]"
+}
+
+void anonymous_119(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSData dataWithData:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_132(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData mutableCopy]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_145(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData isEqual:]"
+}
+
+void anonymous_148(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData writeToFile:options:error:]"
+}
+
+void anonymous_149(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData dataWithBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_162(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData data]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_17(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_autoreleaseReturnValue"
+}
+
+void anonymous_170(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData dataWithBytesNoCopy:length:freeWhenDone:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_18(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_autorelease"
+}
+
+void anonymous_183(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData dataWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_19(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_retainAutoreleasedReturnValue"
+}
+
+void anonymous_196(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData dataWithContentsOfFile:options:error:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_20(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_retainAutoreleaseReturnValue"
+}
+
+void anonymous_209(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData dataWithContentsOfURL:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_21(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_retainAutorelease"
+}
+
+void anonymous_22(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSObject retain]"
+}
+
+void anonymous_222(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData dataWithData:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_23(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSObject autorelease]"
+}
+
+void anonymous_235(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData dataWithCapacity:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_24(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_release"
+}
+
+void anonymous_243(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableData dataWithLength:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_25(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSObject release]"
+}
+
+void anonymous_251(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSMutableData mutableBytes]"
+}
+
+void anonymous_26(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSObject dealloc]"
+}
+
+void anonymous_260(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString string]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_266(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString stringWithString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_27(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSObject respondsToSelector:]"
+}
+
+void anonymous_277(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString stringWithCString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_288(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString stringWithCharacters:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_299(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString initWithData:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_311(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString initWithString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_323(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString getCString:maxLength:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_33(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSData dataWithBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_332(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_341(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString cStringUsingEncoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_350(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString lowercaseString]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_361(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableString stringWithString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_372(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableString stringWithCharacters:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_383(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSDictionary dictionaryWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_389(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSDictionary dictionaryWithObject:forKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_398(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSDictionary dictionaryWithObjectsAndKeys:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_404(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSDictionary dictionary]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_410(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSDictionary dictionaryWithDictionary:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_416(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSDictionary dictionaryWithObjects:forKeys:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_422(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSDictionary dictionaryWithObjects:forKeys:count:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_428(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSDictionary initWithObjectsAndKeys:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_435(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSDictionary objectForKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_442(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSDictionary valueForKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_449(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableDictionary dictionaryWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_455(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableDictionary dictionaryWithObject:forKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_46(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSData dataWithBytesNoCopy:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_464(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableDictionary dictionaryWithObjectsAndKeys:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_470(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableDictionary dictionary]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_476(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableDictionary dictionaryWithDictionary:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_482(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSJSONSerialization dataWithJSONObject:options:error:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_488(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData bytes]"
+}
+
+void anonymous_500(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData getBytes:range:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_517(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData getBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_537(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData subdataWithRange:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_550(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSMutableData setLength:]"
+}
+
+void anonymous_553(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSMutableData appendData:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_565(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSMutableData appendBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_577(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData length]"
+}
+
+void anonymous_580(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString dataUsingEncoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_59(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSData data]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_593(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "memcpy"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_604(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CCKeyDerivationPBKDF"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X7"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_621(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CCCalibratePBKDF"
+}
+
+void anonymous_626(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CCCryptorCreate"
+}
+
+void anonymous_627(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CCCryptorCreateWithMode"
+}
+
+void anonymous_631(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CCCrypt"
+}
+
+void anonymous_632(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CCCryptorUpdate"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_645(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_setProperty_nonatomic_copy"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_654(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_getProperty"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_668(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_setProperty_nonatomic"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_FRC_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_67(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSData dataWithBytesNoCopy:length:freeWhenDone:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_680(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_setProperty_atomic"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_FRC_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_692(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_setProperty"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_FRC_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_704(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_loadWeakRetained"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_718(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString UTF8String]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_731(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSArray arrayWithArray:]"
+}
+
+void anonymous_734(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSArray arrayWithObject:]"
+}
+
+void anonymous_735(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSArray arrayWithObjects:]"
+}
+
+void anonymous_736(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSArray array]"
+}
+
+void anonymous_737(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSArray objectAtIndex:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_747(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSArray objectAtIndexedSubscript:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_757(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableString stringWithCapacity:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_763(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableString stringWithUTF8String:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_764(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSMutableString string]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_765(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString stringWithCString:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_771(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString stringWithContentsOfFile:encoding:error:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_772(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString stringWithFormat:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_773(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString stringWithUTF8String:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_774(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSString stringWithCString:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_781(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSObject init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_788(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSMutableData init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_789(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData initWithBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_790(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData initWithBase64EncodedData:options:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_791(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData initWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_792(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData initWithData:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_793(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_794(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData initWithBase64EncodedString:options:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_795(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString initWithBytes:length:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_796(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString initWithData:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_797(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString initWithFormat:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_798(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSMutableDictionary init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_799(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSDictionary init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_8(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_retain"
+}
+
+void anonymous_80(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSData dataWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_800(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[UITableViewController init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_801(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData initWithBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_810(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData initWithBase64EncodedString:options:]"
+}
+
+void anonymous_816(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString copy]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_825(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSMutableString copy]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_834(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSData copy]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_843(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CC_SHA256_Init"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_847(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CC_SHA256_Update"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_857(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CC_SHA256_Final"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_864(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "arc4random"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_870(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "SecRandomCopyBytes"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_878(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_storeStrong"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_FRC_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_888(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_storeWeak"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_FRC_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_898(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_getClass"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_907(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "bzero"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_915(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSBundle bundleWithPath:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_923(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSBundle bundleForClass:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_924(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSBundle mainBundle]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_925(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "NSLog"
+}
+
+void anonymous_926(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "__stack_chk_fail"
+}
+
+void anonymous_927(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_enumerationMutation"
+}
+
+void anonymous_928(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_terminate"
+}
+
+void anonymous_929(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_sync_exit"
+}
+
+void anonymous_93(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSData dataWithContentsOfFile:options:error:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_930(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_sync_enter"
+}
+
+void anonymous_931(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_exception_rethrow"
+}
+
+void anonymous_932(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_exception_throw"
+}
+
+void anonymous_933(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_destroyWeak"
+}
+
+void anonymous_934(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_end_catch"
+}
+
+void anonymous_935(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "objc_begin_catch"
+}
+
+void anonymous_936(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "_Znam"
+}
+
+void anonymous_941(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "_Znwm"
+}
+
+void anonymous_946(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "_ZnwmRKSt9nothrow_t"
+}
+
+void anonymous_951(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CC_MD5"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_958(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "CC_SHA256"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_965(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "read"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_971(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "open"
+}
+
+void anonymous_977(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "+[NSNumber numberWithInt:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst);
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    lock.lock();
+    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));
+    lock.unlock();
+  }
+} //End Def
+}
+
+void anonymous_987(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSNumber integerValue]"
+}
+
+void anonymous_993(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString intValue]"
+}
+
+void anonymous_999(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+//Handle "-[NSString integerValue]"
+}
+
+bool handleCall(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, const std::string &FName, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {
+  if (FName == "+[NSArray arrayWithArray:]") {
+    anonymous_731(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSArray arrayWithObject:]") {
+    anonymous_734(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSArray arrayWithObjects:]") {
+    anonymous_735(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSArray array]") {
+    anonymous_736(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSBundle bundleForClass:]") {
+    anonymous_923(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSBundle bundleWithPath:]") {
+    anonymous_915(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSBundle mainBundle]") {
+    anonymous_924(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytes:length:]") {
+    anonymous_33(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytesNoCopy:length:]") {
+    anonymous_46(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytesNoCopy:length:freeWhenDone:]") {
+    anonymous_67(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfFile:]") {
+    anonymous_80(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfFile:options:error:]") {
+    anonymous_93(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfURL:]") {
+    anonymous_106(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSData dataWithData:]") {
+    anonymous_119(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSData data]") {
+    anonymous_59(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithContentsOfFile:]") {
+    anonymous_383(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithDictionary:]") {
+    anonymous_410(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObject:forKey:]") {
+    anonymous_389(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjects:forKeys:]") {
+    anonymous_416(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjects:forKeys:count:]") {
+    anonymous_422(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjectsAndKeys:]") {
+    anonymous_398(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionary]") {
+    anonymous_404(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSFileHandle fileHandleForReadingAtPath:]") {
+    anonymous_1008(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSJSONSerialization dataWithJSONObject:options:error:]") {
+    anonymous_482(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSKeyedArchiver archivedDataWithRootObject:]") {
+    anonymous_1115(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithBytes:length:]") {
+    anonymous_149(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithBytesNoCopy:length:freeWhenDone:]") {
+    anonymous_170(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithCapacity:]") {
+    anonymous_235(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfFile:]") {
+    anonymous_183(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfFile:options:error:]") {
+    anonymous_196(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfURL:]") {
+    anonymous_209(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithData:]") {
+    anonymous_222(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithLength:]") {
+    anonymous_243(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableData data]") {
+    anonymous_162(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithContentsOfFile:]") {
+    anonymous_449(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithDictionary:]") {
+    anonymous_476(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithObject:forKey:]") {
+    anonymous_455(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithObjectsAndKeys:]") {
+    anonymous_464(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionary]") {
+    anonymous_470(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithCapacity:]") {
+    anonymous_757(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithCharacters:length:]") {
+    anonymous_372(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithString:]") {
+    anonymous_361(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithUTF8String:]") {
+    anonymous_763(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSMutableString string]") {
+    anonymous_764(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSNull null]") {
+    anonymous_1095(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSNumber numberWithInt:]") {
+    anonymous_977(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCString:]") {
+    anonymous_277(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCString:encoding:]") {
+    anonymous_765(CallInst, PS, commands, lock);
+    anonymous_774(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCharacters:length:]") {
+    anonymous_288(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSString stringWithContentsOfFile:encoding:error:]") {
+    anonymous_771(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSString stringWithFormat:]") {
+    anonymous_772(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSString stringWithString:]") {
+    anonymous_266(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSString stringWithUTF8String:]") {
+    anonymous_773(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[NSString string]") {
+    anonymous_260(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "+[UIApplication sharedApplication]") {
+    anonymous_1098(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSArray objectAtIndex:]") {
+    anonymous_737(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSArray objectAtIndexedSubscript:]") {
+    anonymous_747(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData bytes]") {
+    anonymous_488(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData copy]") {
+    anonymous_834(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData getBytes:length:]") {
+    anonymous_517(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData getBytes:range:]") {
+    anonymous_500(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData initWithBase64EncodedData:options:]") {
+    anonymous_790(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData initWithBase64EncodedString:options:]") {
+    anonymous_794(CallInst, PS, commands, lock);
+    anonymous_810(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData initWithBytes:length:]") {
+    anonymous_789(CallInst, PS, commands, lock);
+    anonymous_801(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData initWithContentsOfFile:]") {
+    anonymous_791(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData initWithData:]") {
+    anonymous_792(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData init]") {
+    anonymous_793(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData isEqual:]") {
+    anonymous_145(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData length]") {
+    anonymous_577(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData mutableCopy]") {
+    anonymous_132(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData subdataWithRange:]") {
+    anonymous_537(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSData writeToFile:options:error:]") {
+    anonymous_148(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSDictionary initWithObjectsAndKeys:]") {
+    anonymous_428(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSDictionary init]") {
+    anonymous_799(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSDictionary objectForKey:]") {
+    anonymous_1127(CallInst, PS, commands, lock);
+    anonymous_435(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSDictionary setObject:forKey:]") {
+    anonymous_1131(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSDictionary setValue:forKey:]") {
+    anonymous_1142(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSDictionary valueForKey:]") {
+    anonymous_1138(CallInst, PS, commands, lock);
+    anonymous_442(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSFileHandle readDataOfLength:]") {
+    anonymous_1019(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSMutableData appendBytes:length:]") {
+    anonymous_565(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSMutableData appendData:]") {
+    anonymous_553(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSMutableData init]") {
+    anonymous_788(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSMutableData mutableBytes]") {
+    anonymous_251(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSMutableData setLength:]") {
+    anonymous_550(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSMutableDictionary init]") {
+    anonymous_798(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSMutableString copy]") {
+    anonymous_825(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSNumber integerValue]") {
+    anonymous_987(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSObject autorelease]") {
+    anonymous_23(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSObject dealloc]") {
+    anonymous_26(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSObject init]") {
+    anonymous_781(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSObject release]") {
+    anonymous_25(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSObject respondsToSelector:]") {
+    anonymous_27(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSObject retain]") {
+    anonymous_22(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString UTF8String]") {
+    anonymous_718(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString cStringUsingEncoding:]") {
+    anonymous_341(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString componentsSeparatedByString:]") {
+    anonymous_1069(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString copy]") {
+    anonymous_816(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString dataUsingEncoding:]") {
+    anonymous_580(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]") {
+    anonymous_332(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString getCString:maxLength:encoding:]") {
+    anonymous_323(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString initWithBytes:length:encoding:]") {
+    anonymous_795(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString initWithData:encoding:]") {
+    anonymous_299(CallInst, PS, commands, lock);
+    anonymous_796(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString initWithFormat:]") {
+    anonymous_797(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString initWithString:]") {
+    anonymous_311(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString intValue]") {
+    anonymous_993(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString integerValue]") {
+    anonymous_999(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString lowercaseString]") {
+    anonymous_350(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString stringByAppendingString:]") {
+    anonymous_1057(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSString stringByTrimmingCharactersInSet:]") {
+    anonymous_1048(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSUserDefaults objectForKey:]") {
+    anonymous_1101(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[NSUserDefaults setObject:forKey:]") {
+    anonymous_1108(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[UIAlertView textFieldAtIndex:]") {
+    anonymous_1121(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[UILabel text]") {
+    anonymous_1042(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[UITableViewController init]") {
+    anonymous_800(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[UITextField text]") {
+    anonymous_1030(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[UITextView text]") {
+    anonymous_1036(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[UIView initWithFrame:]") {
+    anonymous_1081(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "-[UIViewController initWithNibName:bundle:]") {
+    anonymous_1088(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CCCalibratePBKDF") {
+    anonymous_621(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CCCrypt") {
+    anonymous_631(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CCCryptorCreate") {
+    anonymous_626(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CCCryptorCreateWithMode") {
+    anonymous_627(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CCCryptorUpdate") {
+    anonymous_632(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CCKeyDerivationPBKDF") {
+    anonymous_604(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CC_MD5") {
+    anonymous_951(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CC_SHA256") {
+    anonymous_958(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CC_SHA256_Final") {
+    anonymous_857(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CC_SHA256_Init") {
+    anonymous_843(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "CC_SHA256_Update") {
+    anonymous_847(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "NSLog") {
+    anonymous_925(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "SecRandomCopyBytes") {
+    anonymous_870(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "_Znam") {
+    anonymous_936(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "_Znwm") {
+    anonymous_941(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "_ZnwmRKSt9nothrow_t") {
+    anonymous_946(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "__stack_chk_fail") {
+    anonymous_926(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "arc4random") {
+    anonymous_864(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "bzero") {
+    anonymous_907(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "malloc") {
+    anonymous_1005(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "memcpy") {
+    anonymous_593(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_autorelease") {
+    anonymous_18(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_autoreleaseReturnValue") {
+    anonymous_17(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_begin_catch") {
+    anonymous_935(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_destroyWeak") {
+    anonymous_933(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_end_catch") {
+    anonymous_934(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_enumerationMutation") {
+    anonymous_927(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_exception_rethrow") {
+    anonymous_931(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_exception_throw") {
+    anonymous_932(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_getClass") {
+    anonymous_898(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_getProperty") {
+    anonymous_654(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_loadWeakRetained") {
+    anonymous_704(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_release") {
+    anonymous_24(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_retain") {
+    anonymous_8(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_retainAutorelease") {
+    anonymous_21(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_retainAutoreleaseReturnValue") {
+    anonymous_20(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_retainAutoreleasedReturnValue") {
+    anonymous_19(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_setProperty") {
+    anonymous_692(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_setProperty_atomic") {
+    anonymous_680(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_setProperty_nonatomic") {
+    anonymous_668(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_setProperty_nonatomic_copy") {
+    anonymous_645(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_storeStrong") {
+    anonymous_878(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_storeWeak") {
+    anonymous_888(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_sync_enter") {
+    anonymous_930(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_sync_exit") {
+    anonymous_929(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "objc_terminate") {
+    anonymous_928(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "open") {
+    anonymous_971(CallInst, PS, commands, lock);
+    return true;
+  }
+  if (FName == "read") {
+    anonymous_965(CallInst, PS, commands, lock);
+    return true;
+  }
+  return false;
+}
+
+}
+#endif
diff --git a/lib/LLVMSlicer/Modifies/Modifies.cpp b/lib/LLVMSlicer/Modifies/Modifies.cpp
new file mode 100644
index 0000000..8c5e5be
--- /dev/null
+++ b/lib/LLVMSlicer/Modifies/Modifies.cpp
@@ -0,0 +1,418 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#include <algorithm>
+#include <iterator>
+#include <llvm/Analysis/Andersen/StackAccessPass.h>
+#include <llvm/IR/PatternMatch.h>
+
+#include "llvm/IR/Constant.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Module.h"
+
+#include "../Callgraph/Callgraph.h"
+#include "../PointsTo/PointsTo.h"
+#include "Modifies.h"
+#include "ExternalHandler.gen"
+
+using namespace llvm;
+
+namespace llvm {
+    std::set<std::pair<int64_t, const Value*>> getMemcpyDefs(const Instruction *call, const ptr::PointsToSets &PS) {
+        std::set<std::pair<int64_t, const Value*>> defs;
+
+
+        DetectParametersPass::UserSet_t X2_pre = DetectParametersPass::getRegisterValuesBeforeCall(7, call, false);
+        DetectParametersPass::UserSet_t X0_pre = DetectParametersPass::getRegisterValuesBeforeCall(5, call, false);
+
+        Andersen *andersen = ptr::getAndersen();
+
+        Andersen::StackOffsetMap_t stackOffsetMap = andersen->getStackOffsets();
+
+        for (auto &X2_it : X2_pre) {
+            if (const ConstantInt *size = dyn_cast<const ConstantInt>(X2_it)) {
+
+                for (auto &X0_it : X0_pre) {
+
+                    ptr::PointsToSets::PointsToSet X0_ptsTo = ptr::getPointsToSet(X0_it, PS);
+
+                    for (auto &X0pts_it : X0_ptsTo) {
+                        auto &pairs = stackOffsetMap[X0pts_it.first];
+
+                        for (auto &p_it : pairs) {
+
+                            int64_t lo = p_it.second;
+                            int64_t hi = p_it.second + size->getZExtValue();
+
+                            Function *f = (Function*) p_it.first;
+                            StackAccessPass::OffsetValueListMap_t &OffsetValues = andersen->getAnalysis<StackAccessPass>().getOffsetValues(f);
+                            for (auto &O_it : OffsetValues) {
+                                if (O_it.first <= lo || O_it.first >= hi)
+                                    continue;
+
+                                if (!O_it.second)
+                                    continue;
+                                for (auto &V_it: *O_it.second) {
+                                    ptr::PointsToSets::PointsToSet defPtsTo = ptr::getPointsToSet(V_it, PS);
+                                    for (auto &def_it : defPtsTo) {
+                                        int64_t offset = O_it.first - lo;
+
+                                        defs.insert(std::pair<int64_t, const Value*>(offset, def_it.first));
+                                    }
+                                }
+                            }
+
+                        }
+                    }
+                }
+            }
+        }
+
+        return defs;
+    };
+}
+
+namespace llvm { namespace mods {
+
+//  ProgramStructure::ProgramStructure(Module &M) {
+//    for (Module::iterator f = M.begin(); f != M.end(); ++f)
+//      if (!f->isDeclaration() && !memoryManStuff(&*f))
+//        for (inst_iterator i = inst_begin(*f); i != inst_end(*f); ++i)
+//          if (const StoreInst *s = dyn_cast<StoreInst>(&*i)) {
+////            const Value *l = elimConstExpr(s->getPointerOperand());
+////	    this->getContainer()[&*f].push_back(ProgramStructure::Command(
+////		  hasExtraReference(l) ? CMD_VAR : CMD_DREF_VAR, l));
+//              this->getContainer()[&*f].push_back(ProgramStructure::Command(CMD_DREF_VAR, s));
+//          }
+//  }
+
+        ProgramStructure::ProgramStructure(Module &M, const llvm::ptr::PointsToSets &PS) {
+            auto task = [&](Module::iterator &f, inst_iterator &i) {
+                SimpleCallGraph::FunctionSet_t &called = ptr::getAndersen()->getCallGraph().getCalled(&*i);
+                for (auto &functioNName : called) {
+                    handleCall(&*i, PS, *(std::string*)&functioNName, this->getContainer()[&*f], lockC);
+                }
+            };
+            for (Module::iterator f = M.begin(); f != M.end(); ++f) {
+
+                if (!f->isDeclaration() && !memoryManStuff(&*f)) {
+                    for (inst_iterator i = inst_begin(*f); i != inst_end(*f); ++i) {
+                        if (const StoreInst *s = dyn_cast<StoreInst>(&*i)) {
+//                            const Value *l = elimConstExpr(s->getPointerOperand());
+//                            this->getContainer()[&*f].push_back(ProgramStructure::Command(
+//                                    hasExtraReference(l) ? CMD_VAR : CMD_DREF_VAR, l));
+
+                            ConstantInt *constantInt = nullptr;
+                            if (PatternMatch::match(s->getOperand(1), PatternMatch::m_IntToPtr(
+                                    PatternMatch::m_ConstantInt(constantInt)))) {
+                                if (constantInt->getZExtValue() == 4301043416) {
+                                    assert(true);
+                                }
+                                ptr::PointsToSets::PointsToSet pts = ptr::getPointsToSet(s->getOperand(1), PS);
+                                for (auto &p : pts) {
+                                    lockC.lock();
+                                    this->getContainer()[&*f].push_back(
+                                            ProgramStructure::Command(CMD_FRC_DEF, p.first));
+                                    lockC.unlock();
+                                }
+                            } else if (const Instruction *locationInstruction = dyn_cast<const Instruction>(
+                                    s->getOperand(1))) {
+                                if (locationInstruction->getOpcode() != Instruction::GetElementPtr) {
+                                    ptr::PointsToSets::PointsToSet pts = ptr::getPointsToSet(locationInstruction, PS);
+                                    for (auto &p : pts) {
+                                        lockC.lock();
+                                        this->getContainer()[&*f].push_back(
+                                                ProgramStructure::Command(CMD_FRC_DEF, p.first));
+                                        lockC.unlock();
+                                    }
+                                }
+                            }
+//                        } else if (const CallInst *c = dyn_cast<const CallInst>(&*i)) {
+                        } else if (i->getOpcode() == Instruction::Call) {
+//                            pool.async(task, f, i);
+                            task(f, i);
+                        } else if (i->getOpcode() == Instruction::Load) {
+                            Value *Base = nullptr;
+                            Instruction *IVAR = nullptr;
+                            if (PatternMatch::match(i->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_BinOp(PatternMatch::m_Value(Base), PatternMatch::m_SExt(PatternMatch::m_Instruction(IVAR)))))) {
+                                ptr::PointsToSets::PointsToSet pts = ptr::getPointsToSet(&*i, PS);
+                                for (auto &p : pts) {
+                                    lockC.lock();
+                                    this->getContainer()[&*f].push_back(
+                                            ProgramStructure::Command(CMD_FRC_DEF, p.first));
+                                    lockC.unlock();
+                                }
+                            }
+                         }
+                    }
+                }
+
+
+                DetectParametersPass *DPP = ptr::getAndersen()->getAnalysisIfAvailable<DetectParametersPass>();
+                if (!DPP)
+                    DPP = &ptr::getAndersen()->getAnalysis<DetectParametersPass>();
+
+                DetectParametersPass::ParameterAccessPairSet_t &Ret = DPP->getReturnRegisterIndexes(f);
+                for (auto &r : Ret) {
+                    if (const StoreInst *store = dyn_cast<StoreInst>(r.second)) {
+                        this->getContainer()[&*f].push_back(
+                                ProgramStructure::Command(CMD_DEF, store->getOperand(0)));
+                        ptr::PointsToSets::PointsToSet pts = ptr::getPointsToSet(store->getOperand(0), PS);
+                        for (auto &p : pts) {
+                            this->getContainer()[&*f].push_back(
+                                    ProgramStructure::Command(CMD_DEF, p.first));
+                        }
+                    } else {
+                        assert(false);
+                    }
+
+                }
+            }
+
+        }
+
+  const Modifies::ModSet &getModSet(const llvm::Function *const &f,
+	    const Modifies &S) {
+    static const Modifies::ModSet empty;
+    const Modifies::const_iterator it = S.find(f);
+
+    return (it == S.end()) ? empty : it->second;
+  }
+
+
+//  void computeModifies(const ProgramStructure &P,
+//	const callgraph::Callgraph &CG, const ptr::PointsToSets &PS,
+//	Modifies &MOD) {
+//    typedef ptr::PointsToSets::Pointee Pointee;
+//
+//    for (ProgramStructure::const_iterator f = P.begin(); f != P.end(); ++f)
+//      for (ProgramStructure::mapped_type::const_iterator c = f->second.begin();
+//	   c != f->second.end(); ++c) {
+//          StringRef FName = f->first->getName();
+//
+//          if (c->getType() == CMD_VAR) {
+//              if (!isLocalToFunction(c->getVar(), f->first))
+//                  MOD[f->first].insert(Pointee(c->getVar(), -1));
+//          } else if (c->getType() == CMD_DREF_VAR) {
+//              typedef ptr::PointsToSets::PointsToSet PTSet;
+//              const Instruction *Inst = dyn_cast<const Instruction>(c->getVar());
+//              assert(Inst);
+////              const PTSet &S = ptr::getPointsToSet(c->getVar(), PS);
+//              const PTSet &S = ptr::getPointsToSet(Inst->getOperand(1), PS);
+//
+//              for (PTSet::const_iterator p = S.begin(); p != S.end(); ++p)
+//                  if (!isLocalToFunction(p->first, f->first) &&
+//                      !isConstantValue(p->first))
+//                      MOD[f->first].insert(*p);
+//          }
+//      }
+//
+//    typedef callgraph::Callgraph Callgraph;
+//    for (Callgraph::const_iterator i = CG.begin_closure();
+//	  i != CG.end_closure(); ++i) {
+//        StringRef F1 = i->first->getName();
+//        StringRef F2 = i->second->getName();
+//      const Modifies::mapped_type &src = MOD[i->second];
+//      typedef Modifies::mapped_type dst_t;
+//      dst_t &dst = MOD[i->first];
+//
+//      std::copy(src.begin(), src.end(), std::inserter(dst, dst.end()));
+//#if 0 /* original boost+STL uncompilable crap */
+//      using std::tr1::bind;
+//      using std::tr1::placeholders::_1;
+//      using std::tr1::cref;
+//      dst.erase(std::remove_if(dst.begin(), dst.end(),
+//		bind(&ProgramStructure::isLocalToFunction, cref(P), _1, i->first)),
+//		dst.end());
+//#endif
+//      for (dst_t::iterator I = dst.begin(), E = dst.end(); I != E; ) {
+//	if (isLocalToFunction(I->first, i->first))
+//	  dst.erase(I++);
+//	else
+//	  ++I;
+//      }
+//    }
+//
+//#ifdef DEBUG_DUMP
+//    errs() << "\n==== MODSET DUMP ====\n";
+//    for (ProgramStructure::const_iterator f = P.begin(); f != P.end(); ++f) {
+//	const Function *fun = f->first;
+//	const Modifies::ModSet &m = MOD[fun];
+//
+//	errs() << fun->getName() << "\n";
+//	for (Modifies::ModSet::const_iterator I = m.begin(), E = m.end(); I != E; ++I) {
+//	    const Instruction *val = dyn_cast<Instruction>(I->first);
+//	    errs() << "\tFUN=" << val->getParent()->getParent()->getName() <<
+//		" OFF=" << I->second << " ";
+//	    val->dump();
+//	}
+//    }
+//    errs() << "==== MODSET END ====\n";
+//#endif
+//  }
+
+        void computeModifies(const ProgramStructure &P,
+                             const callgraph::Callgraph &CG, const ptr::PointsToSets &PS,
+                             Modifies &MOD) {
+            typedef ptr::PointsToSets::Pointee Pointee;
+
+            DetectParametersPass *DPP = ptr::getAndersen()->getAnalysisIfAvailable<DetectParametersPass>();
+            if (!DPP)
+                DPP = &ptr::getAndersen()->getAnalysis<DetectParametersPass>();
+
+            errs() << "Compute Modifies\n";
+
+
+            for (ProgramStructure::const_iterator f = P.begin(); f != P.end(); ++f) {
+
+                std::set<const Value*> passedReferences, workSet, tmp;
+
+
+
+                DetectParametersPass::ParameterAccessPairSet_t &regParams = DPP->getParameterRegisterIndexes((Function*)f->first);
+                for (auto &regParam : regParams) {
+                    ptr::PointsToSets::PointsToSet ps = ptr::getPointsToSet(regParam.second, PS);
+                    for (auto &p : ps) {
+                        workSet.insert(p.first);
+                    }
+                }
+
+//                std::set<uint64_t> SPIdx;
+//                SPIdx.insert(4);
+//                DetectParametersPass::ParameterAccessPairSet_t stackParams = DPP->getStackParameters(*(Function*)f->first, SPIdx);
+//                for (auto &stackParam : stackParams) {
+//                    ptr::PointsToSets::PointsToSet ps = ptr::getPointsToSet(stackParam.second, PS);
+//                    for (auto &p : ps) {
+//                        workSet.insert(p.first);
+//                    }
+//                }
+
+                while (workSet.size()) {
+                    for (auto &w : workSet) {
+                        if (dyn_cast<const ConstantDataArray>(w)) {
+                            continue;
+                        }
+                        passedReferences.insert(w);
+
+                        ptr::PointsToSets::PointsToSet ps = ptr::getPointsToSet(w, PS);
+                        for (auto &p : ps) {
+                            if (passedReferences.find(p.first) == passedReferences.end()) {
+                                tmp.insert(p.first);
+                            }
+                        }
+                    }
+                    std::swap(workSet, tmp);
+                    tmp.clear();
+                }
+
+                const Instruction *retInst = nullptr;
+                for (const_inst_iterator i_it =  inst_begin(*f->first); i_it != inst_end(*f->first); ++i_it) {
+                    if (i_it->getOpcode() == Instruction::Ret) {
+                        retInst = &*i_it;
+                        break;
+                    }
+                }
+
+                if (retInst) {
+                    DetectParametersPass::UserSet_t x8Vals = DetectParametersPass::getRegisterValuesBeforeCall(13, retInst, false);
+                    for (auto &v : x8Vals) {
+                        ptr::PointsToSets::PointsToSet pts = ptr::getPointsToSet(v, PS);
+                        for (auto &p : pts) {
+                            passedReferences.insert(p.first);
+                        }
+                    }
+                }
+
+                DetectParametersPass::ParameterAccessPairSet_t &Ret = DPP->getReturnRegisterIndexes((Function*)f->first);
+                for (auto &r : Ret) {
+                    if (const StoreInst *store = dyn_cast<StoreInst>(r.second)) {
+                        passedReferences.insert(store->getOperand(0));
+                        ptr::PointsToSets::PointsToSet pts = ptr::getPointsToSet(store->getOperand(0), PS);
+                        for (auto &p : pts) {
+                            passedReferences.insert(p.first);
+                        }
+                    } else {
+                        assert(false);
+                    }
+
+                }
+
+                for (ProgramStructure::mapped_type::const_iterator c = f->second.begin();
+                     c != f->second.end(); ++c) {
+
+                    if (c->getType() == CMD_VAR) {
+                        if (!isLocalToFunction(c->getVar(), f->first))
+                            MOD[f->first].insert(Pointee(c->getVar(), -1));
+                        else {
+                            c->getVar()->dump();
+                            llvm_unreachable("");
+                        }
+                    } else if (c->getType() == CMD_DREF_VAR) {
+                        typedef ptr::PointsToSets::PointsToSet PTSet;
+                        const PTSet &S = ptr::getPointsToSet(c->getVar(), PS);
+
+                        for (PTSet::const_iterator p = S.begin(); p != S.end(); ++p)
+                            if (!isLocalToFunction(p->first, f->first) &&
+                                !isConstantValue(p->first))
+                                MOD[f->first].insert(*p);
+                    } else if (c->getType() == CMD_EXT_ARG) {
+                        std::set<std::pair<int64_t, const Value*>> defs = llvm::getMemcpyDefs(dyn_cast<const Instruction>(c->getVar()), PS);
+                        for (auto &d_it : defs) {
+                            MOD[f->first].insert(Pointee(d_it.second, -1));
+                        }
+                    } else if (c->getType() == CMD_DEF) {
+                        if (passedReferences.find(c->getVar()) != passedReferences.end()) {
+                            MOD[f->first].insert(Pointee(c->getVar(), -1));
+                        }
+                    } else if (c->getType() == CMD_FRC_DEF) {
+                        MOD[f->first].insert(Pointee(c->getVar(), -1));
+                    }
+                }
+            }
+
+            typedef callgraph::Callgraph Callgraph;
+            for (Callgraph::const_iterator i = CG.begin_closure();
+                 i != CG.end_closure(); ++i) {
+                const Modifies::mapped_type &src = MOD[i->second];
+                typedef Modifies::mapped_type dst_t;
+                dst_t &dst = MOD[i->first];
+
+                std::copy(src.begin(), src.end(), std::inserter(dst, dst.end()));
+#if 0 /* original boost+STL uncompilable crap */
+                using std::tr1::bind;
+      using std::tr1::placeholders::_1;
+      using std::tr1::cref;
+      dst.erase(std::remove_if(dst.begin(), dst.end(),
+		bind(&ProgramStructure::isLocalToFunction, cref(P), _1, i->first)),
+		dst.end());
+#endif
+                //We don't need to check for local variables since only 'dummy' locations and return values are added anyway.
+//                for (dst_t::iterator I = dst.begin(), E = dst.end(); I != E; ) {
+//                    if (isLocalToFunction(I->first, i->first))
+//                        dst.erase(I++);
+//                    else
+//                        ++I;
+//                }
+            }
+
+#ifdef DEBUG_DUMP
+            errs() << "\n==== MODSET DUMP ====\n";
+    for (ProgramStructure::const_iterator f = P.begin(); f != P.end(); ++f) {
+	const Function *fun = f->first;
+	const Modifies::ModSet &m = MOD[fun];
+
+	errs() << fun->getName() << "\n" << "----------------------------------------------------------------\n";
+	for (Modifies::ModSet::const_iterator I = m.begin(), E = m.end(); I != E; ++I) {
+	    const Instruction *val = dyn_cast<Instruction>(I->first);
+	    errs() << "\tFUN=" << (val ? val->getParent()->getParent()->getName() : "no parent" )<<
+		" OFF=" << I->second << " ";
+	    I->first->dump();
+	}
+	errs() << "\n";
+    }
+    errs() << "==== MODSET END ====\n";
+#endif
+        }
+
+}}
diff --git a/lib/LLVMSlicer/Modifies/Modifies.h b/lib/LLVMSlicer/Modifies/Modifies.h
new file mode 100644
index 0000000..c26471e
--- /dev/null
+++ b/lib/LLVMSlicer/Modifies/Modifies.h
@@ -0,0 +1,128 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef MODIFIES_MODIFIES_H
+#define MODIFIES_MODIFIES_H
+
+#include <map>
+#include <set>
+#include <vector>
+
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Value.h"
+
+#include "../Languages/LLVM.h"
+#include "../PointsTo/PointsTo.h"
+#include "../Callgraph/Callgraph.h"
+
+namespace llvm { namespace mods {
+
+    struct Modifies {
+        typedef std::set<llvm::ptr::PointsToSets::Pointee> ModSet;
+        typedef std::map<const llvm::Function *, ModSet> Container;
+        typedef Container::key_type key_type;
+        typedef Container::mapped_type mapped_type;
+        typedef Container::value_type value_type;
+        typedef Container::iterator iterator;
+        typedef Container::const_iterator const_iterator;
+        typedef std::pair<iterator, bool> insert_retval;
+
+        virtual ~Modifies() {}
+
+        insert_retval insert(value_type const& val) { return C.insert(val); }
+        mapped_type& operator[](key_type const& key) { return C[key]; }
+        const_iterator find(key_type const& key) const { return C.find(key); }
+        iterator find(key_type const& key) { return C.find(key); }
+        const_iterator begin() const { return C.begin(); }
+        iterator begin() { return C.begin(); }
+        const_iterator end() const { return C.end(); }
+        iterator end() { return C.end(); }
+        Container const& getContainer() const { return C; }
+        Container& getContainer() { return C; }
+    private:
+        Container C;
+    };
+
+    const Modifies::ModSet &getModSet(const llvm::Function *const &f,
+              const Modifies &S);
+
+}}
+
+namespace llvm { namespace mods {
+
+    enum WriteType
+    {
+        CMD_UNKNOWN = 0,
+        CMD_VAR,
+        CMD_DREF_VAR,
+        CMD_EXT_ARG,
+        CMD_DEF,
+        CMD_FRC_DEF
+    };
+
+    struct WriteCommand {
+        WriteCommand()
+            : type(CMD_UNKNOWN)
+        {}
+
+        WriteCommand(WriteType const t, const llvm::Value *v)
+            : type(t)
+            , var(v)
+        {}
+
+        virtual ~WriteCommand()
+        {}
+
+        WriteType getType() const { return type; }
+        const llvm::Value *getVar() const { return var; }
+    private:
+        WriteType type;
+        const llvm::Value *var;
+    };
+}}
+
+namespace llvm { namespace mods {
+
+  struct ProgramStructure {
+      typedef WriteCommand Command;
+      typedef std::vector<Command> Commands;
+      typedef std::map<const llvm::Function *,Commands> Container;
+      typedef Container::key_type key_type;
+      typedef Container::mapped_type mapped_type;
+      typedef Container::value_type value_type;
+      typedef Container::iterator iterator;
+      typedef Container::const_iterator const_iterator;
+      typedef std::pair<iterator, bool> insert_retval;
+
+      ProgramStructure(Module &M, const llvm::ptr::PointsToSets &PS);
+
+      Commands const &getFunctionCommands(const llvm::Function *const& f,
+				  ProgramStructure const& PS) {
+	  return PS.find(f)->second;
+      }
+
+      insert_retval insert(value_type const& val) { return C.insert(val); }
+      mapped_type& operator[](key_type const& key) { return C[key]; }
+      const_iterator find(key_type const& key) const { return C.find(key); }
+      iterator find(key_type const& key) { return C.find(key); }
+      const_iterator begin() const { return C.begin(); }
+      iterator begin() { return C.begin(); }
+      const_iterator end() const { return C.end(); }
+      iterator end() { return C.end(); }
+      Container const& getContainer() const { return C; }
+      Container& getContainer() { return C; }
+  private:
+      Container C;
+      std::mutex lockC;
+  };
+
+}}
+namespace llvm { namespace mods {
+
+    void computeModifies(const ProgramStructure &P,
+			 const callgraph::Callgraph &CG,
+                         const llvm::ptr::PointsToSets &PS, Modifies &M);
+
+}}
+
+#endif
diff --git a/lib/LLVMSlicer/PointsTo/PointsTo.cpp b/lib/LLVMSlicer/PointsTo/PointsTo.cpp
new file mode 100644
index 0000000..2002b20
--- /dev/null
+++ b/lib/LLVMSlicer/PointsTo/PointsTo.cpp
@@ -0,0 +1,696 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#include <map>
+
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/GetElementPtrTypeIterator.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Support/Debug.h"
+
+#include "PointsTo.h"
+#include "RuleExpressions.h"
+
+#include "../Languages/LLVM.h"
+
+#include "llvm/Analysis/Andersen/Andersen.h"
+#include "llvm/IR/LegacyPassManager.h"
+
+namespace llvm { namespace ptr { namespace detail {
+
+class CallMaps {
+private:
+  /* return type -> function */
+  typedef std::multimap<const Type *, const Function *> FunctionsMap;
+  typedef std::multimap<const Type *, const CallInst *> CallsMap;
+
+public:
+  CallMaps(const Module &M) {
+    buildCallMaps(M);
+  }
+
+  template <typename OutIterator>
+  void collectCallRuleCodes(const CallInst *c, const Function *f,
+      OutIterator out);
+
+  template <typename OutIterator>
+  void collectCallRuleCodes(const CallInst *c, OutIterator out);
+
+  template <typename OutIterator>
+  void collectReturnRuleCodes(const ReturnInst *r, OutIterator out);
+
+private:
+  FunctionsMap FM;
+  CallsMap CM;
+
+  static bool compatibleTypes(const Type *t1, const Type *t2);
+  static bool compatibleFunTypes(const FunctionType *f1,
+      const FunctionType *f2);
+  static RuleCode argPassRuleCode(const Value *l, const Value *r);
+  void buildCallMaps(const Module &M);
+};
+
+RuleCode CallMaps::argPassRuleCode(const Value *l, const Value *r)
+{
+    if (isa<ConstantPointerNull const>(r))
+	return ruleCode(ruleVar(l) = ruleNull(r));
+    if (hasExtraReference(l))
+	if (hasExtraReference(r))
+	    return ruleCode(ruleVar(l) = ruleVar(r));
+	else
+	    return ruleCode(ruleVar(l) = *ruleVar(r));
+    else
+	if (hasExtraReference(r))
+	    return ruleCode(ruleVar(l) = &ruleVar(r));
+	else
+	    return ruleCode(ruleVar(l) = ruleVar(r));
+}
+
+template <typename OutIterator>
+void CallMaps::collectCallRuleCodes(const CallInst *c, const Function *f,
+    OutIterator out) {
+  assert(!isInlineAssembly(c) && "Inline assembly is not supported!");
+
+  if (memoryManStuff(f) && !isMemoryAllocation(f))
+    return;
+
+  if (isMemoryAllocation(f)) {
+    const Value *V = c;
+    *out++ = ruleCode(ruleVar(V) = ruleAllocSite(V));
+  } else {
+    static unsigned warned = 0;
+    Function::const_arg_iterator fit = f->arg_begin();
+    unsigned callNumOperands = c->getNumArgOperands();
+    size_t i = 0;
+
+    for (; fit != f->arg_end() && i < callNumOperands; ++fit, ++i)
+      if (isPointerValue(&*fit))
+	*out++ = argPassRuleCode(&*fit, elimConstExpr(c->getOperand(i)));
+
+    if (i < callNumOperands && warned++ < 3) {
+      DEBUG_WITH_TYPE("points-to", errs() << __func__ << ": skipped some vararg arguments in '" <<
+	f->getName() << "(" << i << ", " << callNumOperands << ")'\n";);
+    }
+  }
+}
+
+bool CallMaps::compatibleTypes(const Type *t1, const Type *t2) {
+
+  /*
+   * Casting sucks, we can call (int *) with (char *) parameters.
+   * Let's over-approximate.
+   */
+  if (t1->isPointerTy() && t2->isPointerTy())
+    return true;
+
+  return t1 == t2;
+}
+
+bool CallMaps::compatibleFunTypes(const FunctionType *f1,
+		const FunctionType *f2) {
+
+  unsigned params1 = f1->getNumParams();
+  unsigned params2 = f2->getNumParams();
+
+  if (!f1->isVarArg() && !f2->isVarArg() && params1 != params2)
+    return false;
+
+  if (!compatibleTypes(f1->getReturnType(), f2->getReturnType()))
+    return false;
+
+  for (unsigned i = 0; i < params1 && i < params2; i++)
+    if (!compatibleTypes(f1->getParamType(i), f2->getParamType(i)))
+      return false;
+
+  return true;
+}
+
+template<typename OutIterator>
+void CallMaps::collectCallRuleCodes(const CallInst *c, OutIterator out) {
+
+    if (const Function *f = c->getCalledFunction()) {
+      collectCallRuleCodes(c, f, out);
+      return;
+    }
+
+    const FunctionType *funTy = getCalleePrototype(c);
+    const Type *retTy = funTy->getReturnType();
+
+    for (FunctionsMap::const_iterator I = FM.lower_bound(retTy),
+	E = FM.upper_bound(retTy); I != E; ++I) {
+      const Function *fun = I->second;
+
+      if (compatibleFunTypes(funTy, fun->getFunctionType()))
+	collectCallRuleCodes(c, fun, out);
+    }
+}
+
+template<typename OutIterator>
+void CallMaps::collectReturnRuleCodes(const ReturnInst *r, OutIterator out) {
+  const Value *retVal = r->getReturnValue();
+
+  if (!retVal || !isPointerValue(retVal))
+    return;
+
+  const Function *f = r->getParent()->getParent();
+  const FunctionType *funTy = f->getFunctionType();
+  const Type *retTy = funTy->getReturnType();
+
+  for (CallsMap::const_iterator b = CM.lower_bound(retTy),
+      e = CM.upper_bound(retTy); b != e; ++b) {
+    const CallInst *CI = b->second;
+
+    if (const Function *g = CI->getCalledFunction()) {
+      if (f == g)
+	*out++ = argPassRuleCode(CI, retVal);
+    } else if (compatibleFunTypes(funTy, getCalleePrototype(CI)))
+	*out++ = argPassRuleCode(CI, retVal);
+  }
+}
+
+void CallMaps::buildCallMaps(const Module &M) {
+    for (Module::const_iterator f = M.begin(); f != M.end(); ++f) {
+	if (!f->isDeclaration()) {
+	    const FunctionType *funTy = f->getFunctionType();
+
+	    FM.insert(std::make_pair(funTy->getReturnType(), &*f));
+	}
+
+	for (const_inst_iterator i = inst_begin(f), E = inst_end(f);
+		i != E; ++i) {
+	    if (const CallInst *CI = dyn_cast<CallInst>(&*i)) {
+		if (!isInlineAssembly(CI) && !callToMemoryManStuff(CI)) {
+		    const FunctionType *funTy = getCalleePrototype(CI);
+
+		    CM.insert(std::make_pair(funTy->getReturnType(), CI));
+		}
+	    } else if (const StoreInst *SI = dyn_cast<StoreInst>(&*i)) {
+		const Value *r = SI->getValueOperand();
+
+		if (hasExtraReference(r) && memoryManStuff(r)) {
+		    const Function *fn = dyn_cast<Function>(r);
+		    const FunctionType *funTy = fn->getFunctionType();
+
+		    FM.insert(std::make_pair(funTy->getReturnType(), fn));
+		}
+	    }
+	}
+    }
+}
+
+}}}
+
+namespace llvm { namespace ptr {
+
+typedef PointsToSets::PointsToSet PTSet;
+typedef PointsToSets::Pointer Ptr;
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    VARIABLE<const llvm::Value *>,
+		    VARIABLE<const llvm::Value *>
+		    > const& E) {
+    const llvm::Value *lval = E.getArgument1().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    const PTSet &R = S[Ptr(rval, -1)];
+    const std::size_t old_size = L.size();
+
+    std::copy(R.begin(), R.end(), std::inserter(L, L.end()));
+
+    return old_size != L.size();
+}
+
+static int64_t accumulateConstantOffset(const GetElementPtrInst *gep,
+	const DataLayout &DL, bool &isArray) {
+    int64_t off = 0;
+
+    for (gep_type_iterator GTI = gep_type_begin(gep), GTE = gep_type_end(gep);
+	    GTI != GTE; ++GTI) {
+	ConstantInt *OpC = dyn_cast<ConstantInt>(GTI.getOperand());
+	if (!OpC) /* skip non-const array indices */
+	    continue;
+	if (OpC->isZero())
+	    continue;
+
+	int64_t ElementIdx = OpC->getSExtValue();
+
+	// Handle a struct index, which adds its field offset to the pointer.
+	if (StructType *STy = dyn_cast<StructType>(*GTI)) {
+	    const StructLayout *SL = DL.getStructLayout(STy);
+	    off += SL->getElementOffset(ElementIdx);
+	    continue;
+	} else if (SequentialType *STy = dyn_cast<SequentialType>(*GTI)) {
+	    off += ElementIdx * DL.getTypeStoreSize(GTI.getIndexedType());
+	    isArray = true;
+	    continue;
+	}
+#ifdef FIELD_DEBUG
+	errs() << "skipping " << OpC->getValue() << " in ";
+	gep->dump();
+#endif
+    }
+
+    return off;
+}
+
+static bool checkOffset(const DataLayout &DL, const Value *Rval, uint64_t sum) {
+  if (const GlobalVariable *GV = dyn_cast<GlobalVariable>(Rval)) {
+    if (GV->hasInitializer() &&
+	sum >= DL.getTypeAllocSize(GV->getInitializer()->getType()))
+      return false;
+  } else if (const AllocaInst *AI = dyn_cast<AllocaInst>(Rval)) {
+    if (!AI->isArrayAllocation() &&
+	sum >= DL.getTypeAllocSize(AI->getAllocatedType()))
+      return false;
+  }
+
+  return true;
+}
+
+static bool applyRule(PointsToSets &S, const llvm::DataLayout &DL, ASSIGNMENT<
+		    VARIABLE<const llvm::Value *>,
+		    GEP<VARIABLE<const llvm::Value *> >
+		    > const& E) {
+    const llvm::Value *lval = E.getArgument1().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    const std::size_t old_size = L.size();
+
+    const GetElementPtrInst *gep = dyn_cast<GetElementPtrInst>(rval);
+    const llvm::Value *op = elimConstExpr(gep->getPointerOperand());
+    bool isArray = false;
+    int64_t off = accumulateConstantOffset(gep, DL, isArray);
+
+    if (hasExtraReference(op)) {
+	L.insert(Ptr(op, off)); /* VAR = REF */
+    } else {
+	const PTSet &R = S[Ptr(op, -1)];
+	for (PTSet::const_iterator I = R.begin(), E = R.end(); I != E; ++I) {
+	    assert(I->second >= 0);
+
+	    /* disable recursive structures */
+	    if (L.count(*I))
+		    continue;
+
+	    const Value *Rval = I->first;
+
+	    if (off && (isa<Function>(Rval) || isa<ConstantPointerNull>(Rval)))
+	      continue;
+
+	    int64_t sum = I->second + off;
+
+	    if (!checkOffset(DL, Rval, sum))
+	      continue;
+
+	    unsigned int sameCount = 0;
+	    for (PTSet::const_iterator II = L.begin(), EE = L.end();
+		II != EE; ++II) {
+	      if (II->first == Rval)
+		if (++sameCount >= 5)
+		  break;
+	    }
+
+	    if (sameCount >= 3) {
+#ifdef DEBUG_CROPPING
+	      errs() << "dropping GEP ";
+	      gep->dump();
+	      errs() << "\tHAVE " << off << "+" << " OFF=" << I->second << " ";
+	      Rval->dump();
+#endif
+	      continue;
+	    }
+
+	    if (sum < 0) {
+		    assert(I->second >= 0);
+#ifdef DEBUG_CROPPING
+		    errs() << "variable index, cropping to 0: " <<
+			    I->second << "+" << off << "\n\t";
+		    gep->dump();
+		    errs() << "\tPTR=";
+		    Rval->dump();
+#endif
+		    sum = 0;
+	    }
+
+	    /* an unsoundness :) */
+	    if (isArray && sum > 64)
+		sum = 64;
+
+	    L.insert(Ptr(Rval, sum)); /* V = V */
+	}
+    }
+
+    return old_size != L.size();
+}
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    VARIABLE<const llvm::Value *>,
+		    REFERENCE<VARIABLE<const llvm::Value *> >
+		    > const& E) {
+    const llvm::Value *lval = E.getArgument1().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    const std::size_t old_size = L.size();
+
+    L.insert(Ptr(rval, 0));
+
+    return old_size != L.size();
+}
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    VARIABLE<const llvm::Value *>,
+		    DEREFERENCE< VARIABLE<const llvm::Value *> >
+		    > const& E, const int idx = -1)
+{
+    const llvm::Value *lval = E.getArgument1().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument().getArgument();
+    PTSet &L = S[Ptr(lval, idx)];
+    PTSet &R = S[Ptr(rval, -1)];
+    const std::size_t old_size = L.size();
+
+    for (PTSet::const_iterator i = R.begin(); i!=R.end(); ++i) {
+	PTSet &X = S[*i];
+	std::copy(X.begin(), X.end(), std::inserter(L, L.end()));
+    }
+
+    return old_size != L.size();
+}
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    DEREFERENCE<VARIABLE<const llvm::Value *> >,
+		    VARIABLE<const llvm::Value *>
+		    > const& E)
+{
+    const llvm::Value *lval = E.getArgument1().getArgument().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    PTSet &R = S[Ptr(rval, -1)];
+    bool change = false;
+
+    for (PTSet::const_iterator i = L.begin(); i != L.end(); ++i) {
+	PTSet &X = S[*i];
+	const std::size_t old_size = X.size();
+
+	std::copy(R.begin(), R.end(), std::inserter(X, X.end()));
+	change = change || X.size() != old_size;
+    }
+
+    return change;
+}
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    DEREFERENCE<VARIABLE<const llvm::Value *> >,
+		    REFERENCE<VARIABLE<const llvm::Value *> >
+		    > const &E)
+{
+    const llvm::Value *lval = E.getArgument1().getArgument().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    bool change = false;
+
+    for (PTSet::const_iterator i = L.begin(); i != L.end(); ++i) {
+	PTSet &X = S[*i];
+	const std::size_t old_size = X.size();
+
+	X.insert(Ptr(rval, 0));
+	change = change || X.size() != old_size;
+    }
+
+    return change;
+}
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    DEREFERENCE<VARIABLE<const llvm::Value *> >,
+		    DEREFERENCE<VARIABLE<const llvm::Value *> >
+		    > const& E)
+{
+    const llvm::Value *lval = E.getArgument1().getArgument().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    bool change = false;
+
+    for (PTSet::const_iterator i = L.begin(); i != L.end(); ++i)
+	if (applyRule(S, (ruleVar(i->first) = *ruleVar(rval)).getSort(),
+				i->second))
+	    change = true;
+
+    return change;
+}
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    VARIABLE<const llvm::Value *>,
+		    ALLOC<const llvm::Value *>
+		    > const &E)
+{
+    const llvm::Value *lval = E.getArgument1().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    const std::size_t old_size = L.size();
+
+    L.insert(Ptr(rval, 0));
+
+    return old_size != L.size();
+}
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    VARIABLE<const llvm::Value *>,
+		    NULLPTR<const llvm::Value *>
+		    > const &E)
+{
+    const llvm::Value *lval = E.getArgument1().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    const std::size_t old_size = L.size();
+
+    L.insert(Ptr(rval, 0));
+
+    return old_size != L.size();
+}
+
+static bool applyRule(PointsToSets &S, ASSIGNMENT<
+		    DEREFERENCE<VARIABLE<const llvm::Value *> >,
+		    NULLPTR<const llvm::Value *>
+		    > const &E)
+{
+    const llvm::Value *lval = E.getArgument1().getArgument().getArgument();
+    const llvm::Value *rval = E.getArgument2().getArgument();
+    PTSet &L = S[Ptr(lval, -1)];
+    bool change = false;
+
+    for (PTSet::const_iterator i = L.begin(); i != L.end(); ++i) {
+	PTSet &X = S[*i];
+	const std::size_t old_size = X.size();
+
+	X.insert(Ptr(rval, 0));
+	change = change || X.size() != old_size;
+    }
+
+    return change;
+}
+
+static bool applyRule(PointsToSets &S, DEALLOC<const llvm::Value *>) {
+    return false;
+}
+
+static bool applyRules(const RuleCode &RC, PointsToSets &S,
+		const llvm::DataLayout &DL)
+{
+    const llvm::Value *lval = RC.getLvalue();
+    const llvm::Value *rval = RC.getRvalue();
+
+    switch (RC.getType()) {
+    case RCT_VAR_ASGN_ALLOC:
+	return applyRule(S, (ruleVar(lval) = ruleAllocSite(rval)).getSort());
+    case RCT_VAR_ASGN_NULL:
+	return applyRule(S, (ruleVar(lval) = ruleNull(rval)).getSort());
+    case RCT_VAR_ASGN_VAR:
+	return applyRule(S, (ruleVar(lval) = ruleVar(rval)).getSort());
+    case RCT_VAR_ASGN_GEP:
+	return applyRule(S, DL,
+			(ruleVar(lval) = ruleVar(rval).gep()).getSort());
+    case RCT_VAR_ASGN_REF_VAR:
+	return applyRule(S, (ruleVar(lval) = &ruleVar(rval)).getSort());
+    case RCT_VAR_ASGN_DREF_VAR:
+	return applyRule(S, (ruleVar(lval) = *ruleVar(rval)).getSort());
+    case RCT_DREF_VAR_ASGN_NULL:
+	return applyRule(S, (*ruleVar(lval) = ruleNull(rval)).getSort());
+    case RCT_DREF_VAR_ASGN_VAR:
+	return applyRule(S, (*ruleVar(lval) = ruleVar(rval)).getSort());
+    case RCT_DREF_VAR_ASGN_REF_VAR:
+	return applyRule(S, (*ruleVar(lval) = &ruleVar(rval)).getSort());
+    case RCT_DREF_VAR_ASGN_DREF_VAR:
+	return applyRule(S, (*ruleVar(lval) = *ruleVar(rval)).getSort());
+    case RCT_DEALLOC:
+	return applyRule(S, ruleDeallocSite(RC.getValue()).getSort());
+    default:
+	assert(0);
+    }
+}
+
+/*
+ * It does not really work -- it prunes too much. Like it does not take into
+ * account bitcast instructions in the code.
+ */
+static PointsToSets &pruneByType(PointsToSets &S) {
+  typedef PointsToSets::mapped_type PTSet;
+  for (PointsToSets::iterator s = S.begin(); s != S.end(); ) {
+      const llvm::Value *first = s->first.first;
+      if (llvm::isa<llvm::Function>(first)) {
+	const PointsToSets::iterator tmp = s++;
+	S.getContainer().erase(tmp);
+      } else {
+#if 0
+	if (isPointerValue(first)) {
+	  const llvm::Type *firstTy;
+	  if (const llvm::BitCastInst *BC =
+		      llvm::dyn_cast<llvm::BitCastInst>(first))
+	    firstTy = getPointedType(BC->getSrcTy());
+	  else
+	    firstTy = getPointedType(first);
+
+	  for (typename PTSet::const_iterator v = s->second.begin();
+	       v != s->second.end(); ) {
+	    const llvm::Value *second = *v;
+	    const llvm::Type *secondTy = second->getType();
+
+	    if (hasExtraReference(second))
+		    secondTy = llvm::cast<llvm::PointerType>(secondTy)->
+			    getElementType();
+	    if (const llvm::ArrayType *AT =
+			    llvm::dyn_cast<llvm::ArrayType>(secondTy))
+		    secondTy = AT->getElementType();
+
+	    if (firstTy != secondTy) {
+	      typename PTSet::iterator const tmp = v++;
+	      s->second.erase(tmp);
+	    } else
+	      ++v;
+	  }
+	}
+#endif
+	++s;
+      }
+  }
+  return S;
+}
+
+static PointsToSets &fixpoint(const ProgramStructure &P, PointsToSets &S)
+{
+  bool change;
+
+  DataLayout DL(&P.getModule());
+
+  do {
+    change = false;
+
+    for (ProgramStructure::const_iterator i = P.begin(); i != P.end(); ++i)
+      change |= applyRules(*i, S, DL);
+  } while (change);
+
+  return S;
+}
+
+        static Andersen *andersen = nullptr;
+        static DetectParametersPass *DPP = nullptr;
+
+PointsToSets &computePointsToSets(const ProgramStructure &P, PointsToSets &S) {
+    legacy::PassManager *PM = new legacy::PassManager();
+    DPP = new DetectParametersPass();
+    andersen = new Andersen();
+    PM->add(DPP);
+    PM->add(andersen);
+    PM->run(P.getModule());
+
+
+    //FIXME: Passmanager can't be deallocated here ('andersen' is used later)
+//    delete(PM);
+//  return pruneByType(fixpoint(P, S));
+    return S;
+}
+
+const PTSet &
+getPointsToSet(const llvm::Value *const &memLoc, const PointsToSets &S,
+		const int idx) {
+  const PointsToSets::const_iterator it = S.find(Ptr(memLoc, idx));
+  if (it == S.end()) {
+      std::vector<const llvm::Value*> PT;
+      andersen->getPointsToSet(memLoc, PT);
+
+      static const PTSet emptySet;
+      if (PT.size() == 0) {
+//          errs() << "WARNING[PointsTo]: No points-to set has been found: ";
+//          memLoc->print(errs());
+//          errs() << '\n';
+          return emptySet;
+      }
+
+      PTSet *newSet = new PTSet();
+
+      for(std::vector<const llvm::Value*>::iterator p_it = PT.begin();
+              p_it != PT.end(); ++p_it) {
+          newSet->insert(PointsToSets::Pointee(*p_it, -1));
+      }
+
+
+      ((PointsToSets&)S)[PointsToSets::Pointer(memLoc, -1)] = *newSet;
+
+      return *newSet;
+
+  }
+  return it->second;
+}
+
+SimpleCallGraph &getSimpleCallGraph() {
+    return andersen->getCallGraph();
+}
+
+Andersen *getAndersen() {
+    return andersen;
+}
+
+DetectParametersPass &getDetectParametersPass() {
+    return *DPP;
+}
+
+ProgramStructure::ProgramStructure(Module &M) : M(M) {
+    for (Module::const_global_iterator g = M.global_begin(), E = M.global_end();
+	    g != E; ++g)
+      if (isGlobalPointerInitialization(&*g))
+	detail::toRuleCode(&*g,std::back_inserter(this->getContainer()));
+
+    detail::CallMaps CM(M);
+
+    for (Module::const_iterator f = M.begin(); f != M.end(); ++f) {
+	for (const_inst_iterator i = inst_begin(f), E = inst_end(f);
+		i != E; ++i) {
+	    if (isPointerManipulation(&*i))
+		detail::toRuleCode(&*i,
+			    std::back_inserter(this->getContainer()));
+	    else if (const CallInst *c = dyn_cast<CallInst>(&*i)) {
+		if (!isInlineAssembly(c))
+		    CM.collectCallRuleCodes(c,
+			std::back_inserter(this->getContainer()));
+	    } else if (const ReturnInst *r = dyn_cast<ReturnInst>(&*i)) {
+		CM.collectReturnRuleCodes(r,
+			std::back_inserter(this->getContainer()));
+	    }
+	}
+    }
+#ifdef PS_DEBUG
+    errs() << "==PS START\n";
+    for (const_iterator I = getContainer().begin(), E = getContainer().end();
+	    I != E; ++I) {
+	const RuleCode &rc = *I;
+	errs() << "\tTYPE=" << rc.getType() << "\n\tL=";
+	rc.getLvalue()->dump();
+	errs() << "\tR=";
+	rc.getRvalue()->dump();
+    }
+    errs() << "==PS END\n";
+#endif
+}
+
+}}
diff --git a/lib/LLVMSlicer/PointsTo/PointsTo.h b/lib/LLVMSlicer/PointsTo/PointsTo.h
new file mode 100644
index 0000000..417cbc9
--- /dev/null
+++ b/lib/LLVMSlicer/PointsTo/PointsTo.h
@@ -0,0 +1,109 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef POINTSTO_POINTSTO_H
+#define POINTSTO_POINTSTO_H
+
+#include <map>
+#include <set>
+#include <vector>
+#include <llvm/Analysis/Andersen/SimpleCallGraph.h>
+#include <llvm/Analysis/Andersen/DetectParametersPass.h>
+#include <llvm/Analysis/Andersen/Andersen.h>
+
+#include "llvm/IR/Value.h"
+
+#include "RuleExpressions.h"
+
+namespace llvm { namespace ptr {
+
+  class PointsToSets {
+  public:
+    typedef const llvm::Value *MemoryLocation;
+    /*
+     * pointer is a pair <location, offset> such that the location is:
+     * a) variable, offset is -1
+     * b) alloc,    offset is <0,infty) -- structure members can point too
+     *
+     * Note that in LLVM, both a variable and an alloc (CallInst to malloc)
+     * are llvm::Value.
+     */
+    typedef std::pair<MemoryLocation, int> Pointer;
+    /*
+     * Points-to set contains against pairs <location, offset>, where location
+     * can be only an alloc companied by an offset (we can point to the
+     * middle).
+     */
+    typedef std::pair<MemoryLocation, int> Pointee;
+    typedef std::set<Pointee> PointsToSet;
+
+    typedef std::map<Pointer, PointsToSet> Container;
+    typedef Container::key_type key_type;
+    typedef Container::mapped_type mapped_type;
+    typedef Container::value_type value_type;
+    typedef Container::iterator iterator;
+    typedef Container::const_iterator const_iterator;
+    typedef std::pair<iterator, bool> insert_retval;
+
+    virtual ~PointsToSets() {}
+
+    insert_retval insert(value_type const& val) { return C.insert(val); }
+    PointsToSet& operator[](key_type const& key) { return C[key]; }
+    const_iterator find(key_type const& key) const { return C.find(key); }
+    iterator find(key_type const& key) { return C.find(key); }
+    const_iterator begin() const { return C.begin(); }
+    iterator begin() { return C.begin(); }
+    const_iterator end() const { return C.end(); }
+    iterator end() { return C.end(); }
+    Container const& getContainer() const { return C; }
+    Container& getContainer() { return C; }
+  private:
+    Container C;
+  };
+
+}}
+
+namespace llvm { namespace ptr {
+
+    struct ProgramStructure
+    {
+        typedef RuleCode Command;
+        typedef std::vector<Command> Container;
+        typedef Container::value_type value_type;
+        typedef Container::iterator iterator;
+        typedef Container::const_iterator const_iterator;
+
+        explicit ProgramStructure(Module &M);
+
+        llvm::Module &getModule() const { return M; }
+
+        void insert(iterator it, value_type const& val) { C.insert(it,val); }
+        void push_back(value_type const& val) { return C.push_back(val); }
+        const_iterator begin() const { return C.begin(); }
+        iterator begin() { return C.begin(); }
+        const_iterator end() const { return C.end(); }
+        iterator end() { return C.end(); }
+        Container const& getContainer() const { return C; }
+        Container& getContainer() { return C; }
+    private:
+        Container C;
+        llvm::Module &M;
+    };
+
+}}
+
+namespace llvm { namespace ptr {
+
+  const PointsToSets::PointsToSet &
+  getPointsToSet(const llvm::Value *const &memLoc, const PointsToSets &S,
+		  const int offset = -1);
+
+        SimpleCallGraph &getSimpleCallGraph();
+        DetectParametersPass &getDetectParametersPass();
+        Andersen *getAndersen();
+
+  PointsToSets &computePointsToSets(const ProgramStructure &P, PointsToSets &S);
+
+}}
+
+#endif
diff --git a/lib/LLVMSlicer/PointsTo/RuleExpressions.h b/lib/LLVMSlicer/PointsTo/RuleExpressions.h
new file mode 100644
index 0000000..e00b641
--- /dev/null
+++ b/lib/LLVMSlicer/PointsTo/RuleExpressions.h
@@ -0,0 +1,440 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef POINTSTO_RULEEXPRESSIONS_H
+#define POINTSTO_RULEEXPRESSIONS_H
+
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/Support/Debug.h"
+
+#include "../Languages/LLVM.h"
+
+namespace llvm { namespace ptr {
+
+    struct Expression
+    {
+	virtual ~Expression() {}
+    };
+
+    template<typename SubExpr>
+    struct RuleUnaryExpression : public Expression
+    {
+	typedef SubExpr SubExpression;
+
+	explicit RuleUnaryExpression(SubExpression const sub)
+	    : arg(sub)
+	{}
+
+	SubExpression getArgument() const
+	{ return arg; }
+
+
+	SubExpression arg;
+    };
+
+    template<typename SubExpr1, typename SubExpr2>
+    struct RuleBinaryExpression : public Expression
+    {
+	typedef SubExpr1 SubExpression1;
+	typedef SubExpr2 SubExpression2;
+
+	explicit RuleBinaryExpression(SubExpression1 const sub1,
+				      SubExpression2 const sub2)
+	    : arg1(sub1)
+	    , arg2(sub2)
+	{}
+
+	SubExpression1 getArgument1() const
+	{ return arg1; }
+
+	SubExpression2 getArgument2() const
+	{ return arg2; }
+
+
+	SubExpression1 arg1;
+	SubExpression2 arg2;
+    };
+
+    template<typename MemLoc>
+    struct VARIABLE : public RuleUnaryExpression<MemLoc> {
+	VARIABLE(MemLoc const ml) : RuleUnaryExpression<MemLoc>(ml) {}
+    };
+
+    template<typename MemLoc>
+    struct ALLOC : public RuleUnaryExpression<MemLoc> {
+	ALLOC(MemLoc const ml) : RuleUnaryExpression<MemLoc>(ml) {}
+    };
+
+    template<typename MemLoc>
+    struct DEALLOC : public RuleUnaryExpression<MemLoc> {
+	DEALLOC(MemLoc const ml) : RuleUnaryExpression<MemLoc>(ml) {}
+    };
+
+    template<typename SubExpr>
+    struct GEP : public RuleUnaryExpression<SubExpr> {
+	GEP(SubExpr const sub) : RuleUnaryExpression<SubExpr>(sub) {}
+    };
+
+    template<typename MemLoc>
+    struct NULLPTR : public RuleUnaryExpression<MemLoc> {
+	NULLPTR(MemLoc const ml) : RuleUnaryExpression<MemLoc>(ml) {}
+    };
+
+    template<typename SubExpr>
+    struct REFERENCE : public RuleUnaryExpression<SubExpr> {
+	REFERENCE(SubExpr const sub) : RuleUnaryExpression<SubExpr>(sub) {}
+    };
+
+    template<typename SubExpr>
+    struct DEREFERENCE : public RuleUnaryExpression<SubExpr> {
+	DEREFERENCE(SubExpr const sub) : RuleUnaryExpression<SubExpr>(sub) {}
+    };
+
+    template<typename LSubExpr, typename RSubExpr>
+    struct ASSIGNMENT : public RuleBinaryExpression<LSubExpr,RSubExpr> {
+	ASSIGNMENT(LSubExpr const lsub, RSubExpr const rsub)
+	    : RuleBinaryExpression<LSubExpr,RSubExpr>(lsub,rsub) {}
+    };
+
+    template<typename ExprSort>
+    struct RuleExpression
+    {
+	typedef ExprSort Sort;
+
+	explicit RuleExpression(Sort const& s)
+	    : sort(s)
+	{}
+
+	Sort getSort() const
+	{ return sort; }
+
+	template<typename RSort>
+	RuleExpression< ASSIGNMENT<Sort,RSort> >
+	operator=(RuleExpression<RSort> const& r) const
+	{ return makeAssignment(r); }
+
+	template<typename RSort>
+	RuleExpression< ASSIGNMENT<Sort,RSort> >
+	operator=(RuleExpression<RSort> const& r)
+	{ return makeAssignment(r); }
+
+	RuleExpression< ASSIGNMENT<Sort,Sort> >
+	operator=(RuleExpression<Sort> const& r)
+	{ return makeAssignment(r); }
+
+	RuleExpression< REFERENCE<Sort> > operator&() const
+	{
+	    return RuleExpression< REFERENCE<Sort> >(REFERENCE<Sort>(sort));
+	}
+
+	RuleExpression< DEREFERENCE<Sort> > operator*() const
+	{
+	    return RuleExpression< DEREFERENCE<Sort> >(DEREFERENCE<Sort>(sort));
+	}
+
+	RuleExpression< GEP<Sort> >gep() const
+	{
+	    return RuleExpression< GEP<Sort> >(GEP<Sort>(sort));
+	}
+
+    private:
+	template<typename RSort>
+	RuleExpression< ASSIGNMENT<Sort,RSort> >
+	makeAssignment(RuleExpression<RSort> const& r)
+	{
+	    return RuleExpression< ASSIGNMENT<Sort,RSort> >(
+			ASSIGNMENT<Sort,RSort>(sort,r.getSort()));
+	}
+
+	Sort sort;
+    };
+
+    template<typename MemLoc>
+    RuleExpression< VARIABLE<MemLoc> > ruleVar(MemLoc const ml)
+    {
+	return RuleExpression< VARIABLE<MemLoc> >(VARIABLE<MemLoc>(ml));
+    }
+
+    template<typename MemLoc>
+    RuleExpression< ALLOC<MemLoc> > ruleAllocSite(MemLoc const ml)
+    {
+	return RuleExpression< ALLOC<MemLoc> >(ALLOC<MemLoc>(ml));
+    }
+
+    template<typename MemLoc>
+    RuleExpression< DEALLOC<MemLoc> > ruleDeallocSite(MemLoc const ml)
+    {
+	return RuleExpression< DEALLOC<MemLoc> >(DEALLOC<MemLoc>(ml));
+    }
+
+    template<typename MemLoc>
+    RuleExpression< NULLPTR<MemLoc> > ruleNull(MemLoc const ml)
+    {
+	return RuleExpression< NULLPTR<MemLoc> >(NULLPTR<MemLoc>(ml));
+    }
+
+}}
+
+namespace llvm { namespace ptr {
+
+    enum RuleCodeType
+    {
+	RCT_UNKNOWN = 0,
+	RCT_VAR_ASGN_ALLOC,
+	RCT_VAR_ASGN_NULL,
+	RCT_VAR_ASGN_VAR,
+	RCT_VAR_ASGN_GEP,
+	RCT_VAR_ASGN_REF_VAR,
+	RCT_VAR_ASGN_DREF_VAR,
+	RCT_DREF_VAR_ASGN_NULL,
+	RCT_DREF_VAR_ASGN_VAR,
+	RCT_DREF_VAR_ASGN_REF_VAR,
+	RCT_DREF_VAR_ASGN_DREF_VAR,
+	RCT_DEALLOC,
+    };
+
+    struct RuleCode
+    {
+	typedef const llvm::Value *MemoryLocation;
+
+	RuleCode()
+	    : type(RCT_UNKNOWN)
+	{}
+
+	RuleCode(ASSIGNMENT<VARIABLE<MemoryLocation>,
+			    ALLOC<MemoryLocation> > const& E)
+	    : type(RCT_VAR_ASGN_ALLOC)
+	    , lvalue(E.getArgument1().getArgument())
+	    , rvalue(E.getArgument2().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<VARIABLE<MemoryLocation>,
+			    NULLPTR<MemoryLocation> > const& E)
+	    : type(RCT_VAR_ASGN_NULL)
+	    , lvalue(E.getArgument1().getArgument())
+	    , rvalue(E.getArgument2().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<VARIABLE<MemoryLocation>,
+			    VARIABLE<MemoryLocation> > const& E)
+	    : type(RCT_VAR_ASGN_VAR)
+	    , lvalue(E.getArgument1().getArgument())
+	    , rvalue(E.getArgument2().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<VARIABLE<MemoryLocation>,
+			    GEP<VARIABLE<MemoryLocation> > > const& E)
+	    : type(RCT_VAR_ASGN_GEP)
+	    , lvalue(E.getArgument1().getArgument())
+	    , rvalue(E.getArgument2().getArgument().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<VARIABLE<MemoryLocation>,
+			    REFERENCE<VARIABLE<MemoryLocation> > > const& E)
+	    : type(RCT_VAR_ASGN_REF_VAR)
+	    , lvalue(E.getArgument1().getArgument())
+	    , rvalue(E.getArgument2().getArgument().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<VARIABLE<MemoryLocation>,
+			    DEREFERENCE<VARIABLE<MemoryLocation> > > const& E)
+	    : type(RCT_VAR_ASGN_DREF_VAR)
+	    , lvalue(E.getArgument1().getArgument())
+	    , rvalue(E.getArgument2().getArgument().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<DEREFERENCE<VARIABLE<MemoryLocation> >,
+			    NULLPTR<MemoryLocation> > const& E)
+	    : type(RCT_DREF_VAR_ASGN_NULL)
+	    , lvalue(E.getArgument1().getArgument().getArgument())
+	    , rvalue(E.getArgument2().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<DEREFERENCE<VARIABLE<MemoryLocation> >,
+			    VARIABLE<MemoryLocation> > const& E)
+	    : type(RCT_DREF_VAR_ASGN_VAR)
+	    , lvalue(E.getArgument1().getArgument().getArgument())
+	    , rvalue(E.getArgument2().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<DEREFERENCE<VARIABLE<MemoryLocation> >,
+			    REFERENCE<VARIABLE<MemoryLocation> > > const& E)
+	    : type(RCT_DREF_VAR_ASGN_REF_VAR)
+	    , lvalue(E.getArgument1().getArgument().getArgument())
+	    , rvalue(E.getArgument2().getArgument().getArgument())
+	{}
+
+	RuleCode(ASSIGNMENT<DEREFERENCE<VARIABLE<MemoryLocation> >,
+			    DEREFERENCE<VARIABLE<MemoryLocation> > > const& E)
+	    : type(RCT_DREF_VAR_ASGN_DREF_VAR)
+	    , lvalue(E.getArgument1().getArgument().getArgument())
+	    , rvalue(E.getArgument2().getArgument().getArgument())
+	{}
+
+	RuleCode(DEALLOC<MemoryLocation> const& E)
+	    : type(RCT_DEALLOC)
+	    , lvalue(E.getArgument())
+	    , rvalue()
+	{}
+
+	RuleCodeType getType() const { return type; }
+	MemoryLocation const& getLvalue() const { return lvalue; }
+	MemoryLocation const& getRvalue() const { return rvalue; }
+	MemoryLocation const& getValue() const { return getLvalue(); }
+
+    private:
+	RuleCodeType type;
+	MemoryLocation lvalue;
+	MemoryLocation rvalue;
+    };
+
+    template<typename ExprSort>
+    RuleCode ruleCode(RuleExpression<ExprSort> const& E)
+    {
+	return RuleCode(E.getSort());
+    }
+
+}}
+
+namespace llvm { namespace ptr { namespace detail {
+
+  template<typename OutIterator>
+  void toRuleCode(const Value *V, OutIterator out) {
+    if (const llvm::Instruction *I = llvm::dyn_cast<llvm::Instruction>(V)) {
+      if (const llvm::LoadInst *LI = llvm::dyn_cast<llvm::LoadInst>(I)) {
+	const llvm::Value *op = elimConstExpr(LI->getPointerOperand());
+
+	if (hasExtraReference(op))
+	  *out++ = ruleCode(ruleVar(V) = ruleVar(op));
+	else
+	  *out++ = ruleCode(ruleVar(V) = *ruleVar(op));
+      } else if (const llvm::StoreInst *SI =
+		 llvm::dyn_cast<llvm::StoreInst>(I)) {
+	const llvm::Value *l = elimConstExpr(SI->getPointerOperand());
+	const llvm::Value *r = elimConstExpr(SI->getValueOperand());
+
+	if (!hasExtraReference(l)) {
+	  if (hasExtraReference(r))
+	    *out++ = ruleCode(*ruleVar(l) = &ruleVar(r));
+	  else {
+	    if (isa<ConstantPointerNull>(r))
+	      *out++ = ruleCode(*ruleVar(l) = ruleNull(r));
+	    else
+	      *out++ = ruleCode(*ruleVar(l) = ruleVar(r));
+	  }
+	} else {
+	  if (hasExtraReference(r))
+	    *out++ = ruleCode(ruleVar(l) = &ruleVar(r));
+	  else {
+	    if (isa<ConstantPointerNull>(r))
+	      *out++ = ruleCode(ruleVar(l) = ruleNull(r));
+	    else
+	      *out++ = ruleCode(ruleVar(l) = ruleVar(r));
+	  }
+	}
+      } else if (const llvm::BitCastInst *BCI =
+		 llvm::dyn_cast<llvm::BitCastInst>(I)) {
+	const llvm::Value *op = elimConstExpr(BCI->getOperand(0));
+
+	if (hasExtraReference(op))
+	  *out++ = ruleCode(ruleVar(V) = &ruleVar(op));
+	else
+	  *out++ = ruleCode(ruleVar(V) = ruleVar(op));
+      } else if (const llvm::GetElementPtrInst *gep =
+		 llvm::dyn_cast<llvm::GetElementPtrInst>(I)) {
+	const llvm::Value *op = gep;
+
+	*out++ = ruleCode(ruleVar(V) = ruleVar(op).gep());
+      } else if (const llvm::CallInst *C =
+		 llvm::dyn_cast<llvm::CallInst>(I)) {
+	if (isInlineAssembly(C)) {
+	} else if (isMemoryAllocation(C->getCalledValue()))
+	  *out++ = ruleCode(ruleVar(V) = ruleAllocSite(V));
+	else if (isMemoryDeallocation(C->getCalledValue()))
+	  *out++ = ruleCode(ruleDeallocSite(V));
+	else if (isMemoryCopy(C->getCalledValue()) ||
+	    isMemoryMove(C->getCalledValue())) {
+	  const llvm::Value *l = elimConstExpr(C->getArgOperand(0));
+	  const llvm::Value *r = elimConstExpr(C->getArgOperand(1));
+
+	  *out++ = ruleCode(*ruleVar(l) = *ruleVar(r));
+	}
+      } else if (const llvm::PHINode *PHI = llvm::dyn_cast<llvm::PHINode>(I)) {
+	unsigned int i, n = PHI->getNumIncomingValues();
+
+	for (i = 0; i < n; ++i) {
+	  const llvm::Value *r = PHI->getIncomingValue(i);
+
+	  if (llvm::isa<llvm::ConstantPointerNull>(r))
+	      *out++ = ruleCode(ruleVar(V) = ruleNull(r));
+	  else
+	      *out++ = ruleCode(ruleVar(V) = ruleVar(r));
+	}
+      } else if (const llvm::ExtractValueInst *EV =
+		 llvm::dyn_cast<llvm::ExtractValueInst>(I)) {
+	// TODO: Instruction 'ExtractValueIns' has not been tested yet!
+
+	const llvm::Value *op = EV->getAggregateOperand();
+	assert(!hasExtraReference(op) && "Agregate operand must "
+	       "be a value and not a pointer.");
+	*out++ = ruleCode(ruleVar(V) = ruleVar(op));
+	    } else if (const llvm::InsertValueInst *IV =
+		       llvm::dyn_cast<llvm::InsertValueInst>(I)) {
+	// TODO: Instruction 'InsertValueInst' has not been tested yet!
+
+	const llvm::Value *l = IV->getAggregateOperand();
+	assert(!hasExtraReference(l) && "Agregate operand must "
+	       "be a value and not a pointer.");
+	const llvm::Value *r = IV->getInsertedValueOperand();
+	if (hasExtraReference(r))
+	  *out++ = ruleCode(ruleVar(l) = &ruleVar(r));
+	else {
+	  if (isa<ConstantPointerNull>(r))
+	    *out++ = ruleCode(ruleVar(l) = ruleNull(r));
+	  else
+	    *out++ = ruleCode(ruleVar(l) = ruleVar(r));
+	}
+      } else if (const llvm::IntToPtrInst *ITPI =
+		 llvm::dyn_cast<llvm::IntToPtrInst>(I)) {
+
+	DEBUG_WITH_TYPE("rule-exp", errs() << __func__ << ": WARNING[PointsTo]: Integer ";);
+
+	if (const llvm::ConstantInt *C =
+	    llvm::dyn_cast<llvm::ConstantInt>(ITPI->getOperand(0)))
+        DEBUG_WITH_TYPE("rule-exp", errs() << "(" << C->getValue() << ") ";);
+
+          DEBUG_WITH_TYPE("rule-exp", errs() << "converted to a pointer in '" <<
+	    I->getParent()->getParent()->getName() <<
+	    "' => getting unsound analysis!\n";);
+      } else if (const llvm::SelectInst *SEL =
+		 llvm::dyn_cast<llvm::SelectInst>(I)) {
+	  const llvm::Value *r1 = elimConstExpr(SEL->getTrueValue());
+	  const llvm::Value *r2 = elimConstExpr(SEL->getFalseValue());
+
+	  if (llvm::isa<llvm::ConstantPointerNull>(r1))
+	      *out++ = ruleCode(ruleVar(V) = ruleNull(r1));
+	  else if (hasExtraReference(r1))
+	      *out++ = ruleCode(ruleVar(V) = &ruleVar(r1));
+	  else
+	      *out++ = ruleCode(ruleVar(V) = ruleVar(r1));
+
+	  if (llvm::isa<llvm::ConstantPointerNull>(r2))
+	      *out++ = ruleCode(ruleVar(V) = ruleNull(r2));
+	  else if (hasExtraReference(r2))
+	      *out++ = ruleCode(ruleVar(V) = &ruleVar(r2));
+	  else
+	      *out++ = ruleCode(ruleVar(V) = ruleVar(r2));
+      }
+    } else if (const llvm::GlobalVariable *GV =
+	       llvm::dyn_cast<llvm::GlobalVariable>(V)) {
+      const llvm::Value *op = GV->getInitializer();
+
+      *out++ = ruleCode(ruleVar(V) = &ruleVar(op));
+    }
+  }
+
+}}}
+
+#endif
diff --git a/lib/LLVMSlicer/Slicing/ExternalHandler.h b/lib/LLVMSlicer/Slicing/ExternalHandler.h
new file mode 100644
index 0000000..f283616
--- /dev/null
+++ b/lib/LLVMSlicer/Slicing/ExternalHandler.h
@@ -0,0 +1,5335 @@
+#ifndef LLVM_EXTERNALHANDLER_H
+#define LLVM_EXTERNALHANDLER_H
+
+#include "llvm/Analysis/Andersen/DetectParametersPass.h"
+
+namespace llvm {
+
+namespace {
+int translateRegister(std::string RegName) {
+  if (RegName == "X0") 
+    return 5;
+  if (RegName == "X1") 
+    return 6;
+  if (RegName == "X2") 
+    return 7;
+  if (RegName == "X3") 
+    return 8;
+  if (RegName == "X4") 
+    return 9;
+  if (RegName == "X5") 
+    return 10;
+  if (RegName == "X6") 
+    return 11;
+  if (RegName == "X7") 
+    return 12;
+  llvm_unreachable("Unknown Register");
+}
+}
+void anonymous_1005(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "malloc"
+}
+
+void anonymous_1008(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSFileHandle fileHandleForReadingAtPath:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_1019(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSFileHandle readDataOfLength:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_1030(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[UITextField text]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_1036(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[UITextView text]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_1042(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[UILabel text]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_1048(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString stringByTrimmingCharactersInSet:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_1057(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString stringByAppendingString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_106(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSData dataWithContentsOfURL:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_1069(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString componentsSeparatedByString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_1081(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[UIView initWithFrame:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_1088(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[UIViewController initWithNibName:bundle:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_1095(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSNull null]"
+}
+
+void anonymous_1098(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[UIApplication sharedApplication]"
+}
+
+void anonymous_1101(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSUserDefaults objectForKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_1108(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSUserDefaults setObject:forKey:]"
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_1115(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSKeyedArchiver archivedDataWithRootObject:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_1121(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[UIAlertView textFieldAtIndex:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_1127(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSDictionary objectForKey:]"
+}
+
+void anonymous_1131(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSDictionary setObject:forKey:]"
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_1138(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSDictionary valueForKey:]"
+}
+
+void anonymous_1142(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSDictionary setValue:forKey:]"
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_119(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSData dataWithData:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_132(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData mutableCopy]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_145(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData isEqual:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_148(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData writeToFile:options:error:]"
+}
+
+void anonymous_149(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData dataWithBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_162(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData data]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_17(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_autoreleaseReturnValue"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_170(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData dataWithBytesNoCopy:length:freeWhenDone:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_18(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_autorelease"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_183(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData dataWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_19(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_retainAutoreleasedReturnValue"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_196(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData dataWithContentsOfFile:options:error:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_20(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_retainAutoreleaseReturnValue"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_209(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData dataWithContentsOfURL:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_21(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_retainAutorelease"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_22(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSObject retain]"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_222(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData dataWithData:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_23(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSObject autorelease]"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_235(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData dataWithCapacity:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_24(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_release"
+}
+
+void anonymous_243(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableData dataWithLength:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_25(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSObject release]"
+}
+
+void anonymous_251(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSMutableData mutableBytes]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_26(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSObject dealloc]"
+}
+
+void anonymous_260(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString string]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_266(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString stringWithString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_27(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSObject respondsToSelector:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_277(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString stringWithCString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_288(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString stringWithCharacters:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_299(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString initWithData:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_311(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString initWithString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_323(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString getCString:maxLength:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_33(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSData dataWithBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_332(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_341(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString cStringUsingEncoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_350(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString lowercaseString]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_361(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableString stringWithString:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_372(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableString stringWithCharacters:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_383(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSDictionary dictionaryWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_389(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSDictionary dictionaryWithObject:forKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_398(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSDictionary dictionaryWithObjectsAndKeys:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_404(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSDictionary dictionary]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_410(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSDictionary dictionaryWithDictionary:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_416(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSDictionary dictionaryWithObjects:forKeys:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_422(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSDictionary dictionaryWithObjects:forKeys:count:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_428(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSDictionary initWithObjectsAndKeys:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_435(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSDictionary objectForKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_442(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSDictionary valueForKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_449(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableDictionary dictionaryWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_455(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableDictionary dictionaryWithObject:forKey:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_46(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSData dataWithBytesNoCopy:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_464(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableDictionary dictionaryWithObjectsAndKeys:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_470(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableDictionary dictionary]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_476(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableDictionary dictionaryWithDictionary:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_482(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSJSONSerialization dataWithJSONObject:options:error:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_488(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData bytes]"
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_500(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData getBytes:range:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_517(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData getBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_537(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData subdataWithRange:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_550(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSMutableData setLength:]"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_553(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSMutableData appendData:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_565(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSMutableData appendBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_577(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData length]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_580(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString dataUsingEncoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_59(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSData data]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_593(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "memcpy"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_604(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CCKeyDerivationPBKDF"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns(), true);
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns(), true);
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X7"), (Instruction*)CallInst->getIns(), true);
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X7"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_621(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CCCalibratePBKDF"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X5"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_626(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CCCryptorCreate"
+}
+
+void anonymous_627(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CCCryptorCreateWithMode"
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X4"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_631(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CCCrypt"
+}
+
+void anonymous_632(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CCCryptorUpdate"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_645(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_setProperty_nonatomic_copy"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_654(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_getProperty"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_668(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_setProperty_nonatomic"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_67(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSData dataWithBytesNoCopy:length:freeWhenDone:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_680(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_setProperty_atomic"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_692(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_setProperty"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X3"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_704(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_loadWeakRetained"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_718(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString UTF8String]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_731(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSArray arrayWithArray:]"
+}
+
+void anonymous_734(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSArray arrayWithObject:]"
+}
+
+void anonymous_735(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSArray arrayWithObjects:]"
+}
+
+void anonymous_736(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSArray array]"
+}
+
+void anonymous_737(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSArray objectAtIndex:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_747(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSArray objectAtIndexedSubscript:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_757(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableString stringWithCapacity:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_763(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableString stringWithUTF8String:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_764(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSMutableString string]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_765(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString stringWithCString:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_771(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString stringWithContentsOfFile:encoding:error:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_772(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString stringWithFormat:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_773(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString stringWithUTF8String:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_774(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSString stringWithCString:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_781(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSObject init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_788(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSMutableData init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_789(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData initWithBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_790(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData initWithBase64EncodedData:options:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_791(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData initWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_792(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData initWithData:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_793(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_794(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData initWithBase64EncodedString:options:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_795(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString initWithBytes:length:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_796(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString initWithData:encoding:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_797(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString initWithFormat:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_798(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSMutableDictionary init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_799(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSDictionary init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_8(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_retain"
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_80(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSData dataWithContentsOfFile:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_800(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[UITableViewController init]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_801(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData initWithBytes:length:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_810(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData initWithBase64EncodedString:options:]"
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_816(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString copy]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_825(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSMutableString copy]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_834(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSData copy]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_843(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CC_SHA256_Init"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_847(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CC_SHA256_Update"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_857(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CC_SHA256_Final"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_864(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "arc4random"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_870(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "SecRandomCopyBytes"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_878(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_storeStrong"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_888(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_storeWeak"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_898(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_getClass"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_907(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "bzero"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_915(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSBundle bundleWithPath:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_923(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSBundle bundleForClass:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_924(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSBundle mainBundle]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_925(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "NSLog"
+}
+
+void anonymous_926(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "__stack_chk_fail"
+}
+
+void anonymous_927(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_enumerationMutation"
+}
+
+void anonymous_928(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_terminate"
+}
+
+void anonymous_929(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_sync_exit"
+}
+
+void anonymous_93(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSData dataWithContentsOfFile:options:error:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+{ //Ref
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));
+  }
+} //End ref
+}
+
+void anonymous_930(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_sync_enter"
+}
+
+void anonymous_931(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_exception_rethrow"
+}
+
+void anonymous_932(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_exception_throw"
+}
+
+void anonymous_933(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_destroyWeak"
+}
+
+void anonymous_934(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_end_catch"
+}
+
+void anonymous_935(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "objc_begin_catch"
+}
+
+void anonymous_936(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "_Znam"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_941(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "_Znwm"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_946(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "_ZnwmRKSt9nothrow_t"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+}
+
+void anonymous_951(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CC_MD5"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_958(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "CC_SHA256"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_965(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "read"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X1"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_971(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "open"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_977(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "+[NSNumber numberWithInt:]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Def
+DetectParametersPass::UserSet_t DefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    DefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X2"), (Instruction*)CallInst->getIns());
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_987(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSNumber integerValue]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_993(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString intValue]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+void anonymous_999(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {
+//Handle "-[NSString integerValue]"
+{ //Def
+DetectParametersPass::UserSet_t DefRegs = DetectParametersPass::getRegisterValuesAfterCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {
+    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));
+  }
+} //End Def
+{ //Ref1
+DetectParametersPass::UserSet_t RefRegs;
+{
+DetectParametersPass::UserSet_t Src = DetectParametersPass::getRegisterValuesBeforeCall(translateRegister("X0"), (Instruction*)CallInst->getIns());
+for (auto S : Src) {
+  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets
+  for (auto &P : PtsTo) {
+    assert(isa<const User>(P.first));
+    RefRegs.insert((User*)P.first);
+  }
+}
+}
+  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {
+    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);
+  }
+} //End Ref1
+}
+
+bool handleCall(llvm::slicing::InsInfo *CallInst, std::string FName, const ptr::PointsToSets &PS) {
+  if (FName == "+[NSArray arrayWithArray:]") {
+    anonymous_731(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSArray arrayWithObject:]") {
+    anonymous_734(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSArray arrayWithObjects:]") {
+    anonymous_735(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSArray array]") {
+    anonymous_736(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSBundle bundleForClass:]") {
+    anonymous_923(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSBundle bundleWithPath:]") {
+    anonymous_915(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSBundle mainBundle]") {
+    anonymous_924(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytes:length:]") {
+    anonymous_33(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytesNoCopy:length:]") {
+    anonymous_46(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSData dataWithBytesNoCopy:length:freeWhenDone:]") {
+    anonymous_67(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfFile:]") {
+    anonymous_80(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfFile:options:error:]") {
+    anonymous_93(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSData dataWithContentsOfURL:]") {
+    anonymous_106(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSData dataWithData:]") {
+    anonymous_119(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSData data]") {
+    anonymous_59(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithContentsOfFile:]") {
+    anonymous_383(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithDictionary:]") {
+    anonymous_410(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObject:forKey:]") {
+    anonymous_389(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjects:forKeys:]") {
+    anonymous_416(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjects:forKeys:count:]") {
+    anonymous_422(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionaryWithObjectsAndKeys:]") {
+    anonymous_398(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSDictionary dictionary]") {
+    anonymous_404(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSFileHandle fileHandleForReadingAtPath:]") {
+    anonymous_1008(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSJSONSerialization dataWithJSONObject:options:error:]") {
+    anonymous_482(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSKeyedArchiver archivedDataWithRootObject:]") {
+    anonymous_1115(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithBytes:length:]") {
+    anonymous_149(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithBytesNoCopy:length:freeWhenDone:]") {
+    anonymous_170(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithCapacity:]") {
+    anonymous_235(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfFile:]") {
+    anonymous_183(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfFile:options:error:]") {
+    anonymous_196(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithContentsOfURL:]") {
+    anonymous_209(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithData:]") {
+    anonymous_222(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData dataWithLength:]") {
+    anonymous_243(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableData data]") {
+    anonymous_162(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithContentsOfFile:]") {
+    anonymous_449(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithDictionary:]") {
+    anonymous_476(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithObject:forKey:]") {
+    anonymous_455(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionaryWithObjectsAndKeys:]") {
+    anonymous_464(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableDictionary dictionary]") {
+    anonymous_470(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithCapacity:]") {
+    anonymous_757(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithCharacters:length:]") {
+    anonymous_372(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithString:]") {
+    anonymous_361(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableString stringWithUTF8String:]") {
+    anonymous_763(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSMutableString string]") {
+    anonymous_764(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSNull null]") {
+    anonymous_1095(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSNumber numberWithInt:]") {
+    anonymous_977(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCString:]") {
+    anonymous_277(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCString:encoding:]") {
+    anonymous_765(CallInst, PS);
+    anonymous_774(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSString stringWithCharacters:length:]") {
+    anonymous_288(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSString stringWithContentsOfFile:encoding:error:]") {
+    anonymous_771(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSString stringWithFormat:]") {
+    anonymous_772(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSString stringWithString:]") {
+    anonymous_266(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSString stringWithUTF8String:]") {
+    anonymous_773(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[NSString string]") {
+    anonymous_260(CallInst, PS);
+    return true;
+  }
+  if (FName == "+[UIApplication sharedApplication]") {
+    anonymous_1098(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSArray objectAtIndex:]") {
+    anonymous_737(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSArray objectAtIndexedSubscript:]") {
+    anonymous_747(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData bytes]") {
+    anonymous_488(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData copy]") {
+    anonymous_834(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData getBytes:length:]") {
+    anonymous_517(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData getBytes:range:]") {
+    anonymous_500(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData initWithBase64EncodedData:options:]") {
+    anonymous_790(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData initWithBase64EncodedString:options:]") {
+    anonymous_794(CallInst, PS);
+    anonymous_810(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData initWithBytes:length:]") {
+    anonymous_789(CallInst, PS);
+    anonymous_801(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData initWithContentsOfFile:]") {
+    anonymous_791(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData initWithData:]") {
+    anonymous_792(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData init]") {
+    anonymous_793(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData isEqual:]") {
+    anonymous_145(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData length]") {
+    anonymous_577(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData mutableCopy]") {
+    anonymous_132(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData subdataWithRange:]") {
+    anonymous_537(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSData writeToFile:options:error:]") {
+    anonymous_148(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSDictionary initWithObjectsAndKeys:]") {
+    anonymous_428(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSDictionary init]") {
+    anonymous_799(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSDictionary objectForKey:]") {
+    anonymous_1127(CallInst, PS);
+    anonymous_435(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSDictionary setObject:forKey:]") {
+    anonymous_1131(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSDictionary setValue:forKey:]") {
+    anonymous_1142(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSDictionary valueForKey:]") {
+    anonymous_1138(CallInst, PS);
+    anonymous_442(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSFileHandle readDataOfLength:]") {
+    anonymous_1019(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSMutableData appendBytes:length:]") {
+    anonymous_565(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSMutableData appendData:]") {
+    anonymous_553(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSMutableData init]") {
+    anonymous_788(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSMutableData mutableBytes]") {
+    anonymous_251(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSMutableData setLength:]") {
+    anonymous_550(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSMutableDictionary init]") {
+    anonymous_798(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSMutableString copy]") {
+    anonymous_825(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSNumber integerValue]") {
+    anonymous_987(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSObject autorelease]") {
+    anonymous_23(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSObject dealloc]") {
+    anonymous_26(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSObject init]") {
+    anonymous_781(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSObject release]") {
+    anonymous_25(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSObject respondsToSelector:]") {
+    anonymous_27(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSObject retain]") {
+    anonymous_22(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString UTF8String]") {
+    anonymous_718(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString cStringUsingEncoding:]") {
+    anonymous_341(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString componentsSeparatedByString:]") {
+    anonymous_1069(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString copy]") {
+    anonymous_816(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString dataUsingEncoding:]") {
+    anonymous_580(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]") {
+    anonymous_332(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString getCString:maxLength:encoding:]") {
+    anonymous_323(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString initWithBytes:length:encoding:]") {
+    anonymous_795(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString initWithData:encoding:]") {
+    anonymous_299(CallInst, PS);
+    anonymous_796(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString initWithFormat:]") {
+    anonymous_797(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString initWithString:]") {
+    anonymous_311(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString intValue]") {
+    anonymous_993(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString integerValue]") {
+    anonymous_999(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString lowercaseString]") {
+    anonymous_350(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString stringByAppendingString:]") {
+    anonymous_1057(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSString stringByTrimmingCharactersInSet:]") {
+    anonymous_1048(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSUserDefaults objectForKey:]") {
+    anonymous_1101(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[NSUserDefaults setObject:forKey:]") {
+    anonymous_1108(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[UIAlertView textFieldAtIndex:]") {
+    anonymous_1121(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[UILabel text]") {
+    anonymous_1042(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[UITableViewController init]") {
+    anonymous_800(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[UITextField text]") {
+    anonymous_1030(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[UITextView text]") {
+    anonymous_1036(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[UIView initWithFrame:]") {
+    anonymous_1081(CallInst, PS);
+    return true;
+  }
+  if (FName == "-[UIViewController initWithNibName:bundle:]") {
+    anonymous_1088(CallInst, PS);
+    return true;
+  }
+  if (FName == "CCCalibratePBKDF") {
+    anonymous_621(CallInst, PS);
+    return true;
+  }
+  if (FName == "CCCrypt") {
+    anonymous_631(CallInst, PS);
+    return true;
+  }
+  if (FName == "CCCryptorCreate") {
+    anonymous_626(CallInst, PS);
+    return true;
+  }
+  if (FName == "CCCryptorCreateWithMode") {
+    anonymous_627(CallInst, PS);
+    return true;
+  }
+  if (FName == "CCCryptorUpdate") {
+    anonymous_632(CallInst, PS);
+    return true;
+  }
+  if (FName == "CCKeyDerivationPBKDF") {
+    anonymous_604(CallInst, PS);
+    return true;
+  }
+  if (FName == "CC_MD5") {
+    anonymous_951(CallInst, PS);
+    return true;
+  }
+  if (FName == "CC_SHA256") {
+    anonymous_958(CallInst, PS);
+    return true;
+  }
+  if (FName == "CC_SHA256_Final") {
+    anonymous_857(CallInst, PS);
+    return true;
+  }
+  if (FName == "CC_SHA256_Init") {
+    anonymous_843(CallInst, PS);
+    return true;
+  }
+  if (FName == "CC_SHA256_Update") {
+    anonymous_847(CallInst, PS);
+    return true;
+  }
+  if (FName == "NSLog") {
+    anonymous_925(CallInst, PS);
+    return true;
+  }
+  if (FName == "SecRandomCopyBytes") {
+    anonymous_870(CallInst, PS);
+    return true;
+  }
+  if (FName == "_Znam") {
+    anonymous_936(CallInst, PS);
+    return true;
+  }
+  if (FName == "_Znwm") {
+    anonymous_941(CallInst, PS);
+    return true;
+  }
+  if (FName == "_ZnwmRKSt9nothrow_t") {
+    anonymous_946(CallInst, PS);
+    return true;
+  }
+  if (FName == "__stack_chk_fail") {
+    anonymous_926(CallInst, PS);
+    return true;
+  }
+  if (FName == "arc4random") {
+    anonymous_864(CallInst, PS);
+    return true;
+  }
+  if (FName == "bzero") {
+    anonymous_907(CallInst, PS);
+    return true;
+  }
+  if (FName == "malloc") {
+    anonymous_1005(CallInst, PS);
+    return true;
+  }
+  if (FName == "memcpy") {
+    anonymous_593(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_autorelease") {
+    anonymous_18(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_autoreleaseReturnValue") {
+    anonymous_17(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_begin_catch") {
+    anonymous_935(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_destroyWeak") {
+    anonymous_933(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_end_catch") {
+    anonymous_934(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_enumerationMutation") {
+    anonymous_927(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_exception_rethrow") {
+    anonymous_931(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_exception_throw") {
+    anonymous_932(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_getClass") {
+    anonymous_898(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_getProperty") {
+    anonymous_654(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_loadWeakRetained") {
+    anonymous_704(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_release") {
+    anonymous_24(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_retain") {
+    anonymous_8(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_retainAutorelease") {
+    anonymous_21(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_retainAutoreleaseReturnValue") {
+    anonymous_20(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_retainAutoreleasedReturnValue") {
+    anonymous_19(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_setProperty") {
+    anonymous_692(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_setProperty_atomic") {
+    anonymous_680(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_setProperty_nonatomic") {
+    anonymous_668(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_setProperty_nonatomic_copy") {
+    anonymous_645(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_storeStrong") {
+    anonymous_878(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_storeWeak") {
+    anonymous_888(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_sync_enter") {
+    anonymous_930(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_sync_exit") {
+    anonymous_929(CallInst, PS);
+    return true;
+  }
+  if (FName == "objc_terminate") {
+    anonymous_928(CallInst, PS);
+    return true;
+  }
+  if (FName == "open") {
+    anonymous_971(CallInst, PS);
+    return true;
+  }
+  if (FName == "read") {
+    anonymous_965(CallInst, PS);
+    return true;
+  }
+  return false;
+}
+
+}
+
+
+#endif //LLVM_EXTERNALHANDLER_H
+
diff --git a/lib/LLVMSlicer/Slicing/FunctionStaticSlicer.cpp b/lib/LLVMSlicer/Slicing/FunctionStaticSlicer.cpp
new file mode 100644
index 0000000..e4a21f8
--- /dev/null
+++ b/lib/LLVMSlicer/Slicing/FunctionStaticSlicer.cpp
@@ -0,0 +1,2367 @@
+//===- Hello.cpp - Example code from "Writing an LLVM Pass" ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+// Details are in a white paper by F. Tip called:
+// A survey of program slicing techniques
+//===----------------------------------------------------------------------===//
+
+#include <ctype.h>
+#include <map>
+#include <llvm/IR/PatternMatch.h>
+#include <llvm/Analysis/Andersen/StackAccessPass.h>
+#include <llvm/ADT/StringExtras.h>
+#include <llvm/ProfileData/InstrProfReader.h>
+
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/Pass.h"
+#include "llvm/IR/TypeBuilder.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/Analysis/PostDominators.h"
+#include "llvm/IR/CFG.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+#include "PostDominanceFrontier.h"
+#include "../Callgraph/Callgraph.h"
+#include "../Modifies/Modifies.h"
+#include "../PointsTo/PointsTo.h"
+#include "../Languages/LLVMSupport.h"
+
+#include "FunctionStaticSlicer.h"
+#include "ExternalHandler.h"
+
+//#define DEBUG_SLICE
+//#define DEBUG_SLICING
+//#define DEBUG_RC
+
+#define DEBUG_TYPE "function-slicer"
+
+using namespace llvm;
+using namespace llvm::slicing;
+
+InsInfo::StructSliceInfoSet_t::iterator InsInfo::defaultStructIterator;
+
+std::mutex FunctionStaticSlicer::passLock;
+
+bool isStackPointer(const Value *v) {
+  const Instruction *i = dyn_cast<const Instruction>(v);
+  if (!i || i->getOpcode() != Instruction::Load)
+    return false;
+
+  const Instruction *regPtr = dyn_cast<const Instruction>(i->getOperand(0));
+  if (!regPtr || regPtr->getOpcode() != Instruction::GetElementPtr)
+    return false;
+
+  const ConstantInt *idx = dyn_cast<const ConstantInt>(regPtr->getOperand(2));
+  if (!idx || (idx->getZExtValue() != 0 && idx->getZExtValue() != 3))
+    return false;
+  return true;
+}
+
+static uint64_t getSizeOfMem(const Value *val) {
+
+  if (const ConstantInt *CI = dyn_cast<ConstantInt>(val)) {
+    return CI->getLimitedValue();
+  } else if (const Constant *C = dyn_cast<Constant>(val)) {
+    if (C->isNullValue())
+      return 0;
+    assert(0 && "unknown constant");
+  }
+
+  /* This sucks indeed, it is only a wild guess... */
+  return 64;
+}
+
+void InsInfo::addDEFArray(const ptr::PointsToSets &PS, const Value *V,
+                          uint64_t lenConst) {
+  if (isPointerValue(V)) {
+    typedef ptr::PointsToSets::PointsToSet PTSet;
+
+    const PTSet &L = getPointsToSet(V, PS);
+    for (PTSet::const_iterator p = L.begin(); p != L.end(); ++p)
+      for (uint64_t i = 0; i < lenConst; i++)
+        addDEF(Pointee(p->first, p->second + i));
+  }
+}
+
+void InsInfo::handleVariousFuns(const ptr::PointsToSets &PS, const CallInst *C) {
+  StringRef fName;
+  if (C->getCalledFunction() && C->getCalledFunction()->hasName())
+    fName = C->getCalledFunction()->getName();
+
+
+  if (fName.equals("klee_make_symbolic")) {
+    const Value *l = elimConstExpr(C->getArgOperand(0));
+    const Value *len = elimConstExpr(C->getArgOperand(1));
+    uint64_t lenConst = getSizeOfMem(len);
+
+    addREF(Pointee(l, -1));
+    addDEFArray(PS, l, lenConst);
+    if (!isConstantValue(len))
+      addREF(Pointee(len, -1));
+  } else {
+    //FIXME: this should be handled automatically...
+
+    if (fName.equals("objc_msgSend")) {
+      DetectParametersPass::UserSet_t Pre_X0 = DetectParametersPass::getRegisterValuesBeforeCall(5, C, true);
+      DetectParametersPass::UserSet_t Pre_X1 = DetectParametersPass::getRegisterValuesBeforeCall(6, C, true);
+
+      for (auto Pre : Pre_X0) {
+        addREF(Pointee(Pre, -1));
+      }
+      for (auto Pre : Pre_X1) {
+        addREF(Pointee(Pre, -1));
+      }
+    }
+
+    if (fName.equals("SecItemCopyMatching")) {
+      DetectParametersPass::UserSet_t PreX1 = DetectParametersPass::getRegisterValuesBeforeCall(6, C);
+      for (auto &X1 : PreX1) {
+        std::vector<const Value *> ptsToSet1;
+        ptr::getAndersen()->getPointsToSet(X1, ptsToSet1);
+        for (auto &pts1 : ptsToSet1) {
+          addDEF(Pointee(pts1, -1));
+        }
+      }
+    }
+
+  }
+//  } else if (fName.equals("objc_retain") || fName.equals("objc_autoreleaseReturnValue") || fName.equals("objc_autorelease") ||
+//          fName.equals("objc_release") ||
+//          fName.equals("objc_retainAutoreleasedReturnValue") ||
+//          fName.equals("objc_retainAutorelease")) {
+//      DetectParametersPass::UserSet_t Pre = DetectParametersPass::getRegisterValuesBeforeCall(5, C, true);
+//      DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(5, C);
+//
+//      for (DetectParametersPass::UserSet_t::iterator Pre_it = Pre.begin(); Pre_it != Pre.end(); ++Pre_it) {
+//          addREF(Pointee(*Pre_it, -1));
+//      }
+//      for (DetectParametersPass::UserSet_t::iterator Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+//          addDEF(Pointee(*Post_it, -1));
+//      }
+//  } else if (fName.equals("objc_msgSendSuper2")) {
+//      //Do nothing?
+//  } else if (fName.equals("objc_msgSend")) {
+//      DetectParametersPass::UserSet_t Pre_X0 = DetectParametersPass::getRegisterValuesBeforeCall(5, (CallInst*)C, true);
+//      DetectParametersPass::UserSet_t Pre_X1 = DetectParametersPass::getRegisterValuesBeforeCall(6, (CallInst*)C, true);
+//      for (DetectParametersPass::UserSet_t::iterator Pre_it = Pre_X0.begin(); Pre_it != Pre_X0.end(); ++Pre_it) {
+//          addREF(Pointee(*Pre_it,-1));
+//      }
+//      for (DetectParametersPass::UserSet_t::iterator Pre_it = Pre_X1.begin(); Pre_it != Pre_X1.end(); ++Pre_it) {
+//          addREF(Pointee(*Pre_it,-1));
+//      }
+//
+  const Module *M = C->getParent()->getParent()->getParent();
+  SimpleCallGraph &CG = ptr::getSimpleCallGraph();
+  for (SimpleCallGraph::FunctionSet_t::iterator F_it = CG.getCalled(C).begin(); F_it != CG.getCalled(C).end(); ++F_it) {
+    const Function *F = M->getFunction(*F_it);
+    if (!F) {
+      handleCall(this, *F_it, PS);
+    } else {
+      handleCall(this, F->getName(), PS);
+    }
+  }
+//  } else {
+//      errs() << fName << "\n";
+////      assert(false);
+//  }
+}
+
+void InsInfo::addREFArray(const ptr::PointsToSets &PS, const Value *V,
+                          uint64_t lenConst) {
+  if (isPointerValue(V)) {
+    typedef ptr::PointsToSets::PointsToSet PTSet;
+
+    const PTSet &R = getPointsToSet(V, PS);
+    for (PTSet::const_iterator p = R.begin(); p != R.end(); ++p)
+      for (uint64_t i = 0; i < lenConst; i++)
+        addREF(Pointee(p->first, p->second + i));
+  }
+}
+
+#define DETAILED_DUMP
+
+void InsInfo::dump(bool def, bool ref, bool rc, bool pred) {
+  ins->dump();
+  if (def) {
+    errs() << "Size Def " << DEF.size() << "\n";
+    for (ValSet::const_iterator I = DEF.begin(); I != DEF.end(); ++I)
+      (*I).first->dump();
+  }
+  if (ref) {
+    errs() << "Size Ref " << REF.size() << "\n";
+    for (ValSet::const_iterator I = REF.begin(); I != REF.end(); ++I) {
+      errs() << "F: " << (int64_t) getREFInc(*I) << "; ";
+      (*I).first->dump();
+    }
+  }
+  if (rc) {
+    errs() << "Size RC " << RC.size() << "\n";
+    for (ValSet::const_iterator I = RC.begin(); I != RC.end(); ++I) {
+      IncType_t inc = getRCInc(*I);
+
+      errs() << "F: " << (inc < INC_MAX ? inc : -1U) << "; ";
+      (*I).first->print(errs());
+      errs() << ";";
+#ifdef DETAILED_DUMP
+      for (auto &s : RCSources[(*I).first]) {
+        s->print(errs());
+        errs() << "; ";
+      }
+      if (const Instruction *inst = dyn_cast<const Instruction>(I->first)) {
+        errs() << "(" << inst->getParent()->getParent()->getName() << ")";
+      }
+#endif
+      errs() << "\n";
+    }
+  }
+#ifdef DETAILED_DUMP
+  errs() << "RCStructSliceInfos\n";
+
+  if (false) {
+    for (auto it : RCStructInfos) {
+      it.first->print(errs());
+      errs() << ": ";
+      for (auto j : it.second) {
+        j->accessInstruction->dump();
+        errs() << j->baseOffset << ": ";
+        for (auto k : j->basePointers) {
+          k.first->print(errs());
+          errs() << "   ;   ";
+        }
+      }
+      errs() << "\n";
+    }
+    errs() << "\n";
+  }
+  if (pred) {
+    errs() << "SlicedPredecessors " << SlicedPredecessors.size() << "\n";
+    for (auto &p : SlicedPredecessors) {
+      p.first->print(errs());
+      errs() << ": ";
+      for (auto &i : p.second) {
+        i->print(errs());
+        errs() << *i << "(" << i->getParent()->getParent()->getName() << "); ";
+      }
+      errs() << "\n";
+    }
+    errs() << "\n";
+  }
+  if (false) {
+    errs() << "Translations:\n";
+
+    for (auto &t : translations) {
+      t.first->print(errs());
+      errs() << ": ";
+      for (auto &t2 : t.second) {
+        t2->print(errs());
+        errs() << ";";
+      }
+      errs() << "\n";
+    }
+  }
+#endif
+}
+
+InsInfo::InsInfo(const Instruction *i, const ptr::PointsToSets &PS,
+                 const mods::Modifies &MOD) : ins(i), sliced(true) {
+  typedef ptr::PointsToSets::PointsToSet PTSet;
+
+  unsigned opcode = i->getOpcode();
+
+  if (i->getName() == "X0_14582") {
+    assert(true);
+  }
+
+  switch (opcode) {
+    case Instruction::Load: {
+      const LoadInst *LI = (const LoadInst *) i;
+
+      BinaryOperator *BO = NULL;
+      IntToPtrInst *ItoP = NULL;
+      if (PatternMatch::match(LI->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_BinOp(BO)))) {
+        if (BO->getOpcode() == Instruction::Add || BO->getOpcode() == Instruction::Sub) {
+          ItoP = dyn_cast<IntToPtrInst>(LI->getOperand(0));
+          assert(ItoP);
+          Instruction *LoadInst = NULL;
+          Instruction *GetElem = NULL;
+          ConstantInt *Idx = NULL;
+          ConstantInt *Offset = NULL;
+
+          //All memory accesses that are not located on the stack (base pointer is not the stack pointer) are assumed
+          //to be struct elements
+          if (PatternMatch::match(BO->getOperand(0), PatternMatch::m_Instruction(LoadInst)) && LoadInst &&
+              LoadInst->getOpcode() ==
+              Instruction::Load &&
+              PatternMatch::match(
+                LoadInst->getOperand(
+                  0),
+                PatternMatch::m_Instruction(
+                  GetElem)) && GetElem &&
+              GetElem->getOpcode() ==
+              Instruction::GetElementPtr &&
+              PatternMatch::match(GetElem->getOperand(2), PatternMatch::m_ConstantInt(Idx)) && Idx &&
+              PatternMatch::match(BO, PatternMatch::m_BinOp(PatternMatch::m_Value(),
+                                                            PatternMatch::m_ConstantInt(Offset)))) {
+
+            auto findStackValue = [&](const Value *base, int64_t offset, std::set<Pointee> &REFs) {
+              bool found = false;
+
+              if (const Instruction *baseInst = dyn_cast<const Instruction>(base)) {
+                Instruction *SPInst = NULL;
+                Instruction *getElemPtr = NULL;
+                ConstantInt *Idx = NULL;
+                if (baseInst->getOpcode() == Instruction::Add &&
+                    PatternMatch::match(baseInst->getOperand(0), PatternMatch::m_Instruction(SPInst)) &&
+                    SPInst->getOpcode() == Instruction::Load &&
+                    PatternMatch::match(SPInst->getOperand(0), PatternMatch::m_Instruction(getElemPtr)) &&
+                    getElemPtr->getOpcode() == Instruction::GetElementPtr &&
+                    PatternMatch::match(getElemPtr->getOperand(2), PatternMatch::m_ConstantInt(Idx)) &&
+                    (Idx->getZExtValue() == 3 || Idx->getZExtValue() == 0)) {
+                  Function *f = (Function *) baseInst->getParent()->getParent();
+                  StackAccessPass *SAP = ptr::getAndersen()->getAnalysisIfAvailable<StackAccessPass>();
+                  if (!SAP)
+                    SAP = &ptr::getAndersen()->getAnalysis<StackAccessPass>();
+
+                  for (auto &baseStackOffset_it : *SAP->getOffsets(f)[baseInst]) {
+                    int64_t targetOffset = baseStackOffset_it + offset;
+                    if (!SAP->getOffsetValues(f)[targetOffset])
+                      continue;
+                    for (auto &target : *SAP->getOffsetValues(f)[targetOffset]) {
+                      ptr::PointsToSets::PointsToSet PtsTo = ptr::getPointsToSet(target, PS);
+                      for (auto &PtsTo_it : PtsTo) {
+                        REFs.insert(PtsTo_it);
+                        found = true;
+                      }
+                    }
+                  }
+                }
+              }
+
+              return found;
+            };
+
+            if (Idx->getZExtValue() != 0 && Idx->getZExtValue() != 3) {
+              ptr::PointsToSets::PointsToSet P = ptr::getPointsToSet(BO->getOperand(0), PS);
+              ptr::PointsToSets::PointsToSet P_loc = ptr::getPointsToSet(ItoP, PS);
+
+//                      //All memory accesses have their own pointer variable
+//                      assert(i->getNumUses() == 1);
+//                      assert(isa<const Instruction>(*i->user_begin()));
+              for (auto user_it : i->users()) {
+                StructSliceInfo *structSliceInfo = new StructSliceInfo(Offset->getZExtValue(), user_it);
+                std::set<Pointee> REFs;
+                for (auto &P_it : P) {
+                  if (!findStackValue(P_it.first, Offset->getZExtValue(), REFs))
+                    structSliceInfo->basePointers.insert(P_it);
+                }
+//                                if (P_loc.size() > 5) {
+//                                    i->dump();
+//                                    errs() << P_loc.size() << "\n";
+//                                }
+                for (auto &P_it : P_loc) {
+                  structSliceInfo->locations.insert(P_it);
+//                                    llvm_unreachable("");
+                }
+
+                for (auto &DEF_it : REFs) {
+                  addREF(DEF_it);
+                }
+
+                DEFStructInfos.insert(structSliceInfo);
+              }
+
+            }
+          }
+        }
+      }
+
+      addDEF(Pointee(i, -1));
+
+//      const Value *op = elimConstExpr(LI->getPointerOperand());
+      const Value *op = LI->getOperand(0);
+      const GetElementPtrInst *getElementPtrInst = dyn_cast<GetElementPtrInst>(op);
+      if (isa<ConstantPointerNull>(op)) {
+        errs() << "ERROR in analysed code -- reading from address 0 at " <<
+        i->getParent()->getParent()->getName() << ":\n";
+        i->print(errs());
+      } else if (isa<ConstantInt>(op)) {
+      } else {
+        if (getElementPtrInst) {
+          ConstantInt *Idx = dyn_cast<ConstantInt>(getElementPtrInst->getOperand(2));
+          if (Idx && Idx->getZExtValue() == 5) {
+            for (Instruction *I = (Instruction *) i; I != &i->getParent()->front(); I = I->getPrevNode()) {
+              if (I->getOpcode() == Instruction::Call) {
+//                          addREF(Pointee(I, -1));
+                break;
+              }
+            }
+          }
+          //TODO: should this be 1???
+//              addREF(Pointee(i, -1), 1);
+//              addREF(Pointee(i, -1));
+          addREF(Pointee(getElementPtrInst, -1));
+        }
+        //The address is not relevant
+//          addREF(Pointee(op, -1), DBL_MAX);
+        if (hasExtraReference(op)) {
+          addREF(Pointee(op, 0));
+        } else {
+          ConstantInt *address = nullptr;
+          bool refPtsTo = true;
+          if (PatternMatch::match(LI->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt(address)))) {
+            if (ptr::getAndersen()->getMachO().isClassRef(address->getZExtValue()) ||
+                ptr::getAndersen()->getMachO().isSelectorRef(address->getZExtValue())) {
+              refPtsTo = false;
+            }
+
+            if (ptr::getAndersen()->getMachO().isConstValue(address->getZExtValue())) {
+              refPtsTo = false;
+            }
+
+            std::string sectionName = ptr::getAndersen()->getMachO().getSectionName(address->getZExtValue());
+            if (sectionName == "__common") {
+              refPtsTo = false;
+
+              const PTSet &S2 = getPointsToSet(i->getOperand(0), PS);
+              for (PTSet::const_iterator I = S2.begin(), E = S2.end(); I != E; ++I)
+                addREF(*I, 1);
+            }
+          }
+
+          Value *Base = nullptr;
+          Instruction *IVAR = nullptr;
+          bool isIVAR = false;
+          if (PatternMatch::match(LI->getOperand(0), PatternMatch::m_IntToPtr(
+            PatternMatch::m_BinOp(PatternMatch::m_Value(Base),
+                                  PatternMatch::m_SExt(PatternMatch::m_Instruction(IVAR)))))) {
+            if (!isa<Constant>(Base)) {
+              const PTSet &S2 = getPointsToSet(IVAR, PS);
+              for (PTSet::const_iterator I = S2.begin(), E = S2.end(); I != E; ++I)
+                addREF(*I, 1);
+
+              refPtsTo = false;
+              isIVAR = true;
+            }
+          }
+
+          const PTSet &S = getPointsToSet(i, PS);
+          for (PTSet::const_iterator I = S.begin(), E = S.end(); I != E; ++I)
+            if (refPtsTo) {
+              addREF(*I, 1);
+//                      addDEF(*I);
+            } else {
+              addDEF(*I);
+            }
+
+          const PTSet &S1 = getPointsToSet(i->getOperand(0), PS);
+          for (PTSet::const_iterator I = S1.begin(), E = S1.end(); I != E; ++I) {
+            //The location the address points to is relevant
+            if (refPtsTo) {
+              addREF(*I, 1);
+//                      addDEF(*I);
+            } else {
+//                            addDEF(*I);
+            }
+          }
+
+        }
+      }
+      break;
+    }
+    case Instruction::Store: {
+      const StoreInst *SI = (const StoreInst *) i;
+      bool isConstString = false;
+
+      if (SI->getOperand(0)->getName() == "X0_14582") {
+        assert(true);
+      }
+
+      if (const ConstantInt *c = dyn_cast<ConstantInt>(SI->getOperand(0))) {
+        if (c->getBitWidth() <= 64) {
+          if (c->getZExtValue() == 4295000208) {
+            assert(true);
+          }
+          std::string secName = ptr::getAndersen()->getMachO().getSectionName(c->getZExtValue());
+          if (secName == "__cstring" || secName == "__cfstring") {
+            isConstString = true;
+          }
+          const PTSet &S = getPointsToSet(c, PS);
+          for (auto &s : S) {
+            addDEF(s);
+          }
+        }
+      }
+      addDEF(Pointee(i, -1));
+      const Value *l = SI->getOperand(1);// elimConstExpr(SI->getPointerOperand());
+//      const Value *l = elimConstExpr(SI->getPointerOperand());
+
+      bool isIVAR = false;
+
+      if (isa<ConstantPointerNull>(l)) {
+        errs() << "ERROR in analysed code -- writing to address 0 at " <<
+        i->getParent()->getParent()->getName() << ":\n";
+        i->print(errs());
+      } else if (isa<ConstantInt>(l)) {
+        addDEF(Pointee(l, -1));
+      } else {
+        if (hasExtraReference(l)) {
+          addDEF(Pointee(l, 0));
+        } else {
+          addREF(Pointee(SI->getOperand(1), -1));
+          const PTSet &S = getPointsToSet(l, PS);
+
+          for (auto &S_it : S) {
+            addDEF(S_it);
+          }
+
+//        for (PTSet::const_iterator I = S.begin(), E = S.end(); I != E; ++I)
+//          addDEF(*I);
+
+
+          Value *Base = nullptr;
+          Instruction *IVAR = nullptr;
+
+          if (PatternMatch::match(SI->getOperand(1), PatternMatch::m_IntToPtr(
+            PatternMatch::m_BinOp(PatternMatch::m_Value(Base),
+                                  PatternMatch::m_SExt(PatternMatch::m_Instruction(IVAR)))))) {
+            if (!isa<Constant>(Base)) {
+              isIVAR = true;
+              const PTSet &S2 = getPointsToSet(IVAR, PS);
+              for (PTSet::const_iterator I = S2.begin(), E = S2.end(); I != E; ++I)
+                addDEF(*I);
+            }
+          }
+        }
+
+
+        const Value *r = elimConstExpr(SI->getValueOperand());
+        const PTSet &S = getPointsToSet(r, PS);
+        bool skip = false;
+
+        if (S.size() == 1) {
+          const Value *x = S.begin()->first;
+          const Value *y = ptr::getAndersen()->getNodeFactory().getLocation(x);
+          if (y && isa<ConstantInt>(y)) {
+            if (((ConstantInt *) y)->getZExtValue() == 0) {
+              skip = true;
+            }
+          }
+        }
+
+        //This allows to trace the value stored here and not a value that was loaded before from the IVAR location...
+        if (!isIVAR && !isConstString && !skip) {
+          for (auto S_it : S) {
+            addREF(S_it, 1);
+          }
+        }
+
+        if (!l->getType()->isIntegerTy())
+          addREF(Pointee(l, -1));
+
+        if (!hasExtraReference(r) && !isConstantValue(r)) {
+          addREF(Pointee(r, -1), S.size() && !isIVAR ? INC_MAX : 1);
+        }
+
+        std::set<const Value *> visited;
+        std::function<void(const PHINode *)> addConstPHIRef = [&](const PHINode *phiNode) {
+          if (visited.find(phiNode) == visited.end()) {
+            visited.insert(phiNode);
+            for (unsigned k = 0; k < phiNode->getNumIncomingValues(); ++k) {
+              if (dyn_cast<const ConstantInt>(
+                phiNode->getIncomingValue(k))) {
+                addREF(Pointee(phiNode, -1), 1);
+              } else if (const PHINode *phiNode1 = dyn_cast<const PHINode>(
+                phiNode->getIncomingValue(k))) {
+                addConstPHIRef(phiNode1);
+              }
+            }
+          }
+        };
+
+        if (const PHINode *phiNode = dyn_cast<const PHINode>(r)) {
+          addConstPHIRef(phiNode);
+        }
+
+      }
+
+      if (const ConstantInt *addr = dyn_cast<const ConstantInt>(ins->getOperand(0))) {
+        if (addr->getBitWidth() <= 64) {
+          if (ptr::getAndersen()->getMachO().isCFString(addr->getZExtValue())) {
+            for (auto &ptsTo : ptr::getPointsToSet(addr, PS)) {
+              addDEF(ptsTo);
+            }
+          }
+        }
+      }
+
+      break;
+    }
+    case Instruction::GetElementPtr: {
+      addDEF(Pointee(i, -1));
+      break;
+    }
+    case Instruction::Call: {
+      const CallInst *C = (const CallInst *) i;
+
+      if (getSuccInBlock(i)->getName() == "LR_8188") {
+        assert(true);
+      }
+
+      const Value *cv = C->getCalledValue();
+
+
+      if (const IntToPtrInst *ItoP = dyn_cast<const IntToPtrInst>(C->getOperand(0))) {
+        addREF(Pointee(ItoP, -1));
+      } else if (C->getCalledValue() && !C->getCalledFunction()) {
+        addREF(Pointee(C->getCalledValue(), -1));
+      }
+
+
+      if (isInlineAssembly(C)) {
+        errs() << "ERROR: Inline assembler detected in " <<
+        i->getParent()->getParent()->getName() << ", ignoring\n";
+      } else if (isMemoryAllocation(cv)) {
+        if (!isConstantValue(C->getArgOperand(0)))
+          addREF(Pointee(C->getArgOperand(0), -1));
+        addDEF(Pointee(i, -1));
+      } else if (isMemoryDeallocation(cv)) {
+      } else if (isMemoryCopy(cv) || isMemoryMove(cv) || isMemorySet(cv)) {
+        const Value *len = elimConstExpr(C->getArgOperand(2));
+        uint64_t lenConst = getSizeOfMem(len);
+
+        const Value *l = elimConstExpr(C->getOperand(0));
+        addDEFArray(PS, l, lenConst);
+        addREF(Pointee(l, -1));
+
+        const Value *r = elimConstExpr(C->getOperand(1));
+        /* memset has a constant/variable there */
+        if (isMemoryCopy(cv) || isMemoryMove(cv))
+          addREFArray(PS, r, lenConst);
+        addREF(Pointee(r, -1));
+
+        /* memcpy/memset wouldn't work with len being 'undef' */
+        if (!isConstantValue(len))
+          addREF(Pointee(len, -1));
+      } else {
+        typedef std::vector<const llvm::Function *> CalledVec;
+
+        /* did we miss something? */
+        assert(!memoryManStuff(cv));
+
+//      if (const Function *F = dyn_cast<Function>(cv))
+        handleVariousFuns(PS, C);
+//      else
+//	addREF(Pointee(cv, -1));
+
+        CalledVec CV;
+        getCalledFunctions(C, PS, std::back_inserter(CV));
+
+        for (CalledVec::const_iterator f = CV.begin(); f != CV.end(); ++f) {
+          mods::Modifies::mapped_type const &M = getModSet(*f, MOD);
+          for (mods::Modifies::mapped_type::const_iterator v = M.begin();
+               v != M.end(); ++v) {
+            addDEF(*v);
+          }
+        }
+
+        if (!callToVoidFunction(C))
+          addDEF(Pointee(C, -1));
+      }
+
+      if (C->getCalledFunction() && C->getCalledFunction()->getName() == "memcpy") {
+        DetectParametersPass::UserSet_t X2_pre = DetectParametersPass::getRegisterValuesBeforeCall(7, C, false);
+        DetectParametersPass::UserSet_t X0_pre = DetectParametersPass::getRegisterValuesBeforeCall(5, C, false);
+
+        Andersen *andersen = ptr::getAndersen();
+
+        Andersen::StackOffsetMap_t stackOffsetMap = andersen->getStackOffsets();
+
+        for (auto &X2_it : X2_pre) {
+          if (const ConstantInt *size = dyn_cast<const ConstantInt>(X2_it)) {
+
+            for (auto &X0_it : X0_pre) {
+
+              ptr::PointsToSets::PointsToSet X0_ptsTo = ptr::getPointsToSet(X0_it, PS);
+
+              for (auto &X0pts_it : X0_ptsTo) {
+                auto &pairs = stackOffsetMap[X0pts_it.first];
+
+                for (auto &p_it : pairs) {
+
+                  int64_t lo = p_it.second;
+                  int64_t hi = p_it.second + size->getZExtValue();
+
+                  Function *f = (Function *) p_it.first;
+                  StackAccessPass::OffsetValueListMap_t &OffsetValues = andersen->getAnalysis<StackAccessPass>().getOffsetValues(
+                    f);
+                  for (auto &O_it : OffsetValues) {
+                    if (O_it.first <= lo || O_it.first >= hi)
+                      continue;
+
+                    if (!O_it.second)
+                      continue;
+                    for (auto &V_it: *O_it.second) {
+                      ptr::PointsToSets::PointsToSet defPtsTo = ptr::getPointsToSet(V_it, PS);
+                      for (auto &def_it : defPtsTo) {
+                        addDEF(def_it);
+
+                        int64_t offset = O_it.first - lo;
+
+                        defOffsets[def_it.first].insert(offset);
+                      }
+                    }
+                  }
+
+                }
+              }
+            }
+          }
+        }
+      }
+
+      break;
+    }
+
+
+    case Instruction::Add:
+    case Instruction::FAdd:
+    case Instruction::Sub:
+    case Instruction::FSub:
+    case Instruction::Mul:
+    case Instruction::FMul:
+    case Instruction::UDiv:
+    case Instruction::SDiv:
+    case Instruction::FDiv:
+    case Instruction::URem:
+    case Instruction::SRem:
+    case Instruction::FRem:
+    case Instruction::Shl:
+    case Instruction::LShr:
+    case Instruction::AShr:
+    case Instruction::And:
+    case Instruction::Or:
+    case Instruction::Xor: {
+      const BinaryOperator *BO = (const BinaryOperator *) i;
+
+      const PTSet &S = getPointsToSet(BO, PS);
+      bool add = true;
+      for (PTSet::iterator i = S.begin(); i != S.end(); ++i) {
+//          if (i->first == BO) {
+        add = false;
+//                addREF(*i, 1);
+//          }
+      }
+//      if (add)
+      addDEF(Pointee(i, -1));
+
+      if (!isConstantValue(BO->getOperand(0)))
+        addREF(Pointee(BO->getOperand(0), -1), 1);
+//          addREF(Pointee(BO->getOperand(0), -1));
+      if (!isConstantValue(BO->getOperand(1)))
+        addREF(Pointee(BO->getOperand(1), -1), 1);
+//          addREF(Pointee(BO->getOperand(1), -1));
+
+      break;
+    }
+    case Instruction::IntToPtr: {
+      addDEF(Pointee(i, -1));
+      addREF(Pointee(i->getOperand(0), -1));
+      break;
+    }
+    case Instruction::Trunc:
+    case Instruction::ZExt:
+    case Instruction::SExt:
+    case Instruction::FPToUI:
+    case Instruction::FPToSI:
+    case Instruction::UIToFP:
+    case Instruction::SIToFP:
+    case Instruction::FPTrunc:
+    case Instruction::FPExt:
+    case Instruction::PtrToInt:
+    case Instruction::BitCast: {
+      const CastInst *CI = (const CastInst *) i;
+      addDEF(Pointee(i, -1));
+
+      if (!hasExtraReference(CI->getOperand(0)))
+        addREF(Pointee(CI->getOperand(0), -1), 1); //TODO: always increment by 1?
+      break;
+    }
+    case Instruction::ICmp:
+    case Instruction::FCmp: {
+      const CmpInst *CI = (const CmpInst *) i;
+
+      addDEF(Pointee(i, -1));
+
+      if (!isConstantValue(CI->getOperand(0)))
+        addREF(Pointee(CI->getOperand(0), -1), 1);
+      if (!isConstantValue(CI->getOperand(1)))
+        addREF(Pointee(CI->getOperand(1), -1), 1);
+      break;
+    }
+    case Instruction::Br:
+    case Instruction::IndirectBr: {
+      const BranchInst *BI = (const BranchInst *) i;
+
+      if (BI->isConditional() && !isConstantValue(BI->getCondition()))
+        addREF(Pointee(BI->getCondition(), -1));
+      break;
+    }
+    case Instruction::PHI: {
+      std::set<const Value *> visitedPhi;
+      std::function<void(const PHINode *)> addConst = [&](const PHINode *phiNode) {
+        if (visitedPhi.find(phiNode) == visitedPhi.end()) {
+          visitedPhi.insert(phiNode);
+          for (unsigned k = 0; k < phiNode->getNumIncomingValues(); ++k) {
+            if (const ConstantInt *constantInt = dyn_cast<const ConstantInt>(
+              phiNode->getIncomingValue(k))) {
+              addDEF(Pointee(constantInt, -1));
+            } else if (const PHINode *phiNode1 = dyn_cast<const PHINode>(phiNode->getIncomingValue(k))) {
+              addConst(phiNode1);
+            }
+          }
+        }
+      };
+
+      const PHINode *phi = (const PHINode *) i;
+
+      addDEF(Pointee(i, -1));
+
+      for (unsigned k = 0; k < phi->getNumIncomingValues(); ++k) {
+        const Value *p = phi->getIncomingValue(k);
+
+        if (!isa<const ConstantInt>(p))
+          continue;
+
+//        if (!isConstantValue(phi->getIncomingValue(k)))
+//                addREF(Pointee(phi->getIncomingValue(k), -1), 1.0);
+//                addDEF(Pointee(phi->getIncomingValue(k), -1));
+        ptr::PointsToSets::PointsToSet PtsTo = ptr::getPointsToSet(phi->getIncomingValue(k), PS);
+        for (auto &p : PtsTo) {
+          addDEF(p);
+//                    addREF(p, 1.0);
+        }
+      }
+      break;
+    }
+    case Instruction::Select: {
+      const SelectInst *SI = (const SelectInst *) i;
+      // TODO: THE FOLLOWING CODE HAS NOT BEEN TESTED YET
+
+      addDEF(Pointee(i, -1));
+
+      if (!isConstantValue(SI->getCondition()))
+        addREF(Pointee(SI->getCondition(), -1));
+      if (!isConstantValue(SI->getTrueValue()))
+        addREF(Pointee(SI->getTrueValue(), -1));
+      if (!isConstantValue(SI->getFalseValue()))
+        addREF(Pointee(SI->getFalseValue(), -1));
+      break;
+    }
+    case Instruction::ExtractValue: {
+      const ExtractValueInst *EV = (const ExtractValueInst *) i;
+      addDEF(Pointee(i, -1));
+      addREF(Pointee(EV->getAggregateOperand(), -1));
+      break;
+    }
+    case Instruction::Unreachable:
+    case Instruction::Ret: {
+      break;
+    }
+    default:
+      DEBUG(errs() << "ERROR: Unsupported instruction reached\n";
+              i->dump(););
+      break;
+  }
+
+//if (const AllocaInst *AI = dyn_cast<const AllocaInst>(i)) {
+//      addDEF(Pointee(AI, -1));
+//    if (!isConstantValue(AI->getArraySize()))
+//      addREF(Pointee(AI->getArraySize(), -1));
+//  } else if (const CmpInst *CI = dyn_cast<const CmpInst>(i)) {
+//  } else if (const BranchInst *BI = dyn_cast<const BranchInst>(i)) {
+//  } else if (const PHINode *phi = dyn_cast<const PHINode>(i)) {
+//  } else if (const SwitchInst *SI = dyn_cast<SwitchInst>(i)) {
+//    if (!isConstantValue(SI->getCondition()))
+//      addREF(Pointee(SI->getCondition(), -1));
+//  } else if (const SelectInst *SI = dyn_cast<const SelectInst>(i)) {
+//  } else if (isa<const UnreachableInst>(i)) {
+//  } else if (const ExtractValueInst *EV = dyn_cast<const ExtractValueInst>(i)) {
+//  } else if (const InsertValueInst *IV = dyn_cast<const InsertValueInst>(i)) {
+////      TODO THE FOLLOWING CODE HAS NOT BEEN TESTED YET
+//
+//      const Value *r = IV->getInsertedValueOperand();
+//      addDEF(Pointee(IV->getAggregateOperand(), -1));
+//      if (!isConstantValue(r))
+//	addREF(Pointee(r, -1));
+//  } else {
+//
+//  }
+
+}
+
+void InsInfo::deslice(FunctionStaticSlicer *FSS) {
+  sliced = false;
+}
+
+namespace {
+  class FunctionSlicer : public ModulePass {
+  public:
+    static char ID;
+
+    FunctionSlicer() : ModulePass(ID) { }
+
+    virtual bool runOnModule(Module &M);
+
+    void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.addRequired<PostDominatorTree>();
+      AU.addRequired<PostDominanceFrontier>();
+
+      AU.addPreserved<PostDominatorTree>();
+      AU.addPreserved<PostDominanceFrontier>();
+    }
+
+  private:
+    bool runOnFunction(Function &F, const ptr::PointsToSets &PS,
+                       const mods::Modifies &MOD);
+  };
+}
+
+static RegisterPass<FunctionSlicer> X("slice", "Slices the code");
+char FunctionSlicer::ID;
+
+FunctionStaticSlicer::~FunctionStaticSlicer() {
+  for (InsInfoMap::const_iterator I = insInfoMap.begin(), E = insInfoMap.end();
+       I != E; I++)
+    delete I->second;
+}
+
+typedef llvm::SmallVector<const Instruction *, 10> SuccList;
+
+static SuccList getSuccList(const Instruction *i) {
+  SuccList succList;
+  const BasicBlock *bb = i->getParent();
+  if (i != &bb->back()) {
+    BasicBlock::const_iterator I(i);
+    I++;
+    succList.push_back(&*I);
+  } else {
+    for (succ_const_iterator I = succ_begin(bb), E = succ_end(bb); I != E; I++)
+      succList.push_back(&(*I)->front());
+  }
+  return succList;
+}
+
+void FunctionStaticSlicer::initializeInfos() {
+
+  std::unique_lock<std::mutex> lock(initLock);
+
+  if (infosInitialized) {
+    return;
+  }
+  infosInitialized = true;
+
+  for (llvm::inst_iterator I = llvm::inst_begin(fun), E = llvm::inst_end(fun);
+       I != E; ++I)
+    insInfoMap.insert(InsInfoMap::value_type(&*I, new InsInfo(&*I, PS, mods)));
+//
+//      for (llvm::inst_iterator I = llvm::inst_begin(F); I != llvm::inst_end(F); ++I) {
+//          if (I->getOpcode() == Instruction::Call && F.getName() != "_EXTERNAL_") {
+//              SimpleCallGraph::FunctionSet_t Called = ptr::getSimpleCallGraph().getCalled(&*I);
+//              for (SimpleCallGraph::FunctionSet_t::iterator Called_it = Called.begin(); Called_it != Called.end(); ++Called_it) {
+//                  Function *Called_F = F.getParent()->getFunction(*Called_it);
+//                  if (!Called_F)
+//                      continue;
+//                  DetectParametersPass::ParameterAccessPairSet_t Returns = ptr::getDetectParametersPass().getReturnRegisterIndexes(Called_F);
+//
+//                  for (DetectParametersPass::ParameterAccessPairSet_t::iterator Return_it = Returns.begin(); Return_it != Returns.end(); ++Return_it) {
+//                      DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(Return_it->first, &*I);
+//
+//                      for (DetectParametersPass::UserSet_t::iterator Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+//                          if (Instruction *Inst = dyn_cast<Instruction>(*Post_it)) {
+//                              getInsInfo(Inst)->addREF(ptr::PointsToSets::Pointee(Return_it->second, -1));
+//                          }
+//                      }
+//                  }
+//              }
+//          }
+//      }
+
+  SimpleCallGraph::InstructionSet_t Callers = ptr::getSimpleCallGraph().getCallers(fun.getName());
+
+  DetectParametersPass::ParameterAccessPairSet_t Params = ptr::getDetectParametersPass().getParameterRegisterIndexes(
+    &fun);
+  for (DetectParametersPass::ParameterAccessPairSet_t::iterator Params_it = Params.begin();
+       Params_it != Params.end(); ++Params_it) {
+
+//        for (SimpleCallGraph::InstructionSet_t::iterator Caller_it = Callers.begin(); Caller_it != Callers.end(); ++Caller_it) {
+//            if ((*Caller_it)->getParent()->getParent()->getName() == "_EXTERNAL_")
+//                continue;
+//            const CallInst *call = dyn_cast<const CallInst>(*Caller_it);
+//            if (!call) {
+//                llvm_unreachable("A caller has to be a call instruction...");
+//            }
+//            DetectParametersPass::UserSet_t Pre = DetectParametersPass::getRegisterValuesBeforeCall(Params_it->first, (Instruction*)(*Caller_it), true);
+//            for (DetectParametersPass::UserSet_t::iterator Pre_it = Pre.begin(); Pre_it != Pre.end(); ++Pre_it) {
+//                InsInfo *info = getInsInfo(Params_it->second);
+////                info->clearREF();
+//                info->addREF(ptr::PointsToSets::Pointee(*Pre_it, -1), 1);
+//
+//                Instruction *param = dyn_cast<Instruction>(*Pre_it);
+//                if (!param) {
+//                    llvm_unreachable("this has to be a store instruction!");
+//                }
+//            }
+//        }
+    InsInfo *info = getInsInfo(Params_it->second);
+    info->addREF(ptr::PointsToSets::Pointee(Params_it->second, -1), 1);
+  }
+
+  DetectParametersPass &DPP = ptr::getAndersen()->getAnalysis<DetectParametersPass>();
+
+  for (inst_iterator I_it = inst_begin(fun); I_it != inst_end(fun); ++I_it) {
+    if (I_it->getOpcode() == Instruction::Call) {
+      CallInst *call = (CallInst *) &*I_it;
+      if (call->getCalledFunction() &&
+          (call->getCalledFunction()->isIntrinsic() || call->getCalledFunction()->isDeclaration())) {
+
+        //Add a 'self-REF' for a parameter/return value that is defined by an external function
+        InsInfo *callInfo = getInsInfo(call);
+        for (ValSet::const_iterator DEF_it = callInfo->DEF_begin(); DEF_it != callInfo->DEF_end(); ++DEF_it) {
+          if (const Instruction *defInst = dyn_cast<const Instruction>(DEF_it->first)) {
+            if (defInst->getOpcode() == Instruction::Load &&
+                defInst->getParent()->getParent() == call->getParent()->getParent()) {
+              getInsInfo(defInst)->addREF(Pointee(defInst, -1), 1);
+            }
+          }
+        }
+
+//                continue;
+      } else if (!call->getCalledFunction()) {
+        continue;
+      }
+      DetectParametersPass::UserSet_t PostX0 = DetectParametersPass::getRegisterValuesAfterCall(5, call);
+
+      Module *M = call->getParent()->getParent()->getParent();
+      SimpleCallGraph::FunctionSet_t called = ptr::getSimpleCallGraph().getCalled(call);
+
+      for (std::string functionName : called) {
+        if (functionName == "-[ViewController getIterations]") {
+          assert(true);
+        }
+        Function *function = M->getFunction(functionName);
+        if (!function) {
+          continue;
+        }
+
+
+        DetectParametersPass::ParameterAccessPairSet_t &Ret = DPP.getReturnRegisterIndexes(function);
+
+        for (auto &r_it : Ret) {
+          Value *ref = nullptr;
+          if (r_it.second->getOpcode() == Instruction::Store) {
+            ref = r_it.second->getOperand(0);
+          } else {
+            ref = r_it.second;
+          }
+          assert(r_it.first == 5);
+          for (auto &post_it : PostX0) {
+            getInsInfo(dyn_cast<Instruction>(post_it))->addREF(Pointee(ref, -1), 1);
+          }
+        }
+      }
+    }
+  }
+}
+
+bool FunctionStaticSlicer::sameValues(const Pointee &val1, const Pointee &val2) {
+  return val1.first == val2.first && val1.second == val2.second;
+}
+
+/*
+ * RC(i)=RC(i) \cup
+ *   {v| v \in RC(j), v \notin DEF(i)} \cup
+ *   {v| v \in REF(i), DEF(i) \cap RC(j) \neq \emptyset}
+ */
+bool FunctionStaticSlicer::computeRCi(InsInfo *insInfoi, InsInfo *insInfoj) {
+  bool changed = false;
+
+  if (insInfoj->getIns()->getName() == "LR_6524") {
+    assert(true);
+  }
+
+  if (insInfoi->getIns()->getOpcode() == Instruction::Call) {
+    const CallInst *callInst = dyn_cast<const CallInst>(insInfoi->getIns());
+    if (callInst->getCalledFunction() && callInst->getCalledFunction()->getName() == "memcpy") {
+      DetectParametersPass::UserSet_t X2_pre = DetectParametersPass::getRegisterValuesBeforeCall(7, callInst, false);
+      DetectParametersPass::UserSet_t X1_pre = DetectParametersPass::getRegisterValuesBeforeCall(6, callInst, false);
+      DetectParametersPass::UserSet_t X0_pre = DetectParametersPass::getRegisterValuesBeforeCall(5, callInst, false);
+
+      for (auto &X2_pre_it : X2_pre) {
+        const ConstantInt *size = dyn_cast<const ConstantInt>(X2_pre_it);
+        //We consider only copies of known size because a structs size is known at compile time (other cases signal that we don't have a struct here)
+        if (!size)
+          continue;
+
+        auto findStackValue = [&](const Value *base, int64_t offset, std::set<Pointee> &REFs) {
+          bool found = false;
+
+          if (const Instruction *baseInst = dyn_cast<const Instruction>(base)) {
+            Instruction *SPInst = NULL;
+            Instruction *getElemPtr = NULL;
+            ConstantInt *Idx = NULL;
+            if (baseInst->getOpcode() == Instruction::Add &&
+                PatternMatch::match(baseInst->getOperand(0), PatternMatch::m_Instruction(SPInst)) &&
+                SPInst->getOpcode() == Instruction::Load &&
+                PatternMatch::match(SPInst->getOperand(0), PatternMatch::m_Instruction(getElemPtr)) &&
+                getElemPtr->getOpcode() == Instruction::GetElementPtr &&
+                PatternMatch::match(getElemPtr->getOperand(2), PatternMatch::m_ConstantInt(Idx)) &&
+                (Idx->getZExtValue() == 3 || Idx->getZExtValue() == 0)) {
+              Function *f = (Function *) baseInst->getParent()->getParent();
+              StackAccessPass *SAP = ptr::getAndersen()->getAnalysisIfAvailable<StackAccessPass>();
+              if (!SAP)
+                SAP = &ptr::getAndersen()->getAnalysis<StackAccessPass>();
+
+              for (auto &baseStackOffset_it : *SAP->getOffsets(f)[baseInst]) {
+                int64_t targetOffset = baseStackOffset_it + offset;
+                if (!SAP->getOffsetValues(f)[targetOffset])
+                  continue;
+                for (auto &target : *SAP->getOffsetValues(f)[targetOffset]) {
+                  ptr::PointsToSets::PointsToSet PtsTo = ptr::getPointsToSet(target, PS);
+                  for (auto &PtsTo_it : PtsTo) {
+                    REFs.insert(PtsTo_it);
+
+                    found = true;
+                  }
+                }
+              }
+            }
+          }
+
+          return found;
+        };
+
+
+//                for (ValSet::const_iterator DEF_it = insInfoi->DEF_begin(); DEF_it != insInfoi->DEF_end(); ++DEF_it) {
+        for (ValSet::const_iterator RC_it = insInfoj->RC_begin(); RC_it != insInfoj->RC_end(); ++RC_it) {
+
+          for (InsInfo::StructSliceInfoSet_t::const_iterator ssi_it = insInfoj->RCStruct_begin(RC_it->first);
+               ssi_it != insInfoj->RCStruct_end(RC_it->first); ++ssi_it) {
+            //Check if the value gets copied here
+            if ((*ssi_it)->baseOffset < (int64_t) size->getZExtValue()) {
+
+              for (auto &X0_it : X0_pre) {
+                ptr::PointsToSets::PointsToSet X0_ptsTo = ptr::getPointsToSet(X0_it, PS);
+                bool usesBase = false;
+                for (auto X0_pts_it : X0_ptsTo) {
+                  for (auto base_it : (*ssi_it)->basePointers) {
+                    if (X0_pts_it == base_it) {
+                      usesBase = true;
+                      break;
+                    }
+
+                  }
+                }
+                if (!usesBase)
+                  continue;
+
+                for (auto X1_it : X1_pre) {
+
+                  std::set<Pointee> REFs;
+                  if (findStackValue(X1_it, (*ssi_it)->baseOffset, REFs)) {
+                    for (auto &RC_new : REFs) {
+                      insInfoi->addRC(RC_new, (*ssi_it)->accessInstruction, insInfoProvider, 1);
+                    }
+                  } else if (const ConstantInt *constAddr = dyn_cast<const ConstantInt>(X1_it)) {
+                    ConstantInt *addr = ConstantInt::get(getGlobalContext(), APInt(64,
+                                                                                   constAddr->getZExtValue() +
+                                                                                   (*ssi_it)->baseOffset));
+                    changed |= insInfoi->addREF(Pointee(addr, -1), insInfoj->getRCInc(*RC_it));
+//                                            changed |= insInfoi->addRC(Pointee(addr, -1), insInfoi->getIns(), 1);
+//                                            changed |= insInfoi->addDEF(*RC_it);
+                    for (auto &loc_it : (*ssi_it)->locations) {
+                      changed |= insInfoi->addDEF(loc_it);
+                      if (changed) {
+                        DEBUG(errs() << "TRANSLATE: ";
+                                loc_it.first->print(errs());
+                                errs() << " to " << utohexstr(addr->getZExtValue()) << "\n";);
+                        insInfoi->addTranslation(loc_it.first, addr);
+                      }
+                    }
+                  } else {
+                    if (PatternMatch::match(X1_it,
+                                            PatternMatch::m_BinOp(PatternMatch::m_Value(),
+                                                                  PatternMatch::m_ConstantInt()))) {
+                      //TODO:
+//                                                errs() << "TODO: stack stored struct?\n";
+                    } else {
+                      //The argument represents the new base pointer
+                      StructSliceInfo *ssiNew = new StructSliceInfo((*ssi_it)->baseOffset, callInst);
+
+                      ssiNew->basePointers = ptr::getPointsToSet(X1_it, PS);
+
+                      bool alreadyDefined = false;
+                      for (auto s_it : getInsInfo(callInst)->getDEFStructSliceInfos()) {
+                        if (s_it->basePointers == ssiNew->basePointers &&
+                            s_it->baseOffset == ssiNew->baseOffset &&
+                            s_it->accessInstruction == ssiNew->accessInstruction) {
+                          alreadyDefined = true;
+
+                          for (auto &l : s_it->locations) {
+                            changed |= getInsInfo(callInst)->addREF(l, insInfoj->getRCInc(*RC_it));
+                          }
+                        }
+                      }
+
+                      if (alreadyDefined) {
+                        delete (ssiNew);
+                        continue;
+                      }
+
+                      Value *dummy = new llvm::GlobalVariable(*fun.getParent(),
+                                                              llvm::IntegerType::get(
+                                                                llvm::getGlobalContext(),
+                                                                1), false,
+                                                              llvm::GlobalVariable::ExternalLinkage,
+                                                              nullptr);
+                      ssiNew->locations.insert(Pointee(dummy, -1));
+//                                            changed |= getInsInfo(dyn_cast<Instruction>(baseLoadInst->getOperand(0)))->addREF(Pointee(dummy, -1));
+                      changed |= getInsInfo(callInst)->addREF(Pointee(dummy, -1),
+                                                              insInfoj->getRCInc(*RC_it));
+
+                      //TODO: maybe add an own function for adding struct infos...
+                      getInsInfo(callInst)->getDEFStructSliceInfos().insert(ssiNew);
+
+                      for (auto l : (*ssi_it)->locations) {
+                        changed |= getInsInfo(callInst)->addDEF(l);
+                        insInfoi->addTranslation(l.first, dummy);
+                      }
+                    }
+
+                  }
+                }
+              }
+            }
+          }
+        }
+//                }
+      }
+    }
+  }
+
+  if (insInfoi->getIns()->getOpcode() == Instruction::IntToPtr) {
+    ptr::PointsToSets::PointsToSet locPts = ptr::getPointsToSet(insInfoi->getIns()->getOperand(0), PS);
+    for (ValSet::const_iterator RC_it = insInfoj->RC_begin(); RC_it != insInfoj->RC_end(); ++RC_it) {
+      for (InsInfo::StructSliceInfoSet_t::const_iterator ssi_it = insInfoj->RCStruct_begin(RC_it->first);
+           ssi_it != insInfoj->RCStruct_end(RC_it->first); ++ssi_it) {
+
+        bool intersect = false;
+        for (auto &loc_it : locPts) {
+          for (auto &base_it : (*ssi_it)->basePointers) {
+            if (loc_it == base_it) {
+              intersect = true;
+              break;
+            }
+          }
+        }
+
+        //This means that the base pointer was not used...
+        if (!intersect) {
+          continue;
+        }
+
+        assert(insInfoi->getIns()->getNumUses() == 1);
+        const StoreInst *baseStoreInst = dyn_cast<const StoreInst>(*insInfoi->getIns()->user_begin());
+        if (!baseStoreInst)
+          continue;
+
+        uint64_t storeSize =
+          baseStoreInst->getOperand(1)->getType()->getPointerElementType()->getPrimitiveSizeInBits() /
+          8;
+
+        int64_t baseStoreOffset = 0;
+
+        ConstantInt *baseStoreOffsetValue = NULL;
+        Value *basePointer = NULL;
+        if (PatternMatch::match(baseStoreInst->getOperand(1), PatternMatch::m_IntToPtr(
+          PatternMatch::m_BinOp(PatternMatch::m_Value(basePointer),
+                                PatternMatch::m_ConstantInt(baseStoreOffsetValue))))) {
+          baseStoreOffset = baseStoreOffsetValue->getZExtValue();
+        }
+
+        if ((int64_t) storeSize < (*ssi_it)->baseOffset) {
+          for (Instruction *I_it = ((Instruction *) baseStoreInst)->getPrevNode();
+               I_it != &I_it->getParent()->front(); I_it = I_it->getPrevNode()) {
+            if (const StoreInst *s2 = dyn_cast<const StoreInst>(I_it)) {
+
+              ConstantInt *offset2_1 = NULL;
+              ConstantInt *offset2_2 = NULL;
+
+              int64_t offset2 = 0;
+              bool match = false;
+
+              if (PatternMatch::match(s2->getOperand(1), PatternMatch::m_IntToPtr(
+                PatternMatch::m_BinOp(PatternMatch::m_Specific(basePointer),
+                                      PatternMatch::m_ConstantInt(offset2_1))))) {
+                offset2 = offset2_1->getZExtValue();
+                match = true;
+              } else if (PatternMatch::match(s2->getOperand(1), PatternMatch::m_IntToPtr(
+                PatternMatch::m_BinOp(
+                  PatternMatch::m_BinOp(PatternMatch::m_Specific(basePointer),
+                                        PatternMatch::m_ConstantInt(offset2_1)),
+                  PatternMatch::m_ConstantInt(offset2_2))))) {
+                match = true;
+                offset2 = offset2_1->getZExtValue() + offset2_2->getZExtValue();
+              }
+              if (match) {
+                if (baseStoreOffset + (int64_t) storeSize != offset2) {
+//                                    assert(false);
+                  continue;
+                }
+                uint64_t s2Size = s2->getOperand(
+                  1)->getType()->getPointerElementType()->getPrimitiveSizeInBits() / 8;
+
+                //The current store writes to the structs element
+                if ((int64_t) (storeSize + s2Size) >= (*ssi_it)->baseOffset) {
+                  if (const LoadInst *baseLoadInst = dyn_cast<const LoadInst>(
+                    baseStoreInst->getOperand(0))) {
+                    Value *srcBase = NULL;
+
+                    //TODO: does this always mean, that a sub-struct gets copied?
+                    if (PatternMatch::match(baseLoadInst->getOperand(0),
+                                            PatternMatch::m_IntToPtr(
+                                              PatternMatch::m_BinOp()))) {
+//                                            assert(PatternMatch::match(baseLoadInst, PatternMatch::m_IntToPtr(srcBase)));
+                      srcBase = ((Instruction *) baseLoadInst->getOperand(0))->getOperand(0);
+
+                      //TODO: stack pointers need to be handled separately!?
+                      const Value *baseNew = ((Instruction *) srcBase)->getOperand(0);
+                      if (isStackPointer(baseNew)) {
+                        continue;
+                        assert(false);
+                      }
+
+
+                      const ConstantInt *srcBaseOffset = dyn_cast<const ConstantInt>(
+                        ((Instruction *) srcBase)->getOperand(1));
+                      assert(srcBaseOffset);
+                      ptr::PointsToSets::PointsToSet PtsTo = ptr::getPointsToSet(srcBase, PS);
+
+                      for (auto &x : (*ssi_it)->locations) {
+                        changed |= getInsInfo(s2)->addDEF(x);
+                      }
+
+                      StructSliceInfo *ssiNew = new StructSliceInfo(
+                        srcBaseOffset->getZExtValue() + (*ssi_it)->baseOffset,
+                        baseLoadInst);
+
+                      ptr::PointsToSets::PointsToSet ptsToNew = ptr::getPointsToSet(baseNew,
+                                                                                    PS);
+                      ssiNew->basePointers.insert(Pointee(baseNew, -1));
+                      for (auto pts_it : ptsToNew) {
+                        ssiNew->basePointers.insert(pts_it);
+                      }
+
+                      bool alreadyDefined = false;
+//                                            for (auto s_it : getInsInfo(dyn_cast<Instruction>(baseLoadInst->getOperand(0)))->getDEFStructSliceInfos()) {
+                      for (auto s_it : getInsInfo(s2)->getDEFStructSliceInfos()) {
+                        if (s_it->basePointers == ssiNew->basePointers &&
+                            s_it->baseOffset == ssiNew->baseOffset &&
+                            s_it->accessInstruction == ssiNew->accessInstruction) {
+                          alreadyDefined = true;
+                          break;
+                        }
+                      }
+
+                      if (alreadyDefined) {
+                        delete (ssiNew);
+                        continue;
+                      }
+
+
+                      Value *dummy = new llvm::GlobalVariable(*fun.getParent(),
+                                                              llvm::IntegerType::get(
+                                                                llvm::getGlobalContext(),
+                                                                1), false,
+                                                              llvm::GlobalVariable::ExternalLinkage,
+                                                              nullptr);
+
+                      for (auto &x : (*ssi_it)->locations) {
+                        getInsInfo(s2)->addTranslation(x.first, dummy);
+                      }
+
+                      ssiNew->locations.insert(Pointee(dummy, -1));
+//                                            changed |= getInsInfo(dyn_cast<Instruction>(baseLoadInst->getOperand(0)))->addREF(Pointee(dummy, -1));
+                      changed |= getInsInfo(s2)->addREF(Pointee(dummy, -1),
+                                                        insInfoj->getRCInc(*RC_it));
+
+                      //TODO: maybe add an own function for adding struct infos...
+//                                            getInsInfo(dyn_cast<Instruction>(baseLoadInst->getOperand(0)))->getDEFStructSliceInfos().insert(ssiNew);
+                      getInsInfo(s2)->getDEFStructSliceInfos().insert(ssiNew);
+
+
+                    } else if (PatternMatch::match(baseLoadInst->getOperand(0),
+                                                   PatternMatch::m_IntToPtr(
+                                                     PatternMatch::m_Value(srcBase)))) {
+//                                            assert(false);
+                    }
+                  }
+                }
+              }
+            } else if (I_it->getOpcode() == Instruction::Call) {
+              break;
+            }
+          }
+        }
+      }
+    }
+
+  }
+
+  /* {v| v \in RC(j), v \notin DEF(i)} */
+  for (ValSet::const_iterator I = insInfoj->RC_begin(),
+         E = insInfoj->RC_end(); I != E; I++) {
+    const Pointee &RCj = *I;
+    bool in_DEF = false;
+    for (ValSet::const_iterator II = insInfoi->DEF_begin(),
+           EE = insInfoi->DEF_end(); II != EE; II++) {
+      if (sameValues(*II, RCj)) {
+        in_DEF = true;
+        break;
+      }
+    }
+    if (!in_DEF) {
+
+      const InsInfo::ValSet_t &RCSources = insInfoj->getRCSource(RCj);
+      if (insInfoi->addRC(RCj, RCSources, insInfoProvider, insInfoj->getRCInc(RCj))) {
+        changed = true;
+      }
+
+      for (InsInfo::StructSliceInfoSet_t::const_iterator b = insInfoj->RCStruct_begin(RCj.first);
+           b != insInfoj->RCStruct_end(RCj.first); ++b) {
+        insInfoi->addRCStruct(RCj.first, *b);
+      }
+    }
+  }
+  /* DEF(i) \cap RC(j) \neq \emptyset */
+  bool isect_nonempty = false;
+  IncType_t f_RC_min = INC_MAX;
+  InsInfo::StructSliceInfoSet_t structInfos;
+  for (ValSet::const_iterator I = insInfoi->DEF_begin(),
+//       E = insInfoi->DEF_end(); I != E && !isect_nonempty; I++) {
+         E = insInfoi->DEF_end(); I != E; I++) {
+    const Pointee &DEFi = *I;
+    for (ValSet::const_iterator II = insInfoj->RC_begin(),
+           EE = insInfoj->RC_end(); II != EE; II++) {
+      if (sameValues(DEFi, *II)) {
+        InsInfo::DefOffsets_t &defOffsets = insInfoi->getDEFOffset();
+        if (defOffsets.find(DEFi.first) != defOffsets.end()) {
+
+          DetectParametersPass::UserSet_t X1_pre = DetectParametersPass::getRegisterValuesBeforeCall(6,
+                                                                                                     insInfoi->getIns(),
+                                                                                                     false);
+
+          for (auto &X1_it : X1_pre) {
+            if (const ConstantInt *baseAddr = dyn_cast<const ConstantInt>(X1_it)) {
+              for (auto &o : defOffsets[DEFi.first]) {
+                ConstantInt *addr = ConstantInt::get(getGlobalContext(), APInt(64,
+                                                                               baseAddr->getZExtValue() +
+                                                                               o));
+                changed |= insInfoi->addREF(Pointee(addr, -1), insInfoj->getRCInc(*II));
+                insInfoi->addTranslation(DEFi.first, addr);
+              }
+            } else {
+              for (auto &o : defOffsets[DEFi.first]) {
+                StructSliceInfo *ssiNew = new StructSliceInfo(o, insInfoi->getIns());
+
+                ptr::PointsToSets::PointsToSet X1PtsTo = ptr::getPointsToSet(X1_it, PS);
+                for (auto &X1PtsTo_it : X1PtsTo) {
+                  ssiNew->basePointers.insert(X1PtsTo_it);
+                }
+
+                bool alreadyDefined = false;
+//                                            for (auto s_it : getInsInfo(dyn_cast<Instruction>(baseLoadInst->getOperand(0)))->getDEFStructSliceInfos()) {
+                for (auto &ssi_it : insInfoi->getDEFStructSliceInfos()) {
+                  if (ssi_it->basePointers == ssiNew->basePointers &&
+                      ssi_it->baseOffset == ssiNew->baseOffset &&
+                      ssi_it->accessInstruction == ssiNew->accessInstruction) {
+                    alreadyDefined = true;
+                    break;
+                  }
+                }
+
+                if (alreadyDefined) {
+                  delete (ssiNew);
+                  continue;
+                }
+
+
+                Value *dummy = new llvm::GlobalVariable(*fun.getParent(),
+                                                        llvm::IntegerType::get(llvm::getGlobalContext(), 1), false,
+                                                        llvm::GlobalVariable::ExternalLinkage,
+                                                        nullptr);
+
+                ssiNew->locations.insert(Pointee(dummy, -1));
+//                                            changed |= getInsInfo(dyn_cast<Instruction>(baseLoadInst->getOperand(0)))->addREF(Pointee(dummy, -1));
+                changed |= insInfoi->addREF(Pointee(dummy, -1),
+                                            insInfoj->getRCInc(*II));
+
+                insInfoi->getDEFStructSliceInfos().insert(ssiNew);
+              }
+
+            }
+          }
+
+        }
+
+        isect_nonempty = true;
+        IncType_t RC_inc = insInfoj->getRCInc(*II);
+        f_RC_min = RC_inc < f_RC_min ? RC_inc : f_RC_min;
+
+//          for (InsInfo::StructSliceInfoSet_t::const_iterator b = insInfoj->RCStruct_begin(II->first); b != insInfoj->RCStruct_end(II->first); ++b) {
+//              structInfos.insert(*b);
+//          }
+
+        structInfos.insert(insInfoi->getDEFStructSliceInfos().begin(), insInfoi->getDEFStructSliceInfos().end());
+      }
+    }
+  }
+
+  /* {v| v \in REF(i), ...} */
+  if (isect_nonempty) {
+    for (ValSet::const_iterator I = insInfoi->REF_begin(),
+           E = insInfoi->REF_end(); I != E; I++) {
+      for (auto &s : structInfos) {
+        insInfoi->addRCStruct(I->first, s);
+      }
+      for (InsInfo::StructSliceInfoSet_t::iterator ssi_it = insInfoi->REFStruct_begin(I->first);
+           ssi_it != insInfoi->REFStruct_end(I->first); ++ssi_it) {
+        insInfoi->addRCStruct(I->first, *ssi_it);
+      }
+
+//        if (insInfoi->addRC(*I, insInfoi->getIns(), insInfoi->getREFInc(*I)))
+      if (insInfoi->addRC(*I, insInfoi->getIns(), insInfoProvider, f_RC_min + insInfoi->getREFInc(*I)))
+        changed = true;
+    }
+  }
+#ifdef DEBUG_RC
+  errs() << "  " << __func__ << "2 END";
+  if (changed)
+    errs() << " ----------CHANGED";
+  errs() << '\n';
+    insInfoi->dump();
+#endif
+  return changed;
+}
+
+bool FunctionStaticSlicer::computeRCi(InsInfo *insInfoi) {
+  const Instruction *i = insInfoi->getIns();
+  bool changed = false;
+#ifdef DEBUG_RC
+  errs() << "  " << __func__ << ": " << i->getOpcodeName();
+  if (i->hasName())
+    errs() << " (" << i->getName() << ")";
+  errs() << '\n';
+  errs() << "    DUMP: ";
+  i->print(errs());
+  errs() << '\n';
+#endif
+  SuccList succList = getSuccList(i);
+  for (SuccList::const_iterator I = succList.begin(), E = succList.end();
+       I != E; I++)
+    changed |= computeRCi(insInfoi, getInsInfo(*I));
+
+  return changed;
+}
+
+void FunctionStaticSlicer::computeRC() {
+  bool changed;
+#ifdef DEBUG_RC
+  int it = 1;
+#endif
+  do {
+    changed = false;
+#ifdef DEBUG_RC
+    errs() << __func__ << ": ============== Iteration " << it++ << '\n';
+#endif
+    bool dumpInfo = false;
+    typedef std::reverse_iterator<Function::iterator> revFun;
+    for (revFun I = revFun(fun.end()), E = revFun(fun.begin()); I != E; I++) {
+      typedef std::reverse_iterator<BasicBlock::iterator> rev;
+      InsInfo *past = NULL;
+      for (rev II = rev(I->end()), EE = rev(I->begin()); II != EE; ++II) {
+        InsInfo *insInfo = getInsInfo(&*II);
+        if (!past)
+          changed |= computeRCi(insInfo);
+        else
+          changed |= computeRCi(insInfo, past);
+        past = insInfo;
+        if (dumpInfo) {
+          insInfo->dump();
+        }
+      }
+    }
+  } while (changed);
+}
+
+/*
+ * SC(i)={i| DEF(i) \cap RC(j) \neq \emptyset}
+ */
+void FunctionStaticSlicer::computeSCi(const Instruction *i, const Instruction *j) {
+  InsInfo *insInfoi = getInsInfo(i), *insInfoj = getInsInfo(j);
+
+
+  bool isect_nonempty = false;
+  for (ValSet::const_iterator I = insInfoi->DEF_begin(),
+//       E = insInfoi->DEF_end(); I != E && !isect_nonempty; I++) {
+         E = insInfoi->DEF_end(); I != E; I++) {
+    const Pointee &DEFi = *I;
+    for (ValSet::const_iterator II = insInfoj->RC_begin(),
+           EE = insInfoj->RC_end(); II != EE; II++) {
+      if (sameValues(DEFi, *II)) {
+        for (auto &src : insInfoj->getRCSource(*II)) {
+          if (!src)
+            continue;
+          if (const Instruction *srcIns = dyn_cast<const Instruction>(src)) {
+            InsInfo *srcInfo = insInfoProvider->getInsInfo(srcIns);
+            assert(srcInfo);
+            //TODO: get this srcInfo from other functions
+            if (srcInfo)
+              srcInfo->addSlicedPredecessor(*II, i, insInfoProvider);
+          }
+
+        }
+        isect_nonempty = true;
+//        break;
+      }
+    }
+  }
+
+  if (isect_nonempty) {
+
+    insInfoi->deslice(this);
+
+#ifdef DEBUG_SLICING
+    errs() << "XXXXXXXXXXXXXY ";
+    i->print(errs());
+    errs() << '\n';
+#endif
+  }
+}
+
+void FunctionStaticSlicer::computeSC() {
+  for (inst_iterator I = inst_begin(fun), E = inst_end(fun); I != E; I++) {
+    const Instruction *i = &*I;
+    SuccList succList = getSuccList(i);
+    for (SuccList::const_iterator II = succList.begin(), EE = succList.end();
+         II != EE; II++)
+      computeSCi(i, *II);
+  }
+}
+
+bool FunctionStaticSlicer::computeBC() {
+  bool changed = false;
+#ifdef DEBUG_BC
+  errs() << __func__ << " ============ BEG\n";
+#endif
+  passLock.lock();
+  PostDominanceFrontier &PDF = MP->getAnalysis<PostDominanceFrontier>(fun);
+  for (inst_iterator I = inst_begin(fun), E = inst_end(fun); I != E; I++) {
+    Instruction *i = &*I;
+    const InsInfo *ii = getInsInfo(i);
+    if (ii->isSliced())
+      continue;
+    BasicBlock *BB = i->getParent();
+#ifdef DEBUG_BC
+    errs() << "  ";
+    i->print(errs());
+    errs() << " -> bb=" << BB->getName() << '\n';
+#endif
+    PostDominanceFrontier::const_iterator frontier = PDF.find(BB);
+    if (frontier == PDF.end())
+      continue;
+    changed |= updateRCSC(frontier->second.begin(), frontier->second.end());
+  }
+  passLock.unlock();
+#ifdef DEBUG_BC
+  errs() << __func__ << " ============ END\n";
+#endif
+  return changed;
+}
+
+bool FunctionStaticSlicer::updateRCSC(
+  PostDominanceFrontier::DomSetType::const_iterator start,
+  PostDominanceFrontier::DomSetType::const_iterator end) {
+  bool changed = false;
+#ifdef DEBUG_RC
+  errs() << __func__ << " ============ BEG\n";
+#endif
+  for (; start != end; start++) {
+    const BasicBlock *BB = *start;
+    const Instruction &i = BB->back();
+    InsInfo *ii = getInsInfo(&i);
+    /* SC = BC \cup ... */
+#ifdef DEBUG_SLICING
+    errs() << "XXXXXXXXXXXXXX " << BB->getName() << " ";
+    i.print(errs());
+    errs() << '\n';
+#endif
+    ii->deslice(this);
+    /* RC = ... \cup \cup(b \in BC) RB */
+    for (ValSet::const_iterator II = ii->REF_begin(), EE = ii->REF_end();
+         II != EE; II++)
+      //TODO: is this instruction the correct one as RC source?
+      if (ii->addRC(*II, ii->getIns(), insInfoProvider)) {
+        changed = true;
+#ifdef DEBUG_RC
+
+        errs() << "  added " << II->first->getName() << "\n";
+#endif
+      }
+  }
+#ifdef DEBUG_RC
+  errs() << __func__ << " ============ END: changed=" << changed << "\n";
+#endif
+  return changed;
+}
+
+
+void FunctionStaticSlicer::dump() {
+#ifdef DEBUG_DUMP
+  for (inst_iterator I = inst_begin(fun), E = inst_end(fun); I != E; I++) {
+    const Instruction &i = *I;
+    const InsInfo *ii = getInsInfo(&i);
+    i.print(errs());
+    errs() << "\n    ";
+    if (!ii->isSliced() || !canSlice(i))
+      errs() << "UN";
+    errs() << "SLICED\n    DEF:\n";
+    for (ValSet::const_iterator II = ii->DEF_begin(), EE = ii->DEF_end();
+         II != EE; II++) {
+      errs() << "      OFF=" << II->second << " ";
+      II->first->dump();
+    }
+    errs() << "    REF:\n";
+    for (ValSet::const_iterator II = ii->REF_begin(), EE = ii->REF_end();
+         II != EE; II++) {
+      errs() << "      OFF=" << II->second << " ";
+      II->first->dump();
+    }
+    errs() << "    RC:\n";
+    for (ValSet::const_iterator II = ii->RC_begin(), EE = ii->RC_end();
+         II != EE; II++) {
+      errs() << "      OFF=" << II->second << " ";
+      II->first->dump();
+    }
+  }
+#endif
+}
+
+/**
+ * this method calculates the static slice for the CFG
+ */
+void FunctionStaticSlicer::calculateStaticSlice() {
+  //If we can't get the lock some other thread handles this function..
+//    if (!slicerLock.try_lock())
+//        return;
+  slicerLock.lock();
+  DEBUG(errs() << "Slice: " << fun.getName() << "\n");
+#ifdef DEBUG_SLICE
+  errs() << __func__ << " ============ BEG\n";
+#endif
+  do {
+#ifdef DEBUG_SLICE
+    errs() << __func__ << " ======= compute RC\n";
+#endif
+    computeRC();
+#ifdef DEBUG_SLICE
+    errs() << __func__ << " ======= compute SC\n";
+#endif
+    computeSC();
+
+#ifdef DEBUG_SLICE
+    errs() << __func__ << " ======= compute BC\n";
+#endif
+  } while (computeBC());
+  slicerLock.unlock();
+
+//  dump();
+
+#ifdef DEBUG_SLICE
+  errs() << __func__ << " ============ END\n";
+#endif
+}
+
+bool FunctionStaticSlicer::slice() {
+#ifdef DEBUG_SLICE
+  errs() << __func__ << " ============ BEG\n";
+#endif
+  bool removed = false;
+  for (inst_iterator I = inst_begin(fun), E = inst_end(fun); I != E;) {
+    Instruction &i = *I;
+    InsInfoMap::iterator ii_iter = insInfoMap.find(&i);
+    assert(ii_iter != insInfoMap.end() || !infosInitialized);
+    const InsInfo *ii = infosInitialized ? ii_iter->second : nullptr;
+    ++I;
+
+    if ((!infosInitialized || ii->isSliced()) && canSlice(i)) {
+#ifdef DEBUG_SLICE
+      errs() << "  removing:";
+      i.print(errs());
+      errs() << " from " << i.getParent()->getName() << '\n';
+#endif
+      i.replaceAllUsesWith(UndefValue::get(i.getType()));
+      i.eraseFromParent();
+      if (infosInitialized && ii_iter != insInfoMap.end()) {
+//            insInfoMap.erase(ii_iter);
+//            delete ii;
+      }
+      removed = true;
+    }
+  }
+  return removed;
+}
+
+/**
+ * removeUndefBranches -- remove branches with undef condition
+ *
+ * These are irrelevant to the code, so may be removed completely with their
+ * bodies.
+ */
+void FunctionStaticSlicer::removeUndefBranches(ModulePass *MP, Function &F) {
+#ifdef DEBUG_SLICE
+  errs() << __func__ << " ============ Removing unused branches\n";
+#endif
+  passLock.lock();
+  PostDominatorTree &PDT = MP->getAnalysis<PostDominatorTree>(F);
+
+  typedef llvm::SmallVector<const BasicBlock *, 10> Unsafe;
+  Unsafe unsafe;
+
+  for (Function::iterator I = F.begin(), E = F.end(); I != E; ++I) {
+    BasicBlock &bb = *I;
+    if (std::distance(succ_begin(&bb), succ_end(&bb)) <= 1)
+      continue;
+    Instruction &back = bb.back();
+    if (back.getOpcode() != Instruction::Br &&
+        back.getOpcode() != Instruction::Switch)
+      continue;
+    const Value *cond = back.getOperand(0);
+    if (cond->getValueID() != Value::UndefValueVal)
+      continue;
+    DomTreeNode *node = PDT.getNode(&bb);
+    if (!node) /* this bb is unreachable */
+      continue;
+    DomTreeNode *idom = node->getIDom();
+    assert(idom);
+/*    if (!idom)
+      continue;*/
+    BasicBlock *dest = idom->getBlock();
+    if (!dest) /* TODO when there are nodes with noreturn calls */
+      continue;
+#ifdef DEBUG_SLICE
+    errs() << "  considering branch: " << bb.getName() << '\n';
+    errs() << "  dest=" << dest->getName() << "\n";
+#endif
+    if (PHINode *PHI = dyn_cast<PHINode>(&dest->front())) if (PHI->getBasicBlockIndex(&bb) == -1) {
+      /* TODO this is unsafe! */
+      unsafe.push_back(&bb);
+      PHI->addIncoming(Constant::getNullValue(PHI->getType()), &bb);
+    }
+    BasicBlock::iterator ii(back);
+    Instruction *newI = BranchInst::Create(dest);
+    ReplaceInstWithInst(bb.getInstList(), ii, newI);
+  }
+  for (Unsafe::const_iterator I = unsafe.begin(), E = unsafe.end();
+       I != E; ++I) {
+    const BasicBlock *bb = *I;
+    if (std::distance(pred_begin(bb), pred_end(bb)) > 1)
+      errs() << "WARNING: PHI node with added value which is zero\n";
+  }
+  passLock.unlock();
+#ifdef DEBUG_SLICE
+  errs() << __func__ << " ============ END\n";
+#endif
+}
+
+/**
+ * removeUndefCalls -- remove calls with undef function
+ *
+ * These are irrelevant to the code, so may be removed completely.
+ */
+void FunctionStaticSlicer::removeUndefCalls(ModulePass *MP, Function &F) {
+  for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E;) {
+    CallInst *CI = dyn_cast<CallInst>(&*I);
+    ++I;
+    if (CI && isa<UndefValue>(CI->getCalledValue())) {
+      CI->replaceAllUsesWith(UndefValue::get(CI->getType()));
+      CI->eraseFromParent();
+    }
+  }
+}
+
+void FunctionStaticSlicer::removeUndefs(ModulePass *MP, Function &F) {
+  removeUndefBranches(MP, F);
+  removeUndefCalls(MP, F);
+}
+
+void FunctionStaticSlicer::dumpInfos() {
+  for (inst_iterator it = inst_begin(fun); it != inst_end(fun); ++it) {
+    insInfoMap[&*it]->dump();
+  }
+}
+
+
+static bool handleAssert(Function &F, FunctionStaticSlicer &ss,
+                         const CallInst *CI) {
+
+  const char *ass_file = getenv("SLICE_ASSERT_FILE");
+  const char *ass_line = getenv("SLICE_ASSERT_LINE");
+  const ConstantExpr *fileArg = dyn_cast<ConstantExpr>(CI->getArgOperand(1));
+  const ConstantInt *lineArg = dyn_cast<ConstantInt>(CI->getArgOperand(2));
+
+  if (ass_file && ass_line) {
+    if (fileArg && fileArg->getOpcode() == Instruction::GetElementPtr &&
+        lineArg) {
+      const GlobalVariable *strVar =
+        dyn_cast<GlobalVariable>(fileArg->getOperand(0));
+      assert(strVar && strVar->hasInitializer());
+      const ConstantDataArray *str =
+        dyn_cast<ConstantDataArray>(strVar->getInitializer());
+      assert(str && str->isCString());
+      /* trim the NUL terminator */
+      StringRef fileArgStr = str->getAsString().drop_back(1);
+      const int ass_line_int = atoi(ass_line);
+
+      errs() << "ASSERT at " << fileArgStr << ":" << lineArg->getValue() << "\n";
+
+      if (fileArgStr.equals(ass_file) && lineArg->equalsInt(ass_line_int)) {
+        errs() << "\tMATCH\n";
+        goto count;
+      }
+    }
+    ss.addSkipAssert(CI);
+    return false;
+  }
+
+  count:
+#ifdef DEBUG_INITCRIT
+  errs() << "    adding\n";
+#endif
+
+  const Value *aif = F.getParent()->getGlobalVariable("__ai_init_functions",
+                                                      true);
+  ss.addInitialCriterion(CI, ptr::PointsToSets::Pointee(aif, -1));
+
+  return true;
+}
+
+bool llvm::slicing::findInitialCriterion(llvm::Function &F, FunctionStaticSlicer &ss,
+                                         std::vector<Rule *> &rules) {
+
+  bool added = false;
+
+  auto addCriterion = [&](std::string functionName, const Instruction *inst, uint64_t regNo, Rule &r,
+                          std::vector<Rule *> preconditions) {
+    DetectParametersPass::UserSet_t pre = DetectParametersPass::getRegisterValuesBeforeCall(regNo, inst, true);
+    for (auto &p_it : pre) {
+      Rule::InstructionRuleList_t preconditionInstructions;
+
+      for (auto &preCond : preconditions) {
+        for (auto &preCrit : preCond->getCriterions()) {
+          if (preCrit.second.first.getFunctionName() != functionName) {
+            continue;
+            llvm_unreachable("Precondition has to be for the same function");
+          }
+          DetectParametersPass::UserSet_t prePreCond = DetectParametersPass::getRegisterValuesBeforeCall(
+            preCrit.second.first.getRegNo(), (Instruction *) inst, true);
+          for (auto &prePreCond_it : prePreCond) {
+            const Instruction *prePreInst = dyn_cast<const Instruction>(prePreCond_it);
+            Rule::InstructionRule_t instRule(prePreInst, (Rule *) preCrit.first);
+            preconditionInstructions.push_back(instRule);
+            ss.addInitialCriterion(inst, ptr::PointsToSets::Pointee(prePreInst, -1));
+          }
+        }
+      }
+
+      ss.addInitialCriterion(inst, ptr::PointsToSets::Pointee(p_it, -1));
+      r.addInitialInstruction(inst, dyn_cast<const Instruction>(p_it), preconditionInstructions);
+      added = true;
+    }
+  };
+
+  for (inst_iterator inst_it = inst_begin(F), E = inst_end(F); inst_it != E; ++inst_it) {
+    if (inst_it->getOpcode() == Instruction::Call) {
+      SimpleCallGraph::FunctionSet_t calledFunctions = ptr::getSimpleCallGraph().getCalled(&*inst_it);
+      for (auto &rule : rules) {
+        for (auto &criterion : rule->getCriterions()) {
+          for (auto &called : calledFunctions) {
+            if (called == criterion.second.first.getFunctionName()) {
+              addCriterion(called, &*inst_it, criterion.second.first.getRegNo(), *(Rule *) criterion.first,
+                           criterion.second.second);
+              errs() << "Found call to: " << called << "\n";
+            }
+
+            if (called == "objc_setProperty") {
+              DetectParametersPass::UserSet_t PreVal = DetectParametersPass::getRegisterValuesBeforeCall(7, &*inst_it);
+              for (auto &pre : PreVal) {
+                Instruction *sext = nullptr;
+                if (PatternMatch::match(pre, PatternMatch::m_SExt(PatternMatch::m_Instruction(sext)))) {
+                  std::vector<const Value *> ptsToSet;
+                  ptr::getAndersen()->getPointsToSet(sext->getOperand(0), ptsToSet);
+
+                  for (auto &ptsTo : ptsToSet) {
+                    for (auto &relevant : rule->getRelevantVariables()) {
+                      if (ptsTo != relevant) {
+                        continue;
+                      }
+                      ss.addInitialCriterion(&*inst_it, ptr::PointsToSets::Pointee(&*inst_it, -1));
+                      rule->addInitialInstruction(nullptr, &*inst_it, Rule::InstructionRuleList_t());
+                      added = true;
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+        for (auto &called : calledFunctions) {
+          if (called == "objc_setProperty") {
+            DetectParametersPass::UserSet_t PreVal = DetectParametersPass::getRegisterValuesBeforeCall(7, &*inst_it);
+            for (auto &pre : PreVal) {
+              Instruction *sext = nullptr;
+              if (PatternMatch::match(pre, PatternMatch::m_SExt(PatternMatch::m_Instruction(sext)))) {
+                std::vector<const Value *> ptsToSet;
+                ptr::getAndersen()->getPointsToSet(sext->getOperand(0), ptsToSet);
+
+                for (auto &ptsTo : ptsToSet) {
+                  for (auto &relevant : rule->getRelevantVariables()) {
+                    if (ptsTo == relevant) {
+                      DetectParametersPass::UserSet_t PreStore = DetectParametersPass::getRegisterValuesBeforeCall(8,
+                                                                                                                   &*inst_it,
+                                                                                                                   true);
+                      for (auto &store : PreStore) {
+                        ss.addInitialCriterion((Instruction *) store,
+                                               ptr::PointsToSets::Pointee(store->getOperand(0), -1));
+                        rule->addInitialInstruction(nullptr, (Instruction *) store, Rule::InstructionRuleList_t());
+                        added = true;
+                      }
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+
+//                for (auto &criterion : rule.getCriterions()) {
+//
+//
+//                    if (const CallInst *call = dyn_cast<const CallInst>(&*inst_it)) {
+//                        if (call->getCalledFunction() &&
+//                            call->getCalledFunction()->getName() == criterion.getFunctionName()) {
+//                            addCriterion(&*inst_it, criterion.getRegNumber(), *((Rule*)&rule));
+//                        }
+//                    }
+//
+//                    for (auto &called : calledFunctions) {
+//                        if (called == criterion.getFunctionName()) {
+//                            addCriterion(&*inst_it, criterion.getRegNumber(), *((Rule*)&rule));
+//                        }
+//                    }
+//                }
+      }
+    } else if (inst_it->getOpcode() == Instruction::Store) {
+      if (inst_it->getOperand(0)->getName() == "X0_67") {
+        assert(true);
+      }
+      for (auto &rule : rules) {
+        if (rule->getRelevantLocation()) {
+          Instruction *sext = nullptr;
+          Value *v = inst_it->getOperand(1);
+          if (PatternMatch::match(v, PatternMatch::m_IntToPtr(
+            PatternMatch::m_Add(PatternMatch::m_Value(), PatternMatch::m_SExt(PatternMatch::m_Instruction(sext)))))) {
+            std::vector<const Value *> ptsToSet;
+            ptr::getAndersen()->getPointsToSet(sext->getOperand(0), ptsToSet);
+            for (auto &relevant : rule->getRelevantVariables()) {
+              for (auto &ptsTo : ptsToSet) {
+                if (relevant == ptsTo) {
+                  ss.addInitialCriterion(&*inst_it, ptr::PointsToSets::Pointee(inst_it->getOperand(0), -1));
+                  rule->addInitialInstruction(nullptr, &*inst_it, Rule::InstructionRuleList_t());
+                  added = true;
+                }
+              }
+            }
+          } else {
+            std::vector<const Value *> ptsToSet;
+            ptr::getAndersen()->getPointsToSet(inst_it->getOperand(1), ptsToSet);
+            for (auto &relevant : rule->getRelevantVariables()) {
+              for (auto &ptsTo : ptsToSet) {
+                if (relevant == ptsTo) {
+                  ss.addInitialCriterion(&*inst_it, ptr::PointsToSets::Pointee(inst_it->getOperand(0), -1));
+                  rule->addInitialInstruction(nullptr, &*inst_it, Rule::InstructionRuleList_t());
+                  added = true;
+                }
+              }
+            }
+          }
+        }
+      }
+
+    }
+  }
+  return added;
+}
+
+bool llvm::slicing::findInitialCriterion(Function &F,
+                                         FunctionStaticSlicer &ss,
+                                         bool starting) {
+  bool added = false;
+#ifdef DEBUG_INITCRIT
+  errs() << __func__ << " ============ BEGIN\n";
+#endif
+  const Function *Fklee_assume = F.getParent()->getFunction("klee_assume");
+  const Function *F__assert_fail = F.getParent()->getFunction("__assert_fail");
+  const Function *F_donothing = F.getParent()->getFunction("llvm.donothing");
+  const Function *F_slice = F.getParent()->getFunction("llvm.slice");
+//  if (!F__assert_fail) /* no cookies in this module */
+//    return false;
+
+  for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I) {
+    const Instruction *i = &*I;
+    if (const StoreInst *SI = dyn_cast<StoreInst>(i)) {
+      const Value *LHS = SI->getPointerOperand();
+      if (LHS->hasName() && LHS->getName().startswith("__ai_state_")) {
+#ifdef DEBUG_INITCRIT
+        errs() << "    adding\n";
+#endif
+        ss.addInitialCriterion(SI, ptr::PointsToSets::Pointee(LHS, -1));
+      }
+    } else if (const CallInst *CI = dyn_cast<CallInst>(i)) {
+      Function *callie = CI->getCalledFunction();
+      if (callie && F__assert_fail && callie == F__assert_fail) {
+        added = handleAssert(F, ss, CI);
+      } else if (callie && callie == Fklee_assume) { // this is kind of hack
+        const Value *l = elimConstExpr(CI->getArgOperand(0));
+        ss.addInitialCriterion(CI, ptr::PointsToSets::Pointee(l, -1));
+        added = true;
+      } else if (callie && callie == F_donothing) {
+        ss.addInitialCriterion(CI);
+        added = true;
+      } else if (callie && callie == F_slice) {
+        Value *v = CI->arg_operands().begin()->get();
+        ss.addInitialCriterion(CI, ptr::PointsToSets::Pointee(v, -1));
+        added = true;
+      }
+    } else if (const ReturnInst *RI = dyn_cast<ReturnInst>(i)) {
+      if (starting) {
+        const Module *M = F.getParent();
+        for (Module::const_global_iterator II = M->global_begin(),
+               EE = M->global_end(); II != EE; ++II) {
+          const GlobalVariable &GV = *II;
+          if (!GV.hasName() || !GV.getName().startswith("__ai_state_"))
+            continue;
+#ifdef DEBUG_INITCRIT
+          errs() << "adding " << GV.getName() << " into " << F.getName() <<
+              " to \n";
+          RI->dump();
+#endif
+          ss.addInitialCriterion(RI, ptr::PointsToSets::Pointee(&GV, -1),
+                                 false);
+        }
+      }
+    }
+  }
+#ifdef DEBUG_INITCRIT
+  errs() << __func__ << " ============ END\n";
+#endif
+  return added;
+}
+
+bool FunctionSlicer::runOnFunction(Function &F, const ptr::PointsToSets &PS,
+                                   const mods::Modifies &MOD) {
+  FunctionStaticSlicer ss(F, this, PS, MOD);
+
+  findInitialCriterion(F, ss);
+
+  ss.calculateStaticSlice();
+
+  bool sliced = ss.slice();
+  if (sliced)
+    FunctionStaticSlicer::removeUndefs(this, F);
+
+  return sliced;
+}
+
+bool FunctionSlicer::runOnModule(Module &M) {
+  ptr::PointsToSets PS;
+  {
+    ptr::ProgramStructure P(M);
+    computePointsToSets(P, PS);
+  }
+
+  callgraph::Callgraph CG(M, PS);
+
+  mods::Modifies MOD;
+  {
+    mods::ProgramStructure P1(M, PS);
+    computeModifies(P1, CG, PS, MOD);
+  }
+
+  bool modified = false;
+  for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I) {
+    Function &F = *I;
+    if (!F.isDeclaration())
+      modified |= runOnFunction(F, PS, MOD);
+  }
+  return modified;
+}
+
+
+
+//InsInfo
+
+bool InsInfo::addRC(const Pointee &var, const Value *src, InsInfoProvider *provider, IncType_t RCInc) {
+  bool changed = false;
+  if (RCInc < INC_MAX) {
+    if (RCSources.find(var.first) == RCSources.end())
+      RCSources[var.first] = ValSet_t();
+    ValSet_t &v = RCSources[var.first];
+    if (src)
+      v.insert(src);
+  }
+  IncMap_t::iterator i = RCIncMap.find(var.first);
+  if (RCInc < INC_MAX) {
+    if (i == RCIncMap.end()) {
+      RCIncMap[var.first] = RCInc;
+      changed = true;
+    }
+    else {
+      if (i->second > RCInc) {
+        RCIncMap[var.first] = RCInc;
+        changed = true;
+      }
+    }
+
+  }
+  if (std::find(RC.begin(), RC.end(), var) != RC.end()) {
+
+  } else {
+    RC.insert(var);
+    changed = true;
+  }
+  return changed;
+}
+
+bool InsInfo::addRC(const Pointee &var, const ValSet_t &sources, InsInfoProvider *provider, IncType_t RCInc) {
+  bool r = addRC(var, NULL, provider, RCInc);
+  if (RCInc < INC_MAX) {
+    if (RCSources.find(var.first) == RCSources.end())
+      RCSources[var.first] = ValSet_t();
+    ValSet_t &v = RCSources[var.first];
+    for (auto &s : sources) {
+      if (std::find(v.begin(), v.end(), s) == v.end()) {
+        v.insert(s);
+        r = true;
+      }
+    }
+  }
+  return r;
+}
+
+bool InsInfo::addDEF(const Pointee &var) {
+  if (ptr::getAndersen()->isDummyHelper(var.first))
+    return false;
+
+  if (std::find(DEF.begin(), DEF.end(), var) != DEF.end()) {
+    return false;
+  }
+  DEF.insert(var);
+  return true;
+}
+
+
+bool InsInfo::addREF(const Pointee &var, IncType_t RefInc) {
+  if (ptr::getAndersen()->isDummyHelper(var.first))
+    return false;
+  if (dyn_cast<const ConstantInt>(var.first)) {
+    return false;
+  }
+  if (RefInc < INC_MAX) {
+    IncMap_t::iterator i = RefIncMap.find(var.first);
+    if (i == RefIncMap.end())
+      RefIncMap[var.first] = RefInc;
+    else
+      RefIncMap[var.first] = i->second < RefInc ? i->second : RefInc;
+  }
+  if (std::find(REF.begin(), REF.end(), var) != REF.end()) {
+    return false;
+  }
+  REF.insert(var);
+  return true;
+}
+
+void InsInfo::addRCStruct(const Value *ref, const StructSliceInfo *ssi) {
+  bool hasRC = false;
+  for (ValSet::const_iterator RC_it = RC_begin(); RC_it != RC_end(); ++RC_it) {
+    for (auto &l : ssi->locations) {
+      if (RC_it->first == l.first) {
+        hasRC = true;
+        break;
+      }
+    }
+  }
+  if (hasRC)
+    RCStructInfos[ref].insert((StructSliceInfo *) ssi);
+}
+
+IncType_t InsInfo::getRCInc(const Pointee &var) {
+  IncMap_t::iterator i = RCIncMap.find(var.first);
+  if (i == RCIncMap.end())
+    return INC_MAX;
+  return i->second;
+}
+
+IncType_t InsInfo::getREFInc(const Pointee &var) {
+  IncMap_t::iterator i = RefIncMap.find(var.first);
+  if (i == RefIncMap.end())
+    return INC_MAX;
+  return i->second;
+}
+
+void InsInfo::addSlicedPredecessor(const Pointee &RC, const Instruction *Pred, InsInfoProvider *provider) {
+
+  if (SlicedPredecessors.find(RC.first) == SlicedPredecessors.end())
+    SlicedPredecessors[RC.first] = std::set<const Instruction *>();
+  std::set<const Instruction *> &Preds = SlicedPredecessors[RC.first];
+  if (Preds.find(Pred) != Preds.end())
+    return;
+  if (Pred != ins)
+    Preds.insert(Pred);
+  else {
+    assert(true);
+  }
+
+  for (auto &succ : UpSuccessors[RC.first]) {
+    const Instruction *i = dyn_cast<const Instruction>(succ);
+    if (!i)
+      continue;
+    InsInfo *p = provider->getInsInfo(i);
+    if (!p || p == this)
+      continue;
+    p->addSlicedPredecessor(RC, ins, provider);
+  }
+}
diff --git a/lib/LLVMSlicer/Slicing/FunctionStaticSlicer.h b/lib/LLVMSlicer/Slicing/FunctionStaticSlicer.h
new file mode 100644
index 0000000..5e57269
--- /dev/null
+++ b/lib/LLVMSlicer/Slicing/FunctionStaticSlicer.h
@@ -0,0 +1,462 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef SLICING_FUNCTIONSTATICSLICER_H
+#define SLICING_FUNCTIONSTATICSLICER_H
+
+#include <map>
+#include <tuple>
+#include <mutex>
+#include <float.h>
+#include <Backtrack/Path.h>
+#include <pthread.h>
+#include <utility> /* pair */
+
+#include "llvm/IR/Value.h"
+#include "llvm/ADT/SetVector.h"
+#include "llvm/IR/InstIterator.h"
+
+#include "../PointsTo/PointsTo.h"
+#include "../Modifies/Modifies.h"
+#include "PostDominanceFrontier.h"
+
+#include "../Backtrack/Rule.h"
+#include "../Backtrack/Constraint.h"
+
+#include "llvm/LLVMSlicer/StaticSlicer.h"
+
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/ADT/SparseSet.h"
+
+#include <sparsehash/sparse_hash_map>
+#include <sparsehash/sparse_hash_set>
+#include <sparsehash/dense_hash_map>
+#include <sparsehash/dense_hash_set>
+#include <unordered_set>
+
+#define INC_MAX FLT_MAX
+
+static bool canSlice(const llvm::Instruction &i) {
+  switch (i.getOpcode()) {
+    case llvm::Instruction::Alloca:
+    case llvm::Instruction::Ret:
+    case llvm::Instruction::Unreachable:
+      return false;
+    case llvm::Instruction::Br:
+    case llvm::Instruction::Switch:
+      return false;
+  }
+  return true;
+};
+
+namespace llvm {
+  namespace slicing {
+
+    typedef float IncType_t;
+
+    class FunctionStaticSlicer;
+
+    class InsInfo;
+
+    class StructSliceInfo;
+
+    class InsInfoProvider {
+    public:
+      virtual ~InsInfoProvider() { };
+
+      virtual void addInitialSlicingCriterion(const Instruction *C) = 0;
+
+      virtual InsInfo *getInsInfo(const Instruction *I) = 0;
+    };
+
+    struct PointeeHash {
+      size_t operator()(const llvm::ptr::PointsToSets::Pointee &x) const {
+        std::hash<const Value *> h;
+        return h(x.first);
+      }
+    };
+
+    typedef google::sparse_hash_set<llvm::ptr::PointsToSets::Pointee, PointeeHash> ValSet;
+
+    class StructSliceInfo {
+    public:
+      StructSliceInfo(int64_t baseOffset, const Value *accessInstruction) : accessInstruction(accessInstruction),
+                                                                            baseOffset(baseOffset) {
+
+      }
+
+      StructSliceInfo(const StructSliceInfo &s) {
+        accessInstruction = s.accessInstruction;
+        basePointers = s.basePointers;
+        baseOffset = s.baseOffset;
+        locations = s.locations;
+      }
+
+      const Value *accessInstruction;
+      ptr::PointsToSets::PointsToSet basePointers;
+      int64_t baseOffset;
+      std::set<ptr::PointsToSets::Pointee> locations;
+
+      bool operator<(const StructSliceInfo &rhs) const {
+        if (accessInstruction != rhs.accessInstruction)
+          return true;
+        if (basePointers != rhs.basePointers)
+          return true;
+        if (baseOffset != rhs.baseOffset)
+          return true;
+        if (locations != rhs.locations)
+          return true;
+        return false;
+      }
+    };
+
+
+    class InsInfo {
+    private:
+      typedef llvm::ptr::PointsToSets::Pointee Pointee;
+
+
+    public:
+      typedef google::sparse_hash_set<const Value *> ValSet_t;
+//    typedef std::map<const Value*, std::unique_ptr<ValSet_t>> ValMapSet_t;
+      typedef google::sparse_hash_map<const Value *, ValSet_t> ValMapSet_t;
+      typedef google::sparse_hash_map<const Value *, IncType_t> IncMap_t;
+      typedef std::set<StructSliceInfo *> StructSliceInfoSet_t;
+      typedef google::sparse_hash_map<const Value *, StructSliceInfoSet_t> SliceInfoSetMap_t;
+      typedef google::sparse_hash_set<int64_t> Int64Set_t;
+      typedef google::sparse_hash_map<const Value *, Int64Set_t> DefOffsets_t;
+      typedef google::sparse_hash_set<const Instruction *> InstSet_t;
+      typedef std::pair<const CallInst *, const Instruction *> CallParamPair_t;
+
+      InsInfo(const llvm::Instruction *i, const llvm::ptr::PointsToSets &PS,
+              const llvm::mods::Modifies &MOD);
+
+      virtual ~InsInfo() {
+        if (isSliced() && canSlice(*ins)) {
+//            delete(ins);
+        }
+      }
+
+      const Instruction *getIns() const { return ins; }
+
+
+      bool addRC(const Pointee &var, const Value *src, InsInfoProvider *provider, IncType_t RCInc = INC_MAX);
+
+      bool addRC(const Pointee &var, const ValSet_t &sources, InsInfoProvider *provider,
+                 IncType_t RCInc = INC_MAX);
+
+      bool addDEF(const Pointee &var);
+
+      bool addREF(const Pointee &var, IncType_t RefInc = INC_MAX);
+
+      void addRCStruct(const Value *ref, const StructSliceInfo *ssi);
+
+      IncType_t getRCInc(const Pointee &var);
+
+      IncType_t getREFInc(const Pointee &var);
+
+      void deslice(FunctionStaticSlicer *FSS);
+
+      ValSet::const_iterator RC_begin() const { return RC.begin(); }
+
+      ValSet::const_iterator RC_end() const { return RC.end(); }
+
+      ValSet::const_iterator DEF_begin() const { return DEF.begin(); }
+
+      ValSet::const_iterator DEF_end() const { return DEF.end(); }
+
+      ValSet::const_iterator REF_begin() const { return REF.begin(); }
+
+      ValSet::const_iterator REF_end() const { return REF.end(); }
+
+      static StructSliceInfoSet_t::const_iterator defaultStructIterator;
+
+      StructSliceInfoSet_t::const_iterator REFStruct_begin(const Value *r) {
+        if (REFStructInfos.find(r) == REFStructInfos.end()) {
+          return defaultStructIterator;
+        }
+        return REFStructInfos[r].begin();
+      }
+
+      StructSliceInfoSet_t::const_iterator REFStruct_end(const Value *r) {
+        if (REFStructInfos.find(r) == REFStructInfos.end()) {
+          return defaultStructIterator;
+        }
+        return REFStructInfos[r].end();
+      }
+
+
+      StructSliceInfoSet_t::const_iterator RCStruct_begin(const Value *rc) {
+        if (RCStructInfos.find(rc) == RCStructInfos.end()) {
+          return defaultStructIterator;
+        }
+        return RCStructInfos[rc].begin();
+      }
+
+      StructSliceInfoSet_t::const_iterator RCStruct_end(const Value *rc) {
+        if (RCStructInfos.find(rc) == RCStructInfos.end()) {
+          return defaultStructIterator;
+        }
+        return RCStructInfos[rc].end();
+      }
+
+
+      bool isSliced() const { return sliced; }
+
+      void dump(bool def = false, bool ref = false, bool rc = false, bool pred = false);
+
+      const ValSet_t &getRCSource(const Pointee &var) {
+//        assert(RCSources.find(var.first) != RCSources.end());
+        static ValSet_t emptySet;
+        if (RCSources.find(var.first) == RCSources.end())
+          return emptySet;
+        ValSet_t &set = RCSources[var.first];
+        return set;
+      }
+
+      void addSlicedPredecessor(const Pointee &RC, const Instruction *Pred, InsInfoProvider *provider);
+
+      bool backtrack(InsInfoProvider *provider, PathElementBase *pathElement, std::vector<Path *> &paths,
+                     std::mutex &pathLock, Rule &rule);
+
+      void addTranslation(const Value *from, const Value *to) {
+        ValSet_t &t = translations[from];
+        t.insert(to);
+      }
+
+      bool hasTranslation(const Value *v) {
+        return translations.find(v) != translations.end();
+      }
+
+      StructSliceInfoSet_t &getDEFStructSliceInfos() {
+        return DEFStructInfos;
+      }
+
+      void addReturnPred(const Instruction *ret) {
+        if (ins->getOpcode() != Instruction::Call)
+          llvm_unreachable("'return' predecessors can only be added for call instructions");
+        returnPreds.insert(ret);
+      }
+
+      DefOffsets_t &getDEFOffset() { return defOffsets; }
+
+      void addUP(const Value *up) { Up.insert(up); }
+
+      void addUPSuccessor(const Value *succ, const Value *rc) { UpSuccessors[rc].insert(succ); }
+
+    private:
+
+      void addDEFArray(const ptr::PointsToSets &PS, const Value *V,
+                       uint64_t lenConst);
+
+      void addREFArray(const ptr::PointsToSets &PS, const Value *V,
+                       uint64_t lenConst);
+
+      void handleVariousFuns(const ptr::PointsToSets &PS, const CallInst *C);
+
+      const llvm::Instruction *ins;
+      ValSet RC, DEF, REF;
+      IncMap_t RefIncMap;
+      IncMap_t RCIncMap;
+      bool sliced;
+
+
+      StructSliceInfoSet_t DEFStructInfos;
+      SliceInfoSetMap_t REFStructInfos;
+      SliceInfoSetMap_t RCStructInfos;
+
+      ValMapSet_t RCSources;
+      std::map<const Value *, std::set<const Instruction *>> SlicedPredecessors;
+
+      //If the we reach this instruction tracing a value of the key set in 'translations' we create a path for each
+      //value in the value set of this key
+      ValMapSet_t translations;
+
+      std::set<const Instruction *> returnPreds;
+
+      DefOffsets_t defOffsets;
+      //Contains those instructions that use some of the RCs and have this instructions as RC_source
+      ValSet_t Up;
+      ValMapSet_t UpSuccessors;
+    };
+
+    class FunctionStaticSlicer {
+      friend class slicing::InsInfo;
+
+      typedef llvm::ptr::PointsToSets::Pointee Pointee;
+
+    public:
+      typedef google::sparse_hash_map<const llvm::Instruction *, InsInfo *> InsInfoMap;
+
+      FunctionStaticSlicer(llvm::Function &F, llvm::ModulePass *MP,
+                           const llvm::ptr::PointsToSets &PT,
+                           const llvm::mods::Modifies &mods, slicing::InsInfoProvider *insInfoProvider = NULL) :
+        infosInitialized(false), fun(F), MP(MP), insInfoProvider(insInfoProvider), mods(mods), PS(PT) {
+
+
+      }
+
+      ~FunctionStaticSlicer();
+
+      void initializeInfos();
+
+      ValSet::const_iterator relevant_begin(const llvm::Instruction *I) const {
+        return getInsInfo(I)->RC_begin();
+      }
+
+      ValSet::const_iterator relevant_end(const llvm::Instruction *I) const {
+        return getInsInfo(I)->RC_end();
+      }
+
+      ValSet::const_iterator REF_begin(const llvm::Instruction *I) const {
+        return getInsInfo(I)->REF_begin();
+      }
+
+      ValSet::const_iterator REF_end(const llvm::Instruction *I) const {
+        return getInsInfo(I)->REF_end();
+      }
+
+      template<typename FwdValueIterator>
+      bool addCriterion(const llvm::Instruction *ins, FwdValueIterator b,
+                        FwdValueIterator const e, InsInfoProvider *callback = NULL,
+                        InsInfo::ValMapSet_t rcSources = InsInfo::ValMapSet_t(),
+                        InsInfo::IncMap_t IncMap = InsInfo::IncMap_t(), bool desliceIfChanged = false) {
+        initializeInfos();
+        InsInfo *ii = getInsInfo(ins);
+        bool change = false;
+
+        const CallInst *callInst = dyn_cast<const CallInst>(ins);
+
+        InsInfo::ValSet_t callRCSource;
+        callRCSource.insert(ins);
+
+        for (; b != e; ++b) {
+          InsInfo::IncMap_t::iterator i = IncMap.find(b->first);
+          bool found = i != IncMap.end();
+          IncType_t v = found ? i->second : INC_MAX;
+
+          if (callInst) {
+            if (ii->addRC(*b, callRCSource, callback, v))
+              change = true;
+          } else {
+            if (ii->addRC(*b, rcSources[b->first], callback, v))
+              change = true;
+          }
+        }
+        if (change && desliceIfChanged) {
+          ii->deslice(this);
+          if (callInst && callback) {
+            for (auto &rc : rcSources) {
+              for (auto &src : rc.second) {
+                const Instruction *srcInst = dyn_cast<const Instruction>(src);
+//                    callback->getInsInfo(srcInst)->addSlicedPredecessor(Pointee(rc.first, -1), ins);
+                ii->addUPSuccessor(srcInst, rc.first);
+                ii->addUP(srcInst);
+              }
+            }
+          }
+        }
+        return change;
+      }
+
+      void addInitialCriterion(const llvm::Instruction *ins,
+                               const Pointee &cond = Pointee(0, 0),
+                               bool deslice = true) {
+        initializeInfos();
+        InsInfo *ii = getInsInfo(ins);
+        if (cond.first) {
+          ii->addRC(cond, ins, NULL, 0.0);
+        }
+        ii->deslice(this);
+        if (insInfoProvider && cond.first) {
+          if (const Instruction *C = dyn_cast<const Instruction>(cond.first)) {
+            insInfoProvider->addInitialSlicingCriterion(C);
+          }
+        }
+      }
+
+      void calculateStaticSlice();
+
+      bool slice();
+
+      static void removeUndefs(ModulePass *MP, Function &F);
+
+      void addSkipAssert(const llvm::CallInst *CI) {
+        skipAssert.insert(CI);
+      }
+
+      bool shouldSkipAssert(const llvm::CallInst *CI) {
+        return skipAssert.count(CI);
+      }
+
+      InsInfo *getInsInfo(const llvm::Instruction *i) const {
+        assert(infosInitialized);
+        InsInfoMap::const_iterator I = insInfoMap.find(i);
+
+        //TODO: should we check this before calling?
+        if (I == insInfoMap.end())
+          return NULL;
+        assert(I != insInfoMap.end());
+        return I->second;
+      }
+
+      void dumpInfos();
+
+      bool isInitialized() const {
+        return infosInitialized;
+      }
+
+    private:
+      std::mutex initLock;
+      bool infosInitialized;
+
+      std::mutex slicerLock;
+
+      static std::mutex passLock;
+
+      llvm::Function &fun;
+      llvm::ModulePass *MP;
+      InsInfoMap insInfoMap;
+      llvm::SmallSetVector<const llvm::CallInst *, 10> skipAssert;
+      slicing::InsInfoProvider *insInfoProvider;
+      const llvm::mods::Modifies &mods;
+
+      const llvm::ptr::PointsToSets &PS;
+
+      static bool sameValues(const Pointee &val1, const Pointee &val2);
+
+      void crawlBasicBlock(const llvm::BasicBlock *bb);
+
+      bool computeRCi(InsInfo *insInfoi, InsInfo *insInfoj);
+
+      bool computeRCi(InsInfo *insInfoi);
+
+      void computeRC();
+
+      void computeSCi(const llvm::Instruction *i, const llvm::Instruction *j);
+
+      void computeSC();
+
+      bool computeBC();
+
+      bool updateRCSC(llvm::PostDominanceFrontier::DomSetType::const_iterator start,
+                      llvm::PostDominanceFrontier::DomSetType::const_iterator end);
+
+      void dump();
+
+
+      static void removeUndefBranches(ModulePass *MP, Function &F);
+
+      static void removeUndefCalls(ModulePass *MP, Function &F);
+    };
+
+    bool findInitialCriterion(llvm::Function &F, FunctionStaticSlicer &ss,
+                              bool startingFunction = false);
+
+    bool findInitialCriterion(llvm::Function &F, FunctionStaticSlicer &ss,
+                              std::vector<Rule *> &rules);
+
+  }
+}
+
+#endif
diff --git a/lib/LLVMSlicer/Slicing/PostDominanceFrontier.cpp b/lib/LLVMSlicer/Slicing/PostDominanceFrontier.cpp
new file mode 100644
index 0000000..c791689
--- /dev/null
+++ b/lib/LLVMSlicer/Slicing/PostDominanceFrontier.cpp
@@ -0,0 +1,159 @@
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/Pass.h"
+
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+#include "PostDominanceFrontier.h"
+
+using namespace llvm;
+
+char CreateHammockCFG::ID = 0;
+static RegisterPass<CreateHammockCFG> X_Hammock("create-hammock-cfg", "Creates Hammock Graph from Control Flow Graph", false, true);
+static RegisterAnalysisGroup<CreateHammockCFG> Y_Hammock(X_Hammock);
+
+bool CreateHammockCFG::runOnFunction(Function &F) {
+  if (F.front().getName() == "start")
+	  return false;
+
+  LoopInfo &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();
+  LLVMContext &ctx = F.getContext();
+  Function::BasicBlockListType &BBL = F.getBasicBlockList();
+  ConstantInt *Ctrue = ConstantInt::getTrue(ctx);
+  BasicBlock &entry = BBL.front();
+
+  BasicBlock *BBend = BasicBlock::Create(ctx, "end", &F);
+  new UnreachableInst(ctx, BBend);
+
+  BasicBlock *BBstart = BasicBlock::Create(ctx, "start", &F, &entry);
+  BranchInst::Create(&entry, BBend, Ctrue, BBstart);
+
+  for (Function::iterator I = BBL.begin(), E = BBL.end(); I != E; ++I) {
+    BasicBlock *BB = I;
+    if (LI.isLoopHeader(BB)) {
+      BasicBlock *BBLoopBody = BB->splitBasicBlock(BB->begin(), "body");
+      ReplaceInstWithInst(&BB->back(),
+		      BranchInst::Create(BBLoopBody, BBend, Ctrue));
+    }
+    if (BB == BBend)
+      continue;
+    if (UnreachableInst *UI =
+	llvm::dyn_cast<UnreachableInst>(BB->getTerminator())) {
+      ReplaceInstWithInst(UI, BranchInst::Create(BBend));
+    }
+  }
+
+  return true;
+}
+
+//===----------------------------------------------------------------------===//
+//  PostDominanceFrontier Implementation
+//===----------------------------------------------------------------------===//
+
+static RegisterPass<PostDominanceFrontier> X("postdom-frontier", "Computes postdom frontiers");
+char PostDominanceFrontier::ID = 0;
+
+#ifdef CONTROL_DEPENDENCE_GRAPH
+void PostDominanceFrontier::constructS(const PostDominatorTree &DT,
+		Function &F, Stype &S) {
+  for (Function::iterator I = F.begin(), E = F.end(); I != E; ++I) {
+    BasicBlock *m = I;
+    DomTreeNode *mNode = DT[m];
+    for (succ_iterator II = succ_begin(m), EE = succ_end(m); II != EE; ++II) {
+      BasicBlock *n = *II;
+      DomTreeNode *nNode = DT[n];
+      if (!DT.properlyDominates(nNode, mNode))
+	S.insert(std::make_pair(mNode, nNode));
+    }
+  }
+}
+
+/*
+ * Taken from Dominators.h.
+ * Changed to return a path from LCA to B and optimized.
+ */
+const DomTreeNode *
+PostDominanceFrontier::findNearestCommonDominator(const PostDominatorTree &DT,
+		DomTreeNode *A, DomTreeNode *B) {
+  BasicBlock *BB = A->getBlock();
+  assert(BB);
+  Frontiers[B->getBlock()].insert(BB);
+
+  // If A dominates B then A is nearest common dominator.
+  if (DT.dominates(A, B))
+    return A;
+
+  /* so the LCA has to be A's parent according to Muchnick */
+  DomTreeNode *IDomA = A->getIDom();
+
+  // Walk NodeB immediate dominators chain and find common dominator node.
+  DomTreeNode *IDomB = B->getIDom();
+  while (IDomB) {
+    if (IDomB == IDomA)
+      return IDomB;
+    Frontiers[IDomB->getBlock()].insert(BB);
+
+    IDomB = IDomB->getIDom();
+  }
+
+  assert(0);
+  return NULL;
+}
+
+void
+PostDominanceFrontier::calculate(const PostDominatorTree &DT, Function &F) {
+  Stype S;
+  constructS(DT, F, S);
+  for (Stype::const_iterator I = S.begin(), E = S.end(); I != E; ++I) {
+    DomTreeNode *mNode = I->first;
+    DomTreeNode *nNode = I->second;
+    findNearestCommonDominator(DT, mNode, nNode);
+  }
+}
+
+#else /* CONTROL_DEPENDENCE_GRAPH */
+
+const DominanceFrontier::DomSetType &
+PostDominanceFrontier::calculate(const PostDominatorTree &DT,
+                                 const DomTreeNode *Node) {
+  // Loop over CFG successors to calculate DFlocal[Node]
+  BasicBlock *BB = Node->getBlock();
+  DomSetType &S = Frontiers[BB];       // The new set to fill in...
+  if (getRoots().empty()) return S;
+
+  if (BB)
+    for (pred_iterator SI = pred_begin(BB), SE = pred_end(BB);
+         SI != SE; ++SI) {
+      BasicBlock *P = *SI;
+      // Does Node immediately dominate this predecessor?
+      DomTreeNode *SINode = DT[P];
+      if (SINode && SINode->getIDom() != Node)
+        S.insert(P);
+    }
+
+  // At this point, S is DFlocal.  Now we union in DFup's of our children...
+  // Loop through and visit the nodes that Node immediately dominates (Node's
+  // children in the IDomTree)
+  //
+  for (DomTreeNode::const_iterator
+         NI = Node->begin(), NE = Node->end(); NI != NE; ++NI) {
+    DomTreeNode *IDominee = *NI;
+    const DomSetType &ChildDF = calculate(DT, IDominee);
+
+    DomSetType::const_iterator CDFI = ChildDF.begin(), CDFE = ChildDF.end();
+    for (; CDFI != CDFE; ++CDFI) {
+      if (!DT.properlyDominates(Node, DT[*CDFI]))
+        S.insert(*CDFI);
+    }
+  }
+
+  return S;
+}
+#endif
diff --git a/lib/LLVMSlicer/Slicing/PostDominanceFrontier.h b/lib/LLVMSlicer/Slicing/PostDominanceFrontier.h
new file mode 100644
index 0000000..7ec2d9d
--- /dev/null
+++ b/lib/LLVMSlicer/Slicing/PostDominanceFrontier.h
@@ -0,0 +1,76 @@
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef POST_DOMINANCE_FRONTIER
+#define POST_DOMINANCE_FRONTIER
+
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/DominanceFrontier.h"
+#include "llvm/Analysis/PostDominators.h"
+
+namespace llvm {
+
+  struct CreateHammockCFG : public FunctionPass {
+    static char ID;
+
+    CreateHammockCFG() : FunctionPass(ID) { }
+
+    virtual bool runOnFunction(Function &F);
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.addRequired<LoopInfoWrapperPass>();
+    }
+  };
+
+  /// PostDominanceFrontier Class - Concrete subclass of DominanceFrontier that is
+  /// used to compute the a post-dominance frontier.
+  ///
+  struct PostDominanceFrontier : public DominanceFrontierBase<BasicBlock>, FunctionPass {
+    static char ID;
+    PostDominanceFrontier()
+      : DominanceFrontierBase(true), FunctionPass(ID) { }
+
+    virtual bool runOnFunction(Function &F) {
+      Frontiers.clear();
+      PostDominatorTree &DT = getAnalysis<PostDominatorTree>();
+#ifdef CONTROL_DEPENDENCE_GRAPH
+      calculate(DT, F);
+#else
+      Roots = DT.getRoots();
+      if (const DomTreeNode *Root = DT.getRootNode()) {
+        calculate(DT, Root);
+#ifdef PDF_DUMP
+	errs() << "=== DUMP:\n";
+	dump();
+	errs() << "=== EOD\n";
+#endif
+      }
+#endif
+      return false;
+    }
+
+    virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+      AU.setPreservesAll();
+      AU.addRequired<PostDominatorTree>();
+    }
+
+  private:
+#ifdef CONTROL_DEPENDENCE_GRAPH
+    typedef std::pair<DomTreeNode *, DomTreeNode *> Ssubtype;
+    typedef std::set<Ssubtype> Stype;
+
+    void calculate(const PostDominatorTree &DT, Function &F);
+    void constructS(const PostDominatorTree &DT, Function &F, Stype &S);
+    const DomTreeNode *findNearestCommonDominator(const PostDominatorTree &DT,
+		    DomTreeNode *A, DomTreeNode *B);
+#else
+    const DomSetType &calculate(const PostDominatorTree &DT,
+                                const DomTreeNode *Node);
+#endif
+  };
+}
+
+#endif
diff --git a/lib/LLVMSlicer/Slicing/Prepare.cpp b/lib/LLVMSlicer/Slicing/Prepare.cpp
new file mode 100644
index 0000000..f65395a
--- /dev/null
+++ b/lib/LLVMSlicer/Slicing/Prepare.cpp
@@ -0,0 +1,306 @@
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#include <assert.h>
+#include <cstring>
+
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/IR/InlineAsm.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Pass.h"
+#include "llvm/IR/TypeBuilder.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/IR/Type.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+
+#include "../Callgraph/Callgraph.h"
+#include "../PointsTo/PointsTo.h"
+
+using namespace llvm;
+
+namespace {
+  class Prepare : public ModulePass {
+    public:
+      static char ID;
+
+      Prepare() : ModulePass(ID) {}
+
+      virtual bool runOnModule(Module &M);
+
+    private:
+      static void replaceInsLoad(llvm::Function &F, llvm::CallInst *CI);
+      static void replaceInsStore(llvm::Function &F, llvm::CallInst *CI);
+      static bool handleAsm(Function &F, CallInst *CI);
+      static void makeNop(Function *F);
+      static void deleteAsmBodies(Module &M);
+      static bool runOnFunction(Function &F);
+
+      void findInitFuns(Module &M, const ptr::PointsToSets &PS);
+      bool addInitFun(const callgraph::Callgraph &CG,
+	  SmallVector<Constant *, 10> &initFns, Type *ETy, Function &F,
+	  bool starting = false);
+  };
+}
+
+static RegisterPass<Prepare> X("prepare", "Prepares the code for slicing");
+char Prepare::ID;
+
+static GlobalVariable *getAiVar(Function &F, const CallInst *CI) {
+  const ConstantExpr *GEP =
+    dyn_cast<const ConstantExpr>(CI->getOperand(1));
+  assert(GEP && GEP->getOpcode() == Instruction::GetElementPtr);
+  const GlobalVariable *strVar =
+    dyn_cast<const GlobalVariable>(GEP->getOperand(0));
+  assert(strVar && strVar->hasInitializer());
+  const ConstantDataArray *str =
+    dyn_cast<const ConstantDataArray>(strVar->getInitializer());
+  assert(str && str->isCString());
+  std::string id = str->getAsCString();
+  char *cstr = new char[11 + id.size() + 1];
+  strcpy(cstr, "__ai_state_"); /* len=11 */
+  strcpy(cstr + 11, id.c_str());
+  for (size_t i = 11; i < 11 + id.size(); i++)
+    if (cstr[i] != '_' && !isupper(cstr[i]) && !islower(cstr[i]))
+      cstr[i] = 'X';
+  Type *intType = TypeBuilder<int, false>::get(F.getContext());
+  GlobalVariable *glob =
+    dyn_cast<GlobalVariable>(F.getParent()->getOrInsertGlobal(cstr, intType));
+  delete cstr;
+  glob->setInitializer(ConstantInt::get(
+                            TypeBuilder<int, false>::get(F.getContext()), 0));
+  return glob;
+}
+
+void Prepare::replaceInsLoad(Function &F, CallInst *CI) {
+  GlobalVariable *glob = getAiVar(F, CI);
+  LoadInst *LI = new LoadInst(glob, 0, true);
+  LI->setDebugLoc(CI->getDebugLoc());
+  ReplaceInstWithInst(CI, LI);
+}
+
+void Prepare::replaceInsStore(Function &F, CallInst *CI) {
+  GlobalVariable *glob = getAiVar(F, CI);
+  StoreInst *SI = new StoreInst(CI->getOperand(2), glob, true);
+  SI->setDebugLoc(CI->getDebugLoc());
+  ReplaceInstWithInst(CI, SI);
+}
+
+bool Prepare::handleAsm(Function &F, CallInst *CI) {
+  const InlineAsm *IA = cast<InlineAsm>(CI->getCalledValue());
+  std::string ASM = IA->getAsmString();
+  std::string CONS = IA->getConstraintString();
+
+//  BasicBlock *BB = CI->getParent();
+
+  if ((ASM.empty() && !CI->getNumArgOperands()) || /* a barrier */
+      !ASM.compare(0, 6, "1:\tud2") ||
+      !ASM.compare("lfence") || !ASM.compare("mfence") ||
+      !ASM.compare("sfence")) {
+/*    errs() << ASM << " (" << F.getName() << "): " << ASM.empty() << " " << !ASM.compare(0, 6, "1:\tud2") << " " <<
+      !ASM.compare("lfence") << " " << !ASM.compare("mfence") << " " <<
+      !ASM.compare("sfence");
+    BB->dump();*/
+    CI->eraseFromParent();
+    return true;
+  } else if (ASM.empty() && CI->getNumArgOperands() == 1) { /* reloc hide */
+    ReplaceInstWithInst(CI, CastInst::CreatePointerCast(CI->getArgOperand(0),
+                                                        CI->getType()));
+    return true;
+  } else if (!ASM.compare("movs %gs:${1:c},$0") || /* reading pda */
+             !ASM.compare("movl %gs:${1:c},$0") ||
+             !ASM.compare("movq %gs:${1:c},$0")) {
+    const ConstantInt *param = dyn_cast<ConstantInt>(CI->getArgOperand(0));
+    if (param) {
+      const APInt &paramVal = param->getValue();
+      Module *M = F.getParent();
+      if (paramVal == 0) { /* current */
+        ReplaceInstWithInst(CI, new LoadInst(
+                                  M->getOrInsertGlobal("__ai_current_singleton",
+                                                       CI->getType())));
+        return true;
+      } else { /* others, let's fake it with global var */
+        GlobalVariable *GV = dyn_cast<GlobalVariable>(
+              M->getOrInsertGlobal("__ai_pda_" + paramVal.toString(10, false),
+                                   CI->getType()));
+        GV->setInitializer(Constant::getNullValue(CI->getType()));
+        if (CI->getType()->isPointerTy())
+          errs() << "Warn ptr type => we set it to point to NULL\n";
+        ReplaceInstWithInst(CI, new LoadInst(GV));
+        return true;
+      }
+    }
+  } else if (!ASM.compare(0, 16, "call __put_user_") ||
+             !ASM.compare(0, 16, "call __get_user_") ) {
+    BasicBlock::iterator it(CI);
+    ReplaceInstWithValue(CI->getParent()->getInstList(), it,
+                         Constant::getNullValue(CI->getType()));
+    return true;
+  }
+  errs() << "ASM str (" << F.getName() << "): " << ASM << " from:\n";
+  CI->dump();
+  errs() << "===========\n";
+  return false;
+}
+
+bool Prepare::runOnFunction(Function &F) {
+  bool modified = false;
+  const Module *M = F.getParent();
+  const Function *__ai_load = M->getFunction("__ai_load");
+  const Function *__ai_store = M->getFunction("__ai_store");
+
+  for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E;) {
+    Instruction *ins = &*I;
+    ++I;
+    if (CallInst *CI = dyn_cast<CallInst>(ins)) {
+      if (CI->isInlineAsm()) {
+        modified |= handleAsm(F, CI);
+        continue;
+      }
+      Function *callee = CI->getCalledFunction();
+      if (callee) {
+        if (callee == __ai_load) {
+          replaceInsLoad(F, CI);
+          modified = true;
+        } else if (callee == __ai_store) {
+          replaceInsStore(F, CI);
+          modified = true;
+        }
+      }
+    }
+  }
+  return modified;
+}
+
+void Prepare::makeNop(Function *F) {
+  F->deleteBody();
+  BasicBlock *BB = BasicBlock::Create(F->getContext(), "entry", F);
+  ReturnInst::Create(F->getContext(), F->getReturnType()->isVoidTy() ? NULL :
+                     Constant::getNullValue(F->getReturnType()), BB);
+}
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+void Prepare::deleteAsmBodies(llvm::Module &M) {
+  static const char *toDelete[] = {
+    "atomic_inc", "atomic_dec", "atomic_add", "atomic_sub",
+    "atomic_dec_and_test", "atomic_add_return",
+    "atomic64_inc", "atomic64_dec", "atomic64_add", "atomic64_sub",
+    "local_inc", "local_dec",
+    "__fswab16", "__fswab32", "__fswab64",
+    "__xchg", "__cmpxchg",
+    "__set_bit", "__clear_bit", "set_bit", "clear_bit",
+    "variable_test_bit",
+    "__test_and_set_bit", "__test_and_clear_bit",
+    "test_and_set_bit", "test_and_clear_bit",
+    "__fls", "fls", "__ffs", "ffs", "ffz",
+    "inb", "inw", "inl",
+    "insb", "insw", "insl",
+    "inb_p", "inw_p", "inl_p",
+    "readb", "readw", "readl", "readq",
+    "__readb", "__readw", "__readl", "__readq",
+
+    "___arch__swab32", "___arch__swab64" // generates false positives in stats
+  };
+  static const char *_makeNop[] = {
+    "pagefault_disable",
+    "__raw_local_save_flags", "raw_local_irq_restore",
+    "raw_local_irq_enable", "raw_local_irq_disable",
+    "__raw_spin_is_contended",
+    "local_bh_enable", "local_bh_disable",
+    "schedule", "schedule_timeout", "schedule_timeout_interruptible",
+    "schedule_timeout_uninterruptible",
+    "preempt_schedule",
+    "msleep", "msleep_interruptible", "__udelay", "__const_udelay",
+    "printk_ratelimit", "warn_slowpath", "warn_on_slowpath", "dump_stack",
+    "printk", "vprintk", "snd_verbose_printk",
+    "rep_nop",
+    "outb", "outw", "outl",
+    "outsb", "outsw", "outsl",
+    "outb_p", "outw_p", "outl_p",
+    "writeb", "writew", "writel", "writeq",
+    "__writeb", "__writew", "__writel", "__writeq",
+
+    "mod_timer", "__mod_timer", "del_timer", "del_timer_sync",
+    "complete", "wait_for_completion",
+    "interruptible_sleep_on",
+    "add_wait_queue", "remove_wait_queue", "prepare_to_wait", "finish_wait",
+    "__tasklet_schedule",
+    "queue_work", "schedule_work", "flush_scheduled_work",
+    "schedule_delayed_work",
+    "__wake_up", "wake_up_process", "wake_up_state", "kill_fasync"
+  };
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE(toDelete); i++) {
+    Function *F = M.getFunction(toDelete[i]);
+    if (F)
+      F->deleteBody();
+  }
+  for (i = 0; i < ARRAY_SIZE(_makeNop); i++) {
+    Function *F = M.getFunction(_makeNop[i]);
+    if (F)
+      makeNop(F);
+  }
+}
+
+bool Prepare::addInitFun(const callgraph::Callgraph &CG,
+    SmallVector<Constant *, 10> &initFns, Type *ETy, Function &F, bool starting)
+{
+  if (F.isDeclaration())
+    return false;
+  if (starting) {
+    callgraph::Callgraph::range_iterator callees = CG.callees(&F);
+    if (std::distance(callees.first, callees.second))
+      return false;
+  }
+  initFns.push_back(ConstantExpr::getBitCast(&F, ETy));
+  return true;
+}
+
+void Prepare::findInitFuns(Module &M, const ptr::PointsToSets &PS) {
+  callgraph::Callgraph CG(M, PS);
+
+  SmallVector<Constant *, 10> initFns;
+  Type *ETy = TypeBuilder<void *, false>::get(M.getContext());
+  const char *initFun = getenv("SLICE_INITIAL_FUNCTION");
+
+  if (initFun) {
+    Function *F = M.getFunction(initFun);
+    if (F && addInitFun(CG, initFns, ETy, *F))
+      errs() << "INITIAL set to " << F->getName() << "\n";
+  } else {
+    for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I)
+      addInitFun(CG, initFns, ETy, *I, true);
+  }
+  ArrayType *ATy = ArrayType::get(ETy, initFns.size());
+  new GlobalVariable(M, ATy, true, GlobalVariable::InternalLinkage,
+                     ConstantArray::get(ATy, initFns),
+                     "__ai_init_functions");
+}
+
+bool Prepare::runOnModule(Module &M) {
+  ptr::PointsToSets PS;
+  {
+    ptr::ProgramStructure P(M);
+    computePointsToSets(P, PS);
+  }
+
+  deleteAsmBodies(M);
+
+  for (llvm::Module::iterator I = M.begin(), E = M.end(); I != E; ++I) {
+    Function &F = *I;
+    if (!F.isDeclaration())
+      runOnFunction(F);
+  }
+
+  findInitFuns(M, PS);
+
+  return true;
+}
diff --git a/lib/LLVMSlicer/Slicing/Prepare.h b/lib/LLVMSlicer/Slicing/Prepare.h
new file mode 100644
index 0000000..56d5f96
--- /dev/null
+++ b/lib/LLVMSlicer/Slicing/Prepare.h
@@ -0,0 +1,23 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#ifndef SLICING_PREPARE_H
+#define SLICING_PREPARE_H
+
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/IR/Module.h"
+
+static inline const llvm::ConstantArray *getInitFuns(const llvm::Module &M) {
+  const llvm::GlobalVariable *initFunsVar =
+      M.getGlobalVariable("__ai_init_functions", true);
+
+  if (!initFunsVar)
+    return NULL;
+
+  const llvm::ConstantArray *initFuns =
+      llvm::dyn_cast<llvm::ConstantArray>(initFunsVar->getInitializer());
+  return initFuns;
+}
+
+#endif
diff --git a/lib/LLVMSlicer/Slicing/StaticSlicer.cpp b/lib/LLVMSlicer/Slicing/StaticSlicer.cpp
new file mode 100644
index 0000000..6c728ba
--- /dev/null
+++ b/lib/LLVMSlicer/Slicing/StaticSlicer.cpp
@@ -0,0 +1,1006 @@
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+
+#include <llvm/IR/PassManager.h>
+#include <llvm/Analysis/Andersen/DetectParametersPass.h>
+#include <thread>
+#include <future>
+#include <utility>
+#include <llvm/Support/UniqueLock.h>
+#include <signal.h>
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Function.h"
+#include "llvm/Pass.h"
+#include "llvm/IR/Value.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/PassSupport.h"
+
+#include "FunctionStaticSlicer.h"
+#include "../Callgraph/Callgraph.h"
+#include "../Modifies/Modifies.h"
+#include "../PointsTo/PointsTo.h"
+#include "../Backtrack/Path.h"
+#include "../Backtrack/Rule.h"
+#include "../Backtrack/Constraint.h"
+#include "llvm/LLVMSlicer/StaticSlicer.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/Support/Format.h"
+#include "llvm/Support/Debug.h"
+
+#define DEBUG_TYPE "slicer"
+
+using namespace llvm;
+
+static cl::opt<std::string>
+        ReportFilename("r", cl::desc("Path to HTML report output file"),
+                       cl::value_desc("report"));
+
+namespace llvm { namespace slicing { namespace detail {
+
+
+
+
+    typedef ptr::PointsToSets::Pointee Pointee;
+    typedef std::map<const Pointee, const Pointee> ParamsToArgs;
+    typedef std::set<Pointee> RelevantSet;
+
+    static void fillParamsToArgs(const CallInst *C, const Function *F,
+			  ParamsToArgs &toArgs)
+    {
+	Function::const_arg_iterator p = F->arg_begin();
+
+	for (unsigned a = 0; a < C->getNumArgOperands(); ++a, ++p) {
+	    const Value *P = &*p;
+
+	    const Value *A = C->getArgOperand(a);
+	    if (!isConstantValue(A))
+		toArgs.insert(ParamsToArgs::value_type(Pointee(P, -1),
+					Pointee(A, -1)));
+	}
+    }
+
+static void getRelevantVarsAtCall(const CallInst *C, const Function *F, DetectParametersPass *DPP, const ptr::PointsToSets &PS,
+                                  ValSet::const_iterator b,
+                                  const ValSet::const_iterator &e,
+                                  RelevantSet &out,
+                                  FunctionStaticSlicer *FSS,
+                                  InsInfo *entry,
+                                  InsInfo::IncMap_t &RCInc,
+                                  InsInfo::SliceInfoSetMap_t &structSliceInfos,
+                                  InsInfo::ValMapSet_t &RCSources) {
+    assert(!isInlineAssembly(C) && "Inline assembly is not supported!");
+    DEBUG(errs() << C->getParent()->getParent()->getName() << " -> " << F->getName() << "\n");
+
+    if (C->getParent()->getParent()->getName() == "-[SOEncryptionModel encryptData:withSymetricKey:]") {
+        assert(true);
+    }
+
+//    if (C->getParent()->getParent()->getName() == "_EXTERNAL_")
+//        return;
+
+    ParamsToArgs toArgs;
+    fillParamsToArgs(C, F, toArgs);
+
+
+    DetectParametersPass::ParameterAccessPairSet_t Reg = DPP->getParameterRegisterIndexes((Function*)F);
+
+    for (; b != e; ++b) {
+//        if (Instruction *Ref = dyn_cast<Instruction>((Value*)b->first)) {
+//            if (Ref->getOpcode() == Instruction::Store) {
+//                out.insert(ptr::PointsToSets::Pointee(Ref->getOperand(0), -1));
+//            }
+//        }
+//        if (entry->getRCInc(*b) >= INC_MAX) {
+//            continue;
+//        }
+
+        const Value *loc = ptr::getAndersen()->getNodeFactory().getLocation(b->first);
+        if (loc) {
+            if (const Instruction *locInst = dyn_cast<const Instruction>(loc)) {
+                if (loc->getName().find("init") != StringRef::npos && locInst->getParent()->getParent() == F) {
+                    RCSources.erase(b->first);
+                    continue;
+                }
+            }
+        }
+
+        bool foundParameter = false;
+        if (const Instruction *I = dyn_cast<const Instruction>(b->first)) {
+            if (I->getOpcode() == Instruction::Load) {
+
+                for (DetectParametersPass::ParameterAccessPairSet_t::iterator Reg_it = Reg.begin(); Reg_it != Reg.end(); ++Reg_it) {
+                    if (I == Reg_it->second) {
+                        DetectParametersPass::UserSet_t Pre = DetectParametersPass::getRegisterValuesBeforeCall(Reg_it->first, C, true);
+                        for (DetectParametersPass::UserSet_t::iterator Pre_it = Pre.begin(); Pre_it != Pre.end(); ++Pre_it) {
+
+                            Instruction *I = (Instruction*)(*Pre_it);
+                            Pointee p(*Pre_it, -1);
+
+                            const InsInfo::ValSet_t src = entry->getRCSource(*b);
+                            if (src.size() == 0) {
+                                continue;
+                            }
+                            RCSources[p.first] = src;
+                            RCSources[p.first].insert(I);
+
+                            out.insert(p);
+
+                            structSliceInfos[p.first].insert(entry->RCStruct_begin(p.first), entry->RCStruct_end(p.first));
+
+                            RCInc[p.first] = RCInc[(*b).first];
+
+                            foundParameter = true;
+                        }
+                    }
+                }
+            }
+        }
+
+//        for (DetectParametersPass::ParameterAccessPairSet_t::iterator Pair = Ret.begin(); Pair != Ret.end(); ++Pair) {
+//            const ptr::PointsToSets::PointsToSet &PT = ptr::getPointsToSet(Pair->second, PS);
+//            for (ptr::PointsToSets::PointsToSet::iterator P_it = PT.begin(); P_it != PT.end(); ++P_it) {
+//                P_it->first->dump();
+////                if (P_it->first == b->first) {
+//                    DetectParametersPass::UserSet_t Pre = DetectParametersPass::getRegisterValuesBeforeCall(Pair->first, (Instruction*)C, true);
+//                    for (DetectParametersPass::UserSet_t::iterator Pre_it = Pre.begin(); Pre_it != Pre.end(); ++Pre_it) {
+//                        (*Pre_it)->dump();
+//                        out.insert(ptr::PointsToSets::Pointee(*Pre_it, -1));
+////                    }
+//                }
+//            }
+//        }
+
+        const InsInfo::ValSet_t src = entry->getRCSource(*b);
+        if (src.size() == 0) {
+            continue;
+        }
+        RCSources[b->first].insert(src.begin(), src.end());
+
+        //Copy all values that were not matched as parameters too
+        structSliceInfos[b->first].insert(entry->RCStruct_begin(b->first), entry->RCStruct_end(b->first));
+
+        if (foundParameter)
+            continue;
+
+//
+//        bool hasDEF = false;
+//
+//        for (const_inst_iterator I_it = inst_begin(callingFunction); I_it != inst_end(callingFunction) && !hasDEF; ++I_it) {
+//            InsInfo *info = FSS->getInsInfo(&*I_it);
+//
+//            for (ValSet::const_iterator DEF_it = info->DEF_begin(); DEF_it != info->DEF_end(); ++DEF_it) {
+//                if (b->first == DEF_it->first) {
+//                    hasDEF = true;
+//                    break;
+//                }
+//
+//                for (std::set<StructSliceInfo*>::iterator Struct_it = entry->RCStruct_begin(b->first); Struct_it != entry->RCStruct_end(b->first); ++Struct_it) {
+//                    for (auto &base : (*Struct_it)->basePointers) {
+//                        if (base.first == DEF_it->first) {
+//                            hasDEF = true;
+//                            break;
+//                        }
+//                    }
+//                }
+//            }
+//        }
+//
+//        if (!hasDEF) {
+////            continue;
+//        }
+
+//        continue;
+
+        ParamsToArgs::const_iterator it = toArgs.find(*b);
+        if (it != toArgs.end())
+            out.insert(it->second);
+        else if (!isLocalToFunction(b->first, F))
+            out.insert(*b);
+    }
+    return;
+}
+
+    static void getRelevantVarsAtExit(const CallInst *C, const ReturnInst *R, DetectParametersPass *DPP, const ptr::PointsToSets &PS,
+			       ValSet::const_iterator b,
+			       const ValSet::const_iterator &e,
+			       RelevantSet &out,
+                   InsInfo *succInfo,
+                   InsInfo *callInfo,
+                   InsInfo::IncMap_t &RCInc,
+                   InsInfo::SliceInfoSetMap_t &structSliceInfos,
+                   InsInfo::ValMapSet_t &RCSources,
+                   const mods::Modifies &MOD) {
+        DEBUG(errs() << C->getParent()->getParent()->getName() << " -> " << R->getParent()->getParent()->getName() << "\n");
+	assert(!isInlineAssembly(C) && "Inline assembly is not supported!");
+
+        DetectParametersPass::ParameterAccessPairSet_t Ret = DPP->getReturnRegisterIndexes((Function*)R->getParent()->getParent());
+
+//        for (DetectParametersPass::ParameterAccessPairSet_t::iterator Ret_it = Ret.begin(); Ret_it != Ret.end(); ++Ret_it) {
+//            out.insert(ptr::PointsToSets::Pointee(Ret_it->second, -1));
+//            out.insert(ptr::PointsToSets::Pointee(Ret_it->second->getOperand(0), -1));
+//            DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(Ret_it->first, C);
+//            for (DetectParametersPass::UserSet_t::iterator Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+//                out.insert(ptr::PointsToSets::Pointee(*Post_it, -1));
+//            }
+//        }
+
+//        return;
+
+	if (callToVoidFunction(C)) {
+
+//        std::copy(b, e, std::inserter(out, out.begin()));
+
+        for (ValSet::const_iterator it = b; it != e; ++it) {
+//            if (succInfo->getRCInc(*it) >= INC_MAX) {
+//                continue;
+//            }
+//            RCSources[it->first].insert(succInfo->getIns());
+//            RCSources[it->first].insert(callInfo->getIns());
+
+            //Check if the relevant variable is modified in this function
+            bool intersect = false;
+            mods::Modifies::mapped_type const& M = getModSet(R->getParent()->getParent(), MOD);
+            for (mods::Modifies::mapped_type::const_iterator v = M.begin();
+                 v != M.end(); ++v) {
+                if (v->first == (*it).first) {
+                    intersect = true;
+                    break;
+                }
+            }
+
+            //Relevant variable won't be modified anywhere here...
+            if (!intersect) {
+                continue;
+            }
+
+            RCSources[it->first].insert(R);
+
+            structSliceInfos[it->first].insert(callInfo->RCStruct_begin(it->first), callInfo->RCStruct_end(it->first));
+
+            out.insert(*it);
+
+//            const InsInfo::ValSet_t src = succInfo->getRCSource(*b);
+//            RCSources[it->first] = src;
+            structSliceInfos[it->first].insert(callInfo->RCStruct_begin(it->first), callInfo->RCStruct_end(it->first));
+        }
+
+        return;
+
+        for (DetectParametersPass::ParameterAccessPairSet_t::iterator Ret_it = Ret.begin(); Ret_it != Ret.end(); ++Ret_it) {
+            DetectParametersPass::UserSet_t Post = DetectParametersPass::getRegisterValuesAfterCall(Ret_it->first, C);
+            for (DetectParametersPass::UserSet_t::iterator Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {
+                for (ValSet::const_iterator b_it = b ; b_it != e; ++b_it) {
+                    if (const Instruction *I = dyn_cast<const Instruction>(b_it->first)) {
+                        if (I == (*Post_it)) {
+                            Pointee p(Ret_it->second, -1);
+                            out.insert(p);
+                            RCInc[p.first] = RCInc[b_it->first];
+
+                            const InsInfo::ValSet_t src = succInfo->getRCSource(*b);
+                            RCSources[p.first] = src;
+//                            RCSources[p.first].insert(callInfo->getIns());
+                            structSliceInfos[p.first].insert(callInfo->RCStruct_begin(p.first), callInfo->RCStruct_end(p.first));
+                        }
+                    }
+                }
+            }
+        }
+        return;
+	}
+
+        llvm_unreachable("Decompiled code uses void functions only");
+
+	for ( ; b != e; ++b)
+	    if (b->first == C) {
+		Value *ret = R->getReturnValue();
+		if (!ret) {
+/*		    C->dump();
+		    C->getCalledValue()->dump();
+		    R->dump();*/
+//		    abort();
+		    return;
+		}
+		out.insert(Pointee(R->getReturnValue(), -1));
+	    } else
+		out.insert(*b);
+    }
+
+}}}
+
+namespace llvm { namespace slicing {
+
+
+
+        static cl::opt<int> limitCalls("limit-calls", cl::init(0), cl::Hidden);
+
+    class StaticSlicer : public InsInfoProvider {
+    public:
+        typedef std::map<llvm::Function const*, FunctionStaticSlicer *> Slicers;
+        typedef std::multimap<llvm::Function const*,llvm::CallInst const*>
+                FuncsToCalls;
+        typedef std::multimap<llvm::CallInst const*,llvm::Function const*>
+                CallsToFuncs;
+
+        StaticSlicer(ModulePass *MP, Module &M,
+		     const ptr::PointsToSets &PS,
+                     const callgraph::Callgraph &CG,
+                     const mods::Modifies &MOD,
+                     std::vector<Rule*> rules);
+
+        ~StaticSlicer();
+
+        void computeSlice();
+        void ruleIteration();
+        bool sliceModule();
+
+        virtual void addInitialSlicingCriterion(const Instruction *C);
+
+        virtual InsInfo *getInsInfo(const Instruction *I);
+
+        bool addRule(Rule *rule);
+        const std::vector<Rule*> getRules() const {
+            return rules;
+        }
+
+    private:
+        typedef llvm::SmallVector<const llvm::Function *, 20> InitFuns;
+
+        legacy::PassManager *PM;
+        DetectParametersPass *DPP;
+        const ptr::PointsToSets &PS;
+        const mods::Modifies &MOD;
+
+        std::vector<Rule*> rules;
+        std::vector<Rule*> ruleWorklist;
+
+	void buildDicts(const ptr::PointsToSets &PS, const CallInst *c);
+        void buildDicts(const ptr::PointsToSets &PS);
+
+        void findInitialCriterions();
+
+        template<typename OutIterator>
+        void emitToCalls(llvm::Function const* const f, OutIterator out);
+
+        template<typename OutIterator>
+        void emitToExits(llvm::Function const* const f, OutIterator out);
+
+        void runFSS(Function &F, const ptr::PointsToSets &PS,
+                    const callgraph::Callgraph &CG, const mods::Modifies &MOD);
+
+        ModulePass *MP;
+        Module &module;
+        Slicers slicers;
+        std::mutex slicersLock;
+        InitFuns initFuns;
+        FuncsToCalls funcsToCalls;
+        CallsToFuncs callsToFuncs;
+
+        std::set<const Instruction*> InitialCriterions;
+    };
+
+    template<typename OutIterator>
+    void StaticSlicer::emitToCalls(const Function *f, OutIterator out) {
+        const Instruction *entry = getFunctionEntry(f);
+        const ValSet::const_iterator relBgn = slicers[f]->relevant_begin(entry);
+        const ValSet::const_iterator relEnd = slicers[f]->relevant_end(entry);
+
+
+        if (relBgn == relEnd) {
+//            errs() << "Skip: " << f->getName() << "\n";
+            return;
+        }
+
+        if (f->getName() == "-[RNCryptorEngine initWithOperation:settings:key:IV:error:]") {
+            assert(true);
+        }
+
+        bool dump = false;
+        if (dump) {
+            for (ValSet::const_iterator it = relBgn; it != relEnd; ++it) {
+                (*it).first->dump();
+            }
+        }
+
+        InsInfo::IncMap_t RCInc;
+        InsInfo *entryInfo = slicers[f]->getInsInfo(entry);
+        for (ValSet::const_iterator i = relBgn; i != relEnd; ++i) {
+            double RC_inc = entryInfo->getRCInc(*i);
+            RCInc[i->first] = RC_inc;
+        }
+
+        FuncsToCalls::const_iterator c, e;
+        std::tie(c, e) = funcsToCalls.equal_range(f);
+
+        if (limitCalls && std::distance(c, e) > limitCalls) {
+            errs() << "To many calls to function " << f->getName() << " -> skip\n";
+            return;
+        }
+
+        std::set<std::string> calls;
+
+        for (; c != e; ++c) {
+            const CallInst *CI = c->second;
+            const Function *g = CI->getParent()->getParent();
+            FunctionStaticSlicer *FSS = slicers[g];
+
+            detail::RelevantSet R;
+            InsInfo::SliceInfoSetMap_t structSliceInfos;
+            InsInfo::ValMapSet_t rcSources;
+            detail::getRelevantVarsAtCall(c->second, f, DPP, PS, relBgn, relEnd, R, FSS, entryInfo, RCInc, structSliceInfos, rcSources);
+
+            if (R.begin() == R.end()) {
+//                errs() << "Skip: " << f->getName() << "\n";
+                continue;
+            }
+
+            typedef std::set<const Function*> FunctionSet_t;
+            std::function< bool(const Value *, const Function *, FunctionSet_t&) > isInScope = [&](const Value *r, const Function *f, FunctionSet_t &visited) {
+                if (visited.find(f) != visited.end()) {
+                    return false;
+                }
+                visited.insert(f);
+
+                //probably a constant inst stored in a register. needs to be kept
+                if (dyn_cast<const StoreInst>(r)) {
+                    return true;
+                }
+
+                if (dyn_cast<const Constant>(r)) {
+                    return true;
+                }
+
+                mods::Modifies::mapped_type const& M = getModSet(f, MOD);
+                bool isModified = false;
+
+                for (mods::Modifies::mapped_type::const_iterator v = M.begin();
+                     v != M.end(); ++v) {
+                        if (v->first == r) {
+                            isModified = true;
+                            break;
+                        }
+                }
+
+                if (isModified) {
+
+                } else {
+                    FuncsToCalls::const_iterator calledBy_b, callledBy_e;
+                    std::tie(calledBy_b, callledBy_e) = funcsToCalls.equal_range(f);
+
+                    for (; calledBy_b != callledBy_e; ++calledBy_b) {
+                        if (isInScope(r, calledBy_b->second->getParent()->getParent(), visited)) {
+                            isModified = true;
+                            break;
+                        }
+                    }
+                }
+//
+//                if (!isModified) {
+//                    for (auto &infos : structSliceInfos) {
+//                        for (auto &ssi : infos.second) {
+//                            for (auto &l : ssi->locations) {
+//                                if (r == l.first) {
+//                                    llvm_unreachable("");
+//                                }
+//                            }
+//                        }
+//                    }
+//                }
+                return isModified;
+            };
+
+            detail::RelevantSet toRemove;
+
+            for (auto &r : R) {
+                FunctionSet_t visited;
+                if (!isInScope(r.first, g, visited)) {
+                    toRemove.insert(r);
+                }
+            }
+
+            for (auto &rem : toRemove) {
+                DEBUG(errs() << "Not modified: "; rem.first->dump());
+                R.erase(rem);
+            }
+
+            if (!R.size()) {
+                DEBUG(errs() << "No relevant variables in scope " << f->getName() << "\n");
+                continue;
+            }
+
+            FSS->initializeInfos();
+            InsInfo *CallInfo = FSS->getInsInfo(CI);
+
+            if (FSS->addCriterion(CI, R.begin(), R.end(), this,
+                                  rcSources, RCInc, !FSS->shouldSkipAssert(CI))) {
+                FSS->addCriterion(CI, FSS->REF_begin(CI), FSS->REF_end(CI));
+                *out++ = g;
+                calls.insert(c->second->getParent()->getParent()->getName().str());
+            }
+
+            for (auto &structInfo_it : structSliceInfos) {
+                for (auto &ssi_it : structInfo_it.second) {
+                  CallInfo->addRCStruct(structInfo_it.first, ssi_it);
+                }
+            }
+        }
+#ifdef DUMP_CALLS
+        if (calls.size()) {
+            errs() << f->getName() << " called by:\n";
+            for (auto &s : calls) {
+                errs() << "\t" << s << "\n";
+            }
+            errs() << "\n";
+        }
+#endif
+    }
+
+    template<typename OutIterator>
+    void StaticSlicer::emitToExits(const Function *f, OutIterator out) {
+        typedef std::vector<const CallInst *> CallsVec;
+
+        CallsVec C;
+        getFunctionCalls(f, std::back_inserter(C));
+
+        std::set<std::string> calls;
+
+
+        for (CallsVec::const_iterator c = C.begin(); c != C.end(); ++c) {
+            const Instruction *succ = getSuccInBlock(*c);
+            const ValSet::const_iterator relBgn =
+                    slicers[f]->relevant_begin(succ);
+            const ValSet::const_iterator relEnd =
+                    slicers[f]->relevant_end(succ);
+
+            InsInfo::IncMap_t RCInc;
+            InsInfo *succInfo = slicers[f]->getInsInfo(succ);
+            InsInfo *callInfo = slicers[f]->getInsInfo(*c);
+            for (ValSet::const_iterator i = relBgn; i != relEnd; ++i) {
+                double RC_inc = succInfo->getRCInc(*i);
+                RCInc[i->first] = RC_inc;
+            }
+
+            CallsToFuncs::const_iterator g, e;
+            std::tie(g, e) = callsToFuncs.equal_range(*c);
+
+            for (; g != e; ++g) {
+                typedef std::vector<const llvm::ReturnInst *> ExitsVec;
+                const Function *callie = g->second;
+
+
+
+                ExitsVec E;
+                getFunctionExits(callie, std::back_inserter(E));
+
+                for (ExitsVec::const_iterator e = E.begin(); e != E.end(); ++e) {
+
+                    detail::RelevantSet R;
+                    InsInfo::ValMapSet_t RCSources;
+                    InsInfo::SliceInfoSetMap_t structSliceInfos;
+                    detail::getRelevantVarsAtExit(*c, *e, DPP, PS, relBgn, relEnd, R, succInfo, callInfo, RCInc, structSliceInfos, RCSources, MOD);
+
+                    if (relBgn == relEnd) {
+                        continue;
+                    }
+
+                    slicers[g->second]->initializeInfos();
+                    InsInfo *exitInfo = slicers[g->second]->getInsInfo(*e);
+
+                    callInfo->addReturnPred(*e);
+                    //FIXME: add real rc sources
+                    if (slicers[g->second]->addCriterion(*e, R.begin(), R.end(), this, RCSources, RCInc)) {
+                        *out++ = g->second;
+                        calls.insert(g->second->getName());
+                    }
+
+                    for (auto &structInfo_it : structSliceInfos) {
+                        for (auto &ssi_it : structInfo_it.second) {
+                          exitInfo->addRCStruct(structInfo_it.first, ssi_it);
+                        }
+                    }
+                }
+            }
+        }
+#ifdef DUMP_CALLS
+        if (calls.size()) {
+            errs() << f->getName() << " calls\n";
+            for (auto &s : calls) {
+                errs() << "\t" << s << "\n";
+            }
+            errs() << "\n";
+        }
+#endif
+    }
+
+    void StaticSlicer::buildDicts(const ptr::PointsToSets &PS,
+		const CallInst *c) {
+	typedef std::vector<const Function *> FunCon;
+	FunCon G;
+	getCalledFunctions(c, PS, std::back_inserter(G));
+
+	for (FunCon::const_iterator I = G.begin(), E = G.end(); I != E; ++I) {
+	    const Function *h = *I;
+
+	    if (!memoryManStuff(h) && !h->isDeclaration()) {
+		funcsToCalls.insert(std::make_pair(h, c));
+		callsToFuncs.insert(std::make_pair(c, h));
+	    }
+	}
+    }
+
+    void StaticSlicer::buildDicts(const ptr::PointsToSets &PS)
+    {
+        for (Module::const_iterator f = module.begin(); f != module.end(); ++f)
+            if (!f->isDeclaration() && !memoryManStuff(&*f))
+                for (const_inst_iterator I = inst_begin(*f), E = inst_end(*f);
+			I != E; ++I)
+                    if (const CallInst *c = dyn_cast<CallInst>(&*I)) {
+			if (isInlineAssembly(c)) {
+			    errs() << "ERROR: Inline assembler detected in " <<
+				f->getName() << ", skipping\n";
+			    continue;
+			}
+
+			buildDicts(PS, c);
+		    }
+    }
+
+    StaticSlicer::StaticSlicer(ModulePass *MP, Module &M,
+                               const ptr::PointsToSets &PS,
+                               const callgraph::Callgraph &CG,
+                               const mods::Modifies &MOD,
+                               std::vector<Rule*> rules) :
+                               PS(PS), MOD(MOD), MP(MP), module(M), slicers(), initFuns(), funcsToCalls(), callsToFuncs() {
+        for (auto &rule : rules) {
+            addRule(rule);
+        }
+        for (Module::iterator f = M.begin(); f != M.end(); ++f)
+          if (!f->isDeclaration() && !memoryManStuff(&*f))
+            runFSS(*f, PS, CG, MOD);
+        buildDicts(PS);
+        PM = new legacy::PassManager();
+        DPP = new DetectParametersPass();
+        PM->add(DPP);
+
+        PM->run(M);
+    }
+
+    StaticSlicer::~StaticSlicer() {
+      for (Slicers::const_iterator I = slicers.begin(), E = slicers.end();
+           I != E; ++I)
+        delete I->second;
+    }
+
+    void StaticSlicer::runFSS(Function &F, const ptr::PointsToSets &PS,
+			      const callgraph::Callgraph &CG,
+			      const mods::Modifies &MOD) {
+
+      FunctionStaticSlicer *FSS = new FunctionStaticSlicer(F, MP, PS, MOD, this);
+
+      slicers.insert(Slicers::value_type(&F, FSS));
+    }
+
+        void StaticSlicer::ruleIteration() {
+            findInitialCriterions();
+
+            struct FunctionCmp {
+                bool operator()(const Function* lhs, const Function* rhs) const  { return lhs->getName().str().compare(rhs->getName().str()); }
+            };
+//        typedef SmallVector<const Function *, 20> WorkSet;
+            typedef std::set<const Function *> WorkSet;
+//        WorkSet Q(initFuns);
+            WorkSet Q;
+            for (auto &i : initFuns) {
+                Q.insert(i);
+            }
+
+            errs() << "Found " << initFuns.size() << " initial criterions\n";
+
+            initFuns.clear();
+
+            uint64_t numSlices = 0;
+
+            while (!Q.empty()) {
+
+                size_t numFunctions = Q.size();
+
+                errs() << "Num functions: " << numFunctions << "\n";
+
+
+                for (WorkSet::const_iterator f = Q.begin(); f != Q.end(); ++f) {
+                slicers[*f]->calculateStaticSlice();
+            }
+
+                WorkSet tmp;
+                for (WorkSet::const_iterator f = Q.begin(); f != Q.end(); ++f) {
+                    emitToCalls(*f, std::inserter(tmp, tmp.end()));
+                    emitToExits(*f, std::inserter(tmp, tmp.end()));
+                }
+                std::swap(tmp,Q);
+
+                std::vector<const Function*> x(Q.begin(), Q.end());
+                std::sort(x.begin(), x.end());
+                x.erase(std::unique(x.begin(), x.end()), x.end());
+
+                if (x.size() != Q.size()) {
+                    Q.clear();
+                    Q.insert(x.begin(), x.end());
+                }
+
+            }
+
+            errs() << "Num function slices: " << numSlices << "\n";
+
+            std::vector<Rule*> toCheck(ruleWorklist);
+            std::vector<Rule*> worklist(ruleWorklist);
+
+            while(!worklist.empty()) {
+
+                std::vector<Rule*> tmp;
+
+                for (auto &w : worklist) {
+                    for (auto &c : w->getChildren()) {
+                        if (c->getType() == Constraint::RULE) {
+                            tmp.push_back((Rule*)c);
+                            toCheck.push_back((Rule*)c);
+                        }
+                    }
+                }
+
+                std::swap(worklist, tmp);
+            }
+
+            std::vector<Path*> paths;
+
+            auto createPath = [&](const Instruction *call, const Instruction *inst, Rule *rule, Path *parent = nullptr) {
+                InsInfo *C_info = getInsInfo(inst);
+                assert(C_info);
+
+                PathElement *element = nullptr;
+                if (call) {
+
+                } else {
+
+                }
+
+                Path *path = nullptr;
+                if (parent) {
+                    path = parent;
+                } else {
+                    path = new Path();
+                }
+
+                if (parent) {
+                    element = new PathElement(inst, inst);
+                    path->getLast()->setNext(element);
+                    element->setPrev(path->getLast());
+                } else if (call) {
+                    PathElement *start = new PathElement(call, inst);
+                    element = new PathElement(inst, inst);
+
+                    path->setEntry(start);
+                    start->setNext(element);
+                    element->setPrev(start);
+                } else {
+                    element = new PathElement(inst, inst);
+                    path->setEntry(element);
+                }
+
+                std::vector<Path*> p;
+                std::mutex pathLock;
+                if (C_info->backtrack(this, element, p, pathLock, *rule)) {
+                    pathLock.lock();
+                    if (std::find_if(p.begin(), p.end(), [path](const Path *other) { return *path == *other;}) == p.end()) {
+                        p.push_back(path);
+                    }
+                    pathLock.unlock();
+                } else {
+                    delete(path);
+                }
+                std::sort(p.begin(), p.end());
+
+                bool modified = false;
+                do {
+                    modified = false;
+                    for (std::vector<Path *>::iterator i = p.begin(); i != p.end() && !modified; ++i) {
+                        std::vector<Path *>::iterator j = i;
+                        std::advance(j, 1);
+                        for (; j != p.end(); ++j) {
+                            if (i == j)
+                                continue;
+                            if (**i == **j) {
+                                p.erase(j);
+                                modified = true;
+                                break;
+                            }
+                        }
+                    }
+                }while(modified);
+
+                rule->addPaths(p);
+            };
+
+            errs() << "Backtrack\n";
+            for (std::vector<Rule*>::iterator rule = toCheck.begin(); rule != toCheck.end(); ++rule) {
+                errs() << (*rule)->getRuleTitle() << "\n";
+                for (auto &C : (*rule)->getInitialInstruction()) {
+                    for (auto &C_pre : C.second) {
+                        createPath(C.first.first, C_pre.first, C_pre.second);
+                    }
+
+                    if ((*rule)->getParentRuleTitle().size()) {
+                        for (auto &p : rules) {
+                            if (p->getRuleTitle() == (*rule)->getParentRuleTitle()) {
+                                for (auto &path : p->getPaths()) {
+                                    if (path->getLast()->getElement() == C.first.first) {
+                                        p->setDismissable(path);
+                                        createPath(C.first.first, C.first.second, *rule, new Path(*path));
+                                    }
+                                }
+                            }
+                        }
+                    } else {
+                        createPath(C.first.first, C.first.second, *rule);
+                    }
+
+                }
+            }
+
+            errs() << "Backtrack done\n";
+
+
+            for (auto &rule : ruleWorklist) {
+                rule->removeDismissablePaths();
+                errs() << rule->getRuleTitle() << "\n"  ;
+                rule->checkRule();
+            }
+
+            std::vector<Rule*> checkRules(ruleWorklist);
+            ruleWorklist.clear();
+            for (auto &rule : checkRules) {
+                for (auto &path : rule->getPaths()) {
+                    if (path->getLast()->getType() == PathElementBase::ConstAddressElement) {
+                        if (((ConstPathElement*)path->getLast())->shouldCreateNewCriterion()) {
+                            assert(true);
+                            Rule *newRule = new Rule(*rule, path->getLast()->getElement());
+                            if (!addRule(newRule))
+                                delete(newRule);
+                        }
+                    }
+                }
+            }
+        }
+
+    void StaticSlicer::computeSlice() {
+        while(ruleWorklist.size()) {
+            ruleIteration();
+        }
+    }
+
+    bool StaticSlicer::sliceModule() {
+      bool modified = false;
+      for (Slicers::iterator s = slicers.begin(); s != slicers.end(); ++s)
+        modified |= s->second->slice();
+      if (modified)
+        for (Module::iterator I = module.begin(), E = module.end(); I != E; ++I)
+          if (!I->isDeclaration())
+            FunctionStaticSlicer::removeUndefs(MP, *I);
+
+      return modified;
+    }
+
+        bool StaticSlicer::addRule(Rule *rule) {
+            if (std::find_if(rules.begin(), rules.end(), [&](Rule *other) {return *rule == *other;}) != rules.end())
+                return false;
+            rules.push_back(rule);
+            ruleWorklist.push_back(rule);
+            return true;
+        }
+
+        void StaticSlicer::findInitialCriterions() {
+            for (Module::iterator f = module.begin(); f != module.end(); ++f) {
+                if (!f->isDeclaration() && !memoryManStuff(&*f)) {
+                    FunctionStaticSlicer *FSS = slicers[f];
+                    bool hadAssert = slicing::findInitialCriterion(*f, *FSS, ruleWorklist);
+
+                    if (hadAssert) {
+                        initFuns.push_back(f);
+                        FSS->initializeInfos();
+                    }
+                }
+            }
+        }
+
+        void StaticSlicer::addInitialSlicingCriterion(const Instruction *C) {
+            InitialCriterions.insert(C);
+        }
+
+        InsInfo *StaticSlicer::getInsInfo(const Instruction *I) {
+            if (!I) {
+                return nullptr;
+            }
+            const Function *f = I->getParent()->getParent();
+            FunctionStaticSlicer *fss = slicers[f];
+            if (!fss->isInitialized())
+                return nullptr;
+            return fss->getInsInfo(I);
+        }
+}}
+
+
+char Slicer::ID = 0;
+
+static RegisterPass<Slicer> X("slice-inter", "View CFG of function", false, true);
+static RegisterAnalysisGroup<Slicer> Y(X);
+
+
+bool Slicer::runOnModule(Module &M) {
+  ptr::PointsToSets *PS = new ptr::PointsToSets();
+  {
+    ptr::ProgramStructure P(M);
+    computePointsToSets(P, *PS);
+  }
+
+  callgraph::Callgraph CG(M, *PS);
+
+  mods::Modifies MOD;
+  {
+    mods::ProgramStructure P1(M, *PS);
+    computeModifies(P1, CG, *PS, MOD);
+  }
+    errs() << "done\n";
+
+    using llvm::slicing::Rule;
+    using llvm::slicing::Constraint;
+    using llvm::slicing::Parameter;
+
+    std::vector<Rule*> rules = llvm::slicing::parseRules();
+
+    for (auto &r : rules) {
+        if (r->getParentRuleTitle().size()) {
+            for (auto &r2 : rules) {
+                if (r2->getRuleTitle() == r->getParentRuleTitle()) {
+                    r->setParentRule(r2);
+                }
+            }
+        }
+    }
+
+  slicing::StaticSlicer SS(this, M, (*PS), CG, MOD, rules);
+  SS.computeSlice();
+
+    free(PS);
+    bool s = SS.sliceModule();
+
+
+
+    raw_fd_ostream *report_stream = nullptr;
+    if (ReportFilename.length()) {
+        std::error_code EC;
+
+        report_stream = new raw_fd_ostream(ReportFilename, EC, sys::fs::F_None);
+
+        if (EC) {
+            errs() << EC.message() << '\n';
+        }
+    }
+
+    llvm::slicing::HTMLReportPrinter reportPrinter(report_stream ? *report_stream : nulls());
+    for (auto &rule : SS.getRules()) {
+        errs() << "Print results of \"" << rule->getRuleTitle() << "\"\n";
+        const Rule::CompletePathResultList_t &results = rule->getResults();
+        errs() << results.size() << " paths\n";
+        reportPrinter.addResults(rule, results);
+    }
+    reportPrinter.close();
+
+    if (report_stream) {
+        report_stream->close();
+        delete (report_stream);
+    }
+  return s;
+}
+
+void Slicer::getAnalysisUsage(AnalysisUsage &AU) const {
+    AU.addRequired<PostDominatorTree>();
+    AU.addRequired<PostDominanceFrontier>();
+}
\ No newline at end of file
diff --git a/tools/LLVMBuild.txt b/tools/LLVMBuild.txt
index d6c08d2..f510e1c 100644
--- a/tools/LLVMBuild.txt
+++ b/tools/LLVMBuild.txt
@@ -27,6 +27,7 @@ subdirectories =
  llvm-cov
  llvm-diff
  llvm-dis
+ llvm-andersen
  llvm-dwarfdump
  llvm-extract
  llvm-jitlistener
@@ -41,6 +42,7 @@ subdirectories =
  llvm-rtdyld
  llvm-size
  llvm-split
+ llvm-slicer
  opt
  verify-uselistorder
 
diff --git a/tools/llvm-andersen/CMakeLists.txt b/tools/llvm-andersen/CMakeLists.txt
new file mode 100644
index 0000000..3ae0e64
--- /dev/null
+++ b/tools/llvm-andersen/CMakeLists.txt
@@ -0,0 +1,12 @@
+set(LLVM_LINK_COMPONENTS
+  BitReader
+  Core
+  Support
+  IRReader
+  Analysis
+  Slicer
+  )
+
+add_llvm_tool(llvm-andersen
+        llvm-andersen.cpp
+  )
diff --git a/tools/llvm-andersen/LLVMBuild.txt b/tools/llvm-andersen/LLVMBuild.txt
new file mode 100644
index 0000000..83a5a84
--- /dev/null
+++ b/tools/llvm-andersen/LLVMBuild.txt
@@ -0,0 +1,22 @@
+;===- ./tools/llvm-dis/LLVMBuild.txt ---------------------------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Tool
+name = llvm-andersen
+parent = Tools
+required_libraries = Analysis BitReader IRReader Core Support Object Slicer
diff --git a/tools/llvm-andersen/llvm-andersen.cpp b/tools/llvm-andersen/llvm-andersen.cpp
new file mode 100644
index 0000000..eb79337
--- /dev/null
+++ b/tools/llvm-andersen/llvm-andersen.cpp
@@ -0,0 +1,215 @@
+//===-- llvm-dis.cpp - The low-level LLVM disassembler --------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This utility may be invoked in the following manner:
+//  llvm-dis [options]      - Read LLVM bitcode from stdin, write asm to stdout
+//  llvm-dis [options] x.bc - Read LLVM bitcode from the x.bc file, write asm
+//                            to the x.ll file.
+//  Options:
+//      --help   - Output information about command line switches
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/Bitcode/ReaderWriter.h"
+#include "llvm/IR/AssemblyAnnotationWriter.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/DebugInfo.h"
+#include "llvm/IR/DiagnosticInfo.h"
+#include "llvm/IR/DiagnosticPrinter.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/IRReader/IRReader.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/IR/PassManager.h"
+#include "llvm/IR/Type.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/DataStream.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/FormattedStream.h"
+#include "llvm/Support/ManagedStatic.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/PrettyStackTrace.h"
+#include "llvm/Support/Signals.h"
+#include "llvm/Support/ToolOutputFile.h"
+#include <system_error>
+#include <llvm/Support/SourceMgr.h>
+#include <llvm/Analysis/LoopInfo.h>
+#include <llvm/IR/InstIterator.h>
+#include <llvm/Analysis/Andersen/NonVolatileRegistersPass.h>
+#include <llvm/IR/PatternMatch.h>
+#include "llvm/Analysis/Andersen/Andersen.h"
+#include "llvm/Analysis/Andersen/StackAccessPass.h"
+#include "llvm/Analysis/Andersen/DetectParametersPass.h"
+#include "llvm/IR/Dominators.h"
+
+using namespace llvm;
+
+static cl::opt<std::string>
+        InputFilename(cl::Positional, cl::desc("<input bitcode>"), cl::init("-"));
+
+cl::opt<std::string> CallgraphFile("callgraph", cl::desc(""), cl::init(""), cl::Hidden);
+
+static cl::opt<bool>
+        Replace("replace-calls", cl::desc("If there is only a single candidate for a call it gets replaced"),
+                     cl::init(false));
+
+static cl::opt<bool>
+        NoPrint("no-print", cl::desc(""),
+                cl::init(false));
+
+static cl::list<std::string>
+        ExtractFuncs("func", cl::desc("Specify function to extract"),
+                     cl::ZeroOrMore, cl::value_desc("function"));
+
+int main(int argc, char **argv) {
+    sys::PrintStackTraceOnErrorSignal();
+    PrettyStackTraceProgram X(argc, argv);
+
+    LLVMContext &Context = getGlobalContext();
+    llvm_shutdown_obj Y;  // Call llvm_shutdown() on exit.
+
+    cl::ParseCommandLineOptions(argc, argv, "llvm .bc -> .ll disassembler\n");
+
+
+    SMDiagnostic Err;
+    std::unique_ptr<Module> Mod = parseIRFile(InputFilename, Err, getGlobalContext());
+    if (!Mod) {
+        Err.print(argv[0], errs());
+        return 1;
+    }
+
+    raw_ostream *callgraph = nullptr;
+    if (!CallgraphFile.length())
+        callgraph = &nulls();
+    else {
+        std::error_code EC;
+
+        callgraph = new raw_fd_ostream(CallgraphFile, EC, sys::fs::F_None);
+
+        if (EC) {
+            errs() << EC.message() << '\n';
+            callgraph = &nulls();
+        }
+    }
+
+//    Mod->dump();
+    legacy::PassManager *LPM = new legacy::PassManager();
+    LPM->add(new LoopInfoWrapperPass());
+    LPM->add(new DominatorTreeWrapperPass());
+    LPM->add(new StackAccessPass());
+    LPM->add(new DetectParametersPass());
+    Andersen *andersen = new Andersen();
+    LPM->add(andersen);
+    LPM->run(*Mod);
+
+    andersen->getCallGraph().print(*callgraph);
+
+    if (Replace) {
+        SimpleCallGraph &cg = andersen->getCallGraph();
+        for (Module::FunctionListType::iterator F_it = Mod->getFunctionList().begin(); F_it != Mod->getFunctionList().end() ; ++F_it) {
+            for (inst_iterator I_it = inst_begin(*F_it); I_it != inst_end(*F_it); ++I_it) {
+                if (I_it->getOpcode() == Instruction::Call) {
+                    SimpleCallGraph::FunctionSet_t called = cg.getCalled(&*I_it);
+                    if (called.size() == 1) {
+                        std::string functionName = *called.begin();
+                        Function *function = Mod->getFunction(functionName);
+                        if (!function) {
+                            function = dyn_cast<Function>(Mod->getOrInsertFunction(functionName, Type::getVoidTy(getGlobalContext()), I_it->getParent()->getParent()->getArgumentList().begin()->getType(), NULL));
+                        }
+                        assert(function);
+                        if (function) {
+                            CallInst *call = (CallInst*)&*I_it;
+                            call->setCalledFunction(function);
+                        }
+                    }
+                }
+            }
+        }
+
+
+        std::error_code EC;
+        std::unique_ptr<tool_output_file> FDOut = llvm::make_unique<tool_output_file>(InputFilename, EC,
+                                                                                      sys::fs::F_None);
+        if (EC) {
+            errs() << EC.message() << '\n';
+            return -1;
+        }
+
+        FDOut->os() << *Mod;
+
+        FDOut->keep();
+
+        return 0;
+    }
+
+    if(NoPrint) {
+        return 0;
+    }
+
+    for (Module::FunctionListType::iterator F_it = Mod->getFunctionList().begin(); F_it != Mod->getFunctionList().end() ; ++F_it) {
+        bool extract = ExtractFuncs.size() == 0 ? true : false;
+        for (auto &e : ExtractFuncs) {
+            if (e == F_it->getName()) {
+                extract = true;
+                break;
+            }
+        }
+        if (!extract)
+            continue;
+        errs() << "###############################################################################################\n";
+        errs() << (F_it->hasName() ? F_it->getName() : "UNNAMED") << "\n";
+        for (inst_iterator I_it = inst_begin(*F_it); I_it != inst_end(*F_it); ++I_it) {
+
+            Value *I = &*I_it;
+            Instruction *Inst = &*I_it;
+
+            if (Inst->getOpcode() == Instruction::Load) {
+                if (PatternMatch::match(Inst->getOperand(0), PatternMatch::m_IntToPtr(PatternMatch::m_Constant()))) {
+//                    I = Inst->getOperand(0);
+                }
+            } else if (Inst->getOpcode() == Instruction::Store) {
+//                if (PatternMatch::match(Inst->getOperand(1), PatternMatch::m_IntToPtr(PatternMatch::m_ConstantInt()))) {
+                    I = Inst->getOperand(1);
+//                }
+            }
+            Andersen::StringSet_t Types;
+
+            std::vector<const llvm::Value*> PtsTo;
+            andersen->getPointsToSet(I, PtsTo);
+            if (PtsTo.size()) {
+                errs() << "\n";
+                Inst->dump();
+                errs() << "PtsTo: " << PtsTo.size() << "\n";
+
+                for (unsigned i = 0; i < PtsTo.size(); ++i) {
+                    errs() << *(PtsTo[i]);
+                    const Value *src = andersen->getNodeFactory().getLocation(PtsTo[i]);
+                    errs() << *(PtsTo[i]) << " ";
+                    if (src) {
+                        errs() << *src;
+                        if (const Instruction *srcInst = dyn_cast<const Instruction>(src)) {
+                            errs() << "(" << srcInst->getParent()->getParent()->getName() << ")";
+                        }
+                    }
+                    errs() << "\n";
+                    if (andersen->getType((Value*)PtsTo[i], Types)) {
+                        for (auto &Type : Types) {
+                            errs() << "Type: " << Type << "\n";
+                        }
+                        errs() << "\n";
+                    }
+                }
+
+            }
+        }
+    }
+
+    return 0;
+}
diff --git a/tools/llvm-slicer/CMakeLists.txt b/tools/llvm-slicer/CMakeLists.txt
new file mode 100644
index 0000000..899baa1
--- /dev/null
+++ b/tools/llvm-slicer/CMakeLists.txt
@@ -0,0 +1,10 @@
+set(LLVM_LINK_COMPONENTS
+  IRReader
+  Core
+  Support
+  Slicer
+  )
+
+add_llvm_tool(llvm-slicer
+  llvm-slicer.cpp
+  )
diff --git a/tools/llvm-slicer/LLVMBuild.txt b/tools/llvm-slicer/LLVMBuild.txt
new file mode 100644
index 0000000..5b97da7
--- /dev/null
+++ b/tools/llvm-slicer/LLVMBuild.txt
@@ -0,0 +1,22 @@
+;===- ./tools/llvm-as/LLVMBuild.txt ----------------------------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Tool
+name = llvm-slicer
+parent = Tools
+required_libraries = Core Support IRReader Slicer Object
diff --git a/tools/llvm-slicer/Makefile b/tools/llvm-slicer/Makefile
new file mode 100644
index 0000000..dfd71b2
--- /dev/null
+++ b/tools/llvm-slicer/Makefile
@@ -0,0 +1,17 @@
+##===- tools/llvm-as/Makefile ------------------------------*- Makefile -*-===##
+# 
+#                     The LLVM Compiler Infrastructure
+#
+# This file is distributed under the University of Illinois Open Source
+# License. See LICENSE.TXT for details.
+# 
+##===----------------------------------------------------------------------===##
+
+LEVEL := ../..
+TOOLNAME := llvm-as
+LINK_COMPONENTS := asmparser bitwriter
+
+# This tool has no plugins, optimize startup time.
+TOOL_NO_EXPORTS := 1
+
+include $(LEVEL)/Makefile.common
diff --git a/tools/llvm-slicer/llvm-slicer.cpp b/tools/llvm-slicer/llvm-slicer.cpp
new file mode 100644
index 0000000..e6f2909
--- /dev/null
+++ b/tools/llvm-slicer/llvm-slicer.cpp
@@ -0,0 +1,97 @@
+//===--- llvm-slicer.cpp - The low-level LLVM assembler -------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/AsmParser/Parser.h"
+#include "llvm/Bitcode/ReaderWriter.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Verifier.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/ManagedStatic.h"
+#include "llvm/Support/PrettyStackTrace.h"
+#include "llvm/Support/Signals.h"
+#include "llvm/Support/SourceMgr.h"
+#include "llvm/Support/SystemUtils.h"
+#include "llvm/Support/ToolOutputFile.h"
+#include "llvm/IRReader/IRReader.h"
+#include "llvm/LLVMSlicer/StaticSlicer.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/IR/PassManager.h"
+#include <llvm/IR/NoFolder.h>
+#include "llvm/IR/Verifier.h"
+#include "llvm/Analysis/PostDominators.h"
+#include "../../lib/LLVMSlicer/Slicing/PostDominanceFrontier.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Pass.h"
+#include <memory>
+#include <llvm/Analysis/Andersen/StackAccessPass.h>
+#include <llvm/Analysis/Andersen/DetectParametersPass.h>
+#include <llvm/Transforms/Scalar/SimplifyCFG.h>
+
+using namespace llvm;
+
+static cl::opt<std::string>
+InputFilename(cl::Positional, cl::desc("<input .llvm file>"), cl::init("-"));
+
+static cl::opt<std::string>
+        OutputFilename("o", cl::desc("Override output filename"),
+                       cl::value_desc("filename"));
+
+int main(int argc, char **argv) {
+  // Print a stack trace if we signal out.
+  sys::PrintStackTraceOnErrorSignal();
+  PrettyStackTraceProgram X(argc, argv);
+  llvm_shutdown_obj Y;  // Call llvm_shutdown() on exit.
+  cl::ParseCommandLineOptions(argc, argv, "llvm .ll -> .bc assembler\n");
+    SMDiagnostic Err;
+    std::unique_ptr<Module> Mod = parseIRFile(InputFilename, Err, getGlobalContext());
+    if (!Mod) {
+        Err.print(argv[0], errs());
+        return 1;
+    }
+
+    legacy::PassManager *PM = new legacy::PassManager();
+
+    PM->add(new PostDominatorTree());
+    PM->add(new PostDominanceFrontier());
+    PM->add(new LoopInfoWrapperPass());
+    PM->add(new DetectParametersPass());
+    PM->add(new StackAccessPass());
+
+    Slicer *slicer = new Slicer();
+    PM->add(slicer);
+
+    PM->run(*Mod);
+
+
+    if (OutputFilename.empty())
+        Mod->dump();
+    else {
+        std::error_code EC;
+        std::unique_ptr<tool_output_file> FDOut = llvm::make_unique<tool_output_file>(OutputFilename, EC,
+                                                                                      sys::fs::F_None);
+        if (EC) {
+            errs() << EC.message() << '\n';
+            return -1;
+        }
+
+        FDOut->os() << *Mod;
+
+        FDOut->keep();
+    }
+
+    return 0;
+}
diff --git a/tools/llvm-testpass/CMakeLists.txt b/tools/llvm-testpass/CMakeLists.txt
new file mode 100644
index 0000000..630c5ea
--- /dev/null
+++ b/tools/llvm-testpass/CMakeLists.txt
@@ -0,0 +1,13 @@
+set(LLVM_LINK_COMPONENTS
+        BitReader
+        Core
+        Support
+        IRReader
+        Analysis
+        TransformUtils
+)
+
+add_llvm_tool(llvm-testpass
+  llvm-testpass.cpp
+)
+
diff --git a/tools/llvm-testpass/LLVMBuild.txt b/tools/llvm-testpass/LLVMBuild.txt
new file mode 100644
index 0000000..26f0a44
--- /dev/null
+++ b/tools/llvm-testpass/LLVMBuild.txt
@@ -0,0 +1,22 @@
+;===- ./tools/llc/LLVMBuild.txt --------------------------------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Tool
+name = llvm-testpass
+parent = Tools
+required_libraries = Analysis BitReader IRReader Core TransformUtils
diff --git a/tools/llvm-testpass/llvm-testpass.cpp b/tools/llvm-testpass/llvm-testpass.cpp
new file mode 100644
index 0000000..58c99dad
--- /dev/null
+++ b/tools/llvm-testpass/llvm-testpass.cpp
@@ -0,0 +1,88 @@
+//===-- llc.cpp - Implement the LLVM Native Code Generator ----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This is the llc code generator driver. It provides a convenient
+// command-line interface for generating native assembly-language code
+// or C code, given LLVM bitcode.
+//
+//===----------------------------------------------------------------------===//
+
+
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/Bitcode/ReaderWriter.h"
+#include "llvm/IR/AssemblyAnnotationWriter.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/DebugInfo.h"
+#include "llvm/IR/DiagnosticInfo.h"
+#include "llvm/IR/DiagnosticPrinter.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/IRReader/IRReader.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/IR/PassManager.h"
+#include "llvm/IR/Type.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/DataStream.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/FormattedStream.h"
+#include "llvm/Support/ManagedStatic.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/PrettyStackTrace.h"
+#include "llvm/Support/Signals.h"
+#include "llvm/Support/ToolOutputFile.h"
+#include <system_error>
+#include <llvm/Support/SourceMgr.h>
+#include <llvm/Analysis/LoopInfo.h>
+#include <llvm/Analysis/Andersen/NonVolatileRegistersPass.h>
+#include "llvm/Analysis/Andersen/StackAccessPass.h"
+#include "llvm/Analysis/Andersen/DetectParametersPass.h"
+#include "llvm/IR/Dominators.h"
+using namespace llvm;
+
+// General options for llc.  Other pass-specific options are specified
+// within the corresponding llc passes, and target-specific options
+// and back-end code generation options are specified with the target machine.
+//
+static cl::opt<std::string>
+InputFilename(cl::Positional, cl::desc("<input bitcode>"), cl::init("-"));
+
+
+// main - Entry point for the llc compiler.
+//
+int main(int argc, char **argv) {
+    sys::PrintStackTraceOnErrorSignal();
+    PrettyStackTraceProgram X(argc, argv);
+
+    LLVMContext &Context = getGlobalContext();
+    llvm_shutdown_obj Y;  // Call llvm_shutdown() on exit.
+
+    cl::ParseCommandLineOptions(argc, argv, "llvm .bc -> .ll disassembler\n");
+
+
+    SMDiagnostic Err;
+    std::unique_ptr<Module> Mod = parseIRFile(InputFilename, Err, getGlobalContext());
+    if (!Mod) {
+        Err.print(argv[0], errs());
+        return 1;
+    }
+
+    legacy::PassManager *PM = new legacy::PassManager();
+//    PM->add(new LoopInfoWrapperPass());
+//    PM->add(new StackAccessPass());
+//
+//    PM->add(new DetectParametersPass());
+//    PM->add(new DominatorTreeWrapperPass());
+    PM->add(new NonVolatileRegistersPass());
+
+    PM->run(*Mod);
+
+    Mod->dump();
+  return 0;
+}
+
diff --git a/utils/TableGen/CMakeLists.txt b/utils/TableGen/CMakeLists.txt
index feaa7c7..8d0fb82 100644
--- a/utils/TableGen/CMakeLists.txt
+++ b/utils/TableGen/CMakeLists.txt
@@ -32,4 +32,5 @@ add_tablegen(llvm-tblgen LLVM
   X86ModRMFilters.cpp
   X86RecognizableInstr.cpp
   CTagsEmitter.cpp
+  SliceExtEmitter.cpp
   )
diff --git a/utils/TableGen/SliceExtEmitter.cpp b/utils/TableGen/SliceExtEmitter.cpp
new file mode 100644
index 0000000..b7c372f
--- /dev/null
+++ b/utils/TableGen/SliceExtEmitter.cpp
@@ -0,0 +1,441 @@
+#include "llvm/TableGen/TableGenBackend.h"
+
+#include <llvm/TableGen/Record.h>
+#include <llvm/Support/raw_ostream.h>
+
+
+#define PRE_REGS "DetectParametersPass::getRegisterValuesBeforeCall"
+#define POST_REGS "DetectParametersPass::getRegisterValuesAfterCall"
+
+#define REGS_TYPE "DetectParametersPass::UserSet_t"
+#define REGS_TYPE_IT "DetectParametersPass::UserSet_t::iterator"
+
+namespace llvm {
+
+    typedef std::vector<std::string> string_list_t;
+    typedef std::map<std::string, std::unique_ptr<string_list_t>> string_map_t;
+
+    string_map_t FunctionMap;
+
+    string_map_t PtsToFnMap;
+
+    void EmitRegisterTranslation(RecordKeeper &RK, raw_ostream &OS) {
+
+        OS << "namespace {\n"
+                      "int translateRegister(std::string RegName) {\n";
+
+        for (const auto &R : RK.getAllDerivedDefinitions("TranslateReg")) {
+            OS << "  if (RegName == \"" << R->getValueAsString("Name") << "\") \n    return " << R->getValueAsInt("idx") << ";\n";
+        }
+
+        OS << "  llvm_unreachable(\"Unknown Register\");\n}\n}\n";
+
+    }
+
+    void EmitRegister(RecordKeeper &RK, raw_ostream &OS, const Record *Reg, std::string InstName, std::string DstVar) {
+        if (Reg->isSubClassOf("Pre")) {
+            OS << REGS_TYPE << " " << DstVar << " = ";
+            OS << PRE_REGS << "(translateRegister(\"" << Reg->getValueAsString("Name") << "\"), " << InstName << ");\n";
+        } else if (Reg->isSubClassOf("PreStore")) {
+            OS << REGS_TYPE << " " << DstVar << " = ";
+            OS << PRE_REGS << "(translateRegister(\"" << Reg->getValueAsString("Name") << "\"), " << InstName << ", true);\n";
+        } else if (Reg->isSubClassOf("Post")) {
+            OS << REGS_TYPE << " " << DstVar << " = ";
+            OS << POST_REGS << "(translateRegister(\"" << Reg->getValueAsString("Name") << "\"), " << InstName << ");\n";
+        } else if (Reg->isSubClassOf("DummyObject")) {
+            OS << REGS_TYPE << " " << DstVar << ";\n";
+            OS << DstVar << ".insert(new llvm::GlobalVariable(andersen->getModule(), llvm::IntegerType::get(llvm::getGlobalContext(), 1), false, llvm::GlobalVariable::ExternalLinkage, nullptr, \"" << Reg->getValueAsString("name") <<"\"));\n";
+            OS << "andersen->addConstraint(AndersConstraint::ADDR_OF, ";
+            OS << "andersen->getNodeFactory().createValueNode(*" << DstVar << ".begin()), ";
+            OS << "andersen->getNodeFactory().createObjectNode(*" << DstVar << ".begin()));\n";
+        } else if (Reg->isSubClassOf("Pts")) {
+            OS << REGS_TYPE << " " << DstVar << ";\n";
+            OS << "{\n";
+            EmitRegister(RK, OS, Reg->getValueAsDef("reg"), InstName, "Src");
+            OS <<         "for (auto S : Src) {\n"
+                          "  const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(S, PS);//get points to sets\n"
+                                  "  for (auto &P : PtsTo) {\n"
+                                  "    assert(isa<const User>(P.first));\n"
+                                  "    " << DstVar << ".insert((User*)P.first);\n"
+                                "  }\n"
+                          "}\n";
+            OS << "}\n";
+        } else if (Reg->isSubClassOf("Call")) {
+            OS << REGS_TYPE << " " << DstVar << ";\n";
+            OS << "{\n";
+            OS << "const ptr::PointsToSets::PointsToSet &PtsTo = ptr::getPointsToSet(CallInst->getIns(), PS);//get points to sets\n";
+            OS << "for (auto &P : PtsTo) {\n"
+                          "assert(isa<const User>(P.first));\n"
+                          "    DefRegs.insert((User*)P.first);"
+                          "}\n";
+            OS << "}\n";
+        } else {
+            Reg->dump();
+            llvm_unreachable("");
+        }
+    }
+
+    void EmitExtSliceCode(RecordKeeper &RK, raw_ostream &OS) {
+        for (const auto &F : RK.getAllDerivedDefinitions("Function")) {
+
+            std::string FunctionName = F->getValueAsString("Name");
+
+            if (FunctionMap.find(FunctionName) == FunctionMap.end()) {
+                FunctionMap.insert(std::pair<std::string, std::unique_ptr<string_list_t>>(FunctionName, std::unique_ptr<string_list_t>(new string_list_t())));
+            }
+            FunctionMap[FunctionName]->push_back(F->getName());
+
+            OS << "void " << F->getName() << "(llvm::slicing::InsInfo *CallInst, const ptr::PointsToSets &PS) {\n";
+            OS << "//Handle \"" << FunctionName << "\"\n";
+
+            for (const auto &S : F->getValueAsListOfDefs("SliceOperations")) {
+                //Super class 'Operation' and the actual operation are both super classes
+                assert(S->getSuperClasses().size() == 2);
+                if (S->isSubClassOf("Def")) {
+                    OS << "{ //Def\n";
+                    const Record *d = S->getValueAsDef("define");
+//                    OS <<"  " << REGS_TYPE << " DefRegs" << ++varIdx << " = ";
+                    EmitRegister(RK, OS, d, "(Instruction*)CallInst->getIns()", "DefRegs");
+
+                    OS << "  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {\n";
+                    OS << "    CallInst->addDEF(llvm::ptr::PointsToSets::Pointee(*DefRegs_it, -1));\n";
+                    OS << "  }\n";
+                    OS << "} //End Def\n";
+                } else if (S->isSubClassOf("Ref1")) {
+                    OS << "{ //Ref1\n";
+                    const Record *d = S->getValueAsDef("reference");
+//                    OS <<"  " << REGS_TYPE << " RefRegs" << ++varIdx << " = ";
+                    EmitRegister(RK, OS, d, "(Instruction*)CallInst->getIns()", "RefRegs");
+
+                    OS << "  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {\n";
+                    OS << "    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1), 1.0);\n";
+                    OS << "  }\n";
+                    OS << "} //End Ref1\n";
+                } else if (S->isSubClassOf("Ref")) {
+                    OS << "{ //Ref\n";
+                    const Record *d = S->getValueAsDef("reference");
+//                    OS <<"  " << REGS_TYPE << " RefRegs" << ++varIdx << " = ";
+                    EmitRegister(RK, OS, d, "(Instruction*)CallInst->getIns()", "RefRegs");
+
+                    OS << "  for (auto RefRegs_it = RefRegs.begin(); RefRegs_it != RefRegs.end(); ++RefRegs_it) {\n";
+                    OS << "    CallInst->addREF(llvm::ptr::PointsToSets::Pointee(*RefRegs_it, -1));\n";
+                    OS << "  }\n";
+                    OS << "} //End ref\n";
+                } else {
+                    S->getSuperClasses().back()->dump();
+                    llvm_unreachable("Not handled");
+                }
+            }
+
+            OS << "}\n\n";
+        }
+    }
+
+    void EmitCompares(RecordKeeper &RK, raw_ostream &OS, string_map_t &Functions, std::string ParamList, std::string Parameters) {
+
+        OS << "bool handleCall(" << ParamList << ") {\n";
+
+        for (string_map_t::iterator F_it = Functions.begin(); F_it != Functions.end(); ++F_it) {
+
+            OS << "  if (FName == \"" << F_it->first << "\") {\n";
+
+            for (string_list_t::iterator F2_it = F_it->second->begin(); F2_it != F_it->second->end(); ++F2_it) {
+                OS << "    " << *F2_it << "("<< Parameters <<");\n";
+            }
+            OS << "    return true;\n";
+
+            OS << "  }\n";
+        }
+
+        OS << "  return false;\n";
+        OS << "}\n\n";
+    }
+
+    void EmitSliceExt(RecordKeeper &RK, raw_ostream &OS) {
+
+        OS << "#ifndef LLVM_EXTERNALHANDLER_H\n"
+                      "#define LLVM_EXTERNALHANDLER_H\n"
+                      "\n"
+                      "#include \"llvm/Analysis/Andersen/DetectParametersPass.h\"\n"
+                      "\n"
+                      "namespace llvm {\n\n";
+
+        EmitRegisterTranslation(RK, OS);
+
+        EmitExtSliceCode(RK, OS);
+
+        EmitCompares(RK, OS, FunctionMap, "llvm::slicing::InsInfo *CallInst, std::string FName, const ptr::PointsToSets &PS", "CallInst, PS");
+
+        OS << "}\n"
+                      "\n"
+                      "\n"
+                      "#endif //LLVM_EXTERNALHANDLER_H\n\n";
+    }
+
+
+    void EmitExtPtsToCode(RecordKeeper &RK, raw_ostream &OS) {
+        for (const auto &F : RK.getAllDerivedDefinitions("Function")) {
+
+            std::string FunctionName = F->getValueAsString("Name");
+
+            if (PtsToFnMap.find(FunctionName) == PtsToFnMap.end()) {
+                PtsToFnMap.insert(std::pair<std::string, std::unique_ptr<string_list_t>>(FunctionName, std::unique_ptr<string_list_t>(new string_list_t())));
+            }
+            PtsToFnMap[FunctionName]->push_back(F->getName());
+
+            OS << "void " << F->getName() << "(llvm::Instruction *CallInst, Andersen *andersen) {\n";
+            OS << "//Handle \"" << FunctionName << "\"\n";
+
+            int varIdx = 0;
+            for (const auto &S : F->getValueAsListOfDefs("PtsToOperations")) {
+
+                if (S->isSubClassOf("Load")) {
+                    OS << "{ //Load operation\n";
+                    const Record *val = S->getValueAsDef("val");
+                    const Record *loc = S->getValueAsDef("loc");
+
+                    EmitRegister(RK, OS, val, "CallInst", "Vals");
+                    EmitRegister(RK, OS, loc, "CallInst", "Locs");
+
+
+                    OS << "  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {\n";
+
+                    OS << "    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);\n";
+                    OS << "    if (valIdx == AndersNodeFactory::InvalidIndex)\n";
+                    OS << "      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);\n";
+
+                    OS << "    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {\n";
+
+                    OS << "      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);\n";
+                    OS << "      if (locIdx == AndersNodeFactory::InvalidIndex)\n";
+                    OS << "        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);\n";
+
+                    OS << "      andersen->addConstraint(AndersConstraint::LOAD, valIdx, locIdx);\n";
+
+                    OS << "    }\n";
+
+                    OS << "  }\n";
+
+                    OS << "}\n";
+                } else if (S->isSubClassOf("Store")) {
+                    OS << "{ //Store operation\n";
+                    const Record *val = S->getValueAsDef("val");
+                    const Record *loc = S->getValueAsDef("loc");
+
+                    EmitRegister(RK, OS, val, "CallInst", "Vals");
+                    EmitRegister(RK, OS, loc, "CallInst", "Locs");
+
+
+                    OS << "  for (auto Vals_it = Vals.begin(); Vals_it != Vals.end(); ++Vals_it) {\n";
+
+                    OS << "    NodeIndex valIdx = andersen->getNodeFactory().getValueNodeFor(*Vals_it);\n";
+                    OS << "    if (valIdx == AndersNodeFactory::InvalidIndex)\n";
+                    OS << "      valIdx = andersen->getNodeFactory().createValueNode(*Vals_it);\n";
+
+                    OS << "    for (auto Locs_it = Locs.begin(); Locs_it != Locs.end(); ++Locs_it) {\n";
+
+                    OS << "      NodeIndex locIdx = andersen->getNodeFactory().getValueNodeFor(*Locs_it);\n";
+                    OS << "      if (locIdx == AndersNodeFactory::InvalidIndex)\n";
+                    OS << "        locIdx = andersen->getNodeFactory().createValueNode(*Locs_it);\n";
+
+                    OS << "      andersen->addConstraint(AndersConstraint::STORE, locIdx, valIdx);\n";
+
+                    OS << "    }\n";
+
+                    OS << "  }\n";
+
+                    OS << "}\n";
+
+                } else if (S->isSubClassOf("Alloc")) {
+                    OS << "{ //Alloc operation\n";
+                    const Record *reg = S->getValueAsDef("reg");
+                    std::string type = S->getValueAsString("type");
+                    EmitRegister(RK, OS, reg, "CallInst", "Post");
+
+                    OS << "  for (auto Post_it = Post.begin(); Post_it != Post.end(); ++Post_it) {\n";
+
+                    OS << "    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);\n"
+                          "    if (valIndex == AndersNodeFactory::InvalidIndex)\n"
+                          "      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);\n"
+                          "    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);\n"
+                          "    if (objIndex == AndersNodeFactory::InvalidIndex)\n"
+                          "      objIndex = andersen->getNodeFactory().createObjectNode(*Post_it);\n"
+                          "    andersen->setType(*Post_it, \"" << type << "\");\n"
+                          "    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);\n";
+
+                    OS << "  }\n";
+
+                    OS << "}\n";
+                } else if (S->isSubClassOf("Copy")) {
+                    OS << "{ //Copy operation\n";
+
+                    const Record *from = S->getValueAsDef("from");
+                    const Record *to = S->getValueAsDef("to");
+
+                    EmitRegister(RK, OS, from, "CallInst", "From");
+                    EmitRegister(RK, OS, to, "CallInst", "To");
+
+
+                    OS << "  for (auto From_it = From.begin(); From_it != From.end(); ++From_it) {\n";
+
+                    OS << "    NodeIndex srcIdx = andersen->getNodeFactory().getValueNodeFor(*From_it);\n";
+                    OS << "    if (srcIdx == AndersNodeFactory::InvalidIndex)\n";
+                    OS << "      srcIdx = andersen->getNodeFactory().createValueNode(*From_it);\n";
+
+                    OS << "    for (auto To_it = To.begin(); To_it != To.end(); ++To_it) {\n";
+
+                    OS << "      NodeIndex dstIdx = andersen->getNodeFactory().getValueNodeFor(*To_it);\n";
+                    OS << "      if (dstIdx == AndersNodeFactory::InvalidIndex)\n";
+                    OS << "        dstIdx = andersen->getNodeFactory().createValueNode(*To_it);\n";
+
+                    OS << "      andersen->addConstraint(AndersConstraint::COPY, dstIdx, srcIdx);\n";
+
+                    OS << "    }\n";
+
+                    OS << "  }\n";
+
+                    OS << "} //end copy\n";
+                } else if (S->isSubClassOf("Loc")) {
+                    OS << "{ //Check object\n";
+                    const Record *reg = S->getValueAsDef("reg");
+                    EmitRegister(RK, OS, reg, "CallInst", "Reg");
+
+                    OS << "  for (auto Post_it = Reg.begin(); Post_it != Reg.end(); ++Post_it) {\n";
+
+                    OS << "    NodeIndex valIndex = andersen->getNodeFactory().getValueNodeFor(*Post_it);\n"
+                            "    NodeIndex objIndex = andersen->getNodeFactory().getObjectNodeFor(*Post_it);\n"
+                                  "if (objIndex != AndersNodeFactory::InvalidIndex)\n"
+                                  "continue;"
+                            "    if (objIndex == AndersNodeFactory::InvalidIndex)\n"
+                            "      objIndex = andersen->getNodeFactory().createObjectNodeDummy(*Post_it, *CallInst->getParent()->getParent()->getParent());\n"
+                              "    if (valIndex == AndersNodeFactory::InvalidIndex)\n"
+                              "      valIndex = andersen->getNodeFactory().createValueNode(*Post_it);\n"
+                            "    andersen->addConstraint(AndersConstraint::ADDR_OF, valIndex, objIndex);\n";
+
+                    OS << "  }\n";
+
+                    OS << "}\n";
+                } else {
+                    llvm_unreachable("Not handled");
+                }
+            }
+
+            OS << "}\n\n";
+        }
+    }
+
+    void EmitHelperPtsTo(RecordKeeper &RK, raw_ostream &OS) {
+
+        OS << "bool canHandleCall(const std::string &FName) {\n";
+        for (auto &F : PtsToFnMap) {
+            OS << "  if (FName == \"" << F.first << "\")\n"
+                  "    return true;\n";
+        }
+        OS << "  return false;\n"
+                      "}\n\n";
+    }
+
+    void EmitPtsToExt(RecordKeeper &RK, raw_ostream &OS) {
+
+        OS << "#ifndef LLVM_EXTERNALHANDLER_H\n"
+                      "#define LLVM_EXTERNALHANDLER_H\n\n";
+
+        OS << "namespace llvm {\n"
+                      "    namespace pointsto {\n";
+
+        EmitRegisterTranslation(RK, OS);
+
+        EmitExtPtsToCode
+
+                (RK, OS);
+
+        EmitHelperPtsTo(RK, OS);
+
+        EmitCompares(RK, OS, PtsToFnMap, "llvm::Instruction *CallInst, Andersen *andersen, const std::string &FName", "CallInst, andersen");
+
+        OS << "    }\n"
+                      "}\n"
+                      "\n"
+                      "#endif //LLVM_EXTERNALHANDLER_H\n\n";
+    }
+
+
+    void EmitExtModifiesCode(RecordKeeper &RK, raw_ostream &OS) {
+        for (const auto &F : RK.getAllDerivedDefinitions("Function")) {
+
+            std::string FunctionName = F->getValueAsString("Name");
+
+            if (FunctionMap.find(FunctionName) == FunctionMap.end()) {
+                FunctionMap.insert(std::pair<std::string, std::unique_ptr<string_list_t>>(FunctionName, std::unique_ptr<string_list_t>(new string_list_t())));
+            }
+            FunctionMap[FunctionName]->push_back(F->getName());
+
+            OS << "void " << F->getName() << "(llvm::Instruction *CallInst, const ptr::PointsToSets &PS, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock) {\n";
+            OS << "//Handle \"" << FunctionName << "\"\n";
+
+            for (const auto &S : F->getValueAsListOfDefs("SliceOperations")) {
+                //Super class 'Operation' and the actual operation are both super classes
+                assert(S->getSuperClasses().size() == 2);
+                if (S->isSubClassOf("DefMod")) {
+                    const Record *d = S->getValueAsDef("define");
+                    if (!d->isSubClassOf("Pts")) {
+                        continue;
+                    }
+                    OS << "{ //Def\n";
+//                    OS <<"  " << REGS_TYPE << " DefRegs" << ++varIdx << " = ";
+                    EmitRegister(RK, OS, d, "(Instruction*)CallInst", "DefRegs");
+
+                    OS << "  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {\n";
+                    OS << "    lock.lock();\n";
+                    OS << "    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_FRC_DEF, *DefRegs_it));\n";
+                    OS << "    lock.unlock();\n";
+                    OS << "  }\n";
+                    OS << "} //End Def\n";
+                } else if (S->isSubClassOf("Def")) {
+                    const Record *d = S->getValueAsDef("define");
+                    if (!d->isSubClassOf("Pts")) {
+                        continue;
+                    }
+                    OS << "{ //Def\n";
+//                    OS <<"  " << REGS_TYPE << " DefRegs" << ++varIdx << " = ";
+                    EmitRegister(RK, OS, d, "(Instruction*)CallInst", "DefRegs");
+
+                    OS << "  for (auto DefRegs_it = DefRegs.begin(); DefRegs_it != DefRegs.end(); ++DefRegs_it) {\n";
+                    OS << "    lock.lock();\n";
+                    OS << "    commands.push_back(llvm::mods::ProgramStructure::Command(llvm::mods::CMD_DEF, *DefRegs_it));\n";
+                    OS << "    lock.unlock();\n";
+                    OS << "  }\n";
+                    OS << "} //End Def\n";
+                } else {
+                    if (S->isSubClassOf("Ref1") || S->isSubClassOf("Ref")) {
+                        //do nothing...
+                    } else {
+                        S->getSuperClasses().back()->dump();
+                        llvm_unreachable("Not handled");
+                    }
+                }
+            }
+
+            OS << "}\n\n";
+        }
+
+    }
+
+    void EmitMODExt(RecordKeeper &RK, raw_ostream &OS) {
+        OS << "#ifndef LLVM_EXTERNALMODHANDLER_H\n"
+                "#define LLVM_EXTERNALMODHANDLER_H\n"
+                "\n"
+                "#include \"llvm/Analysis/Andersen/DetectParametersPass.h\"\n"
+                "\n"
+                "namespace llvm {\n\n";
+
+
+        EmitRegisterTranslation(RK, OS);
+        EmitExtModifiesCode(RK, OS);
+        EmitCompares(RK, OS, FunctionMap, "llvm::Instruction *CallInst, const ptr::PointsToSets &PS, const std::string &FName, llvm::mods::ProgramStructure::Commands &commands, std::mutex &lock", "CallInst, PS, commands, lock");
+
+        OS << "}\n"
+                      "#endif\n";
+    }
+
+}
diff --git a/utils/TableGen/TableGen.cpp b/utils/TableGen/TableGen.cpp
index 02fe4dc..d48a935 100644
--- a/utils/TableGen/TableGen.cpp
+++ b/utils/TableGen/TableGen.cpp
@@ -41,7 +41,10 @@ enum ActionType {
   PrintEnums,
   PrintSets,
   GenOptParserDefs,
-  GenCTags
+  GenCTags,
+  GenSliceExt,
+  GenPtsToExt,
+  GenModExt
 };
 
 namespace {
@@ -85,6 +88,12 @@ namespace {
                                "Generate option definitions"),
                     clEnumValN(GenCTags, "gen-ctags",
                                "Generate ctags-compatible index"),
+                    clEnumValN(GenSliceExt, "gen-slice-ext",
+                               "Generate slicing definitions for external functions"),
+                    clEnumValN(GenPtsToExt, "gen-ptsto-ext",
+                               "Generate points-to definitions for external functions"),
+                    clEnumValN(GenModExt, "gen-mod-ext",
+                               "Generate MOD definitions for external functions"),
                     clEnumValEnd));
 
   cl::opt<std::string>
@@ -141,6 +150,15 @@ bool LLVMTableGenMain(raw_ostream &OS, RecordKeeper &Records) {
   case GenOptParserDefs:
     EmitOptParser(Records, OS);
     break;
+  case GenSliceExt:
+      EmitSliceExt(Records, OS);
+    break;
+  case GenPtsToExt:
+      EmitPtsToExt(Records, OS);
+      break;
+  case GenModExt:
+      EmitMODExt(Records, OS);
+      break;
   case PrintEnums:
   {
     for (Record *Rec : Records.getAllDerivedDefinitions(Class))
diff --git a/utils/TableGen/TableGenBackends.h b/utils/TableGen/TableGenBackends.h
index 2dc03ce..ae237bb 100644
--- a/utils/TableGen/TableGenBackends.h
+++ b/utils/TableGen/TableGenBackends.h
@@ -78,6 +78,9 @@ void EmitSubtarget(RecordKeeper &RK, raw_ostream &OS);
 void EmitMapTable(RecordKeeper &RK, raw_ostream &OS);
 void EmitOptParser(RecordKeeper &RK, raw_ostream &OS);
 void EmitCTags(RecordKeeper &RK, raw_ostream &OS);
+void EmitSliceExt(RecordKeeper &RK, raw_ostream &OS);
+void EmitPtsToExt(RecordKeeper &RK, raw_ostream &OS);
+void EmitMODExt(RecordKeeper &RK, raw_ostream &OS);
 
 } // End llvm namespace
 
-- 
2.7.0

